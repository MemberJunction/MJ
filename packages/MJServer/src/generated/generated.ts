/********************************************************************************
* ALL ENTITIES - TypeGraphQL Type Class Definition - AUTO GENERATED FILE
* Generated Entities and Resolvers for Server
*
*   >>> DO NOT MODIFY THIS FILE!!!!!!!!!!!!
*   >>> YOUR CHANGES WILL BE OVERWRITTEN
*   >>> THE NEXT TIME THIS FILE IS GENERATED
*
**********************************************************************************/
import { Arg, Ctx, Int, Query, Resolver, Field, Float, ObjectType, FieldResolver, Root, InputType, Mutation,
            PubSub, PubSubEngine, ResolverBase, RunViewByIDInput, RunViewByNameInput, RunDynamicViewInput,
            AppContext, KeyValuePairInput, DeleteOptionsInput, GraphQLTimestamp as Timestamp,
            GetReadOnlyDataSource, GetReadWriteDataSource, GetReadOnlyProvider, GetReadWriteProvider } from '@memberjunction/server';
import { SQLServerDataProvider } from '@memberjunction/sqlserver-dataprovider';
import { Metadata, EntityPermissionType, CompositeKey, UserInfo } from '@memberjunction/core'

import { MaxLength } from 'class-validator';
import { mj_core_schema } from '../config.js';



import { ActionAuthorizationEntity, ActionCategoryEntity, ActionContextTypeEntity, ActionContextEntity, ActionExecutionLogEntity, ActionFilterEntity, ActionLibraryEntity, ActionParamEntity, ActionResultCodeEntity, ActionEntity, AIActionEntity, AIAgentActionEntity, AIAgentLearningCycleEntity, AIAgentModelEntity, AIAgentNoteTypeEntity, AIAgentNoteEntity, AIAgentRequestEntity, AIAgentEntity, AIModelActionEntity, AIModelTypeEntity, AIModelEntity, AIPromptCategoryEntity, AIPromptTypeEntity, AIPromptEntity, AIResultCacheEntity, ApplicationEntityEntity, ApplicationSettingEntity, ApplicationEntity, AuditLogTypeEntity, AuditLogEntity, AuthorizationRoleEntity, AuthorizationEntity, CommunicationBaseMessageTypeEntity, CommunicationLogEntity, CommunicationProviderMessageTypeEntity, CommunicationProviderEntity, CommunicationRunEntity, CompanyEntity, CompanyIntegrationRecordMapEntity, CompanyIntegrationRunAPILogEntity, CompanyIntegrationRunDetailEntity, CompanyIntegrationRunEntity, CompanyIntegrationEntity, ContentFileTypeEntity, ContentItemAttributeEntity, ContentItemTagEntity, ContentItemEntity, ContentProcessRunEntity, ContentSourceParamEntity, ContentSourceTypeParamEntity, ContentSourceTypeEntity, ContentSourceEntity, ContentTypeAttributeEntity, ContentTypeEntity, ConversationDetailEntity, ConversationEntity, DashboardCategoryEntity, DashboardEntity, DataContextItemEntity, DataContextEntity, DatasetItemEntity, DatasetEntity, DuplicateRunDetailMatchEntity, DuplicateRunDetailEntity, DuplicateRunEntity, EmployeeCompanyIntegrationEntity, EmployeeRoleEntity, EmployeeSkillEntity, EmployeeEntity, EntityEntity, EntityActionFilterEntity, EntityActionInvocationTypeEntity, EntityActionInvocationEntity, EntityActionParamEntity, EntityActionEntity, EntityAIActionEntity, EntityCommunicationFieldEntity, EntityCommunicationMessageTypeEntity, EntityDocumentRunEntity, EntityDocumentSettingEntity, EntityDocumentTypeEntity, EntityDocumentEntity, EntityFieldValueEntity, EntityFieldEntity, EntityPermissionEntity, EntityRecordDocumentEntity, EntityRelationshipDisplayComponentEntity, EntityRelationshipEntity, EntitySettingEntity, ErrorLogEntity, ExplorerNavigationItemEntity, FileCategoryEntity, FileEntityRecordLinkEntity, FileStorageProviderEntity, FileEntity, GeneratedCodeCategoryEntity, GeneratedCodeEntity, IntegrationURLFormatEntity, IntegrationEntity, LibraryEntity, LibraryItemEntity, ListCategoryEntity, ListDetailEntity, ListEntity, AccessControlRuleEntity, AIAgentArtifactTypeEntity, AIAgentConfigurationEntity, AIAgentDataSourceEntity, AIAgentExampleEntity, AIAgentModalityEntity, AIAgentPermissionEntity, AIAgentPromptEntity, AIAgentRelationshipEntity, AIAgentRunMediaEntity, AIAgentRunStepEntity, AIAgentRunEntity, AIAgentStepPathEntity, AIAgentStepEntity, AIAgentTypeEntity, AIArchitectureEntity, AIConfigurationParamEntity, AIConfigurationEntity, AICredentialBindingEntity, AIModalityEntity, AIModelArchitectureEntity, AIModelCostEntity, AIModelModalityEntity, AIModelPriceTypeEntity, AIModelPriceUnitTypeEntity, AIModelVendorEntity, AIPromptModelEntity, AIPromptRunMediaEntity, AIPromptRunEntity, AIVendorTypeDefinitionEntity, AIVendorTypeEntity, AIVendorEntity, APIApplicationScopeEntity, APIApplicationEntity, APIKeyApplicationEntity, APIKeyScopeEntity, APIKeyUsageLogEntity, APIKeyEntity, APIScopeEntity, ArtifactPermissionEntity, ArtifactTypeEntity, ArtifactUseEntity, ArtifactVersionAttributeEntity, ArtifactVersionEntity, ArtifactEntity, CollectionArtifactEntity, CollectionPermissionEntity, CollectionEntity, ComponentDependencyEntity, ComponentLibraryEntity, ComponentLibraryLinkEntity, ComponentRegistryEntity, ComponentEntity, ConversationArtifactPermissionEntity, ConversationArtifactVersionEntity, ConversationArtifactEntity, ConversationDetailArtifactEntity, ConversationDetailAttachmentEntity, ConversationDetailRatingEntity, CredentialCategoryEntity, CredentialTypeEntity, CredentialEntity, DashboardCategoryLinkEntity, DashboardCategoryPermissionEntity, DashboardPartTypeEntity, DashboardPermissionEntity, DashboardUserPreferenceEntity, DashboardUserStateEntity, EncryptionAlgorithmEntity, EncryptionKeySourceEntity, EncryptionKeyEntity, EnvironmentEntity, FileStorageAccountEntity, ListInvitationEntity, ListShareEntity, MCPServerConnectionPermissionEntity, MCPServerConnectionToolEntity, MCPServerConnectionEntity, MCPServerToolEntity, MCPServerEntity, MCPToolExecutionLogEntity, OAuthAuthServerMetadataCacheEntity, OAuthAuthorizationStateEntity, OAuthClientRegistrationEntity, OAuthTokenEntity, ProjectEntity, PublicLinkEntity, QueryParameterEntity, RecordLinkEntity, ReportUserStateEntity, ReportVersionEntity, ScheduledJobRunEntity, ScheduledJobTypeEntity, ScheduledJobEntity, TaskDependencyEntity, TaskTypeEntity, TaskEntity, TestRubricEntity, TestRunFeedbackEntity, TestRunEntity, TestSuiteRunEntity, TestSuiteTestEntity, TestSuiteEntity, TestTypeEntity, TestEntity, UserNotificationPreferenceEntity, UserNotificationTypeEntity, UserSettingEntity, VersionLabelItemEntity, VersionLabelRestoreEntity, VersionLabelEntity, OutputDeliveryTypeEntity, OutputFormatTypeEntity, OutputTriggerTypeEntity, QueryEntity, QueryCategoryEntity, QueryEntityEntity, QueryFieldEntity, QueryPermissionEntity, QueueTaskEntity, QueueTypeEntity, QueueEntity, RecommendationItemEntity, RecommendationProviderEntity, RecommendationRunEntity, RecommendationEntity, RecordChangeReplayRunEntity, RecordChangeEntity, RecordMergeDeletionLogEntity, RecordMergeLogEntity, ReportCategoryEntity, ReportSnapshotEntity, ReportEntity, ResourceLinkEntity, ResourcePermissionEntity, ResourceTypeEntity, RoleEntity, RowLevelSecurityFilterEntity, ScheduledActionParamEntity, ScheduledActionEntity, SchemaInfoEntity, SkillEntity, TaggedItemEntity, TagEntity, TemplateCategoryEntity, TemplateContentTypeEntity, TemplateContentEntity, TemplateParamEntity, TemplateEntity, UserApplicationEntityEntity, UserApplicationEntity, UserFavoriteEntity, UserNotificationEntity, UserRecordLogEntity, UserRoleEntity, UserViewCategoryEntity, UserViewRunDetailEntity, UserViewRunEntity, UserViewEntity, UserEntity, VectorDatabaseEntity, VectorIndexEntity, VersionInstallationEntity, WorkflowEngineEntity, WorkflowRunEntity, WorkflowEntity, WorkspaceItemEntity, WorkspaceEntity } from '@memberjunction/core-entities';
    

//****************************************************************************
// ENTITY CLASS for Action Authorizations
//****************************************************************************
@ObjectType({ description: `Links actions to authorizations, one or more of these must be possessed by a user in order to execute the action.` })
export class MJActionAuthorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class CreateMJActionAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class UpdateMJActionAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Authorizations
//****************************************************************************
@ObjectType()
export class RunMJActionAuthorizationViewResult {
    @Field(() => [MJActionAuthorization_])
    Results: MJActionAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionAuthorization_)
export class MJActionAuthorizationResolver extends ResolverBase {
    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionAuthorizationViewResult)
    async RunMJActionAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionAuthorization_, { nullable: true })
    async MJActionAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionAuthorization_ | null> {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Authorizations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionAuthorization_)
    async CreateMJActionAuthorization(
        @Arg('input', () => CreateMJActionAuthorizationInput) input: CreateMJActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionAuthorization_)
    async UpdateMJActionAuthorization(
        @Arg('input', () => UpdateMJActionAuthorizationInput) input: UpdateMJActionAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionAuthorization_)
    async DeleteMJActionAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Categories
//****************************************************************************
@ObjectType({ description: `Organizes actions into categories, including name, description, and optional parent category for hierarchy.` })
export class MJActionCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the action category.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the action category.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Status of the action category (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJActionCategory_])
    ActionCategories_ParentIDArray: MJActionCategory_[]; // Link to ActionCategories
    
    @Field(() => [MJAction_])
    Actions_CategoryIDArray: MJAction_[]; // Link to Actions
    
    @Field(() => [MJMCPServerTool_])
    MJ_MCPServerTools_GeneratedActionCategoryIDArray: MJMCPServerTool_[]; // Link to MJ_MCPServerTools
    
}

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class CreateMJActionCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class UpdateMJActionCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Categories
//****************************************************************************
@ObjectType()
export class RunMJActionCategoryViewResult {
    @Field(() => [MJActionCategory_])
    Results: MJActionCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionCategory_)
export class MJActionCategoryResolver extends ResolverBase {
    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionCategoryViewResult)
    async RunMJActionCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionCategory_, { nullable: true })
    async MJActionCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionCategory_ | null> {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionCategory_])
    async ActionCategories_ParentIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ParentID]='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async Actions_CategoryIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CategoryID]='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerTool_])
    async MJ_MCPServerTools_GeneratedActionCategoryIDArray(@Root() mjactioncategory_: MJActionCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerTools] WHERE [GeneratedActionCategoryID]='${mjactioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionCategory_)
    async CreateMJActionCategory(
        @Arg('input', () => CreateMJActionCategoryInput) input: CreateMJActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionCategory_)
    async UpdateMJActionCategory(
        @Arg('input', () => UpdateMJActionCategoryInput) input: UpdateMJActionCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionCategory_)
    async DeleteMJActionCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Context Types
//****************************************************************************
@ObjectType({ description: `Lists possible contexts for action execution with optional descriptions.` })
export class MJActionContextType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the context type.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the context type.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJActionContext_])
    ActionContexts_ContextTypeIDArray: MJActionContext_[]; // Link to ActionContexts
    
}

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class CreateMJActionContextTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class UpdateMJActionContextTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Context Types
//****************************************************************************
@ObjectType()
export class RunMJActionContextTypeViewResult {
    @Field(() => [MJActionContextType_])
    Results: MJActionContextType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionContextType_)
export class MJActionContextTypeResolver extends ResolverBase {
    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextTypeViewResult)
    async RunMJActionContextTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Context Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionContextType_, { nullable: true })
    async MJActionContextType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionContextType_ | null> {
        this.CheckUserReadPermissions('Action Context Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContextTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Context Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Context Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionContext_])
    async ActionContexts_ContextTypeIDArray(@Root() mjactioncontexttype_: MJActionContextType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ContextTypeID]='${mjactioncontexttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Contexts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionContextType_)
    async CreateMJActionContextType(
        @Arg('input', () => CreateMJActionContextTypeInput) input: CreateMJActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Context Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionContextType_)
    async UpdateMJActionContextType(
        @Arg('input', () => UpdateMJActionContextTypeInput) input: UpdateMJActionContextTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Context Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionContextType_)
    async DeleteMJActionContextType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Context Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Contexts
//****************************************************************************
@ObjectType({ description: `Links actions to their supported context types enabling a given action to be executable in more than one context.` })
export class MJActionContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ContextTypeID?: string;
        
    @Field({description: `Status of the action context (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContextType?: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class CreateMJActionContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class UpdateMJActionContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Contexts
//****************************************************************************
@ObjectType()
export class RunMJActionContextViewResult {
    @Field(() => [MJActionContext_])
    Results: MJActionContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionContext_)
export class MJActionContextResolver extends ResolverBase {
    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionContextViewResult)
    async RunMJActionContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionContext_, { nullable: true })
    async MJActionContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionContext_ | null> {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Contexts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionContext_)
    async CreateMJActionContext(
        @Arg('input', () => CreateMJActionContextInput) input: CreateMJActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionContext_)
    async UpdateMJActionContext(
        @Arg('input', () => UpdateMJActionContextInput) input: UpdateMJActionContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionContext_)
    async DeleteMJActionContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Execution Logs
//****************************************************************************
@ObjectType({ description: `Tracks every execution of an action, including start and end times, inputs, outputs, and result codes.` })
export class MJActionExecutionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Timestamp when the action execution started (timezone-aware)`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the action execution ended (timezone-aware)`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({nullable: true, description: `JSON-formatted input parameters passed to the action during execution, storing the exact values used for this specific run.`}) 
    Params?: string;
        
    @Field({nullable: true, description: `The outcome code returned by the action execution, indicating success, failure, or specific error conditions as defined in Action Result Codes.`}) 
    @MaxLength(510)
    ResultCode?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain the log; NULL for indefinite retention.`}) 
    RetentionPeriod?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON-formatted output data or response from the action execution`}) 
    Message?: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class CreateMJActionExecutionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Params: string | null;

    @Field({ nullable: true })
    ResultCode: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Message: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class UpdateMJActionExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Params?: string | null;

    @Field({ nullable: true })
    ResultCode?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Execution Logs
//****************************************************************************
@ObjectType()
export class RunMJActionExecutionLogViewResult {
    @Field(() => [MJActionExecutionLog_])
    Results: MJActionExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionExecutionLog_)
export class MJActionExecutionLogResolver extends ResolverBase {
    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionExecutionLogViewResult)
    async RunMJActionExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Execution Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionExecutionLog_, { nullable: true })
    async MJActionExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionExecutionLog_ | null> {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Execution Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionExecutionLog_)
    async CreateMJActionExecutionLog(
        @Arg('input', () => CreateMJActionExecutionLogInput) input: CreateMJActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Execution Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionExecutionLog_)
    async UpdateMJActionExecutionLog(
        @Arg('input', () => UpdateMJActionExecutionLogInput) input: UpdateMJActionExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Execution Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionExecutionLog_)
    async DeleteMJActionExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Execution Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Filters
//****************************************************************************
@ObjectType({ description: `Defines filters that can be evaluated ahead of executing an action. Action Filters are usable in any code pipeline you can execute them with the same context as the action itself and use the outcome to determine if the action should execute or not.` })
export class MJActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Human-readable explanation of what this filter checks and when it should prevent action execution, written for non-technical users.`}) 
    UserDescription: string;
        
    @Field({nullable: true, description: `Additional notes or implementation details about the filter logic, including examples or edge cases to consider.`}) 
    UserComments?: string;
        
    @Field({description: `JavaScript code that evaluates to true (allow action) or false (prevent action), executed in the same context as the action.`}) 
    Code: string;
        
    @Field({nullable: true, description: `Technical documentation of the filter code logic, including expected inputs, outputs, and any dependencies or assumptions.`}) 
    CodeExplanation?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityActionFilter_])
    EntityActionFilters_ActionFilterIDArray: MJEntityActionFilter_[]; // Link to EntityActionFilters
    
}

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class CreateMJActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class UpdateMJActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Filters
//****************************************************************************
@ObjectType()
export class RunMJActionFilterViewResult {
    @Field(() => [MJActionFilter_])
    Results: MJActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionFilter_)
export class MJActionFilterResolver extends ResolverBase {
    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionFilterViewResult)
    async RunMJActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionFilter_, { nullable: true })
    async MJActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionFilter_ | null> {
        this.CheckUserReadPermissions('Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Filters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionFilter_])
    async EntityActionFilters_ActionFilterIDArray(@Root() mjactionfilter_: MJActionFilter_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ActionFilterID]='${mjactionfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionFilter_)
    async CreateMJActionFilter(
        @Arg('input', () => CreateMJActionFilterInput) input: CreateMJActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionFilter_)
    async UpdateMJActionFilter(
        @Arg('input', () => UpdateMJActionFilterInput) input: UpdateMJActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionFilter_)
    async DeleteMJActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Libraries
//****************************************************************************
@ObjectType({ description: `Tracks the list of libraries that a given Action uses, including a list of classes/functions for each library.` })
export class MJActionLibrary_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({nullable: true, description: `List of classes and functions used by the action from the library.`}) 
    ItemsUsed?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class CreateMJActionLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class UpdateMJActionLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Libraries
//****************************************************************************
@ObjectType()
export class RunMJActionLibraryViewResult {
    @Field(() => [MJActionLibrary_])
    Results: MJActionLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionLibrary_)
export class MJActionLibraryResolver extends ResolverBase {
    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionLibraryViewResult)
    async RunMJActionLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionLibrary_, { nullable: true })
    async MJActionLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionLibrary_ | null> {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Libraries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionLibrary_)
    async CreateMJActionLibrary(
        @Arg('input', () => CreateMJActionLibraryInput) input: CreateMJActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionLibrary_)
    async UpdateMJActionLibrary(
        @Arg('input', () => UpdateMJActionLibraryInput) input: UpdateMJActionLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionLibrary_)
    async DeleteMJActionLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Params
//****************************************************************************
@ObjectType({ description: `Tracks the input and output parameters for Actions.` })
export class MJActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `The default value for this parameter if not provided during action execution, can be a literal value or JSON for complex types.`}) 
    DefaultValue?: string;
        
    @Field({description: `Specifies whether this parameter is used for Input, Output, or Both directions in the action execution flow.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `Tracks the basic value type of the parameter, additional information can be provided in the Description field`}) 
    @MaxLength(60)
    ValueType: string;
        
    @Field(() => Boolean, {description: `Indicates whether this parameter accepts or returns an array of values rather than a single value.`}) 
    IsArray: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Determines if this parameter must be provided for input parameters or will always be populated for output parameters.`}) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Specifies the type of media this parameter outputs when ValueType is MediaOutput. Used for action discovery and validation.`}) 
    @MaxLength(40)
    MediaModality?: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [MJEntityActionParam_])
    EntityActionParams_ActionParamIDArray: MJEntityActionParam_[]; // Link to EntityActionParams
    
    @Field(() => [MJScheduledActionParam_])
    ScheduledActionParams_ActionParamIDArray: MJScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class CreateMJActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    MediaModality: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class UpdateMJActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    MediaModality?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Params
//****************************************************************************
@ObjectType()
export class RunMJActionParamViewResult {
    @Field(() => [MJActionParam_])
    Results: MJActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionParam_)
export class MJActionParamResolver extends ResolverBase {
    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionParamViewResult)
    async RunMJActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionParam_, { nullable: true })
    async MJActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionParam_ | null> {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionParam_])
    async EntityActionParams_ActionParamIDArray(@Root() mjactionparam_: MJActionParam_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ActionParamID]='${mjactionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledActionParam_])
    async ScheduledActionParams_ActionParamIDArray(@Root() mjactionparam_: MJActionParam_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ActionParamID]='${mjactionparam_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJActionParam_)
    async CreateMJActionParam(
        @Arg('input', () => CreateMJActionParamInput) input: CreateMJActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionParam_)
    async UpdateMJActionParam(
        @Arg('input', () => UpdateMJActionParamInput) input: UpdateMJActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionParam_)
    async DeleteMJActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Result Codes
//****************************************************************************
@ObjectType({ description: `Defines the possible result codes for each action.` })
export class MJActionResultCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `The unique code string returned by the action to indicate specific outcomes, used for programmatic handling of results.`}) 
    @MaxLength(510)
    ResultCode: string;
        
    @Field(() => Boolean, {description: `Indicates if the result code is a success or not. It is possible an action might have more than one failure condition/result code and same for success conditions.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `Description of the result code.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class CreateMJActionResultCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class UpdateMJActionResultCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Result Codes
//****************************************************************************
@ObjectType()
export class RunMJActionResultCodeViewResult {
    @Field(() => [MJActionResultCode_])
    Results: MJActionResultCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJActionResultCode_)
export class MJActionResultCodeResolver extends ResolverBase {
    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionResultCodeViewResult)
    async RunMJActionResultCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Result Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJActionResultCode_, { nullable: true })
    async MJActionResultCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJActionResultCode_ | null> {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Action Result Codes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJActionResultCode_)
    async CreateMJActionResultCode(
        @Arg('input', () => CreateMJActionResultCodeInput) input: CreateMJActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Action Result Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJActionResultCode_)
    async UpdateMJActionResultCode(
        @Arg('input', () => UpdateMJActionResultCodeInput) input: UpdateMJActionResultCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Action Result Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJActionResultCode_)
    async DeleteMJActionResultCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Result Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Actions
//****************************************************************************
@ObjectType({ description: `Stores action definitions, including prompts, generated code, user comments, and status.` })
export class MJAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `The name of the action. Must be unique within the combination of CategoryID and ParentID. Actions with the same name can exist in different categories or under different parents.`}) 
    @MaxLength(850)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Generated or Custom. Generated means the UserPrompt is used to prompt an AI model to automatically create the code for the Action. Custom means that a custom class has been implemented that subclasses the BaseAction class. The custom class needs to use the @RegisterClass decorator and be included in the MJAPI (or other runtime environment) to be available for execution.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `The natural language prompt provided by the user describing what the action should accomplish, used for AI code generation.`}) 
    UserPrompt?: string;
        
    @Field({nullable: true, description: `User's comments not shared with the LLM.`}) 
    UserComments?: string;
        
    @Field({nullable: true, description: `The generated or manually written code that implements the action logic, typically TypeScript/JavaScript that will be executed.`}) 
    Code?: string;
        
    @Field({nullable: true, description: `AI's explanation of the code.`}) 
    CodeComments?: string;
        
    @Field({description: `An action won't be usable until the code is approved.`}) 
    @MaxLength(40)
    CodeApprovalStatus: string;
        
    @Field({nullable: true, description: `Optional comments when an individual (or an AI) reviews and approves the code.`}) 
    CodeApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CodeApprovedByUserID?: string;
        
    @Field({nullable: true, description: `When the code was approved.`}) 
    @MaxLength(10)
    CodeApprovedAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 1, Code will never be generated by the AI system. This overrides all other settings including the ForceCodeGeneration bit`}) 
    CodeLocked: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, the Action will generate code for the provided UserPrompt on the next Save even if the UserPrompt hasn't changed. This is useful to force regeneration when other candidates (such as a change in Action Inputs/Outputs) occurs or on demand by a user.`}) 
    ForceCodeGeneration: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain execution logs; NULL for indefinite.`}) 
    RetentionPeriod?: number;
        
    @Field({description: `Status of the action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `For actions where Type='Custom', this specifies the fully qualified class name of the BaseAction sub-class that should be instantiated to handle the action execution. This provides a more reliable mechanism than relying on the Name field for class instantiation.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Optional ID of the parent action this action inherits from. Used for hierarchical action composition where child actions can specialize parent actions.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class (e.g., fa-cog, fa-play, fa-search) for visual representation of the action.`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field({nullable: true, description: `Default prompt for compacting/summarizing this action's results when used by agents with CompactMode=AISummary. Action designers define how their specific results should be summarized. Can be overridden per agent in AIAgentAction.CompactPromptID.`}) 
    @MaxLength(16)
    DefaultCompactPromptID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CodeApprovedByUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultCompactPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJActionParam_])
    ActionParams_ActionIDArray: MJActionParam_[]; // Link to ActionParams
    
    @Field(() => [MJActionLibrary_])
    ActionLibraries_ActionIDArray: MJActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [MJActionResultCode_])
    ActionResultCodes_ActionIDArray: MJActionResultCode_[]; // Link to ActionResultCodes
    
    @Field(() => [MJScheduledAction_])
    ScheduledActions_ActionIDArray: MJScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [MJAIAgentAction_])
    AIAgentActions_ActionIDArray: MJAIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [MJMCPServerTool_])
    MJ_MCPServerTools_GeneratedActionIDArray: MJMCPServerTool_[]; // Link to MJ_MCPServerTools
    
    @Field(() => [MJActionContext_])
    ActionContexts_ActionIDArray: MJActionContext_[]; // Link to ActionContexts
    
    @Field(() => [MJEntityAction_])
    EntityActions_ActionIDArray: MJEntityAction_[]; // Link to EntityActions
    
    @Field(() => [MJAIAgentStep_])
    MJ_AIAgentSteps_ActionIDArray: MJAIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [MJActionExecutionLog_])
    ActionExecutionLogs_ActionIDArray: MJActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [MJActionAuthorization_])
    ActionAuthorizations_ActionIDArray: MJActionAuthorization_[]; // Link to ActionAuthorizations
    
    @Field(() => [MJAction_])
    Actions_ParentIDArray: MJAction_[]; // Link to Actions
    
}

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class CreateMJActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    CodeComments: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID: string | null;

    @Field({ nullable: true })
    CodeApprovedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    DefaultCompactPromptID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class UpdateMJActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    CodeComments?: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments?: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID?: string | null;

    @Field({ nullable: true })
    CodeApprovedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    DefaultCompactPromptID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Actions
//****************************************************************************
@ObjectType()
export class RunMJActionViewResult {
    @Field(() => [MJAction_])
    Results: MJAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAction_)
export class MJActionResolver extends ResolverBase {
    @Query(() => RunMJActionViewResult)
    async RunMJActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionViewResult)
    async RunMJActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJActionViewResult)
    async RunMJActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAction_, { nullable: true })
    async MJAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAction_ | null> {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionParam_])
    async ActionParams_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionLibrary_])
    async ActionLibraries_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Libraries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionResultCode_])
    async ActionResultCodes_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Result Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledAction_])
    async ScheduledActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async AIAgentActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerTool_])
    async MJ_MCPServerTools_GeneratedActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerTools] WHERE [GeneratedActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionContext_])
    async ActionContexts_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Contexts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAction_])
    async EntityActions_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJ_AIAgentSteps_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionExecutionLog_])
    async ActionExecutionLogs_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionAuthorization_])
    async ActionAuthorizations_ActionIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ActionID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async Actions_ParentIDArray(@Root() mjaction_: MJAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [ParentID]='${mjaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAction_)
    async CreateMJAction(
        @Arg('input', () => CreateMJActionInput) input: CreateMJActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAction_)
    async UpdateMJAction(
        @Arg('input', () => UpdateMJActionInput) input: UpdateMJActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAction_)
    async DeleteMJAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Actions
//****************************************************************************
@ObjectType({ description: `List of all actions that are possible across all AI Models` })
export class MJAIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `The standard prompt template used when invoking this AI action, can include placeholders for dynamic values.`}) 
    DefaultPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DefaultModelID?: string;
        
    @Field(() => Boolean, {description: `Controls whether this AI action is currently available for use across the system.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DefaultModel?: string;
        
    @Field(() => [MJAIModelAction_])
    AIModelActions_AIActionIDArray: MJAIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [MJEntityAIAction_])
    EntityAIActions_AIActionIDArray: MJEntityAIAction_[]; // Link to EntityAIActions
    
}

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class CreateMJAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultPrompt: string | null;

    @Field({ nullable: true })
    DefaultModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class UpdateMJAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultPrompt?: string | null;

    @Field({ nullable: true })
    DefaultModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Actions
//****************************************************************************
@ObjectType()
export class RunMJAIActionViewResult {
    @Field(() => [MJAIAction_])
    Results: MJAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAction_)
export class MJAIActionResolver extends ResolverBase {
    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIActionViewResult)
    async RunMJAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAction_, { nullable: true })
    async MJAIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAction_ | null> {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIAction_])
    async AllAIActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions]` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelAction_])
    async AIModelActions_AIActionIDArray(@Root() mjaiaction_: MJAIAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIActionID]='${mjaiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async EntityAIActions_AIActionIDArray(@Root() mjaiaction_: MJAIAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIActionID]='${mjaiaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAction_)
    async CreateMJAIAction(
        @Arg('input', () => CreateMJAIActionInput) input: CreateMJAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAction_)
    async UpdateMJAIAction(
        @Arg('input', () => UpdateMJAIActionInput) input: UpdateMJAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAction_)
    async DeleteMJAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Actions
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and actions.` })
export class MJAIAgentAction_ {
    @Field({description: `The unique identifier for each AI agent-action mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from the AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated action from the Action table.`}) 
    @MaxLength(16)
    ActionID?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Minimum number of times this action must be executed per agent run`}) 
    MinExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of times this action can be executed per agent run`}) 
    MaxExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of conversation turns before action results expire from conversation context. NULL = never expire (default). 0 = expire immediately after next turn.`}) 
    ResultExpirationTurns?: number;
        
    @Field({description: `How to handle expired action results: None (no expiration, default), Remove (delete message entirely), Compact (reduce size via CompactMode while preserving key information).`}) 
    @MaxLength(40)
    ResultExpirationMode: string;
        
    @Field({nullable: true, description: `How to compact results when ResultExpirationMode=Compact: FirstNChars (truncate to CompactLength characters, fast and free), AISummary (use LLM to intelligently summarize with CompactPromptID or Action.DefaultCompactPromptID).`}) 
    @MaxLength(40)
    CompactMode?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of characters to keep when CompactMode=FirstNChars. Required when CompactMode is FirstNChars, ignored otherwise.`}) 
    CompactLength?: number;
        
    @Field({nullable: true, description: `Optional override for AI summarization prompt when CompactMode=AISummary. Lookup hierarchy: this field -> Action.DefaultCompactPromptID -> system default. Allows agent-specific summarization focus (e.g., technical vs. marketing perspective).`}) 
    @MaxLength(16)
    CompactPromptID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Action?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CompactPrompt?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class CreateMJAIAgentActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    ResultExpirationTurns: number | null;

    @Field({ nullable: true })
    ResultExpirationMode?: string;

    @Field({ nullable: true })
    CompactMode: string | null;

    @Field(() => Int, { nullable: true })
    CompactLength: number | null;

    @Field({ nullable: true })
    CompactPromptID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class UpdateMJAIAgentActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    ResultExpirationTurns?: number | null;

    @Field({ nullable: true })
    ResultExpirationMode?: string;

    @Field({ nullable: true })
    CompactMode?: string | null;

    @Field(() => Int, { nullable: true })
    CompactLength?: number | null;

    @Field({ nullable: true })
    CompactPromptID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Actions
//****************************************************************************
@ObjectType()
export class RunMJAIAgentActionViewResult {
    @Field(() => [MJAIAgentAction_])
    Results: MJAIAgentAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentAction_)
export class MJAIAgentActionResolver extends ResolverBase {
    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentActionViewResult)
    async RunMJAIAgentActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentAction_, { nullable: true })
    async MJAIAgentAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentAction_ | null> {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agent Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentAction_)
    async CreateMJAIAgentAction(
        @Arg('input', () => CreateMJAIAgentActionInput) input: CreateMJAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentAction_)
    async UpdateMJAIAgentAction(
        @Arg('input', () => UpdateMJAIAgentActionInput) input: UpdateMJAIAgentActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentAction_)
    async DeleteMJAIAgentAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Learning Cycles
//****************************************************************************
@ObjectType({ description: `Tracks the learning cycles for AI Agents where the Agent does offline reasoning, reflection, learning, and updates metadata.` })
export class MJAIAgentLearningCycle_ {
    @Field({description: `Unique identifier for the learning cycle.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Identifier for the AI Agent associated with this learning cycle.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp indicating when the learning cycle started.`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp indicating when the learning cycle ended.`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Status of the learning cycle (In-Progress, Complete, or Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Text summary provided by the agent about what it learned and any changes it requested for stored metadata.`}) 
    AgentSummary?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class CreateMJAIAgentLearningCycleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class UpdateMJAIAgentLearningCycleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Learning Cycles
//****************************************************************************
@ObjectType()
export class RunMJAIAgentLearningCycleViewResult {
    @Field(() => [MJAIAgentLearningCycle_])
    Results: MJAIAgentLearningCycle_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentLearningCycle_)
export class MJAIAgentLearningCycleResolver extends ResolverBase {
    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentLearningCycleViewResult)
    async RunMJAIAgentLearningCycleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Learning Cycles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentLearningCycle_, { nullable: true })
    async MJAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentLearningCycle_ | null> {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agent Learning Cycles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentLearningCycle_)
    async CreateMJAIAgentLearningCycle(
        @Arg('input', () => CreateMJAIAgentLearningCycleInput) input: CreateMJAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Learning Cycles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentLearningCycle_)
    async UpdateMJAIAgentLearningCycle(
        @Arg('input', () => UpdateMJAIAgentLearningCycleInput) input: UpdateMJAIAgentLearningCycleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Learning Cycles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentLearningCycle_)
    async DeleteMJAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Learning Cycles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Models
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and AI models.` })
export class MJAIAgentModel_ {
    @Field({description: `The unique identifier for each AI agent-model mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `The unique identifier of the associated AI model.`}) 
    @MaxLength(16)
    ModelID?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether this specific agent-model combination is currently enabled for use in AI operations.`}) 
    Active?: boolean;
        
    @Field(() => Int, {nullable: true, description: `The priority level of the AI model for the agent, where higher values indicate higher priority.`}) 
    Priority?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Model?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class CreateMJAIAgentModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    Active: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class UpdateMJAIAgentModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Models
//****************************************************************************
@ObjectType()
export class RunMJAIAgentModelViewResult {
    @Field(() => [MJAIAgentModel_])
    Results: MJAIAgentModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentModel_)
export class MJAIAgentModelResolver extends ResolverBase {
    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModelViewResult)
    async RunMJAIAgentModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentModel_, { nullable: true })
    async MJAIAgentModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentModel_ | null> {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agent Models', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentModel_)
    async CreateMJAIAgentModel(
        @Arg('input', () => CreateMJAIAgentModelInput) input: CreateMJAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentModel_)
    async UpdateMJAIAgentModel(
        @Arg('input', () => UpdateMJAIAgentModelInput) input: UpdateMJAIAgentModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentModel_)
    async DeleteMJAIAgentModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Note Types
//****************************************************************************
@ObjectType({ description: `Defines categories and types for AI agent notes, enabling classification and organization of agent-generated observations, recommendations, and learnings.` })
export class MJAIAgentNoteType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {description: `Priority for injection ordering. Lower numbers are injected first (0 is highest priority).`}) 
    Priority: number;
        
    @Field({description: `Status of the note type: Pending (awaiting approval), Active (available for use), or Revoked (deprecated).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_AgentNoteTypeIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentNoteTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentNoteTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Note Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentNoteTypeViewResult {
    @Field(() => [MJAIAgentNoteType_])
    Results: MJAIAgentNoteType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentNoteType_)
export class MJAIAgentNoteTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteTypeViewResult)
    async RunMJAIAgentNoteTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Note Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentNoteType_, { nullable: true })
    async MJAIAgentNoteType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentNoteType_ | null> {
        this.CheckUserReadPermissions('AI Agent Note Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNoteTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Note Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agent Note Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_AgentNoteTypeIDArray(@Root() mjaiagentnotetype_: MJAIAgentNoteType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentNoteTypeID]='${mjaiagentnotetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentNoteType_)
    async CreateMJAIAgentNoteType(
        @Arg('input', () => CreateMJAIAgentNoteTypeInput) input: CreateMJAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Note Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentNoteType_)
    async UpdateMJAIAgentNoteType(
        @Arg('input', () => UpdateMJAIAgentNoteTypeInput) input: UpdateMJAIAgentNoteTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Note Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentNoteType_)
    async DeleteMJAIAgentNoteType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Note Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Notes
//****************************************************************************
@ObjectType({ description: `Stores notes, observations, and learnings for AI agents with multi-dimensional scoping (Agent, User, company). Scoping is determined by which FK fields are populated: all NULL = global, AgentID only = agent-specific, UserID only = user-specific across all agents, etc.` })
export class MJAIAgentNote_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentNoteTypeID?: string;
        
    @Field({nullable: true, description: `The content of the note, observation, or learning captured by the AI agent during its execution.`}) 
    Note?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Foreign key referencing the ID column in the User table, indicating the user associated with the note. Used when Type=User`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({description: `Quick categorization of the note content: Preference (user preferences), Constraint (hard rules/requirements), Context (background information), Example (sample interactions), or Issue (known problems/limitations). Complements the more detailed AIAgentNoteType categorization.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates whether this note was automatically generated by an AI agent (1) or manually created (0).`}) 
    IsAutoGenerated: boolean;
        
    @Field({nullable: true, description: `Internal comments about this note, not included in agent context injection.`}) 
    Comments?: string;
        
    @Field({description: `Status of the note: Pending (awaiting review), Active (in use), or Revoked (disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional reference to the conversation that inspired or generated this note.`}) 
    @MaxLength(16)
    SourceConversationID?: string;
        
    @Field({nullable: true, description: `Optional reference to the specific conversation message that inspired this note.`}) 
    @MaxLength(16)
    SourceConversationDetailID?: string;
        
    @Field({nullable: true, description: `Optional reference to the AI agent run that generated this note.`}) 
    @MaxLength(16)
    SourceAIAgentRunID?: string;
        
    @Field({nullable: true, description: `Optional company scope for this note. When populated with UserID, creates org+user specific notes.`}) 
    @MaxLength(16)
    CompanyID?: string;
        
    @Field({nullable: true, description: `JSON array of embedding vector for semantic search on Note field. Auto-generated when Note changes.`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `Reference to the AI model used to generate the embedding vector.`}) 
    @MaxLength(16)
    EmbeddingModelID?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying which entity type is used for primary scoping. NULL means this is a global note.`}) 
    @MaxLength(16)
    PrimaryScopeEntityID?: string;
        
    @Field({nullable: true, description: `The record ID within the primary scope entity. NULL means global note. When set with empty SecondaryScopes, indicates primary-scope-only note.`}) 
    @MaxLength(200)
    PrimaryScopeRecordID?: string;
        
    @Field({nullable: true, description: `JSON object containing additional scope dimensions. Empty/NULL with PrimaryScopeRecordID set = org-level note. Populated = fully-scoped note.`}) 
    SecondaryScopes?: string;
        
    @Field({nullable: true, description: `Timestamp of when this note was last accessed/injected into agent context. Used for lifecycle management and cleanup.`}) 
    @MaxLength(10)
    LastAccessedAt?: Date;
        
    @Field(() => Int, {description: `Number of times this note has been accessed/injected into agent context. Used for analytics and determining note value.`}) 
    AccessCount: number;
        
    @Field({nullable: true, description: `Optional expiration timestamp. Notes past this date are candidates for archival. NULL means no expiration.`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentNoteType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceConversation?: string;
        
    @Field({nullable: true}) 
    SourceConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceAIAgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Company?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmbeddingModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    PrimaryScopeEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class CreateMJAIAgentNoteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID: string | null;

    @Field({ nullable: true })
    Note: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SourceConversationID: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID: string | null;

    @Field({ nullable: true })
    CompanyID: string | null;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID: string | null;

    @Field({ nullable: true })
    SecondaryScopes: string | null;

    @Field({ nullable: true })
    LastAccessedAt: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class UpdateMJAIAgentNoteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID?: string | null;

    @Field({ nullable: true })
    Note?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SourceConversationID?: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID?: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID?: string | null;

    @Field({ nullable: true })
    CompanyID?: string | null;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID?: string | null;

    @Field({ nullable: true })
    SecondaryScopes?: string | null;

    @Field({ nullable: true })
    LastAccessedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Notes
//****************************************************************************
@ObjectType()
export class RunMJAIAgentNoteViewResult {
    @Field(() => [MJAIAgentNote_])
    Results: MJAIAgentNote_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentNote_)
export class MJAIAgentNoteResolver extends ResolverBase {
    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentNoteViewResult)
    async RunMJAIAgentNoteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Notes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentNote_, { nullable: true })
    async MJAIAgentNote(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentNote_ | null> {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agent Notes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentNote_)
    async CreateMJAIAgentNote(
        @Arg('input', () => CreateMJAIAgentNoteInput) input: CreateMJAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Notes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentNote_)
    async UpdateMJAIAgentNote(
        @Arg('input', () => UpdateMJAIAgentNoteInput) input: UpdateMJAIAgentNoteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Notes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentNote_)
    async DeleteMJAIAgentNote(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Notes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Requests
//****************************************************************************
@ObjectType({ description: `Table to log AI Agent requests, responses, and their statuses.` })
export class MJAIAgentRequest_ {
    @Field({description: `Primary key for the AIAgentRequest table, uniquely identifies each record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key referencing the ID column in the AIAgent table.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp when the request was made by the agent.`}) 
    @MaxLength(10)
    RequestedAt: Date;
        
    @Field({nullable: true, description: `Optional, a user that the AI specifically is directing the request to, if null intended for general system owner.`}) 
    @MaxLength(16)
    RequestForUserID?: string;
        
    @Field({description: `Current status of the request (Requested, Approved, Rejected, Canceled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Details of what the AI Agent is requesting.`}) 
    Request: string;
        
    @Field({nullable: true, description: `Response provided by the human to the agent request.`}) 
    Response?: string;
        
    @Field({nullable: true, description: `Populated when a user responds indicating which user responded to the request.`}) 
    @MaxLength(16)
    ResponseByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when the response was provided by the human.`}) 
    @MaxLength(10)
    RespondedAt?: Date;
        
    @Field({nullable: true, description: `Additional comments about the request. Not shared with the agent, purely record keeping.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    RequestForUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ResponseByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class CreateMJAIAgentRequestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response: string | null;

    @Field({ nullable: true })
    ResponseByUserID: string | null;

    @Field({ nullable: true })
    RespondedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRequestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response?: string | null;

    @Field({ nullable: true })
    ResponseByUserID?: string | null;

    @Field({ nullable: true })
    RespondedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Requests
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRequestViewResult {
    @Field(() => [MJAIAgentRequest_])
    Results: MJAIAgentRequest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRequest_)
export class MJAIAgentRequestResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRequestViewResult)
    async RunMJAIAgentRequestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Requests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRequest_, { nullable: true })
    async MJAIAgentRequest(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRequest_ | null> {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agent Requests', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentRequest_)
    async CreateMJAIAgentRequest(
        @Arg('input', () => CreateMJAIAgentRequestInput) input: CreateMJAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agent Requests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRequest_)
    async UpdateMJAIAgentRequest(
        @Arg('input', () => UpdateMJAIAgentRequestInput) input: UpdateMJAIAgentRequestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agent Requests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRequest_)
    async DeleteMJAIAgentRequest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Requests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agents
//****************************************************************************
@ObjectType({ description: `Table to store information about AI agents.` })
export class MJAIAgent_ {
    @Field({description: `The unique identifier for each AI agent. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `The name of the AI agent.`}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true, description: `A detailed description of the AI agent.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `URL to an image file or base64 data URI (e.g., data:image/png;base64,...) for the agent logo. Takes precedence over IconClass in UI display.`}) 
    @MaxLength(510)
    LogoURL?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `References the parent agent in the hierarchical structure. If NULL, this is a root (top-level) agent.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field(() => Boolean, {description: `When true, this agent can be exposed as an action for use by other agents. Only valid for root agents.`}) 
    ExposeAsAction: boolean;
        
    @Field(() => Int, {description: `The order in which this agent should be executed among its siblings under the same parent.`}) 
    ExecutionOrder: number;
        
    @Field({description: `Controls how this agent's child agents are executed. Sequential runs children in order, Parallel runs them simultaneously.`}) 
    @MaxLength(40)
    ExecutionMode: string;
        
    @Field(() => Boolean, {description: `When true, enables automatic compression of conversation context when the message threshold is reached.`}) 
    EnableContextCompression: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of messages that triggers context compression when EnableContextCompression is true.`}) 
    ContextCompressionMessageThreshold?: number;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ContextCompressionPromptID?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of recent messages to keep uncompressed when context compression is applied.`}) 
    ContextCompressionMessageRetentionCount?: number;
        
    @Field({nullable: true, description: `Reference to the AIAgentType that defines the category and system-level behavior for this agent. Cannot be null.`}) 
    @MaxLength(16)
    TypeID?: string;
        
    @Field({description: `Current status of the AI agent. Active agents can be executed, Disabled agents are inactive, and Pending agents are awaiting configuration or approval. Allowed values: Active, Disabled, Pending.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional override for the class name used by the MemberJunction class factory to instantiate this specific agent. If specified, this overrides the agent type's DriverClass. Useful for specialized agent implementations.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class (e.g., fa-robot, fa-brain) for the agent. Used as fallback when LogoURL is not set or fails to load.`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field({description: `Controls whether model selection is driven by the Agent Type's system prompt or the Agent's specific prompt. Default is Agent Type for backward compatibility.`}) 
    @MaxLength(100)
    ModelSelectionMode: string;
        
    @Field({description: `JSON array of paths that define which parts of the payload should be sent downstream to sub-agents. Use ["*"] to send entire payload, or specify paths like ["customer.id", "campaign.*", "analysis.sentiment"]`}) 
    PayloadDownstreamPaths: string;
        
    @Field({description: `JSON array of paths that define which parts of the payload sub-agents are allowed to write back upstream. Use ["*"] to allow all writes, or specify paths like ["analysis.results", "recommendations.*"]`}) 
    PayloadUpstreamPaths: string;
        
    @Field({nullable: true, description: `JSON array of paths that specify what parts of the payload the agent's own prompt can read. Controls downstream data 
flow when the agent executes its own prompt step.`}) 
    PayloadSelfReadPaths?: string;
        
    @Field({nullable: true, description: `JSON array of paths that specify what parts of the payload the agent's own prompt can write back. Controls upstream 
data flow when the agent executes its own prompt step.`}) 
    PayloadSelfWritePaths?: string;
        
    @Field({nullable: true, description: `Defines the scope/path within the parent payload that this sub-agent operates on. When set, the sub-agent receives only this portion of the payload and all change requests are relative to this scope. Format: /path/to/scope (e.g. /PropA/SubProp1)`}) 
    PayloadScope?: string;
        
    @Field({nullable: true, description: `Optional JSON schema or requirements that define the expected structure and content of the agent's final payload. Used to validate the output when the agent declares success. Similar to OutputExample in AI Prompts.`}) 
    FinalPayloadValidation?: string;
        
    @Field({description: `Determines how to handle validation failures when FinalPayloadValidation is specified. Options: Retry (default) - retry the agent with validation feedback, Fail - fail the agent run immediately, Warn - log a warning but allow success.`}) 
    @MaxLength(50)
    FinalPayloadValidationMode: string;
        
    @Field(() => Int, {description: `Maximum number of retry attempts allowed when FinalPayloadValidation fails with
Retry mode. After reaching this limit, the validation will fail permanently.`}) 
    FinalPayloadValidationMaxRetries: number;
        
    @Field(() => Float, {nullable: true, description: `Maximum cost in dollars allowed for a single agent run. Run will be terminated
if this limit is exceeded.`}) 
    MaxCostPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum total tokens (input + output) allowed for a single agent run. Run will
be terminated if this limit is exceeded.`}) 
    MaxTokensPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of prompt iterations allowed for a single agent run. Run will be
terminated if this limit is exceeded.`}) 
    MaxIterationsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum time in seconds allowed for a single agent run. Run will be terminated
if this limit is exceeded.`}) 
    MaxTimePerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `When acting as a sub-agent, minimum number of times this agent must be executed per parent agent run`}) 
    MinExecutionsPerRun?: number;
        
    @Field(() => Int, {nullable: true, description: `When acting as a sub-agent, maximum number of times this agent can be executed per parent agent run`}) 
    MaxExecutionsPerRun?: number;
        
    @Field({nullable: true, description: `Optional JSON schema validation to apply to the input payload before agent execution begins. Uses the same JSONValidator format as FinalPayloadValidation.`}) 
    StartingPayloadValidation?: string;
        
    @Field({description: `Determines how to handle StartingPayloadValidation failures. Fail = reject invalid input, Warn = log warning but proceed.`}) 
    @MaxLength(50)
    StartingPayloadValidationMode: string;
        
    @Field(() => Int, {nullable: true, description: `Default effort level for all prompts executed by this agent (1-100, where 1=minimal effort, 100=maximum effort). Takes precedence over individual prompt EffortLevel settings but can be overridden by runtime parameters. Inherited by sub-agents unless explicitly overridden.`}) 
    DefaultPromptEffortLevel?: number;
        
    @Field({nullable: true, description: `Controls how Chat next steps are handled. When null (default), Chat propagates to caller. When set to Success, Failed, or Retry, Chat steps are remapped to that value and re-validated.`}) 
    @MaxLength(60)
    ChatHandlingOption?: string;
        
    @Field({nullable: true, description: `Default artifact type produced by this agent. This is the primary artifact type; additional artifact types can be linked via AIAgentArtifactType junction table. Can be NULL if agent does not produce artifacts by default.`}) 
    @MaxLength(16)
    DefaultArtifactTypeID?: string;
        
    @Field({description: `The user who owns and created this AI agent. Automatically set to the current user if not specified. Owner has full permissions (view, run, edit, delete) regardless of ACL entries.`}) 
    @MaxLength(16)
    OwnerUserID: string;
        
    @Field({description: `Controls how the agent can be invoked: Any (default - can be top-level or sub-agent), Top-Level (only callable as primary agent), Sub-Agent (only callable as sub-agent). Used to filter available agents in tools like Sage.`}) 
    @MaxLength(40)
    InvocationMode: string;
        
    @Field({description: `Controls how artifacts are created from this agent's payloads. "Always" creates visible artifacts, "Never" skips artifact creation, "System Only" creates hidden system artifacts.`}) 
    @MaxLength(40)
    ArtifactCreationMode: string;
        
    @Field({nullable: true, description: `Detailed markdown formatted requirements that explain the business goals of the agent without specific technical implementation details.`}) 
    FunctionalRequirements?: string;
        
    @Field({nullable: true, description: `Detailed markdown that explains the structure of the agent including agent architecture, actions, sub-agents, prompts, and payload structure.`}) 
    TechnicalDesign?: string;
        
    @Field(() => Boolean, {description: `When enabled, agent notes will be automatically injected into the agent context based on scoping rules.`}) 
    InjectNotes: boolean;
        
    @Field(() => Int, {description: `Maximum number of notes to inject into agent context per request.`}) 
    MaxNotesToInject: number;
        
    @Field({description: `Strategy for selecting which notes to inject: Relevant (semantic search), Recent (most recent first), or All (up to max limit).`}) 
    @MaxLength(40)
    NoteInjectionStrategy: string;
        
    @Field(() => Boolean, {description: `When enabled, agent examples will be automatically injected into the agent context based on scoping rules.`}) 
    InjectExamples: boolean;
        
    @Field(() => Int, {description: `Maximum number of examples to inject into agent context per request.`}) 
    MaxExamplesToInject: number;
        
    @Field({description: `Strategy for selecting which examples to inject: Semantic (vector similarity), Recent (most recent first), or Rated (highest success score first).`}) 
    @MaxLength(40)
    ExampleInjectionStrategy: string;
        
    @Field(() => Boolean, {description: `When true, agent is restricted to system/scheduled use only and hidden from user selection, Agent Manager, and MCP/A2A discovery.`}) 
    IsRestricted: boolean;
        
    @Field({description: `Specifies how conversation messages are passed from parent agent to this child sub-agent (when this agent is a child via ParentID). Valid values: 'None' (fresh start - only context and task message, default), 'All' (all parent conversation history), 'Latest' (most recent MaxMessages messages), 'Bookend' (first 2 messages + most recent MaxMessages-2 messages with indicator between). Stored on child agent because each child has only one parent relationship.`}) 
    @MaxLength(100)
    MessageMode: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of conversation messages to include when MessageMode is 'Latest' or 'Bookend'. NULL means no limit (ignored for 'None' and 'All' modes). Must be greater than 0 if specified. For 'Latest': keeps most recent N messages. For 'Bookend': keeps first 2 + most recent (N-2) messages.`}) 
    MaxMessages?: number;
        
    @Field({nullable: true, description: `File storage provider for large attachments. Overrides the default from AIConfiguration. NULL uses system default.`}) 
    @MaxLength(16)
    AttachmentStorageProviderID?: string;
        
    @Field({nullable: true, description: `Base path within the storage provider for this agent's attachments. Agent run ID and sequence number are appended to create unique paths. Format: /folder/subfolder`}) 
    @MaxLength(1000)
    AttachmentRootPath?: string;
        
    @Field(() => Int, {nullable: true, description: `File size threshold for inline storage. Files <= this size are stored as base64 inline, larger files use MJStorage. NULL uses system default (1MB). Set to 0 to always use MJStorage.`}) 
    InlineStorageThresholdBytes?: number;
        
    @Field({nullable: true, description: `JSON object containing parameter values that customize how this agent's type-level system prompt is rendered. The schema is defined by the agent type's PromptParamsSchema field. Allows per-agent control over which prompt sections are included, enabling token savings by excluding unused documentation.`}) 
    AgentTypePromptParams?: string;
        
    @Field({nullable: true, description: `JSON configuration defining scope dimensions for multi-tenant deployments. Example: {"dimensions":[{"name":"OrganizationID","entityId":"...","isPrimary":true,"required":true},{"name":"ContactID","entityId":"...","isPrimary":false,"required":false}],"inheritanceMode":"cascading"}`}) 
    ScopeConfig?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain notes before archiving due to inactivity. Default 90. NULL means use system default.`}) 
    NoteRetentionDays?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain examples before archiving due to inactivity. Default 180. NULL means use system default.`}) 
    ExampleRetentionDays?: number;
        
    @Field(() => Boolean, {description: `Whether automatic archival of stale notes/examples is enabled for this agent. Default true.`}) 
    AutoArchiveEnabled: boolean;
        
    @Field({nullable: true, description: `JSON configuration for optional reranking of retrieved memory items. Schema: { enabled: boolean, rerankerModelId: string, retrievalMultiplier: number (default 3), minRelevanceThreshold: number (default 0.5), rerankPromptId?: string, contextFields?: string[], fallbackOnError: boolean (default true) }. When null or disabled, vector search results are used directly without reranking.`}) 
    RerankerConfiguration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContextCompressionPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Type?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DefaultArtifactType?: string;
        
    @Field() 
    @MaxLength(200)
    OwnerUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    AttachmentStorageProvider?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAIAgentModel_])
    AIAgentModels_AgentIDArray: MJAIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [MJAIAgentAction_])
    AIAgentActions_AgentIDArray: MJAIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [MJAIAgentLearningCycle_])
    AIAgentLearningCycles_AgentIDArray: MJAIAgentLearningCycle_[]; // Link to AIAgentLearningCycles
    
    @Field(() => [MJAIAgentRequest_])
    AIAgentRequests_AgentIDArray: MJAIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [MJAIAgentStep_])
    MJ_AIAgentSteps_AgentIDArray: MJAIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [MJAIAgentRelationship_])
    MJ_AIAgentRelationships_AgentIDArray: MJAIAgentRelationship_[]; // Link to MJ_AIAgentRelationships
    
    @Field(() => [MJAIAgentArtifactType_])
    MJ_AIAgentArtifactTypes_AgentIDArray: MJAIAgentArtifactType_[]; // Link to MJ_AIAgentArtifactTypes
    
    @Field(() => [MJAIAgentPermission_])
    MJ_AIAgentPermissions_AgentIDArray: MJAIAgentPermission_[]; // Link to MJ_AIAgentPermissions
    
    @Field(() => [MJAIAgentDataSource_])
    MJ_AIAgentDataSources_AgentIDArray: MJAIAgentDataSource_[]; // Link to MJ_AIAgentDataSources
    
    @Field(() => [MJAIAgentModality_])
    MJ_AIAgentModalities_AgentIDArray: MJAIAgentModality_[]; // Link to MJ_AIAgentModalities
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_AgentIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJAIAgentPrompt_])
    MJ_AIAgentPrompts_AgentIDArray: MJAIAgentPrompt_[]; // Link to MJ_AIAgentPrompts
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_AgentIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJAIAgentStep_])
    MJ_AIAgentSteps_SubAgentIDArray: MJAIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [MJAIAgentRelationship_])
    MJ_AIAgentRelationships_SubAgentIDArray: MJAIAgentRelationship_[]; // Link to MJ_AIAgentRelationships
    
    @Field(() => [MJTask_])
    MJ_Tasks_AgentIDArray: MJTask_[]; // Link to MJ_Tasks
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_AgentIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
    @Field(() => [MJAIAgentConfiguration_])
    MJ_AIAgentConfigurations_AgentIDArray: MJAIAgentConfiguration_[]; // Link to MJ_AIAgentConfigurations
    
    @Field(() => [MJAIResultCache_])
    AIResultCache_AgentIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_AgentIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJConversationDetail_])
    ConversationDetails_AgentIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [MJAIAgent_])
    AIAgents_ParentIDArray: MJAIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class CreateMJAIAgentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field(() => Boolean, { nullable: true })
    ExposeAsAction?: boolean;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ExecutionMode?: string;

    @Field(() => Boolean, { nullable: true })
    EnableContextCompression?: boolean;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageThreshold: number | null;

    @Field({ nullable: true })
    ContextCompressionPromptID: string | null;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageRetentionCount: number | null;

    @Field({ nullable: true })
    TypeID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    ModelSelectionMode?: string;

    @Field({ nullable: true })
    PayloadDownstreamPaths?: string;

    @Field({ nullable: true })
    PayloadUpstreamPaths?: string;

    @Field({ nullable: true })
    PayloadSelfReadPaths: string | null;

    @Field({ nullable: true })
    PayloadSelfWritePaths: string | null;

    @Field({ nullable: true })
    PayloadScope: string | null;

    @Field({ nullable: true })
    FinalPayloadValidation: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    FinalPayloadValidationMaxRetries?: number;

    @Field(() => Float, { nullable: true })
    MaxCostPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxTokensPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxIterationsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxTimePerRun: number | null;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun: number | null;

    @Field({ nullable: true })
    StartingPayloadValidation: string | null;

    @Field({ nullable: true })
    StartingPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    DefaultPromptEffortLevel: number | null;

    @Field({ nullable: true })
    ChatHandlingOption: string | null;

    @Field({ nullable: true })
    DefaultArtifactTypeID: string | null;

    @Field({ nullable: true })
    OwnerUserID?: string;

    @Field({ nullable: true })
    InvocationMode?: string;

    @Field({ nullable: true })
    ArtifactCreationMode?: string;

    @Field({ nullable: true })
    FunctionalRequirements: string | null;

    @Field({ nullable: true })
    TechnicalDesign: string | null;

    @Field(() => Boolean, { nullable: true })
    InjectNotes?: boolean;

    @Field(() => Int, { nullable: true })
    MaxNotesToInject?: number;

    @Field({ nullable: true })
    NoteInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    InjectExamples?: boolean;

    @Field(() => Int, { nullable: true })
    MaxExamplesToInject?: number;

    @Field({ nullable: true })
    ExampleInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    IsRestricted?: boolean;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages: number | null;

    @Field({ nullable: true })
    AttachmentStorageProviderID: string | null;

    @Field({ nullable: true })
    AttachmentRootPath: string | null;

    @Field(() => Int, { nullable: true })
    InlineStorageThresholdBytes: number | null;

    @Field({ nullable: true })
    AgentTypePromptParams: string | null;

    @Field({ nullable: true })
    ScopeConfig: string | null;

    @Field(() => Int, { nullable: true })
    NoteRetentionDays?: number | null;

    @Field(() => Int, { nullable: true })
    ExampleRetentionDays?: number | null;

    @Field(() => Boolean, { nullable: true })
    AutoArchiveEnabled?: boolean;

    @Field({ nullable: true })
    RerankerConfiguration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class UpdateMJAIAgentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => Boolean, { nullable: true })
    ExposeAsAction?: boolean;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ExecutionMode?: string;

    @Field(() => Boolean, { nullable: true })
    EnableContextCompression?: boolean;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageThreshold?: number | null;

    @Field({ nullable: true })
    ContextCompressionPromptID?: string | null;

    @Field(() => Int, { nullable: true })
    ContextCompressionMessageRetentionCount?: number | null;

    @Field({ nullable: true })
    TypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    ModelSelectionMode?: string;

    @Field({ nullable: true })
    PayloadDownstreamPaths?: string;

    @Field({ nullable: true })
    PayloadUpstreamPaths?: string;

    @Field({ nullable: true })
    PayloadSelfReadPaths?: string | null;

    @Field({ nullable: true })
    PayloadSelfWritePaths?: string | null;

    @Field({ nullable: true })
    PayloadScope?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidation?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    FinalPayloadValidationMaxRetries?: number;

    @Field(() => Float, { nullable: true })
    MaxCostPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxTokensPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxIterationsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxTimePerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MinExecutionsPerRun?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionsPerRun?: number | null;

    @Field({ nullable: true })
    StartingPayloadValidation?: string | null;

    @Field({ nullable: true })
    StartingPayloadValidationMode?: string;

    @Field(() => Int, { nullable: true })
    DefaultPromptEffortLevel?: number | null;

    @Field({ nullable: true })
    ChatHandlingOption?: string | null;

    @Field({ nullable: true })
    DefaultArtifactTypeID?: string | null;

    @Field({ nullable: true })
    OwnerUserID?: string;

    @Field({ nullable: true })
    InvocationMode?: string;

    @Field({ nullable: true })
    ArtifactCreationMode?: string;

    @Field({ nullable: true })
    FunctionalRequirements?: string | null;

    @Field({ nullable: true })
    TechnicalDesign?: string | null;

    @Field(() => Boolean, { nullable: true })
    InjectNotes?: boolean;

    @Field(() => Int, { nullable: true })
    MaxNotesToInject?: number;

    @Field({ nullable: true })
    NoteInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    InjectExamples?: boolean;

    @Field(() => Int, { nullable: true })
    MaxExamplesToInject?: number;

    @Field({ nullable: true })
    ExampleInjectionStrategy?: string;

    @Field(() => Boolean, { nullable: true })
    IsRestricted?: boolean;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages?: number | null;

    @Field({ nullable: true })
    AttachmentStorageProviderID?: string | null;

    @Field({ nullable: true })
    AttachmentRootPath?: string | null;

    @Field(() => Int, { nullable: true })
    InlineStorageThresholdBytes?: number | null;

    @Field({ nullable: true })
    AgentTypePromptParams?: string | null;

    @Field({ nullable: true })
    ScopeConfig?: string | null;

    @Field(() => Int, { nullable: true })
    NoteRetentionDays?: number | null;

    @Field(() => Int, { nullable: true })
    ExampleRetentionDays?: number | null;

    @Field(() => Boolean, { nullable: true })
    AutoArchiveEnabled?: boolean;

    @Field({ nullable: true })
    RerankerConfiguration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agents
//****************************************************************************
@ObjectType()
export class RunMJAIAgentViewResult {
    @Field(() => [MJAIAgent_])
    Results: MJAIAgent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgent_)
export class MJAIAgentResolver extends ResolverBase {
    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentViewResult)
    async RunMJAIAgentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgent_, { nullable: true })
    async MJAIAgent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgent_ | null> {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Agents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentModel_])
    async AIAgentModels_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async AIAgentActions_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentLearningCycle_])
    async AIAgentLearningCycles_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Learning Cycles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async AIAgentRequests_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJ_AIAgentSteps_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRelationship_])
    async MJ_AIAgentRelationships_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRelationships] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentArtifactType_])
    async MJ_AIAgentArtifactTypes_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentArtifactTypes] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Artifact Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPermission_])
    async MJ_AIAgentPermissions_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPermissions] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentDataSource_])
    async MJ_AIAgentDataSources_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Data Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentDataSources] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Data Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Data Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentModality_])
    async MJ_AIAgentModalities_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModalities] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPrompt_])
    async MJ_AIAgentPrompts_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJ_AIAgentSteps_SubAgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [SubAgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRelationship_])
    async MJ_AIAgentRelationships_SubAgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRelationships] WHERE [SubAgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentConfiguration_])
    async MJ_AIAgentConfigurations_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentConfigurations] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_AgentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [AgentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async AIAgents_ParentIDArray(@Root() mjaiagent_: MJAIAgent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ParentID]='${mjaiagent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgent_)
    async CreateMJAIAgent(
        @Arg('input', () => CreateMJAIAgentInput) input: CreateMJAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Agents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgent_)
    async UpdateMJAIAgent(
        @Arg('input', () => UpdateMJAIAgentInput) input: UpdateMJAIAgentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Agents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgent_)
    async DeleteMJAIAgent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Actions
//****************************************************************************
@ObjectType({ description: `Tracks the actions supported by each AI Model` })
export class MJAIModelAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field(() => Boolean, {description: `Determines if this specific action is currently enabled for the associated AI model.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class CreateMJAIModelActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class UpdateMJAIModelActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Actions
//****************************************************************************
@ObjectType()
export class RunMJAIModelActionViewResult {
    @Field(() => [MJAIModelAction_])
    Results: MJAIModelAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelAction_)
export class MJAIModelActionResolver extends ResolverBase {
    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelActionViewResult)
    async RunMJAIModelActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelAction_, { nullable: true })
    async MJAIModelAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelAction_ | null> {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Model Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIModelAction_])
    async AllAIModelActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions]` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelAction_)
    async CreateMJAIModelAction(
        @Arg('input', () => CreateMJAIModelActionInput) input: CreateMJAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Model Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelAction_)
    async UpdateMJAIModelAction(
        @Arg('input', () => UpdateMJAIModelActionInput) input: UpdateMJAIModelActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Model Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelAction_)
    async DeleteMJAIModelAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Types
//****************************************************************************
@ObjectType({ description: `Types of AI Models` })
export class MJAIModelType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Default input modality for this model type. Models of this type inherit this as their primary input modality unless overridden.`}) 
    @MaxLength(16)
    DefaultInputModalityID: string;
        
    @Field({description: `Default output modality for this model type. Models of this type inherit this as their primary output modality unless overridden.`}) 
    @MaxLength(16)
    DefaultOutputModalityID: string;
        
    @Field() 
    @MaxLength(100)
    DefaultInputModality: string;
        
    @Field() 
    @MaxLength(100)
    DefaultOutputModality: string;
        
    @Field(() => [MJAIModel_])
    AIModels_AIModelTypeIDArray: MJAIModel_[]; // Link to AIModels
    
    @Field(() => [MJAIPrompt_])
    AIPrompts_AIModelTypeIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
}

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class CreateMJAIModelTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultInputModalityID?: string;

    @Field({ nullable: true })
    DefaultOutputModalityID?: string;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultInputModalityID?: string;

    @Field({ nullable: true })
    DefaultOutputModalityID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelTypeViewResult {
    @Field(() => [MJAIModelType_])
    Results: MJAIModelType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelType_)
export class MJAIModelTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelTypeViewResult)
    async RunMJAIModelTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelType_, { nullable: true })
    async MJAIModelType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelType_ | null> {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Model Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIModelType_])
    async AllAIModelTypes(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes]` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Model Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModel_])
    async AIModels_AIModelTypeIDArray(@Root() mjaimodeltype_: MJAIModelType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [AIModelTypeID]='${mjaimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_AIModelTypeIDArray(@Root() mjaimodeltype_: MJAIModelType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [AIModelTypeID]='${mjaimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelType_)
    async CreateMJAIModelType(
        @Arg('input', () => CreateMJAIModelTypeInput) input: CreateMJAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Model Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelType_)
    async UpdateMJAIModelType(
        @Arg('input', () => UpdateMJAIModelTypeInput) input: UpdateMJAIModelTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Model Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelType_)
    async DeleteMJAIModelType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Models
//****************************************************************************
@ObjectType({ description: `Catalog of all AI Models configured in the system` })
export class MJAIModel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the power of the AI model. Default is 0 and should be non-negative.`}) 
    PowerRank?: number;
        
    @Field(() => Boolean, {description: `Controls whether this AI model is available for use in the system.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the speed of the AI model. Default is 0 and should be non-negative.`}) 
    SpeedRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the cost of the AI model. Default is 0 and should be non-negative.`}) 
    CostRank?: number;
        
    @Field({nullable: true, description: `This column stores unstructured text notes that provide insights into what the model is particularly good at and areas where it may not perform as well. These notes can be used by a human or an AI to determine if the model is a good fit for various purposes.`}) 
    ModelSelectionInsights?: string;
        
    @Field(() => Boolean, {description: `When TRUE (default), the model inherits default input/output modalities from its AIModelType AND can extend with additional modalities via AIModelModality records. When FALSE, only modalities explicitly defined in AIModelModality are used.`}) 
    InheritTypeModalities: boolean;
        
    @Field({nullable: true, description: `Reference to the previous version of this model, creating a version lineage chain. For example, GPT-4 Turbo might reference GPT-4 as its prior version.`}) 
    @MaxLength(16)
    PriorVersionID?: string;
        
    @Field() 
    @MaxLength(100)
    AIModelType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    APIName?: string;
        
    @Field(() => Int, {nullable: true}) 
    InputTokenLimit?: number;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SupportedResponseFormats?: string;
        
    @Field(() => Boolean, {nullable: true}) 
    SupportsEffortLevel?: boolean;
        
    @Field(() => [MJAIAction_])
    AIActions_DefaultModelIDArray: MJAIAction_[]; // Link to AIActions
    
    @Field(() => [MJAIModelAction_])
    AIModelActions_AIModelIDArray: MJAIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [MJVectorIndex_])
    VectorIndexes_EmbeddingModelIDArray: MJVectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_AIModelIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [MJEntityAIAction_])
    EntityAIActions_AIModelIDArray: MJEntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [MJContentType_])
    ContentTypes_AIModelIDArray: MJContentType_[]; // Link to ContentTypes
    
    @Field(() => [MJAIResultCache_])
    AIResultCache_AIModelIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_EmbeddingModelIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_EmbeddingModelIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
    @Field(() => [MJAIModelModality_])
    MJ_AIModelModalities_ModelIDArray: MJAIModelModality_[]; // Link to MJ_AIModelModalities
    
    @Field(() => [MJAIModelArchitecture_])
    MJ_AIModelArchitectures_ModelIDArray: MJAIModelArchitecture_[]; // Link to MJ_AIModelArchitectures
    
    @Field(() => [MJAIAgentModel_])
    AIAgentModels_ModelIDArray: MJAIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [MJAIModelVendor_])
    MJ_AIModelVendors_ModelIDArray: MJAIModelVendor_[]; // Link to MJ_AIModelVendors
    
    @Field(() => [MJGeneratedCode_])
    GeneratedCodes_GeneratedByModelIDArray: MJGeneratedCode_[]; // Link to GeneratedCodes
    
    @Field(() => [MJAIModelCost_])
    MJ_AIModelCosts_ModelIDArray: MJAIModelCost_[]; // Link to MJ_AIModelCosts
    
    @Field(() => [MJAIPromptModel_])
    MJ_AIPromptModels_ModelIDArray: MJAIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_ModelIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_OverrideModelIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJQuery_])
    Queries_EmbeddingModelIDArray: MJQuery_[]; // Link to Queries
    
    @Field(() => [MJAIModel_])
    AIModels_PriorVersionIDArray: MJAIModel_[]; // Link to AIModels
    
}

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class CreateMJAIModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights: string | null;

    @Field(() => Boolean, { nullable: true })
    InheritTypeModalities?: boolean;

    @Field({ nullable: true })
    PriorVersionID: string | null;

    @Field({ nullable: true })
    Vendor: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats: string | null;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel: boolean | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class UpdateMJAIModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights?: string | null;

    @Field(() => Boolean, { nullable: true })
    InheritTypeModalities?: boolean;

    @Field({ nullable: true })
    PriorVersionID?: string | null;

    @Field({ nullable: true })
    Vendor?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string | null;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Models
//****************************************************************************
@ObjectType()
export class RunMJAIModelViewResult {
    @Field(() => [MJAIModel_])
    Results: MJAIModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModel_)
export class MJAIModelResolver extends ResolverBase {
    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelViewResult)
    async RunMJAIModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModel_, { nullable: true })
    async MJAIModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModel_ | null> {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Models', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAIModel_])
    async AllAIModels(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels]` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAction_])
    async AIActions_DefaultModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [DefaultModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelAction_])
    async AIModelActions_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Model Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVectorIndex_])
    async VectorIndexes_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [EmbeddingModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Vector Indexes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async EntityAIActions_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentType_])
    async ContentTypes_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_AIModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [EmbeddingModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [EmbeddingModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelModality_])
    async MJ_AIModelModalities_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelModalities] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelArchitecture_])
    async MJ_AIModelArchitectures_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelArchitectures] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Architectures', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentModel_])
    async AIAgentModels_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelVendor_])
    async MJ_AIModelVendors_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async GeneratedCodes_GeneratedByModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [GeneratedByModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelCost_])
    async MJ_AIModelCosts_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptModel_])
    async MJ_AIPromptModels_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_ModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_OverrideModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [OverrideModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQuery_])
    async Queries_EmbeddingModelIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [EmbeddingModelID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Queries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModel_])
    async AIModels_PriorVersionIDArray(@Root() mjaimodel_: MJAIModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [PriorVersionID]='${mjaimodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModel_)
    async CreateMJAIModel(
        @Arg('input', () => CreateMJAIModelInput) input: CreateMJAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModel_)
    async UpdateMJAIModel(
        @Arg('input', () => UpdateMJAIModelInput) input: UpdateMJAIModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModel_)
    async DeleteMJAIModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Categories
//****************************************************************************
@ObjectType({ description: `Categories for organizing AI prompts in a hierarchical structure.` })
export class MJAIPromptCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Parent category ID for hierarchical organization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAIPrompt_])
    AIPrompts_CategoryIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [MJAIPromptCategory_])
    AIPromptCategories_ParentIDArray: MJAIPromptCategory_[]; // Link to AIPromptCategories
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class CreateMJAIPromptCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class UpdateMJAIPromptCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Categories
//****************************************************************************
@ObjectType()
export class RunMJAIPromptCategoryViewResult {
    @Field(() => [MJAIPromptCategory_])
    Results: MJAIPromptCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptCategory_)
export class MJAIPromptCategoryResolver extends ResolverBase {
    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptCategoryViewResult)
    async RunMJAIPromptCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptCategory_, { nullable: true })
    async MJAIPromptCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptCategory_ | null> {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Prompt Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_CategoryIDArray(@Root() mjaipromptcategory_: MJAIPromptCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [CategoryID]='${mjaipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptCategory_])
    async AIPromptCategories_ParentIDArray(@Root() mjaipromptcategory_: MJAIPromptCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ParentID]='${mjaipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Prompt Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptCategory_)
    async CreateMJAIPromptCategory(
        @Arg('input', () => CreateMJAIPromptCategoryInput) input: CreateMJAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompt Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptCategory_)
    async UpdateMJAIPromptCategory(
        @Arg('input', () => UpdateMJAIPromptCategoryInput) input: UpdateMJAIPromptCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompt Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptCategory_)
    async DeleteMJAIPromptCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Types
//****************************************************************************
@ObjectType({ description: `Types of AI prompts such as Chat, Text-to-Image, Text-to-Video, etc.` })
export class MJAIPromptType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIPrompt_])
    AIPrompts_TypeIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class CreateMJAIPromptTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class UpdateMJAIPromptTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Types
//****************************************************************************
@ObjectType()
export class RunMJAIPromptTypeViewResult {
    @Field(() => [MJAIPromptType_])
    Results: MJAIPromptType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptType_)
export class MJAIPromptTypeResolver extends ResolverBase {
    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptTypeViewResult)
    async RunMJAIPromptTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptType_, { nullable: true })
    async MJAIPromptType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptType_ | null> {
        this.CheckUserReadPermissions('AI Prompt Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompt Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Prompt Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_TypeIDArray(@Root() mjaiprompttype_: MJAIPromptType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TypeID]='${mjaiprompttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptType_)
    async CreateMJAIPromptType(
        @Arg('input', () => CreateMJAIPromptTypeInput) input: CreateMJAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompt Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptType_)
    async UpdateMJAIPromptType(
        @Arg('input', () => UpdateMJAIPromptTypeInput) input: UpdateMJAIPromptTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompt Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptType_)
    async DeleteMJAIPromptType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompts
//****************************************************************************
@ObjectType({ description: `Stores AI prompts, including references to categories, types, and templates.` })
export class MJAIPrompt_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Reference to the template used for the prompt.`}) 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({nullable: true, description: `Reference to the category the prompt belongs to.`}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `Reference to the type of the prompt.`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Specifies the expected response format for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(40)
    ResponseFormat: string;
        
    @Field({nullable: true, description: `A JSON-formatted string containing model-specific response format instructions. This will be parsed and provided as a JSON object to the model.`}) 
    ModelSpecificResponseFormat?: string;
        
    @Field({nullable: true, description: `References the type of AI model this prompt is designed for (LLM, Image, Audio, etc.).`}) 
    @MaxLength(16)
    AIModelTypeID?: string;
        
    @Field(() => Int, {nullable: true, description: `The minimum power rank required for models to be considered for this prompt.`}) 
    MinPowerRank?: number;
        
    @Field({description: `Determines how models are selected for this prompt (Default, Specific, ByPower).`}) 
    @MaxLength(40)
    SelectionStrategy: string;
        
    @Field({description: `When using ByPower selection strategy, determines whether to prefer highest, lowest, or balanced power models.`}) 
    @MaxLength(40)
    PowerPreference: string;
        
    @Field({description: `Controls parallelization: None (no parallelization), StaticCount (use AIPrompt.ParallelCount for total runs), ConfigParam (use config param specified in ParallelConfigParam for total runs), or ModelSpecific (check each AIPromptModel's individual settings).`}) 
    @MaxLength(40)
    ParallelizationMode: string;
        
    @Field(() => Int, {nullable: true, description: `When ParallelizationMode is StaticCount, specifies the number of parallel executions.`}) 
    ParallelCount?: number;
        
    @Field({nullable: true, description: `When ParallelizationMode is ConfigParam, specifies the name of the configuration parameter that contains the parallel count.`}) 
    @MaxLength(200)
    ParallelConfigParam?: string;
        
    @Field({description: `The expected data type of the prompt output: string, number, boolean, date, or object.`}) 
    @MaxLength(100)
    OutputType: string;
        
    @Field({nullable: true, description: `JSON example output when OutputType is "object", used for validating structured outputs.`}) 
    OutputExample?: string;
        
    @Field({description: `Determines how validation failures are handled: Strict (fail), Warn (log warning), or None (ignore).`}) 
    @MaxLength(100)
    ValidationBehavior: string;
        
    @Field(() => Int, {description: `Maximum number of retry attempts for API failures.`}) 
    MaxRetries: number;
        
    @Field(() => Int, {description: `Delay between retry attempts in milliseconds.`}) 
    RetryDelayMS: number;
        
    @Field({description: `Strategy for calculating retry delays: Fixed (same delay each time), Exponential (doubling delay), or Linear (linearly increasing delay).`}) 
    @MaxLength(40)
    RetryStrategy: string;
        
    @Field({nullable: true, description: `References another prompt that selects the best result from multiple parallel executions.`}) 
    @MaxLength(16)
    ResultSelectorPromptID?: string;
        
    @Field(() => Boolean, {description: `When true, results from this prompt will be cached for potential reuse.`}) 
    EnableCaching: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in seconds for cached results. NULL means results never expire.`}) 
    CacheTTLSeconds?: number;
        
    @Field({description: `Method for matching cached results: Exact (string matching) or Vector (embedding similarity).`}) 
    @MaxLength(40)
    CacheMatchType: string;
        
    @Field(() => Float, {nullable: true, description: `Threshold (0-1) for vector similarity matching. Higher values require closer matches.`}) 
    CacheSimilarityThreshold?: number;
        
    @Field(() => Boolean, {description: `When true, the AI model must match for a cache hit. When false, results from any model can be used.`}) 
    CacheMustMatchModel: boolean;
        
    @Field(() => Boolean, {description: `When true, the vendor must match for a cache hit. When false, results from any vendor can be used.`}) 
    CacheMustMatchVendor: boolean;
        
    @Field(() => Boolean, {description: `When true, the agent context must match for a cache hit. When false, agent-specific and non-agent results can be used interchangeably.`}) 
    CacheMustMatchAgent: boolean;
        
    @Field(() => Boolean, {description: `When true, the configuration must match for a cache hit. When false, results from any configuration can be used.`}) 
    CacheMustMatchConfig: boolean;
        
    @Field({description: `Determines how the prompt is used in conversation: System (always first message), User (positioned by PromptPosition), Assistant (positioned by PromptPosition), or SystemOrUser (try system first, fallback to user last if system slot taken)`}) 
    @MaxLength(40)
    PromptRole: string;
        
    @Field({description: `Controls message placement for User and Assistant role prompts: First (beginning of conversation) or Last (end of conversation). Not used for System role prompts which are always first`}) 
    @MaxLength(40)
    PromptPosition: string;
        
    @Field(() => Float, {nullable: true, description: `Default temperature setting for this prompt. Controls randomness in the output. 0 = more focused and deterministic, 2 = more random and creative. Can be overridden at runtime.`}) 
    Temperature?: number;
        
    @Field(() => Float, {nullable: true, description: `Default TopP (nucleus sampling) for this prompt. Only consider tokens with cumulative probability up to this value. 1 = consider all tokens. Can be overridden at runtime.`}) 
    TopP?: number;
        
    @Field(() => Int, {nullable: true, description: `Default TopK sampling for this prompt. Only sample from the top K tokens. Lower values reduce randomness. Can be overridden at runtime.`}) 
    TopK?: number;
        
    @Field(() => Float, {nullable: true, description: `Default MinP (minimum probability) for this prompt. Tokens with probability below this threshold are filtered out. Can be overridden at runtime.`}) 
    MinP?: number;
        
    @Field(() => Float, {nullable: true, description: `Default frequency penalty for this prompt. Penalizes tokens based on their frequency in the text. Positive values decrease likelihood of repetition. Can be overridden at runtime.`}) 
    FrequencyPenalty?: number;
        
    @Field(() => Float, {nullable: true, description: `Default presence penalty for this prompt. Penalizes tokens that have appeared in the text. Positive values increase topic diversity. Can be overridden at runtime.`}) 
    PresencePenalty?: number;
        
    @Field(() => Int, {nullable: true, description: `Default random seed for this prompt. Used for deterministic generation. Same seed produces same output. Can be overridden at runtime.`}) 
    Seed?: number;
        
    @Field({nullable: true, description: `Default stop sequences for this prompt. Comma-delimited list of sequences that will stop generation when encountered. Can be overridden at runtime.`}) 
    @MaxLength(2000)
    StopSequences?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Default setting for including log probabilities in the response. Can be overridden at runtime.`}) 
    IncludeLogProbs?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Default number of top log probabilities to include when IncludeLogProbs is true. Can be overridden at runtime.`}) 
    TopLogProbs?: number;
        
    @Field({description: `Failover strategy to use when the primary model fails. Options: SameModelDifferentVendor, NextBestModel, PowerRank, None`}) 
    @MaxLength(100)
    FailoverStrategy: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of failover attempts before giving up`}) 
    FailoverMaxAttempts?: number;
        
    @Field(() => Int, {nullable: true, description: `Initial delay in seconds between failover attempts`}) 
    FailoverDelaySeconds?: number;
        
    @Field({description: `Strategy for selecting failover models. Options: PreferSameModel, PreferDifferentModel, RequireSameModel`}) 
    @MaxLength(100)
    FailoverModelStrategy: string;
        
    @Field({description: `Types of errors that should trigger failover. Options: All, NetworkOnly, RateLimitOnly, ServiceErrorOnly`}) 
    @MaxLength(100)
    FailoverErrorScope: string;
        
    @Field(() => Int, {nullable: true, description: `Effort level for this specific prompt (1-100, where 1=minimal effort, 100=maximum effort). Higher values request more thorough reasoning and analysis. Can be overridden by agent DefaultPromptEffortLevel or runtime parameters.`}) 
    EffortLevel?: number;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    AIModelType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResultSelectorPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootResultSelectorPromptID?: string;
        
    @Field(() => [MJAIResultCache_])
    AIResultCache_AIPromptIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [MJAIConfiguration_])
    MJ_AIConfigurations_DefaultPromptForContextCompressionIDArray: MJAIConfiguration_[]; // Link to MJ_AIConfigurations
    
    @Field(() => [MJAIAgentType_])
    MJ_AIAgentTypes_SystemPromptIDArray: MJAIAgentType_[]; // Link to MJ_AIAgentTypes
    
    @Field(() => [MJAIAgentAction_])
    AIAgentActions_CompactPromptIDArray: MJAIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [MJAIConfiguration_])
    MJ_AIConfigurations_DefaultPromptForContextSummarizationIDArray: MJAIConfiguration_[]; // Link to MJ_AIConfigurations
    
    @Field(() => [MJAIPrompt_])
    AIPrompts_ResultSelectorPromptIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [MJAIPromptModel_])
    MJ_AIPromptModels_PromptIDArray: MJAIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [MJAIAgentPrompt_])
    MJ_AIAgentPrompts_PromptIDArray: MJAIAgentPrompt_[]; // Link to MJ_AIAgentPrompts
    
    @Field(() => [MJAIAgentStep_])
    MJ_AIAgentSteps_PromptIDArray: MJAIAgentStep_[]; // Link to MJ_AIAgentSteps
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_PromptIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJAIAgent_])
    AIAgents_ContextCompressionPromptIDArray: MJAIAgent_[]; // Link to AIAgents
    
    @Field(() => [MJAction_])
    Actions_DefaultCompactPromptIDArray: MJAction_[]; // Link to Actions
    
}

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class CreateMJAIPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat: string | null;

    @Field({ nullable: true })
    AIModelTypeID: string | null;

    @Field(() => Int, { nullable: true })
    MinPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string;

    @Field({ nullable: true })
    PowerPreference?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount: number | null;

    @Field({ nullable: true })
    ParallelConfigParam: string | null;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputExample: string | null;

    @Field({ nullable: true })
    ValidationBehavior?: string;

    @Field(() => Int, { nullable: true })
    MaxRetries?: number;

    @Field(() => Int, { nullable: true })
    RetryDelayMS?: number;

    @Field({ nullable: true })
    RetryStrategy?: string;

    @Field({ nullable: true })
    ResultSelectorPromptID: string | null;

    @Field(() => Boolean, { nullable: true })
    EnableCaching?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLSeconds: number | null;

    @Field({ nullable: true })
    CacheMatchType?: string;

    @Field(() => Float, { nullable: true })
    CacheSimilarityThreshold: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchModel?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchVendor?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchAgent?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchConfig?: boolean;

    @Field({ nullable: true })
    PromptRole?: string;

    @Field({ nullable: true })
    PromptPosition?: string;

    @Field(() => Float, { nullable: true })
    Temperature: number | null;

    @Field(() => Float, { nullable: true })
    TopP: number | null;

    @Field(() => Int, { nullable: true })
    TopK: number | null;

    @Field(() => Float, { nullable: true })
    MinP: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty: number | null;

    @Field(() => Int, { nullable: true })
    Seed: number | null;

    @Field({ nullable: true })
    StopSequences: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeLogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs: number | null;

    @Field({ nullable: true })
    FailoverStrategy?: string;

    @Field(() => Int, { nullable: true })
    FailoverMaxAttempts?: number | null;

    @Field(() => Int, { nullable: true })
    FailoverDelaySeconds?: number | null;

    @Field({ nullable: true })
    FailoverModelStrategy?: string;

    @Field({ nullable: true })
    FailoverErrorScope?: string;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class UpdateMJAIPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string | null;

    @Field(() => Int, { nullable: true })
    MinPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string;

    @Field({ nullable: true })
    PowerPreference?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number | null;

    @Field({ nullable: true })
    ParallelConfigParam?: string | null;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputExample?: string | null;

    @Field({ nullable: true })
    ValidationBehavior?: string;

    @Field(() => Int, { nullable: true })
    MaxRetries?: number;

    @Field(() => Int, { nullable: true })
    RetryDelayMS?: number;

    @Field({ nullable: true })
    RetryStrategy?: string;

    @Field({ nullable: true })
    ResultSelectorPromptID?: string | null;

    @Field(() => Boolean, { nullable: true })
    EnableCaching?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLSeconds?: number | null;

    @Field({ nullable: true })
    CacheMatchType?: string;

    @Field(() => Float, { nullable: true })
    CacheSimilarityThreshold?: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchModel?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchVendor?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchAgent?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheMustMatchConfig?: boolean;

    @Field({ nullable: true })
    PromptRole?: string;

    @Field({ nullable: true })
    PromptPosition?: string;

    @Field(() => Float, { nullable: true })
    Temperature?: number | null;

    @Field(() => Float, { nullable: true })
    TopP?: number | null;

    @Field(() => Int, { nullable: true })
    TopK?: number | null;

    @Field(() => Float, { nullable: true })
    MinP?: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty?: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty?: number | null;

    @Field(() => Int, { nullable: true })
    Seed?: number | null;

    @Field({ nullable: true })
    StopSequences?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeLogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs?: number | null;

    @Field({ nullable: true })
    FailoverStrategy?: string;

    @Field(() => Int, { nullable: true })
    FailoverMaxAttempts?: number | null;

    @Field(() => Int, { nullable: true })
    FailoverDelaySeconds?: number | null;

    @Field({ nullable: true })
    FailoverModelStrategy?: string;

    @Field({ nullable: true })
    FailoverErrorScope?: string;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompts
//****************************************************************************
@ObjectType()
export class RunMJAIPromptViewResult {
    @Field(() => [MJAIPrompt_])
    Results: MJAIPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPrompt_)
export class MJAIPromptResolver extends ResolverBase {
    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptViewResult)
    async RunMJAIPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPrompt_, { nullable: true })
    async MJAIPrompt(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPrompt_ | null> {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Prompts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_AIPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJ_AIConfigurations_DefaultPromptForContextCompressionIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [DefaultPromptForContextCompressionID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentType_])
    async MJ_AIAgentTypes_SystemPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentTypes] WHERE [SystemPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentAction_])
    async AIAgentActions_CompactPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [CompactPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJ_AIConfigurations_DefaultPromptForContextSummarizationIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [DefaultPromptForContextSummarizationID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_ResultSelectorPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [ResultSelectorPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptModel_])
    async MJ_AIPromptModels_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [PromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPrompt_])
    async MJ_AIAgentPrompts_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [PromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStep_])
    async MJ_AIAgentSteps_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [PromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_PromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [PromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async AIAgents_ContextCompressionPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ContextCompressionPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async Actions_DefaultCompactPromptIDArray(@Root() mjaiprompt_: MJAIPrompt_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [DefaultCompactPromptID]='${mjaiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPrompt_)
    async CreateMJAIPrompt(
        @Arg('input', () => CreateMJAIPromptInput) input: CreateMJAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPrompt_)
    async UpdateMJAIPrompt(
        @Arg('input', () => UpdateMJAIPromptInput) input: UpdateMJAIPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPrompt_)
    async DeleteMJAIPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Result Cache
//****************************************************************************
@ObjectType({ description: `Stores cached results of AI prompts, including multiple runs for history and tracking purposes.` })
export class MJAIResultCache_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the AI prompt this result corresponds to.`}) 
    @MaxLength(16)
    AIPromptID: string;
        
    @Field({description: `Reference to the AI model that generated this result.`}) 
    @MaxLength(16)
    AIModelID: string;
        
    @Field({description: `Timestamp of when this result was generated.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field({description: `The prompt text used to generate this result.`}) 
    PromptText: string;
        
    @Field({nullable: true, description: `The text of the result generated by the AI model.`}) 
    ResultText?: string;
        
    @Field({description: `The status of this result, indicating whether it is currently active or expired.`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp of when this result was marked as expired.`}) 
    @MaxLength(10)
    ExpiredOn?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The vendor that provided this result.`}) 
    @MaxLength(16)
    VendorID?: string;
        
    @Field({nullable: true, description: `The agent that initiated the request, if any.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `The configuration used for this execution.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field(() => Int, {nullable: true, description: `Vector representation of the prompt for similarity matching.`}) 
    PromptEmbedding?: number;
        
    @Field({nullable: true, description: `Reference to the AIPromptRun that created this cache entry.`}) 
    @MaxLength(16)
    PromptRunID?: string;
        
    @Field() 
    @MaxLength(510)
    AIPrompt: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    PromptRun?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class CreateMJAIResultCacheInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn: Date | null;

    @Field({ nullable: true })
    VendorID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field(() => Int, { nullable: true })
    PromptEmbedding: number | null;

    @Field({ nullable: true })
    PromptRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class UpdateMJAIResultCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn?: Date | null;

    @Field({ nullable: true })
    VendorID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field(() => Int, { nullable: true })
    PromptEmbedding?: number | null;

    @Field({ nullable: true })
    PromptRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Result Cache
//****************************************************************************
@ObjectType()
export class RunMJAIResultCacheViewResult {
    @Field(() => [MJAIResultCache_])
    Results: MJAIResultCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIResultCache_)
export class MJAIResultCacheResolver extends ResolverBase {
    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIResultCacheViewResult)
    async RunMJAIResultCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Result Cache';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIResultCache_, { nullable: true })
    async MJAIResultCache(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIResultCache_ | null> {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('AI Result Cache', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIResultCache_)
    async CreateMJAIResultCache(
        @Arg('input', () => CreateMJAIResultCacheInput) input: CreateMJAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('AI Result Cache', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIResultCache_)
    async UpdateMJAIResultCache(
        @Arg('input', () => UpdateMJAIResultCacheInput) input: UpdateMJAIResultCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('AI Result Cache', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIResultCache_)
    async DeleteMJAIResultCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Result Cache', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Entities
//****************************************************************************
@ObjectType({ description: `List of entities within each application. An application can have any number of entities and an entity can be part of any number of applications.` })
export class MJApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of this entity within the application, lower numbers appear first in navigation and menus.`}) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `When set to 1, the entity will be included by default for a new user when they first access the application in question`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    EntityBaseTableCodeName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class CreateMJApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class UpdateMJApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Entities
//****************************************************************************
@ObjectType()
export class RunMJApplicationEntityViewResult {
    @Field(() => [MJApplicationEntity_])
    Results: MJApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplicationEntity_)
export class MJApplicationEntityResolver extends ResolverBase {
    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationEntityViewResult)
    async RunMJApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplicationEntity_, { nullable: true })
    async MJApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplicationEntity_ | null> {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Application Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJApplicationEntity_)
    async CreateMJApplicationEntity(
        @Arg('input', () => CreateMJApplicationEntityInput) input: CreateMJApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplicationEntity_)
    async UpdateMJApplicationEntity(
        @Arg('input', () => UpdateMJApplicationEntityInput) input: UpdateMJApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplicationEntity_)
    async DeleteMJApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Settings
//****************************************************************************
@ObjectType({ description: `Stores configuration settings and preferences for applications, including key-value pairs for runtime parameters and user-specific customizations.` })
export class MJApplicationSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The setting value, can be simple text, numbers, booleans, or JSON for complex configuration objects.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class CreateMJApplicationSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class UpdateMJApplicationSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Settings
//****************************************************************************
@ObjectType()
export class RunMJApplicationSettingViewResult {
    @Field(() => [MJApplicationSetting_])
    Results: MJApplicationSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplicationSetting_)
export class MJApplicationSettingResolver extends ResolverBase {
    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationSettingViewResult)
    async RunMJApplicationSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplicationSetting_, { nullable: true })
    async MJApplicationSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplicationSetting_ | null> {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Application Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJApplicationSetting_)
    async CreateMJApplicationSetting(
        @Arg('input', () => CreateMJApplicationSettingInput) input: CreateMJApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Application Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplicationSetting_)
    async UpdateMJApplicationSetting(
        @Arg('input', () => UpdateMJApplicationSettingInput) input: UpdateMJApplicationSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Application Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplicationSetting_)
    async DeleteMJApplicationSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Applications
//****************************************************************************
@ObjectType({ description: `Applications are used to group entities in the user interface for ease of user access` })
export class MJApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Specify the CSS class information for the display icon for each application.`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field(() => Boolean, {description: `If turned on, when a new user first uses the MJ Explorer app, the application records with this turned on will have this application included in their selected application list.`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Comma-delimited list of schema names where entities will be automatically added to the application when created in those schemas`}) 
    SchemaAutoAddNewEntities?: string;
        
    @Field({nullable: true, description: `Hex color code for visual theming (e.g., #4caf50)`}) 
    @MaxLength(40)
    Color?: string;
        
    @Field({nullable: true, description: `JSON array of default navigation items for this application. Parsed by BaseApplication.GetNavItems()`}) 
    DefaultNavItems?: string;
        
    @Field({nullable: true, description: `TypeScript class name for ClassFactory registration (e.g., CRMApplication)`}) 
    @MaxLength(510)
    ClassName?: string;
        
    @Field(() => Int, {description: `Default sequence position when adding this application to a new user's User Applications. Lower values appear first. Used when DefaultForNewUser is true.`}) 
    DefaultSequence: number;
        
    @Field({description: `Application lifecycle status. Pending = not yet ready, Active = available for use, Disabled = temporarily unavailable, Deprecated = being phased out. Only Active applications are shown to users.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `How the application appears in navigation. App Switcher = only in dropdown menu, Nav Bar = permanent icon in top nav, Both = shown in both locations.`}) 
    @MaxLength(40)
    NavigationStyle: string;
        
    @Field({nullable: true, description: `Position of the permanent nav icon when NavigationStyle is Nav Bar or Both. Left of App Switcher = appears before the app switcher, Left of User Menu = appears near the user avatar. Ignored when NavigationStyle is App Switcher.`}) 
    @MaxLength(60)
    TopNavLocation?: string;
        
    @Field(() => Boolean, {description: `When true, the Nav Bar icon for this application is hidden when the application is active. Useful for launcher-style apps like Home that should only be visible when the user is NOT in that app. Only applies when NavigationStyle is Nav Bar or Both.`}) 
    HideNavBarIconWhenActive: boolean;
        
    @Field({description: `URL-friendly slug for the application (e.g., "data-explorer" for "Data Explorer"). Used in URLs instead of the full Name. Auto-generated from Name when AutoUpdatePath is true. Must be unique across all applications.`}) 
    @MaxLength(200)
    Path: string;
        
    @Field(() => Boolean, {description: `When true, Path is automatically generated from Name on save. Set to false to manually control the Path value. Defaults to true for new applications.`}) 
    AutoUpdatePath: boolean;
        
    @Field(() => [MJApplicationEntity_])
    ApplicationEntities_ApplicationIDArray: MJApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [MJUserApplication_])
    UserApplications_ApplicationIDArray: MJUserApplication_[]; // Link to UserApplications
    
    @Field(() => [MJApplicationSetting_])
    ApplicationSettings_ApplicationIDArray: MJApplicationSetting_[]; // Link to ApplicationSettings
    
    @Field(() => [MJDashboard_])
    Dashboards_ApplicationIDArray: MJDashboard_[]; // Link to Dashboards
    
    @Field(() => [MJDashboardUserPreference_])
    MJ_DashboardUserPreferences_ApplicationIDArray: MJDashboardUserPreference_[]; // Link to MJ_DashboardUserPreferences
    
}

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class CreateMJApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field({ nullable: true })
    SchemaAutoAddNewEntities: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field({ nullable: true })
    DefaultNavItems: string | null;

    @Field({ nullable: true })
    ClassName: string | null;

    @Field(() => Int, { nullable: true })
    DefaultSequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    NavigationStyle?: string;

    @Field({ nullable: true })
    TopNavLocation: string | null;

    @Field(() => Boolean, { nullable: true })
    HideNavBarIconWhenActive?: boolean;

    @Field({ nullable: true })
    Path?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdatePath?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class UpdateMJApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field({ nullable: true })
    SchemaAutoAddNewEntities?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field({ nullable: true })
    DefaultNavItems?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultSequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    NavigationStyle?: string;

    @Field({ nullable: true })
    TopNavLocation?: string | null;

    @Field(() => Boolean, { nullable: true })
    HideNavBarIconWhenActive?: boolean;

    @Field({ nullable: true })
    Path?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdatePath?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Applications
//****************************************************************************
@ObjectType()
export class RunMJApplicationViewResult {
    @Field(() => [MJApplication_])
    Results: MJApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJApplication_)
export class MJApplicationResolver extends ResolverBase {
    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJApplicationViewResult)
    async RunMJApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJApplication_, { nullable: true })
    async MJApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJApplication_ | null> {
        this.CheckUserReadPermissions('Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJApplication_])
    async AllApplications(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications]` + this.getRowLevelSecurityWhereClause(provider, 'Applications', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJApplicationEntity_])
    async ApplicationEntities_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserApplication_])
    async UserApplications_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJApplicationSetting_])
    async ApplicationSettings_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Application Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async Dashboards_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserPreference_])
    async MJ_DashboardUserPreferences_ApplicationIDArray(@Root() mjapplication_: MJApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [ApplicationID]='${mjapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJApplication_)
    async CreateMJApplication(
        @Arg('input', () => CreateMJApplicationInput) input: CreateMJApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJApplication_)
    async UpdateMJApplication(
        @Arg('input', () => UpdateMJApplicationInput) input: UpdateMJApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJApplication_)
    async DeleteMJApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Audit Log Types
//****************************************************************************
@ObjectType({ description: `Defines the types of events that can be recorded in the audit log, enabling categorization and filtering of system activities.` })
export class MJAuditLogType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAuditLog_])
    AuditLogs_AuditLogTypeNameArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJAuditLogType_])
    AuditLogTypes_ParentIDArray: MJAuditLogType_[]; // Link to AuditLogTypes
    
}

//****************************************************************************
// INPUT TYPE for Audit Log Types
//****************************************************************************
@InputType()
export class CreateMJAuditLogTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    AuthorizationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Audit Log Types
//****************************************************************************
@InputType()
export class UpdateMJAuditLogTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Audit Log Types
//****************************************************************************
@ObjectType()
export class RunMJAuditLogTypeViewResult {
    @Field(() => [MJAuditLogType_])
    Results: MJAuditLogType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuditLogType_)
export class MJAuditLogTypeResolver extends ResolverBase {
    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogTypeViewResult)
    async RunMJAuditLogTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Log Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuditLogType_, { nullable: true })
    async MJAuditLogType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuditLogType_ | null> {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Audit Log Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAuditLogType_])
    async AllAuditLogTypes(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes]` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_AuditLogTypeNameArray(@Root() mjauditlogtype_: MJAuditLogType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuditLogTypeName]='${mjauditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLogType_])
    async AuditLogTypes_ParentIDArray(@Root() mjauditlogtype_: MJAuditLogType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ParentID]='${mjauditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAuditLogType_)
    async CreateMJAuditLogType(
        @Arg('input', () => CreateMJAuditLogTypeInput) input: CreateMJAuditLogTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Audit Log Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuditLogType_)
    async UpdateMJAuditLogType(
        @Arg('input', () => UpdateMJAuditLogTypeInput) input: UpdateMJAuditLogTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Audit Log Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuditLogType_)
    async DeleteMJAuditLogType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Audit Log Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Audit Logs
//****************************************************************************
@ObjectType({ description: `Tracks system events and user actions for security, compliance, and debugging purposes, providing a complete audit trail. Any application can write entries to this entity.` })
export class MJAuditLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    AuditLogTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON-formatted additional context about the audited event, including before/after values, parameters, or other relevant data.`}) 
    Details?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `The primary key value of the record that was affected by this audited action, enabling direct lookup of the modified data.`}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    AuditLogType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class CreateMJAuditLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class UpdateMJAuditLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Audit Logs
//****************************************************************************
@ObjectType()
export class RunMJAuditLogViewResult {
    @Field(() => [MJAuditLog_])
    Results: MJAuditLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuditLog_)
export class MJAuditLogResolver extends ResolverBase {
    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuditLogViewResult)
    async RunMJAuditLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuditLog_, { nullable: true })
    async MJAuditLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuditLog_ | null> {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Audit Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAuditLog_)
    async CreateMJAuditLog(
        @Arg('input', () => CreateMJAuditLogInput) input: CreateMJAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Audit Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuditLog_)
    async UpdateMJAuditLog(
        @Arg('input', () => UpdateMJAuditLogInput) input: UpdateMJAuditLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Audit Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuditLog_)
    async DeleteMJAuditLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Audit Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorization Roles
//****************************************************************************
@ObjectType({ description: `Links authorizations to roles, defining which permissions are granted to users assigned to specific roles in the system.` })
export class MJAuthorizationRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field({description: `Specifies whether this authorization is granted to ('grant') or explicitly denied ('deny') for the role.`}) 
    @MaxLength(20)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Authorization Roles
//****************************************************************************
@InputType()
export class CreateMJAuthorizationRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for Authorization Roles
//****************************************************************************
@InputType()
export class UpdateMJAuthorizationRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Authorization Roles
//****************************************************************************
@ObjectType()
export class RunMJAuthorizationRoleViewResult {
    @Field(() => [MJAuthorizationRole_])
    Results: MJAuthorizationRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuthorizationRole_)
export class MJAuthorizationRoleResolver extends ResolverBase {
    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationRoleViewResult)
    async RunMJAuthorizationRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorization Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuthorizationRole_, { nullable: true })
    async MJAuthorizationRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuthorizationRole_ | null> {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Authorization Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAuthorizationRole_])
    async AllAuthorizationRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles]` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAuthorizationRole_)
    async CreateMJAuthorizationRole(
        @Arg('input', () => CreateMJAuthorizationRoleInput) input: CreateMJAuthorizationRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Authorization Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuthorizationRole_)
    async UpdateMJAuthorizationRole(
        @Arg('input', () => UpdateMJAuthorizationRoleInput) input: UpdateMJAuthorizationRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Authorization Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuthorizationRole_)
    async DeleteMJAuthorizationRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Authorization Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorizations
//****************************************************************************
@ObjectType({ description: `Stores the fundamental permissions and access rights that can be granted to users and roles throughout the system.` })
export class MJAuthorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field(() => Boolean, {description: `Indicates whether this authorization is currently active and can be granted to users or roles.`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, Audit Log records are created whenever this authorization is invoked for a user`}) 
    UseAuditLog: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAuthorizationRole_])
    AuthorizationRoles_AuthorizationIDArray: MJAuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [MJAuthorization_])
    Authorizations_ParentIDArray: MJAuthorization_[]; // Link to Authorizations
    
    @Field(() => [MJAuditLogType_])
    AuditLogTypes_AuthorizationNameArray: MJAuditLogType_[]; // Link to AuditLogTypes
    
    @Field(() => [MJAuditLog_])
    AuditLogs_AuthorizationNameArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJActionAuthorization_])
    ActionAuthorizations_AuthorizationIDArray: MJActionAuthorization_[]; // Link to ActionAuthorizations
    
}

//****************************************************************************
// INPUT TYPE for Authorizations
//****************************************************************************
@InputType()
export class CreateMJAuthorizationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    UseAuditLog?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Authorizations
//****************************************************************************
@InputType()
export class UpdateMJAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    UseAuditLog?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Authorizations
//****************************************************************************
@ObjectType()
export class RunMJAuthorizationViewResult {
    @Field(() => [MJAuthorization_])
    Results: MJAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAuthorization_)
export class MJAuthorizationResolver extends ResolverBase {
    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAuthorizationViewResult)
    async RunMJAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorizations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAuthorization_, { nullable: true })
    async MJAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAuthorization_ | null> {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Authorizations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJAuthorization_])
    async AllAuthorizations(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations]` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAuthorizationRole_])
    async AuthorizationRoles_AuthorizationIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [AuthorizationID]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuthorization_])
    async Authorizations_ParentIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ParentID]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLogType_])
    async AuditLogTypes_AuthorizationNameArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [AuthorizationName]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Log Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_AuthorizationNameArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuthorizationName]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionAuthorization_])
    async ActionAuthorizations_AuthorizationIDArray(@Root() mjauthorization_: MJAuthorization_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [AuthorizationID]='${mjauthorization_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Authorizations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAuthorization_)
    async CreateMJAuthorization(
        @Arg('input', () => CreateMJAuthorizationInput) input: CreateMJAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Authorizations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAuthorization_)
    async UpdateMJAuthorization(
        @Arg('input', () => UpdateMJAuthorizationInput) input: UpdateMJAuthorizationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Authorizations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAuthorization_)
    async DeleteMJAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Authorizations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Base Message Types
//****************************************************************************
@ObjectType({ description: `Base message types and their supported functionalities.` })
export class MJCommunicationBaseMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The unique identifier for this message type, used for routing and processing communications.`}) 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if attachments are supported.`}) 
    SupportsAttachments: boolean;
        
    @Field(() => Boolean, {description: `Indicates if a subject line is supported.`}) 
    SupportsSubjectLine: boolean;
        
    @Field(() => Boolean, {description: `Indicates if HTML content is supported.`}) 
    SupportsHtml: boolean;
        
    @Field(() => Int, {nullable: true, description: `The maximum size in bytes for the message.`}) 
    MaxBytes?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJCommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray: MJCommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [MJEntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_BaseMessageTypeIDArray: MJEntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
}

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class CreateMJCommunicationBaseMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class UpdateMJCommunicationBaseMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Base Message Types
//****************************************************************************
@ObjectType()
export class RunMJCommunicationBaseMessageTypeViewResult {
    @Field(() => [MJCommunicationBaseMessageType_])
    Results: MJCommunicationBaseMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationBaseMessageType_)
export class MJCommunicationBaseMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationBaseMessageTypeViewResult)
    async RunMJCommunicationBaseMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Base Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationBaseMessageType_, { nullable: true })
    async MJCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationBaseMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Base Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationBaseMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Base Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Communication Base Message Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray(@Root() mjcommunicationbasemessagetype_: MJCommunicationBaseMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationBaseMessageTypeID]='${mjcommunicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_BaseMessageTypeIDArray(@Root() mjcommunicationbasemessagetype_: MJCommunicationBaseMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [BaseMessageTypeID]='${mjcommunicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationBaseMessageType_)
    async CreateMJCommunicationBaseMessageType(
        @Arg('input', () => CreateMJCommunicationBaseMessageTypeInput) input: CreateMJCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Base Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationBaseMessageType_)
    async UpdateMJCommunicationBaseMessageType(
        @Arg('input', () => UpdateMJCommunicationBaseMessageTypeInput) input: UpdateMJCommunicationBaseMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Base Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationBaseMessageType_)
    async DeleteMJCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Base Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Logs
//****************************************************************************
@ObjectType({ description: `Logs of sent and received messages.` })
export class MJCommunicationLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderMessageTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CommunicationRunID?: string;
        
    @Field({description: `The direction of the communication log (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The date and time when the message was logged.`}) 
    @MaxLength(10)
    MessageDate: Date;
        
    @Field({description: `The status of the logged message (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `The content of the logged message.`}) 
    MessageContent?: string;
        
    @Field({nullable: true, description: `The error message if the message sending failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(510)
    CommunicationProviderMessageType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CommunicationRun?: string;
        
}

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class CreateMJCommunicationLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class UpdateMJCommunicationLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID?: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Logs
//****************************************************************************
@ObjectType()
export class RunMJCommunicationLogViewResult {
    @Field(() => [MJCommunicationLog_])
    Results: MJCommunicationLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationLog_)
export class MJCommunicationLogResolver extends ResolverBase {
    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationLogViewResult)
    async RunMJCommunicationLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationLog_, { nullable: true })
    async MJCommunicationLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationLog_ | null> {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Communication Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCommunicationLog_)
    async CreateMJCommunicationLog(
        @Arg('input', () => CreateMJCommunicationLogInput) input: CreateMJCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationLog_)
    async UpdateMJCommunicationLog(
        @Arg('input', () => UpdateMJCommunicationLogInput) input: UpdateMJCommunicationLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationLog_)
    async DeleteMJCommunicationLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Provider Message Types
//****************************************************************************
@ObjectType({ description: `Providers and their supported message types with additional attributes.` })
export class MJCommunicationProviderMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationBaseMessageTypeID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `The status of the provider message type (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Additional attributes specific to the provider message type.`}) 
    AdditionalAttributes?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(200)
    CommunicationBaseMessageType: string;
        
    @Field(() => [MJCommunicationLog_])
    CommunicationLogs_CommunicationProviderMessageTypeIDArray: MJCommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class CreateMJCommunicationProviderMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class UpdateMJCommunicationProviderMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Provider Message Types
//****************************************************************************
@ObjectType()
export class RunMJCommunicationProviderMessageTypeViewResult {
    @Field(() => [MJCommunicationProviderMessageType_])
    Results: MJCommunicationProviderMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationProviderMessageType_)
export class MJCommunicationProviderMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderMessageTypeViewResult)
    async RunMJCommunicationProviderMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Provider Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationProviderMessageType_, { nullable: true })
    async MJCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationProviderMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Communication Provider Message Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationLog_])
    async CommunicationLogs_CommunicationProviderMessageTypeIDArray(@Root() mjcommunicationprovidermessagetype_: MJCommunicationProviderMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderMessageTypeID]='${mjcommunicationprovidermessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationProviderMessageType_)
    async CreateMJCommunicationProviderMessageType(
        @Arg('input', () => CreateMJCommunicationProviderMessageTypeInput) input: CreateMJCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Provider Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationProviderMessageType_)
    async UpdateMJCommunicationProviderMessageType(
        @Arg('input', () => UpdateMJCommunicationProviderMessageTypeInput) input: UpdateMJCommunicationProviderMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Provider Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationProviderMessageType_)
    async DeleteMJCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Provider Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Providers
//****************************************************************************
@ObjectType({ description: `All supported communication providers.` })
export class MJCommunicationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The status of the communication provider (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports sending messages.`}) 
    SupportsSending: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports receiving messages.`}) 
    SupportsReceiving: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports sending messages at a specific time`}) 
    SupportsScheduledSending: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports forwarding messages to another recipient `}) 
    SupportsForwarding: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports replying to messages`}) 
    SupportsReplying: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports creating draft messages`}) 
    SupportsDrafts: boolean;
        
    @Field(() => [MJCommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationProviderIDArray: MJCommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [MJCommunicationLog_])
    CommunicationLogs_CommunicationProviderIDArray: MJCommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class CreateMJCommunicationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsDrafts?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class UpdateMJCommunicationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsDrafts?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Providers
//****************************************************************************
@ObjectType()
export class RunMJCommunicationProviderViewResult {
    @Field(() => [MJCommunicationProvider_])
    Results: MJCommunicationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationProvider_)
export class MJCommunicationProviderResolver extends ResolverBase {
    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationProviderViewResult)
    async RunMJCommunicationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationProvider_, { nullable: true })
    async MJCommunicationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationProvider_ | null> {
        this.CheckUserReadPermissions('Communication Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Communication Providers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationProviderIDArray(@Root() mjcommunicationprovider_: MJCommunicationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationProviderID]='${mjcommunicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCommunicationLog_])
    async CommunicationLogs_CommunicationProviderIDArray(@Root() mjcommunicationprovider_: MJCommunicationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderID]='${mjcommunicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationProvider_)
    async CreateMJCommunicationProvider(
        @Arg('input', () => CreateMJCommunicationProviderInput) input: CreateMJCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationProvider_)
    async UpdateMJCommunicationProvider(
        @Arg('input', () => UpdateMJCommunicationProviderInput) input: UpdateMJCommunicationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationProvider_)
    async DeleteMJCommunicationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Runs
//****************************************************************************
@ObjectType({ description: `Runs of bulk message sends and receives.` })
export class MJCommunicationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `The direction of the communication run (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The status of the communication run (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({nullable: true, description: `The error message if the communication run failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJCommunicationLog_])
    CommunicationLogs_CommunicationRunIDArray: MJCommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class CreateMJCommunicationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class UpdateMJCommunicationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Runs
//****************************************************************************
@ObjectType()
export class RunMJCommunicationRunViewResult {
    @Field(() => [MJCommunicationRun_])
    Results: MJCommunicationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCommunicationRun_)
export class MJCommunicationRunResolver extends ResolverBase {
    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCommunicationRunViewResult)
    async RunMJCommunicationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCommunicationRun_, { nullable: true })
    async MJCommunicationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCommunicationRun_ | null> {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Communication Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCommunicationLog_])
    async CommunicationLogs_CommunicationRunIDArray(@Root() mjcommunicationrun_: MJCommunicationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationRunID]='${mjcommunicationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Communication Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCommunicationRun_)
    async CreateMJCommunicationRun(
        @Arg('input', () => CreateMJCommunicationRunInput) input: CreateMJCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Communication Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCommunicationRun_)
    async UpdateMJCommunicationRun(
        @Arg('input', () => UpdateMJCommunicationRunInput) input: UpdateMJCommunicationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Communication Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCommunicationRun_)
    async DeleteMJCommunicationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Companies
//****************************************************************************
@ObjectType({ description: `A list of organizational units within your business. These can be subsidiaries or divisions or other units. Companies are used to organizae employee records and also for separating integrations if you have multiple integrations of the same type of system.` })
export class MJCompany_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field() 
    @MaxLength(400)
    Description: string;
        
    @Field({nullable: true, description: `The primary website URL for this company or division.`}) 
    @MaxLength(200)
    Website?: string;
        
    @Field({nullable: true, description: `URL pointing to the company's logo image, used for branding in the UI.`}) 
    @MaxLength(1000)
    LogoURL?: string;
        
    @Field({nullable: true, description: `The primary email domain associated with this company, used for employee email validation and SSO configuration.`}) 
    @MaxLength(510)
    Domain?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEmployee_])
    Employees_CompanyIDArray: MJEmployee_[]; // Link to Employees
    
    @Field(() => [MJCompanyIntegration_])
    CompanyIntegrations_CompanyNameArray: MJCompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [MJWorkflow_])
    Workflows_CompanyNameArray: MJWorkflow_[]; // Link to Workflows
    
    @Field(() => [MJMCPServerConnection_])
    MJ_MCPServerConnections_CompanyIDArray: MJMCPServerConnection_[]; // Link to MJ_MCPServerConnections
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_CompanyIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_CompanyIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
}

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class CreateMJCompanyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    Domain: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class UpdateMJCompanyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    Domain?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Companies
//****************************************************************************
@ObjectType()
export class RunMJCompanyViewResult {
    @Field(() => [MJCompany_])
    Results: MJCompany_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompany_)
export class MJCompanyResolver extends ResolverBase {
    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyViewResult)
    async RunMJCompanyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Companies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompany_, { nullable: true })
    async MJCompany(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompany_ | null> {
        this.CheckUserReadPermissions('Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Companies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Companies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJCompany_])
    async AllCompanies(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Companies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies]` + this.getRowLevelSecurityWhereClause(provider, 'Companies', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Companies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployee_])
    async Employees_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [CompanyID]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employees', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegration_])
    async CompanyIntegrations_CompanyNameArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [CompanyName]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJWorkflow_])
    async Workflows_CompanyNameArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [CompanyName]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Workflows', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnection_])
    async MJ_MCPServerConnections_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnections] WHERE [CompanyID]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [CompanyID]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_CompanyIDArray(@Root() mjcompany_: MJCompany_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [CompanyID]='${mjcompany_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompany_)
    async CreateMJCompany(
        @Arg('input', () => CreateMJCompanyInput) input: CreateMJCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Companies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompany_)
    async UpdateMJCompany(
        @Arg('input', () => UpdateMJCompanyInput) input: UpdateMJCompanyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Companies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompany_)
    async DeleteMJCompany(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Companies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Record Maps
//****************************************************************************
@ObjectType({ description: `Maps records between internal entities and external system identifiers, maintaining synchronization between MemberJunction and integrated platforms.` })
export class MJCompanyIntegrationRecordMap_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field({description: `The unique identifier for this record in the external integrated system.`}) 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The internal MemberJunction record ID that corresponds to the external system record.`}) 
    @MaxLength(1500)
    EntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CompanyIntegration: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRecordMapInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRecordMapInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRecordMapViewResult {
    @Field(() => [MJCompanyIntegrationRecordMap_])
    Results: MJCompanyIntegrationRecordMap_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRecordMap_)
export class MJCompanyIntegrationRecordMapResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRecordMapViewResult)
    async RunMJCompanyIntegrationRecordMapDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Record Maps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRecordMap_, { nullable: true })
    async MJCompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRecordMap_ | null> {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Company Integration Record Maps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async CreateMJCompanyIntegrationRecordMap(
        @Arg('input', () => CreateMJCompanyIntegrationRecordMapInput) input: CreateMJCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Record Maps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async UpdateMJCompanyIntegrationRecordMap(
        @Arg('input', () => UpdateMJCompanyIntegrationRecordMapInput) input: UpdateMJCompanyIntegrationRecordMapInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Record Maps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRecordMap_)
    async DeleteMJCompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Record Maps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run API Logs
//****************************************************************************
@ObjectType({ description: `Logs detailed API calls and responses during integration runs, including request/response payloads, status codes, and timing information.` })
export class MJCompanyIntegrationRunAPILog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field({description: `Timestamp when this API call was executed during the integration run.`}) 
    @MaxLength(10)
    ExecutedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether the API call completed successfully or encountered an error.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `HTTP method used for the API call (GET, POST, PUT, DELETE, PATCH).`}) 
    @MaxLength(24)
    RequestMethod?: string;
        
    @Field({nullable: true, description: `The complete URL that was called, including query parameters.`}) 
    URL?: string;
        
    @Field({nullable: true, description: `JSON-formatted request body or parameters sent with the API call.`}) 
    Parameters?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    CompanyIntegrationRun: string;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunAPILogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod: string | null;

    @Field({ nullable: true })
    URL: string | null;

    @Field({ nullable: true })
    Parameters: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunAPILogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod?: string | null;

    @Field({ nullable: true })
    URL?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunAPILogViewResult {
    @Field(() => [MJCompanyIntegrationRunAPILog_])
    Results: MJCompanyIntegrationRunAPILog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRunAPILog_)
export class MJCompanyIntegrationRunAPILogResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunAPILogViewResult)
    async RunMJCompanyIntegrationRunAPILogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run API Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRunAPILog_, { nullable: true })
    async MJCompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRunAPILog_ | null> {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Company Integration Run API Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async CreateMJCompanyIntegrationRunAPILog(
        @Arg('input', () => CreateMJCompanyIntegrationRunAPILogInput) input: CreateMJCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Run API Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async UpdateMJCompanyIntegrationRunAPILog(
        @Arg('input', () => UpdateMJCompanyIntegrationRunAPILogInput) input: UpdateMJCompanyIntegrationRunAPILogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Run API Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRunAPILog_)
    async DeleteMJCompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Run API Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run Details
//****************************************************************************
@ObjectType({ description: `Tracks individual record-level operations within an integration run, including success/failure status and error details for each processed item.` })
export class MJCompanyIntegrationRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the specific record being processed in this integration operation.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field({description: `The type of operation performed (INSERT, UPDATE, DELETE, SYNC).`}) 
    @MaxLength(40)
    Action: string;
        
    @Field({description: `Timestamp when this specific record operation was executed.`}) 
    @MaxLength(10)
    ExecutedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this individual record operation succeeded or failed.`}) 
    IsSuccess: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    RunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    RunEndedAt?: Date;
        
    @Field(() => [MJErrorLog_])
    ErrorLogs_CompanyIntegrationRunDetailIDArray: MJErrorLog_[]; // Link to ErrorLogs
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run Details
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunDetailViewResult {
    @Field(() => [MJCompanyIntegrationRunDetail_])
    Results: MJCompanyIntegrationRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRunDetail_)
export class MJCompanyIntegrationRunDetailResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunDetailViewResult)
    async RunMJCompanyIntegrationRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRunDetail_, { nullable: true })
    async MJCompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRunDetail_ | null> {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Company Integration Run Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJErrorLog_])
    async ErrorLogs_CompanyIntegrationRunDetailIDArray(@Root() mjcompanyintegrationrundetail_: MJCompanyIntegrationRunDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunDetailID]='${mjcompanyintegrationrundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Error Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async CreateMJCompanyIntegrationRunDetail(
        @Arg('input', () => CreateMJCompanyIntegrationRunDetailInput) input: CreateMJCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async UpdateMJCompanyIntegrationRunDetail(
        @Arg('input', () => UpdateMJCompanyIntegrationRunDetailInput) input: UpdateMJCompanyIntegrationRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRunDetail_)
    async DeleteMJCompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Runs
//****************************************************************************
@ObjectType({ description: `Records execution history of company integrations, including start/end times, overall status, and aggregate statistics for monitoring and troubleshooting.` })
export class MJCompanyIntegrationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field(() => Int, {description: `The total number of records processed during this integration run.`}) 
    TotalRecords: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the integration run. Possible values: Pending, In Progress, Success, Failed.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional error log information for the integration run.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Optional configuration data in JSON format for the request that started the integration run for audit purposes.`}) 
    ConfigData?: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJCompanyIntegrationRunAPILog_])
    CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray: MJCompanyIntegrationRunAPILog_[]; // Link to CompanyIntegrationRunAPILogs
    
    @Field(() => [MJErrorLog_])
    ErrorLogs_CompanyIntegrationRunIDArray: MJErrorLog_[]; // Link to ErrorLogs
    
    @Field(() => [MJCompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray: MJCompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ConfigData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ConfigData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Runs
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationRunViewResult {
    @Field(() => [MJCompanyIntegrationRun_])
    Results: MJCompanyIntegrationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegrationRun_)
export class MJCompanyIntegrationRunResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationRunViewResult)
    async RunMJCompanyIntegrationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegrationRun_, { nullable: true })
    async MJCompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegrationRun_ | null> {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Company Integration Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCompanyIntegrationRunAPILog_])
    async CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [CompanyIntegrationRunID]='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Run API Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJErrorLog_])
    async ErrorLogs_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunID]='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Error Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray(@Root() mjcompanyintegrationrun_: MJCompanyIntegrationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [CompanyIntegrationRunID]='${mjcompanyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompanyIntegrationRun_)
    async CreateMJCompanyIntegrationRun(
        @Arg('input', () => CreateMJCompanyIntegrationRunInput) input: CreateMJCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integration Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegrationRun_)
    async UpdateMJCompanyIntegrationRun(
        @Arg('input', () => UpdateMJCompanyIntegrationRunInput) input: UpdateMJCompanyIntegrationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integration Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegrationRun_)
    async DeleteMJCompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integration Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integrations
//****************************************************************************
@ObjectType({ description: `Links individual company records to specific integrations` })
export class MJCompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field(() => Boolean, {nullable: true, description: `Controls whether this integration is currently active for the company.`}) 
    IsActive?: boolean;
        
    @Field({nullable: true, description: `OAuth access token for authenticating with the external system.`}) 
    @MaxLength(510)
    AccessToken?: string;
        
    @Field({nullable: true, description: `OAuth refresh token used to obtain new access tokens when they expire.`}) 
    @MaxLength(510)
    RefreshToken?: string;
        
    @Field({nullable: true, description: `Timestamp when the current access token expires and needs to be refreshed.`}) 
    @MaxLength(10)
    TokenExpirationDate?: Date;
        
    @Field({nullable: true, description: `API key for systems using key-based authentication instead of OAuth.`}) 
    @MaxLength(510)
    APIKey?: string;
        
    @Field({nullable: true, description: `The company's identifier in the external system, used for API calls.`}) 
    @MaxLength(200)
    ExternalSystemID?: string;
        
    @Field(() => Boolean, {description: `Indicates if data can only be read from the external system, not written back.`}) 
    IsExternalSystemReadOnly: boolean;
        
    @Field({nullable: true, description: `OAuth client ID for this integration instance.`}) 
    @MaxLength(510)
    ClientID?: string;
        
    @Field({nullable: true, description: `OAuth client secret for authentication, should be encrypted at rest.`}) 
    @MaxLength(510)
    ClientSecret?: string;
        
    @Field({nullable: true, description: `Flexible field for storing integration-specific configuration or metadata.`}) 
    @MaxLength(510)
    CustomAttribute1?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `User-friendly name for the company integration instance, typically in the format "Company: Integration".`}) 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LastRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    LastRunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    LastRunEndedAt?: Date;
        
    @Field(() => [MJList_])
    Lists_CompanyIntegrationIDArray: MJList_[]; // Link to Lists
    
    @Field(() => [MJEmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_CompanyIntegrationIDArray: MJEmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [MJCompanyIntegrationRun_])
    CompanyIntegrationRuns_CompanyIntegrationIDArray: MJCompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [MJCompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_CompanyIntegrationIDArray: MJCompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
}

//****************************************************************************
// INPUT TYPE for Company Integrations
//****************************************************************************
@InputType()
export class CreateMJCompanyIntegrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive: boolean | null;

    @Field({ nullable: true })
    AccessToken: string | null;

    @Field({ nullable: true })
    RefreshToken: string | null;

    @Field({ nullable: true })
    TokenExpirationDate: Date | null;

    @Field({ nullable: true })
    APIKey: string | null;

    @Field({ nullable: true })
    ExternalSystemID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID: string | null;

    @Field({ nullable: true })
    ClientSecret: string | null;

    @Field({ nullable: true })
    CustomAttribute1: string | null;

    @Field({ nullable: true })
    Name?: string;
}
    

//****************************************************************************
// INPUT TYPE for Company Integrations
//****************************************************************************
@InputType()
export class UpdateMJCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean | null;

    @Field({ nullable: true })
    AccessToken?: string | null;

    @Field({ nullable: true })
    RefreshToken?: string | null;

    @Field({ nullable: true })
    TokenExpirationDate?: Date | null;

    @Field({ nullable: true })
    APIKey?: string | null;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID?: string | null;

    @Field({ nullable: true })
    ClientSecret?: string | null;

    @Field({ nullable: true })
    CustomAttribute1?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integrations
//****************************************************************************
@ObjectType()
export class RunMJCompanyIntegrationViewResult {
    @Field(() => [MJCompanyIntegration_])
    Results: MJCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCompanyIntegration_)
export class MJCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCompanyIntegrationViewResult)
    async RunMJCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCompanyIntegration_, { nullable: true })
    async MJCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Company Integrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJList_])
    async Lists_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRun_])
    async CompanyIntegrationRuns_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_CompanyIntegrationIDArray(@Root() mjcompanyintegration_: MJCompanyIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [CompanyIntegrationID]='${mjcompanyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCompanyIntegration_)
    async CreateMJCompanyIntegration(
        @Arg('input', () => CreateMJCompanyIntegrationInput) input: CreateMJCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Company Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCompanyIntegration_)
    async UpdateMJCompanyIntegration(
        @Arg('input', () => UpdateMJCompanyIntegrationInput) input: UpdateMJCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCompanyIntegration_)
    async DeleteMJCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content File Types
//****************************************************************************
@ObjectType({ description: `Defines supported file types for content management, including extensions and processing rules for different content formats.` })
export class MJContentFileType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `The file extension (e.g., .pdf, .docx, .jpg) used to identify this content type.`}) 
    @MaxLength(510)
    FileExtension?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJContentSource_])
    ContentSources_ContentFileTypeIDArray: MJContentSource_[]; // Link to ContentSources
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentFileTypeIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class CreateMJContentFileTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class UpdateMJContentFileTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content File Types
//****************************************************************************
@ObjectType()
export class RunMJContentFileTypeViewResult {
    @Field(() => [MJContentFileType_])
    Results: MJContentFileType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentFileType_)
export class MJContentFileTypeResolver extends ResolverBase {
    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentFileTypeViewResult)
    async RunMJContentFileTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content File Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentFileType_, { nullable: true })
    async MJContentFileType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentFileType_ | null> {
        this.CheckUserReadPermissions('Content File Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentFileTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content File Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content File Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async ContentSources_ContentFileTypeIDArray(@Root() mjcontentfiletype_: MJContentFileType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentFileTypeID]='${mjcontentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentFileTypeIDArray(@Root() mjcontentfiletype_: MJContentFileType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentFileTypeID]='${mjcontentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentFileType_)
    async CreateMJContentFileType(
        @Arg('input', () => CreateMJContentFileTypeInput) input: CreateMJContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content File Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentFileType_)
    async UpdateMJContentFileType(
        @Arg('input', () => UpdateMJContentFileTypeInput) input: UpdateMJContentFileTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content File Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentFileType_)
    async DeleteMJContentFileType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content File Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Attributes
//****************************************************************************
@ObjectType({ description: `Stores metadata attributes extracted with prompting for content items, enabling flexible key-value properties and custom fields for content classification.` })
export class MJContentItemAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentItemID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The extracted or assigned value for this attribute on the content item.`}) 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    ContentItem?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class CreateMJContentItemAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class UpdateMJContentItemAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Attributes
//****************************************************************************
@ObjectType()
export class RunMJContentItemAttributeViewResult {
    @Field(() => [MJContentItemAttribute_])
    Results: MJContentItemAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItemAttribute_)
export class MJContentItemAttributeResolver extends ResolverBase {
    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemAttributeViewResult)
    async RunMJContentItemAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItemAttribute_, { nullable: true })
    async MJContentItemAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItemAttribute_ | null> {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Item Attributes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentItemAttribute_)
    async CreateMJContentItemAttribute(
        @Arg('input', () => CreateMJContentItemAttributeInput) input: CreateMJContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Item Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItemAttribute_)
    async UpdateMJContentItemAttribute(
        @Arg('input', () => UpdateMJContentItemAttributeInput) input: UpdateMJContentItemAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Item Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItemAttribute_)
    async DeleteMJContentItemAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Tags
//****************************************************************************
@ObjectType({ description: `Links tags to content items for categorization, searchability, and content discovery across the system.` })
export class MJContentItemTag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ItemID: string;
        
    @Field({description: `The tag text applied to the content item for categorization and search.`}) 
    @MaxLength(400)
    Tag: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Item?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class CreateMJContentItemTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class UpdateMJContentItemTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Tags
//****************************************************************************
@ObjectType()
export class RunMJContentItemTagViewResult {
    @Field(() => [MJContentItemTag_])
    Results: MJContentItemTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItemTag_)
export class MJContentItemTagResolver extends ResolverBase {
    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemTagViewResult)
    async RunMJContentItemTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItemTag_, { nullable: true })
    async MJContentItemTag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItemTag_ | null> {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Item Tags', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentItemTag_)
    async CreateMJContentItemTag(
        @Arg('input', () => CreateMJContentItemTagInput) input: CreateMJContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Item Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItemTag_)
    async UpdateMJContentItemTag(
        @Arg('input', () => UpdateMJContentItemTagInput) input: UpdateMJContentItemTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Item Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItemTag_)
    async DeleteMJContentItemTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Items
//****************************************************************************
@ObjectType({ description: `Stores extracted text from content assets, as well as the source location, versioning, and links to extracted tags and attributes.` })
export class MJContentItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field({nullable: true, description: `Hash value of the content used to detect changes and prevent duplicate processing.`}) 
    @MaxLength(200)
    Checksum?: string;
        
    @Field({description: `The source location URL where this content was retrieved from.`}) 
    @MaxLength(4000)
    URL: string;
        
    @Field({nullable: true, description: `The extracted text content from the source document or file.`}) 
    Text?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [MJContentItemAttribute_])
    ContentItemAttributes_ContentItemIDArray: MJContentItemAttribute_[]; // Link to ContentItemAttributes
    
    @Field(() => [MJContentItemTag_])
    ContentItemTags_ItemIDArray: MJContentItemTag_[]; // Link to ContentItemTags
    
}

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class CreateMJContentItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class UpdateMJContentItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum?: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Items
//****************************************************************************
@ObjectType()
export class RunMJContentItemViewResult {
    @Field(() => [MJContentItem_])
    Results: MJContentItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentItem_)
export class MJContentItemResolver extends ResolverBase {
    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentItemViewResult)
    async RunMJContentItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentItem_, { nullable: true })
    async MJContentItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentItem_ | null> {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentItemAttribute_])
    async ContentItemAttributes_ContentItemIDArray(@Root() mjcontentitem_: MJContentItem_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ContentItemID]='${mjcontentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Item Attributes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItemTag_])
    async ContentItemTags_ItemIDArray(@Root() mjcontentitem_: MJContentItem_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ItemID]='${mjcontentitem_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Item Tags', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentItem_)
    async CreateMJContentItem(
        @Arg('input', () => CreateMJContentItemInput) input: CreateMJContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentItem_)
    async UpdateMJContentItem(
        @Arg('input', () => UpdateMJContentItemInput) input: UpdateMJContentItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentItem_)
    async DeleteMJContentItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Process Runs
//****************************************************************************
@ObjectType({ description: `Tracks execution of content tagging workflows, logging the status and details of each execution and ensuring efficient processing of content.` })
export class MJContentProcessRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    SourceID: string;
        
    @Field({nullable: true, description: `Timestamp when the content processing workflow began execution.`}) 
    @MaxLength(10)
    StartTime?: Date;
        
    @Field({nullable: true, description: `Timestamp when the content processing workflow completed or failed.`}) 
    @MaxLength(10)
    EndTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Status?: string;
        
    @Field(() => Int, {nullable: true, description: `Count of content items successfully processed during this run.`}) 
    ProcessedItems?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Source?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class CreateMJContentProcessRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime: Date | null;

    @Field({ nullable: true })
    EndTime: Date | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class UpdateMJContentProcessRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime?: Date | null;

    @Field({ nullable: true })
    EndTime?: Date | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Process Runs
//****************************************************************************
@ObjectType()
export class RunMJContentProcessRunViewResult {
    @Field(() => [MJContentProcessRun_])
    Results: MJContentProcessRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentProcessRun_)
export class MJContentProcessRunResolver extends ResolverBase {
    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentProcessRunViewResult)
    async RunMJContentProcessRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Process Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentProcessRun_, { nullable: true })
    async MJContentProcessRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentProcessRun_ | null> {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Process Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentProcessRun_)
    async CreateMJContentProcessRun(
        @Arg('input', () => CreateMJContentProcessRunInput) input: CreateMJContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Process Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentProcessRun_)
    async UpdateMJContentProcessRun(
        @Arg('input', () => UpdateMJContentProcessRunInput) input: UpdateMJContentProcessRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Process Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentProcessRun_)
    async DeleteMJContentProcessRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Process Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Params
//****************************************************************************
@ObjectType({ description: `Stores configuration parameters for specific content source instances, customizing how content is retrieved and processed from each source.` })
export class MJContentSourceParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field({description: `Reference to the parameter definition in Content Source Type Params.`}) 
    @MaxLength(16)
    ContentSourceTypeParamID: string;
        
    @Field({description: `The configured value for this parameter on this specific content source.`}) 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class CreateMJContentSourceParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class UpdateMJContentSourceParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Params
//****************************************************************************
@ObjectType()
export class RunMJContentSourceParamViewResult {
    @Field(() => [MJContentSourceParam_])
    Results: MJContentSourceParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceParam_)
export class MJContentSourceParamResolver extends ResolverBase {
    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceParamViewResult)
    async RunMJContentSourceParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceParam_, { nullable: true })
    async MJContentSourceParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceParam_ | null> {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Source Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentSourceParam_)
    async CreateMJContentSourceParam(
        @Arg('input', () => CreateMJContentSourceParamInput) input: CreateMJContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceParam_)
    async UpdateMJContentSourceParam(
        @Arg('input', () => UpdateMJContentSourceParamInput) input: UpdateMJContentSourceParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceParam_)
    async DeleteMJContentSourceParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Type Params
//****************************************************************************
@ObjectType({ description: `Defines required and optional parameters for content source types, establishing the configuration for each source type.` })
export class MJContentSourceTypeParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Data type of the parameter (string, number, boolean, date, etc.).`}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true, description: `Default value to use if not specified when configuring a content source.`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this parameter must be provided when setting up a content source.`}) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class CreateMJContentSourceTypeParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class UpdateMJContentSourceTypeParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Type Params
//****************************************************************************
@ObjectType()
export class RunMJContentSourceTypeParamViewResult {
    @Field(() => [MJContentSourceTypeParam_])
    Results: MJContentSourceTypeParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceTypeParam_)
export class MJContentSourceTypeParamResolver extends ResolverBase {
    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeParamViewResult)
    async RunMJContentSourceTypeParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Type Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceTypeParam_, { nullable: true })
    async MJContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceTypeParam_ | null> {
        this.CheckUserReadPermissions('Content Source Type Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypeParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Type Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Source Type Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentSourceTypeParam_)
    async CreateMJContentSourceTypeParam(
        @Arg('input', () => CreateMJContentSourceTypeParamInput) input: CreateMJContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Type Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceTypeParam_)
    async UpdateMJContentSourceTypeParam(
        @Arg('input', () => UpdateMJContentSourceTypeParamInput) input: UpdateMJContentSourceTypeParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Type Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceTypeParam_)
    async DeleteMJContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Type Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Types
//****************************************************************************
@ObjectType({ description: `Catalogs available content source types such as file systems, APIs, websites, databases, and cloud storage platforms with their capabilities.` })
export class MJContentSourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJContentSource_])
    ContentSources_ContentSourceTypeIDArray: MJContentSource_[]; // Link to ContentSources
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentSourceTypeIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class CreateMJContentSourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class UpdateMJContentSourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Types
//****************************************************************************
@ObjectType()
export class RunMJContentSourceTypeViewResult {
    @Field(() => [MJContentSourceType_])
    Results: MJContentSourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSourceType_)
export class MJContentSourceTypeResolver extends ResolverBase {
    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceTypeViewResult)
    async RunMJContentSourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSourceType_, { nullable: true })
    async MJContentSourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSourceType_ | null> {
        this.CheckUserReadPermissions('Content Source Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Source Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async ContentSources_ContentSourceTypeIDArray(@Root() mjcontentsourcetype_: MJContentSourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentSourceTypeID]='${mjcontentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentSourceTypeIDArray(@Root() mjcontentsourcetype_: MJContentSourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceTypeID]='${mjcontentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentSourceType_)
    async CreateMJContentSourceType(
        @Arg('input', () => CreateMJContentSourceTypeInput) input: CreateMJContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Source Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSourceType_)
    async UpdateMJContentSourceType(
        @Arg('input', () => UpdateMJContentSourceTypeInput) input: UpdateMJContentSourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Source Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSourceType_)
    async DeleteMJContentSourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Sources
//****************************************************************************
@ObjectType({ description: `Configures connections to external content repositories and systems from which content is imported, synchronized, and tagged.` })
export class MJContentSource_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field({description: `Base URL or connection string for accessing this content source.`}) 
    @MaxLength(4000)
    URL: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [MJContentProcessRun_])
    ContentProcessRuns_SourceIDArray: MJContentProcessRun_[]; // Link to ContentProcessRuns
    
    @Field(() => [MJContentSourceParam_])
    ContentSourceParams_ContentSourceIDArray: MJContentSourceParam_[]; // Link to ContentSourceParams
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentSourceIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class CreateMJContentSourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class UpdateMJContentSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Sources
//****************************************************************************
@ObjectType()
export class RunMJContentSourceViewResult {
    @Field(() => [MJContentSource_])
    Results: MJContentSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentSource_)
export class MJContentSourceResolver extends ResolverBase {
    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentSourceViewResult)
    async RunMJContentSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentSource_, { nullable: true })
    async MJContentSource(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentSource_ | null> {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Sources', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentProcessRun_])
    async ContentProcessRuns_SourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [SourceID]='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Process Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentSourceParam_])
    async ContentSourceParams_ContentSourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ContentSourceID]='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Source Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentSourceIDArray(@Root() mjcontentsource_: MJContentSource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceID]='${mjcontentsource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentSource_)
    async CreateMJContentSource(
        @Arg('input', () => CreateMJContentSourceInput) input: CreateMJContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentSource_)
    async UpdateMJContentSource(
        @Arg('input', () => UpdateMJContentSourceInput) input: UpdateMJContentSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentSource_)
    async DeleteMJContentSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Type Attributes
//****************************************************************************
@ObjectType({ description: `Defines the attributes available for extraction via prompt for each content type.` })
export class MJContentTypeAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the Content Type this attribute belongs to.`}) 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The AI prompt template used to extract this attribute from content.`}) 
    Prompt: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class CreateMJContentTypeAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class UpdateMJContentTypeAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Type Attributes
//****************************************************************************
@ObjectType()
export class RunMJContentTypeAttributeViewResult {
    @Field(() => [MJContentTypeAttribute_])
    Results: MJContentTypeAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentTypeAttribute_)
export class MJContentTypeAttributeResolver extends ResolverBase {
    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeAttributeViewResult)
    async RunMJContentTypeAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Type Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentTypeAttribute_, { nullable: true })
    async MJContentTypeAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentTypeAttribute_ | null> {
        this.CheckUserReadPermissions('Content Type Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypeAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Type Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Type Attributes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJContentTypeAttribute_)
    async CreateMJContentTypeAttribute(
        @Arg('input', () => CreateMJContentTypeAttributeInput) input: CreateMJContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Type Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentTypeAttribute_)
    async UpdateMJContentTypeAttribute(
        @Arg('input', () => UpdateMJContentTypeAttributeInput) input: UpdateMJContentTypeAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Type Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentTypeAttribute_)
    async DeleteMJContentTypeAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Type Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Types
//****************************************************************************
@ObjectType({ description: `Defines categories of content with specific schemas, behaviors, and processing rules for structured content management.` })
export class MJContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Int, {description: `Minimum number of tags that must be applied to content of this type.`}) 
    MinTags: number;
        
    @Field(() => Int, {description: `Maximum number of tags allowed on content of this type.`}) 
    MaxTags: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [MJContentSource_])
    ContentSources_ContentTypeIDArray: MJContentSource_[]; // Link to ContentSources
    
    @Field(() => [MJContentItem_])
    ContentItems_ContentTypeIDArray: MJContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class CreateMJContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;
}
    

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class UpdateMJContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Types
//****************************************************************************
@ObjectType()
export class RunMJContentTypeViewResult {
    @Field(() => [MJContentType_])
    Results: MJContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJContentType_)
export class MJContentTypeResolver extends ResolverBase {
    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJContentTypeViewResult)
    async RunMJContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJContentType_, { nullable: true })
    async MJContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJContentType_ | null> {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Content Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJContentSource_])
    async ContentSources_ContentTypeIDArray(@Root() mjcontenttype_: MJContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentTypeID]='${mjcontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Sources', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJContentItem_])
    async ContentItems_ContentTypeIDArray(@Root() mjcontenttype_: MJContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentTypeID]='${mjcontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Content Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJContentType_)
    async CreateMJContentType(
        @Arg('input', () => CreateMJContentTypeInput) input: CreateMJContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJContentType_)
    async UpdateMJContentType(
        @Arg('input', () => UpdateMJContentTypeInput) input: UpdateMJContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJContentType_)
    async DeleteMJContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversation Details
//****************************************************************************
@ObjectType({ description: `Stores individual messages, responses, and interactions within a conversation, maintaining the complete dialogue history with timestamps.` })
export class MJConversationDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({nullable: true, description: `External system identifier for this message, used for integration scenarios.`}) 
    @MaxLength(200)
    ExternalID?: string;
        
    @Field({description: `The role of the message sender (user, assistant, system, function).`}) 
    @MaxLength(40)
    Role: string;
        
    @Field({description: `The actual content of the message in the conversation.`}) 
    Message: string;
        
    @Field({nullable: true, description: `Error message if this conversation turn encountered a problem.`}) 
    Error?: string;
        
    @Field(() => Boolean, {description: `Flag indicating if this message should be hidden from end users (system messages, function calls, etc.).`}) 
    HiddenToUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `This column is used to capture user feedback as a rating scale. The scale ranges from 1 to 10, where 1 might represent thumbs down, and 10 might represent thumbs up or the highest rating in a star-based scale.`}) 
    UserRating?: number;
        
    @Field({nullable: true, description: `This column is used to store user text feedback about a given AI response, describing what they liked or disliked.`}) 
    UserFeedback?: string;
        
    @Field({nullable: true, description: `This column stores human or AI-generated reflections on how to improve future responses based on the user feedback and the AI output generated for prior messages in the conversation.`}) 
    ReflectionInsights?: string;
        
    @Field({nullable: true, description: `This column optionally stores a summary of the entire conversation leading up to this particular conversation detail record. It is used in long-running conversations to optimize performance by summarizing earlier parts.`}) 
    SummaryOfEarlierConversation?: string;
        
    @Field({nullable: true, description: `This field, when populated, overrides the UserID at the Conversation level to specify a different user created the message.`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Optional reference to a conversation artifact associated with this conversation detail`}) 
    @MaxLength(16)
    ArtifactID?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific version of a conversation artifact associated with this conversation detail`}) 
    @MaxLength(16)
    ArtifactVersionID?: string;
        
    @Field(() => Int, {nullable: true, description: `Duration in milliseconds representing how long the AI response processing took to complete for this conversation detail.`}) 
    CompletionTime?: number;
        
    @Field(() => Boolean, {description: `Indicates if this message is pinned within the conversation for easy reference`}) 
    IsPinned: boolean;
        
    @Field({nullable: true, description: `Optional reference to parent message for threaded conversations. NULL for top-level messages.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `Denormalized agent ID for quick lookup of agent name and icon without joining through AgentRun`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({description: `Status of the conversation message. Complete indicates finished processing, In-Progress indicates active agent work, Error indicates processing failed.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `DEPRECATED: Use ResponseForm, ActionableCommands, and AutomaticCommands instead. Legacy field for simple text-based suggested responses. Replaced in v2.118 by more powerful structured forms and commands system. Retained for historical data only.`}) 
    SuggestedResponses?: string;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this conversation detail to a test run if this message was part of a test conversation. Allows filtering and analyzing test-specific conversation turns.`}) 
    @MaxLength(16)
    TestRunID?: string;
        
    @Field({nullable: true, description: `JSON object containing agent response form definition with questions and validation rules. Supports 8 question types: text, textarea, email, number, currency, date, datetime, choices (buttongroup/radio/dropdown/checkbox). Used for collecting structured user input with proper validation.`}) 
    ResponseForm?: string;
        
    @Field({nullable: true, description: `JSON array of actionable commands that user can trigger (shown as clickable buttons/links). Supports open:resource (navigate to records/dashboards/reports/forms) and open:url (external links). Typically used after completing work to provide easy navigation to created/modified resources.`}) 
    ActionableCommands?: string;
        
    @Field({nullable: true, description: `JSON array of automatic commands that execute immediately when received (no user interaction). Supports refresh:data (refresh entity data or caches) and notification (show toast messages). Used for keeping UI in sync after agent makes changes and providing user feedback.`}) 
    AutomaticCommands?: string;
        
    @Field(() => Boolean, {description: `Indicates if the original message content was modified after initial creation. Set automatically by the server when the Message field is changed on update.`}) 
    OriginalMessageChanged: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Artifact?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ArtifactVersion?: string;
        
    @Field({nullable: true}) 
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TestRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJReport_])
    Reports_ConversationDetailIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJConversationDetailArtifact_])
    MJ_ConversationDetailArtifacts_ConversationDetailIDArray: MJConversationDetailArtifact_[]; // Link to MJ_ConversationDetailArtifacts
    
    @Field(() => [MJConversationDetailAttachment_])
    MJ_ConversationDetailAttachments_ConversationDetailIDArray: MJConversationDetailAttachment_[]; // Link to MJ_ConversationDetailAttachments
    
    @Field(() => [MJConversationDetailRating_])
    MJ_ConversationDetailRatings_ConversationDetailIDArray: MJConversationDetailRating_[]; // Link to MJ_ConversationDetailRatings
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_SourceConversationDetailIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_ConversationDetailIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJConversationDetail_])
    ConversationDetails_ParentIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [MJTask_])
    MJ_Tasks_ConversationDetailIDArray: MJTask_[]; // Link to MJ_Tasks
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_SourceConversationDetailIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
}

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class CreateMJConversationDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating: number | null;

    @Field({ nullable: true })
    UserFeedback: string | null;

    @Field({ nullable: true })
    ReflectionInsights: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    ArtifactID: string | null;

    @Field({ nullable: true })
    ArtifactVersionID: string | null;

    @Field(() => Int, { nullable: true })
    CompletionTime: number | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SuggestedResponses: string | null;

    @Field({ nullable: true })
    TestRunID: string | null;

    @Field({ nullable: true })
    ResponseForm: string | null;

    @Field({ nullable: true })
    ActionableCommands: string | null;

    @Field({ nullable: true })
    AutomaticCommands: string | null;

    @Field(() => Boolean, { nullable: true })
    OriginalMessageChanged?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error?: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating?: number | null;

    @Field({ nullable: true })
    UserFeedback?: string | null;

    @Field({ nullable: true })
    ReflectionInsights?: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    ArtifactID?: string | null;

    @Field({ nullable: true })
    ArtifactVersionID?: string | null;

    @Field(() => Int, { nullable: true })
    CompletionTime?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SuggestedResponses?: string | null;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field({ nullable: true })
    ResponseForm?: string | null;

    @Field({ nullable: true })
    ActionableCommands?: string | null;

    @Field({ nullable: true })
    AutomaticCommands?: string | null;

    @Field(() => Boolean, { nullable: true })
    OriginalMessageChanged?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversation Details
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailViewResult {
    @Field(() => [MJConversationDetail_])
    Results: MJConversationDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetail_)
export class MJConversationDetailResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailViewResult)
    async RunMJConversationDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversation Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetail_, { nullable: true })
    async MJConversationDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetail_ | null> {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Conversation Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailArtifact_])
    async MJ_ConversationDetailArtifacts_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailArtifacts] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailAttachment_])
    async MJ_ConversationDetailAttachments_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailAttachments] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailRating_])
    async MJ_ConversationDetailRatings_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Ratings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailRatings] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Ratings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Ratings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_SourceConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [SourceConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_ParentIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ParentID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_ConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [ConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_SourceConversationDetailIDArray(@Root() mjconversationdetail_: MJConversationDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [SourceConversationDetailID]='${mjconversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversationDetail_)
    async CreateMJConversationDetail(
        @Arg('input', () => CreateMJConversationDetailInput) input: CreateMJConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Conversation Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetail_)
    async UpdateMJConversationDetail(
        @Arg('input', () => UpdateMJConversationDetailInput) input: UpdateMJConversationDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Conversation Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetail_)
    async DeleteMJConversationDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversation Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversations
//****************************************************************************
@ObjectType({ description: `Tracks conversation sessions between users and AI agents or between users, including context, participants, and metadata.` })
export class MJConversation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `External system identifier for cross-system conversation tracking.`}) 
    @MaxLength(1000)
    ExternalID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type or category of conversation (Skip, Support, Chat, etc.).`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if this conversation has been archived and should not appear in active lists.`}) 
    IsArchived: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `ID of a related record this conversation is about (support ticket, order, etc.).`}) 
    @MaxLength(1000)
    LinkedRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the processing status of the conversation: Available, Processing`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ProjectID?: string;
        
    @Field(() => Boolean, {description: `Indicates if this conversation is pinned to the top of lists`}) 
    IsPinned: boolean;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this conversation to a test run if this conversation was generated as part of a test. Enables tracking test conversations separately from production conversations.`}) 
    @MaxLength(16)
    TestRunID?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Project?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TestRun?: string;
        
    @Field(() => [MJConversationDetail_])
    ConversationDetails_ConversationIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [MJReport_])
    Reports_ConversationIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJConversationArtifact_])
    MJ_ConversationArtifacts_ConversationIDArray: MJConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_ConversationIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_SourceConversationIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_SourceConversationIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
}

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class CreateMJConversationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    TestRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class UpdateMJConversationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsPinned?: boolean;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversations
//****************************************************************************
@ObjectType()
export class RunMJConversationViewResult {
    @Field(() => [MJConversation_])
    Results: MJConversation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversation_)
export class MJConversationResolver extends ResolverBase {
    @Query(() => RunMJConversationViewResult)
    async RunMJConversationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationViewResult)
    async RunMJConversationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationViewResult)
    async RunMJConversationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversation_, { nullable: true })
    async MJConversation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversation_ | null> {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Conversations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationArtifact_])
    async MJ_ConversationArtifacts_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_ConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_SourceConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [SourceConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_SourceConversationIDArray(@Root() mjconversation_: MJConversation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [SourceConversationID]='${mjconversation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversation_)
    async CreateMJConversation(
        @Arg('input', () => CreateMJConversationInput) input: CreateMJConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Conversations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversation_)
    async UpdateMJConversation(
        @Arg('input', () => UpdateMJConversationInput) input: UpdateMJConversationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Conversations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversation_)
    async DeleteMJConversation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboard Categories
//****************************************************************************
@ObjectType({ description: `Organizes dashboards into logical groupings for navigation and access control, supporting hierarchical categorization.` })
export class MJDashboardCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJDashboard_])
    Dashboards_CategoryIDArray: MJDashboard_[]; // Link to Dashboards
    
    @Field(() => [MJDashboardCategory_])
    DashboardCategories_ParentIDArray: MJDashboardCategory_[]; // Link to DashboardCategories
    
    @Field(() => [MJDashboardCategoryPermission_])
    MJ_DashboardCategoryPermissions_DashboardCategoryIDArray: MJDashboardCategoryPermission_[]; // Link to MJ_DashboardCategoryPermissions
    
    @Field(() => [MJDashboardCategoryLink_])
    MJ_DashboardCategoryLinks_DashboardCategoryIDArray: MJDashboardCategoryLink_[]; // Link to MJ_DashboardCategoryLinks
    
}

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboard Categories
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryViewResult {
    @Field(() => [MJDashboardCategory_])
    Results: MJDashboardCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategory_)
export class MJDashboardCategoryResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryViewResult)
    async RunMJDashboardCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboard Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategory_, { nullable: true })
    async MJDashboardCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategory_ | null> {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Dashboard Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDashboard_])
    async Dashboards_CategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [CategoryID]='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategory_])
    async DashboardCategories_ParentIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ParentID]='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryPermission_])
    async MJ_DashboardCategoryPermissions_DashboardCategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryPermissions] WHERE [DashboardCategoryID]='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryLink_])
    async MJ_DashboardCategoryLinks_DashboardCategoryIDArray(@Root() mjdashboardcategory_: MJDashboardCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryLinks] WHERE [DashboardCategoryID]='${mjdashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDashboardCategory_)
    async CreateMJDashboardCategory(
        @Arg('input', () => CreateMJDashboardCategoryInput) input: CreateMJDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dashboard Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategory_)
    async UpdateMJDashboardCategory(
        @Arg('input', () => UpdateMJDashboardCategoryInput) input: UpdateMJDashboardCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dashboard Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategory_)
    async DeleteMJDashboardCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboard Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboards
//****************************************************************************
@ObjectType({ description: `Dashboards are used to group resources into a single display pane for an end-user` })
export class MJDashboard_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `JSON configuration defining the dashboard layout, widgets, data sources, and display options.`}) 
    UIConfigDetails: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Dashboard type supporting Config (metadata-driven), Code (compiled TypeScript), and Dynamic Code (Skip-generated runtime JavaScript/React) options`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Base64 encoded image or URL to an image thumbnail for the dashboard`}) 
    Thumbnail?: string;
        
    @Field({description: `Scope of the dashboard: Global or App-specific`}) 
    @MaxLength(40)
    Scope: string;
        
    @Field({nullable: true, description: `Associated Application ID if Scope is App, otherwise NULL`}) 
    @MaxLength(16)
    ApplicationID?: string;
        
    @Field({nullable: true, description: `Specifies the runtime class that will be used for the Dashboard when Type is set to 'Code'. This class contains the custom logic and implementation for code-based dashboards.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Used to identify the dashboard for code-base dashboards. Allows reuse of the same DriverClass for multiple dashboards that can be rendered differently.`}) 
    @MaxLength(510)
    Code?: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Application?: string;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field(() => [MJDashboardUserState_])
    MJ_DashboardUserStates_DashboardIDArray: MJDashboardUserState_[]; // Link to MJ_DashboardUserStates
    
    @Field(() => [MJDashboardCategoryLink_])
    MJ_DashboardCategoryLinks_DashboardIDArray: MJDashboardCategoryLink_[]; // Link to MJ_DashboardCategoryLinks
    
    @Field(() => [MJDashboardUserPreference_])
    MJ_DashboardUserPreferences_DashboardIDArray: MJDashboardUserPreference_[]; // Link to MJ_DashboardUserPreferences
    
    @Field(() => [MJDashboardPermission_])
    MJ_DashboardPermissions_DashboardIDArray: MJDashboardPermission_[]; // Link to MJ_DashboardPermissions
    
}

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class CreateMJDashboardInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class UpdateMJDashboardInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboards
//****************************************************************************
@ObjectType()
export class RunMJDashboardViewResult {
    @Field(() => [MJDashboard_])
    Results: MJDashboard_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboard_)
export class MJDashboardResolver extends ResolverBase {
    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardViewResult)
    async RunMJDashboardDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboards';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboard_, { nullable: true })
    async MJDashboard(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboard_ | null> {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Dashboards', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDashboardUserState_])
    async MJ_DashboardUserStates_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserStates] WHERE [DashboardID]='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryLink_])
    async MJ_DashboardCategoryLinks_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryLinks] WHERE [DashboardID]='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserPreference_])
    async MJ_DashboardUserPreferences_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [DashboardID]='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardPermission_])
    async MJ_DashboardPermissions_DashboardIDArray(@Root() mjdashboard_: MJDashboard_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardPermissions] WHERE [DashboardID]='${mjdashboard_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDashboard_)
    async CreateMJDashboard(
        @Arg('input', () => CreateMJDashboardInput) input: CreateMJDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dashboards', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboard_)
    async UpdateMJDashboard(
        @Arg('input', () => UpdateMJDashboardInput) input: UpdateMJDashboardInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dashboards', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboard_)
    async DeleteMJDashboard(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboards', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Context Items
//****************************************************************************
@ObjectType({ description: `Data Context Items store information about each item within a Data Context. Each item stores a link to a view, query, or raw sql statement and can optionally cache the JSON representing the last run of that data object as well.` })
export class MJDataContextItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DataContextID: string;
        
    @Field({description: `The type of the item, either "view", "query", "full_entity", "single_record", or "sql"`}) 
    @MaxLength(100)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    QueryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `The Primary Key value for the record, only used when Type='single_record'`}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field({nullable: true, description: `Only used when Type=sql`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Optionally used to cache results of an item. This can be used for performance optimization, and also for having snapshots of data for historical comparisons.`}) 
    DataJSON?: string;
        
    @Field({nullable: true, description: `If DataJSON is populated, this field will show the date the the data was captured`}) 
    @MaxLength(10)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Optional programmatic identifier for this data context item. Must be unique within the DataContext and follow JavaScript naming conventions (letters, numbers, underscore, starting with letter or underscore). Used for improved code generation and programmatic access to data context items.`}) 
    @MaxLength(510)
    CodeName?: string;
        
    @Field() 
    @MaxLength(510)
    DataContext: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    View?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Query?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class CreateMJDataContextItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID: string | null;

    @Field({ nullable: true })
    QueryID: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    DataJSON: string | null;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class UpdateMJDataContextItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID?: string | null;

    @Field({ nullable: true })
    QueryID?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    DataJSON?: string | null;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Context Items
//****************************************************************************
@ObjectType()
export class RunMJDataContextItemViewResult {
    @Field(() => [MJDataContextItem_])
    Results: MJDataContextItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataContextItem_)
export class MJDataContextItemResolver extends ResolverBase {
    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextItemViewResult)
    async RunMJDataContextItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Context Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataContextItem_, { nullable: true })
    async MJDataContextItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataContextItem_ | null> {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Data Context Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDataContextItem_)
    async CreateMJDataContextItem(
        @Arg('input', () => CreateMJDataContextItemInput) input: CreateMJDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Data Context Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataContextItem_)
    async UpdateMJDataContextItem(
        @Arg('input', () => UpdateMJDataContextItemInput) input: UpdateMJDataContextItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Data Context Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataContextItem_)
    async DeleteMJDataContextItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Context Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Contexts
//****************************************************************************
@ObjectType({ description: `Data Contexts are a primitive within the MemberJunction architecture. They store information about data contexts which are groups of data including views, queries, or raw SQL statements. Data contexts can be used in conversations, reports and more.` })
export class MJDataContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Timestamp of when the data in this context was last refreshed or recalculated.`}) 
    @MaxLength(10)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJDataContextItem_])
    DataContextItems_DataContextIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [MJReport_])
    Reports_DataContextIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJConversation_])
    Conversations_DataContextIDArray: MJConversation_[]; // Link to Conversations
    
}

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class CreateMJDataContextInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class UpdateMJDataContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Contexts
//****************************************************************************
@ObjectType()
export class RunMJDataContextViewResult {
    @Field(() => [MJDataContext_])
    Results: MJDataContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataContext_)
export class MJDataContextResolver extends ResolverBase {
    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDataContextViewResult)
    async RunMJDataContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Contexts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataContext_, { nullable: true })
    async MJDataContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataContext_ | null> {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Data Contexts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [DataContextID]='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [DataContextID]='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_DataContextIDArray(@Root() mjdatacontext_: MJDataContext_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [DataContextID]='${mjdatacontext_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDataContext_)
    async CreateMJDataContext(
        @Arg('input', () => CreateMJDataContextInput) input: CreateMJDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Data Contexts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataContext_)
    async UpdateMJDataContext(
        @Arg('input', () => UpdateMJDataContextInput) input: UpdateMJDataContextInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Data Contexts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataContext_)
    async DeleteMJDataContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Contexts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dataset Items
//****************************************************************************
@ObjectType({ description: `A single item in a Dataset and can be sourced from multiple methods.` })
export class MJDatasetItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique code identifier for this dataset item within its parent dataset.`}) 
    @MaxLength(100)
    Code: string;
        
    @Field() 
    @MaxLength(16)
    DatasetID: string;
        
    @Field(() => Int, {description: `Order in which this item should be processed or displayed within the dataset.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({nullable: true, description: `SQL WHERE clause to filter data when this dataset item is sourced from a query.`}) 
    WhereClause?: string;
        
    @Field({description: `The date field name used for incremental updates and change detection.`}) 
    @MaxLength(200)
    DateFieldToCheck: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional column to store a comma-delimited list of columns for the DatasetItem`}) 
    Columns?: string;
        
    @Field() 
    @MaxLength(200)
    Dataset: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Dataset Items
//****************************************************************************
@InputType()
export class CreateMJDatasetItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    DatasetID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field({ nullable: true })
    DateFieldToCheck?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Columns: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Dataset Items
//****************************************************************************
@InputType()
export class UpdateMJDatasetItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    DatasetID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field({ nullable: true })
    DateFieldToCheck?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Columns?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dataset Items
//****************************************************************************
@ObjectType()
export class RunMJDatasetItemViewResult {
    @Field(() => [MJDatasetItem_])
    Results: MJDatasetItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDatasetItem_)
export class MJDatasetItemResolver extends ResolverBase {
    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetItemViewResult)
    async RunMJDatasetItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dataset Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDatasetItem_, { nullable: true })
    async MJDatasetItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDatasetItem_ | null> {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Dataset Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDatasetItem_)
    async CreateMJDatasetItem(
        @Arg('input', () => CreateMJDatasetItemInput) input: CreateMJDatasetItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Dataset Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDatasetItem_)
    async UpdateMJDatasetItem(
        @Arg('input', () => UpdateMJDatasetItemInput) input: UpdateMJDatasetItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Dataset Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDatasetItem_)
    async DeleteMJDatasetItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dataset Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Datasets
//****************************************************************************
@ObjectType({ description: `Cacheable sets of data that can span one or more items` })
export class MJDataset_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJDatasetItem_])
    DatasetItems_DatasetNameArray: MJDatasetItem_[]; // Link to DatasetItems
    
}

//****************************************************************************
// INPUT TYPE for Datasets
//****************************************************************************
@InputType()
export class CreateMJDatasetInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Datasets
//****************************************************************************
@InputType()
export class UpdateMJDatasetInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Datasets
//****************************************************************************
@ObjectType()
export class RunMJDatasetViewResult {
    @Field(() => [MJDataset_])
    Results: MJDataset_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDataset_)
export class MJDatasetResolver extends ResolverBase {
    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDatasetViewResult)
    async RunMJDatasetDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Datasets';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDataset_, { nullable: true })
    async MJDataset(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDataset_ | null> {
        this.CheckUserReadPermissions('Datasets', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasets] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Datasets', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Datasets', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDatasetItem_])
    async DatasetItems_DatasetNameArray(@Root() mjdataset_: MJDataset_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [DatasetName]='${mjdataset_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dataset Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDataset_)
    async CreateMJDataset(
        @Arg('input', () => CreateMJDatasetInput) input: CreateMJDatasetInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Datasets', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDataset_)
    async UpdateMJDataset(
        @Arg('input', () => UpdateMJDatasetInput) input: UpdateMJDatasetInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Datasets', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDataset_)
    async DeleteMJDataset(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Datasets', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType({ description: `Records individual matching pairs of potentially duplicate records identified during a duplicate detection run with confidence scores.` })
export class MJDuplicateRunDetailMatch_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunDetailID: string;
        
    @Field({description: `Either Vector or SP`}) 
    @MaxLength(40)
    MatchSource: string;
        
    @Field({description: `The ID of the record identified as a potential duplicate match.`}) 
    @MaxLength(1000)
    MatchRecordID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 designating the computed probability of a match`}) 
    MatchProbability: number;
        
    @Field({description: `Timestamp when this duplicate match was identified.`}) 
    @MaxLength(10)
    MatchedAt: Date;
        
    @Field({description: `The action to take for this match (Ignore, Merge, Delete).`}) 
    @MaxLength(40)
    Action: string;
        
    @Field({description: `Current approval status of the proposed action (Pending, Approved, Rejected).`}) 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RecordMergeLogID?: string;
        
    @Field({description: `Status of the merge operation if Action is Merge (Pending, Complete, Failed).`}) 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field({description: `Timestamp when records were merged, if applicable.`}) 
    @MaxLength(10)
    MergedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    DuplicateRunDetail: string;
        
    @Field({nullable: true}) 
    @MaxLength(900)
    RecordMergeLog?: string;
        
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunDetailMatchInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunDetailMatchInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunDetailMatchViewResult {
    @Field(() => [MJDuplicateRunDetailMatch_])
    Results: MJDuplicateRunDetailMatch_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRunDetailMatch_)
export class MJDuplicateRunDetailMatchResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailMatchViewResult)
    async RunMJDuplicateRunDetailMatchDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Detail Matches';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRunDetailMatch_, { nullable: true })
    async MJDuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRunDetailMatch_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async CreateMJDuplicateRunDetailMatch(
        @Arg('input', () => CreateMJDuplicateRunDetailMatchInput) input: CreateMJDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Run Detail Matches', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async UpdateMJDuplicateRunDetailMatch(
        @Arg('input', () => UpdateMJDuplicateRunDetailMatchInput) input: UpdateMJDuplicateRunDetailMatchInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Run Detail Matches', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDuplicateRunDetailMatch_)
    async DeleteMJDuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Duplicate Run Detail Matches', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Details
//****************************************************************************
@ObjectType({ description: `Stores detailed results for each record analyzed in a duplicate detection run, including match status and processing metadata.` })
export class MJDuplicateRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunID: string;
        
    @Field({description: `The ID of the record being analyzed for duplicates.`}) 
    @MaxLength(1000)
    RecordID: string;
        
    @Field({description: `Status of duplicate analysis for this record (Pending, Complete, Error).`}) 
    @MaxLength(40)
    MatchStatus: string;
        
    @Field({nullable: true, description: `If MatchStatus=Skipped, this field can be used to store the reason why the record was skipped`}) 
    SkippedReason?: string;
        
    @Field({nullable: true, description: `If MatchStatus='Error' this field can be used to track the error from that phase of the process for logging/diagnostics.`}) 
    MatchErrorMessage?: string;
        
    @Field({description: `Status of any merge operations for this record (Not Applicable, Pending, Complete, Failed).`}) 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field({nullable: true, description: `Error details if merge operation failed for this record.`}) 
    MergeErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    DuplicateRun: string;
        
    @Field(() => [MJDuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_DuplicateRunDetailIDArray: MJDuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason: string | null;

    @Field({ nullable: true })
    MatchErrorMessage: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason?: string | null;

    @Field({ nullable: true })
    MatchErrorMessage?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Details
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunDetailViewResult {
    @Field(() => [MJDuplicateRunDetail_])
    Results: MJDuplicateRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRunDetail_)
export class MJDuplicateRunDetailResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunDetailViewResult)
    async RunMJDuplicateRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRunDetail_, { nullable: true })
    async MJDuplicateRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRunDetail_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Duplicate Run Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_DuplicateRunDetailIDArray(@Root() mjduplicaterundetail_: MJDuplicateRunDetail_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [DuplicateRunDetailID]='${mjduplicaterundetail_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDuplicateRunDetail_)
    async CreateMJDuplicateRunDetail(
        @Arg('input', () => CreateMJDuplicateRunDetailInput) input: CreateMJDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRunDetail_)
    async UpdateMJDuplicateRunDetail(
        @Arg('input', () => UpdateMJDuplicateRunDetailInput) input: UpdateMJDuplicateRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDuplicateRunDetail_)
    async DeleteMJDuplicateRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Duplicate Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Runs
//****************************************************************************
@ObjectType({ description: `Manages execution of duplicate detection processes across entities, tracking configuration, progress, and summary results.` })
export class MJDuplicateRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    StartedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    SourceListID: string;
        
    @Field() 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Overall approval status for the duplicate run results (Pending, Approved, Rejected).`}) 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true, description: `Comments or notes regarding the approval decision for this duplicate run.`}) 
    ApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field({description: `Current processing status of the duplicate detection run (Pending, Running, Complete, Failed).`}) 
    @MaxLength(40)
    ProcessingStatus: string;
        
    @Field({nullable: true, description: `Error details if the duplicate detection run failed.`}) 
    ProcessingErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    StartedByUser: string;
        
    @Field() 
    @MaxLength(200)
    SourceList: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [MJDuplicateRunDetail_])
    DuplicateRunDetails_DuplicateRunIDArray: MJDuplicateRunDetail_[]; // Link to DuplicateRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class CreateMJDuplicateRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments: string | null;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class UpdateMJDuplicateRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments?: string | null;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Runs
//****************************************************************************
@ObjectType()
export class RunMJDuplicateRunViewResult {
    @Field(() => [MJDuplicateRun_])
    Results: MJDuplicateRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDuplicateRun_)
export class MJDuplicateRunResolver extends ResolverBase {
    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDuplicateRunViewResult)
    async RunMJDuplicateRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDuplicateRun_, { nullable: true })
    async MJDuplicateRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDuplicateRun_ | null> {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Duplicate Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJDuplicateRunDetail_])
    async DuplicateRunDetails_DuplicateRunIDArray(@Root() mjduplicaterun_: MJDuplicateRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [DuplicateRunID]='${mjduplicaterun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Duplicate Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJDuplicateRun_)
    async CreateMJDuplicateRun(
        @Arg('input', () => CreateMJDuplicateRunInput) input: CreateMJDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Duplicate Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDuplicateRun_)
    async UpdateMJDuplicateRun(
        @Arg('input', () => UpdateMJDuplicateRunInput) input: UpdateMJDuplicateRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Duplicate Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDuplicateRun_)
    async DeleteMJDuplicateRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Duplicate Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Company Integrations
//****************************************************************************
@ObjectType({ description: `Maps employees to their external identifiers in integrated systems, maintaining synchronization across platforms.` })
export class MJEmployeeCompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field({description: `The employee's unique identifier in the external integrated system.`}) 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `Indicates if this employee integration mapping is currently active.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Employee?: string;
        
    @Field() 
    @MaxLength(510)
    CompanyIntegration: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Company Integrations
//****************************************************************************
@InputType()
export class CreateMJEmployeeCompanyIntegrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Employee Company Integrations
//****************************************************************************
@InputType()
export class UpdateMJEmployeeCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Company Integrations
//****************************************************************************
@ObjectType()
export class RunMJEmployeeCompanyIntegrationViewResult {
    @Field(() => [MJEmployeeCompanyIntegration_])
    Results: MJEmployeeCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeCompanyIntegration_)
export class MJEmployeeCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeCompanyIntegrationViewResult)
    async RunMJEmployeeCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Company Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeCompanyIntegration_, { nullable: true })
    async MJEmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Employee Company Integrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async CreateMJEmployeeCompanyIntegration(
        @Arg('input', () => CreateMJEmployeeCompanyIntegrationInput) input: CreateMJEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employee Company Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async UpdateMJEmployeeCompanyIntegration(
        @Arg('input', () => UpdateMJEmployeeCompanyIntegrationInput) input: UpdateMJEmployeeCompanyIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Company Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeCompanyIntegration_)
    async DeleteMJEmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Company Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Roles
//****************************************************************************
@ObjectType({ description: `Links employees to their assigned roles within the organization, managing role-based permissions and responsibilities.` })
export class MJEmployeeRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Employee?: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Roles
//****************************************************************************
@InputType()
export class CreateMJEmployeeRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Employee Roles
//****************************************************************************
@InputType()
export class UpdateMJEmployeeRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Roles
//****************************************************************************
@ObjectType()
export class RunMJEmployeeRoleViewResult {
    @Field(() => [MJEmployeeRole_])
    Results: MJEmployeeRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeRole_)
export class MJEmployeeRoleResolver extends ResolverBase {
    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeRoleViewResult)
    async RunMJEmployeeRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeRole_, { nullable: true })
    async MJEmployeeRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeRole_ | null> {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Employee Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEmployeeRole_)
    async CreateMJEmployeeRole(
        @Arg('input', () => CreateMJEmployeeRoleInput) input: CreateMJEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employee Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployeeRole_)
    async UpdateMJEmployeeRole(
        @Arg('input', () => UpdateMJEmployeeRoleInput) input: UpdateMJEmployeeRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeRole_)
    async DeleteMJEmployeeRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Skills
//****************************************************************************
@ObjectType({ description: `Tracks skills, competencies, and certifications associated with employees for resource planning and team composition.` })
export class MJEmployeeSkill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    SkillID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Employee?: string;
        
    @Field() 
    @MaxLength(100)
    Skill: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Skills
//****************************************************************************
@InputType()
export class CreateMJEmployeeSkillInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Employee Skills
//****************************************************************************
@InputType()
export class UpdateMJEmployeeSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Skills
//****************************************************************************
@ObjectType()
export class RunMJEmployeeSkillViewResult {
    @Field(() => [MJEmployeeSkill_])
    Results: MJEmployeeSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployeeSkill_)
export class MJEmployeeSkillResolver extends ResolverBase {
    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeSkillViewResult)
    async RunMJEmployeeSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployeeSkill_, { nullable: true })
    async MJEmployeeSkill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployeeSkill_ | null> {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Employee Skills', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEmployeeSkill_)
    async CreateMJEmployeeSkill(
        @Arg('input', () => CreateMJEmployeeSkillInput) input: CreateMJEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employee Skills', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployeeSkill_)
    async UpdateMJEmployeeSkill(
        @Arg('input', () => UpdateMJEmployeeSkillInput) input: UpdateMJEmployeeSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employee Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployeeSkill_)
    async DeleteMJEmployeeSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employees
//****************************************************************************
@ObjectType({ description: `A list of employees across all units of your organization` })
export class MJEmployee_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Business Central Management ID - unique identifier for cross-system employee tracking.`}) 
    @MaxLength(16)
    BCMID: string;
        
    @Field({description: `Employee's first name or given name.`}) 
    @MaxLength(60)
    FirstName: string;
        
    @Field({description: `Employee's last name or surname.`}) 
    @MaxLength(100)
    LastName: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SupervisorID?: string;
        
    @Field({nullable: true, description: `Employee's job title or position within the organization.`}) 
    @MaxLength(100)
    Title?: string;
        
    @Field({description: `Employee's primary email address, must be unique across the system.`}) 
    @MaxLength(200)
    Email: string;
        
    @Field({nullable: true, description: `Employee's primary phone number for business contact.`}) 
    @MaxLength(40)
    Phone?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the employee is currently active in the organization.`}) 
    Active: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Supervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(60)
    SupervisorFirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SupervisorLastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SupervisorEmail?: string;
        
    @Field(() => [MJEmployee_])
    Employees_SupervisorIDArray: MJEmployee_[]; // Link to Employees
    
    @Field(() => [MJEmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_EmployeeIDArray: MJEmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [MJEmployeeRole_])
    EmployeeRoles_EmployeeIDArray: MJEmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [MJEmployeeSkill_])
    EmployeeSkills_EmployeeIDArray: MJEmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [MJUser_])
    Users_EmployeeIDArray: MJUser_[]; // Link to Users
    
}

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class CreateMJEmployeeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class UpdateMJEmployeeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employees
//****************************************************************************
@ObjectType()
export class RunMJEmployeeViewResult {
    @Field(() => [MJEmployee_])
    Results: MJEmployee_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEmployee_)
export class MJEmployeeResolver extends ResolverBase {
    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEmployeeViewResult)
    async RunMJEmployeeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employees';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEmployee_, { nullable: true })
    async MJEmployee(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEmployee_ | null> {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Employees', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEmployee_])
    async AllEmployees(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees]` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employees', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployee_])
    async Employees_SupervisorIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [SupervisorID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employees', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employees', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeRole_])
    async EmployeeRoles_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employee Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEmployeeSkill_])
    async EmployeeSkills_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employee Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUser_])
    async Users_EmployeeIDArray(@Root() mjemployee_: MJEmployee_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [EmployeeID]='${mjemployee_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Users', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEmployee_)
    async CreateMJEmployee(
        @Arg('input', () => CreateMJEmployeeInput) input: CreateMJEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Employees', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEmployee_)
    async UpdateMJEmployee(
        @Arg('input', () => UpdateMJEmployeeInput) input: UpdateMJEmployeeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Employees', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEmployee_)
    async DeleteMJEmployee(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employees', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entities
//****************************************************************************
@ObjectType({ description: `Catalog of all entities across all schemas` })
export class MJEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Optional suffix appended to entity names for display purposes.`}) 
    @MaxLength(510)
    NameSuffix?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the underlying view (first choice) or table (second choice), the Description column in the entity definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field({description: `The underlying database table name for this entity.`}) 
    @MaxLength(510)
    BaseTable: string;
        
    @Field({description: `The "wrapper" database view used for querying this entity with joins and computed fields.`}) 
    @MaxLength(510)
    BaseView: string;
        
    @Field(() => Boolean, {description: `When set to 0, CodeGen no longer generates a base view for the entity.`}) 
    BaseViewGenerated: boolean;
        
    @Field({description: `Database schema containing this entity's table and view.`}) 
    @MaxLength(510)
    SchemaName: string;
        
    @Field(() => Boolean, {description: `Indicates if this is a virtual entity without a physical database table.`}) 
    VirtualEntity: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, changes made via the MemberJunction architecture will result in tracking records being created in the RecordChange table. In addition, when turned on CodeGen will ensure that your table has two fields: __mj_CreatedAt and __mj_UpdatedAt which are special fields used in conjunction with the RecordChange table to track changes to rows in your entity.`}) 
    TrackRecordChanges: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, accessing a record by an end-user will result in an Audit Log record being created`}) 
    AuditRecordAccess: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, users running a view against this entity will result in an Audit Log record being created.`}) 
    AuditViewRuns: boolean;
        
    @Field(() => Boolean, {description: `If set to 0, the entity will not be available at all in the GraphQL API or the object model.`}) 
    IncludeInAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, a GraphQL query will be enabled that allows access to all rows in the entity.`}) 
    AllowAllRowsAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if updates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if creates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowCreateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if deletes are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowDeleteAPI: boolean;
        
    @Field(() => Boolean, {description: `Set to 1 if a custom resolver has been created for the entity.`}) 
    CustomResolverAPI: boolean;
        
    @Field(() => Boolean, {description: `Enabling this bit will result in search being possible at the API and UI layers`}) 
    AllowUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `Whether full-text search indexing is enabled for this entity.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `Name of the SQL Server full-text catalog if search is enabled.`}) 
    @MaxLength(510)
    FullTextCatalog?: string;
        
    @Field(() => Boolean, {description: `Indicates if the full-text catalog was auto-generated by CodeGen.`}) 
    FullTextCatalogGenerated: boolean;
        
    @Field({nullable: true, description: `Name of the full-text index on this entity's table.`}) 
    @MaxLength(510)
    FullTextIndex?: string;
        
    @Field(() => Boolean, {description: `Indicates if the full-text index was auto-generated by CodeGen.`}) 
    FullTextIndexGenerated: boolean;
        
    @Field({nullable: true, description: `Name of the function used for full-text searching this entity.`}) 
    @MaxLength(510)
    FullTextSearchFunction?: string;
        
    @Field(() => Boolean, {description: `Indicates if the search function was auto-generated by CodeGen.`}) 
    FullTextSearchFunctionGenerated: boolean;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of rows to return in user-created views for this entity.`}) 
    UserViewMaxRows?: number;
        
    @Field({nullable: true, description: `Name of the stored procedure for creating records in this entity.`}) 
    @MaxLength(510)
    spCreate?: string;
        
    @Field({nullable: true, description: `Name of the stored procedure for updating records in this entity.`}) 
    @MaxLength(510)
    spUpdate?: string;
        
    @Field({nullable: true, description: `Name of the stored procedure for deleting records in this entity.`}) 
    @MaxLength(510)
    spDelete?: string;
        
    @Field(() => Boolean, {description: `Indicates if the create procedure was auto-generated by CodeGen.`}) 
    spCreateGenerated: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the update procedure was auto-generated by CodeGen.`}) 
    spUpdateGenerated: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the delete procedure was auto-generated by CodeGen.`}) 
    spDeleteGenerated: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, the deleted spDelete will pre-process deletion to related entities that have 1:M cardinality with this entity. This does not have effect if spDeleteGenerated = 0`}) 
    CascadeDeletes: boolean;
        
    @Field({description: `Hard deletes physically remove rows from the underlying BaseTable. Soft deletes do not remove rows but instead mark the row as deleted by using the special field __mj_DeletedAt which will automatically be added to the entity's basetable by the CodeGen tool.`}) 
    @MaxLength(20)
    DeleteType: string;
        
    @Field(() => Boolean, {description: `This field must be turned on in order to enable merging of records for the entity. For AllowRecordMerge to be turned on, AllowDeleteAPI must be set to 1, and DeleteType must be set to Soft`}) 
    AllowRecordMerge: boolean;
        
    @Field({nullable: true, description: `When specified, this stored procedure is used to find matching records in this particular entity. The convention is to pass in the primary key(s) columns for the given entity to the procedure and the return will be zero to many rows where there is a column for each primary key field(s) and a ProbabilityScore (numeric(1,12)) column that has a 0 to 1 value of the probability of a match.`}) 
    @MaxLength(510)
    spMatch?: string;
        
    @Field({description: `When another entity links to this entity with a foreign key, this is the default component type that will be used in the UI. CodeGen will populate the RelatedEntityDisplayType column in the Entity Fields entity with whatever is provided here whenever a new foreign key is detected by CodeGen. The selection can be overridden on a per-foreign-key basis in each row of the Entity Fields entity.`}) 
    @MaxLength(40)
    RelationshipDefaultDisplayType: string;
        
    @Field(() => Boolean, {description: `Indicates if the default user form was auto-generated for this entity.`}) 
    UserFormGenerated: boolean;
        
    @Field({nullable: true, description: `TypeScript class name for the entity subclass in the codebase.`}) 
    @MaxLength(510)
    EntityObjectSubclassName?: string;
        
    @Field({nullable: true, description: `Import path for the entity subclass in the TypeScript codebase.`}) 
    @MaxLength(510)
    EntityObjectSubclassImport?: string;
        
    @Field({nullable: true, description: `Used to specify a field within the entity that in turn contains the field name that will be used for record-level communication preferences. For example in a hypothetical entity called Contacts, say there is a field called PreferredComm and that field had possible values of Email1, SMS, and Phone, and those value in turn corresponded to field names in the entity. Each record in the Contacts entity could have a specific preference for which field would be used for communication. The MJ Communication Framework will use this information when available, as a priority ahead of the data in the Entity Communication Fields entity which is entity-level and not record-level.`}) 
    @MaxLength(510)
    PreferredCommunicationField?: string;
        
    @Field({nullable: true, description: `Optional, specify an icon (CSS Class) for each entity for display in the UI`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional, comma-delimited string indicating the default scope for entity visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for simple defaults for filtering entity visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field({description: `Determines how entity rows should be packaged for external use. Options include None, Sample, and All. Defaults to None.`}) 
    @MaxLength(40)
    RowsToPackWithSchema: string;
        
    @Field({description: `Defines the sampling method for row packing when RowsToPackWithSchema is set to Sample. Options include random, top n, and bottom n. Defaults to random.`}) 
    @MaxLength(40)
    RowsToPackSampleMethod: string;
        
    @Field(() => Int, {description: `The number of rows to pack when RowsToPackWithSchema is set to Sample, based on the designated sampling method. Defaults to 0.`}) 
    RowsToPackSampleCount: number;
        
    @Field({nullable: true, description: `An optional ORDER BY clause for row packing when RowsToPackWithSchema is set to Sample. Allows custom ordering for selected entity data when using top n and bottom n.`}) 
    RowsToPackSampleOrder?: string;
        
    @Field(() => Int, {nullable: true, description: `Frequency in hours for automatically performing row counts on this entity. If NULL, automatic row counting is disabled. If greater than 0, schedules recurring SELECT COUNT(*) queries at the specified interval.`}) 
    AutoRowCountFrequency?: number;
        
    @Field(() => Int, {nullable: true, description: `Cached row count for this entity, populated by automatic row count processes when AutoRowCountFrequency is configured.`}) 
    RowCount?: number;
        
    @Field({nullable: true, description: `Timestamp indicating when the last automatic row count was performed for this entity.`}) 
    @MaxLength(10)
    RowCountRunAt?: Date;
        
    @Field({description: `Status of the entity. Active: fully functional; Deprecated: functional but generates console warnings when used; Disabled: not available for use even though metadata and physical table remain.`}) 
    @MaxLength(50)
    Status: string;
        
    @Field({nullable: true, description: `Optional display name for the entity. If not provided, the entity Name will be used for display purposes.`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({nullable: true}) 
    CodeName?: string;
        
    @Field({nullable: true}) 
    ClassName?: string;
        
    @Field({nullable: true}) 
    BaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseView?: string;
        
    @Field(() => [MJEntityPermission_])
    EntityPermissions_EntityIDArray: MJEntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [MJEntityRelationship_])
    EntityRelationships_EntityIDArray: MJEntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [MJEntityField_])
    EntityFields_EntityIDArray: MJEntityField_[]; // Link to EntityFields
    
    @Field(() => [MJEntityAIAction_])
    EntityAIActions_EntityIDArray: MJEntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [MJUserRecordLog_])
    UserRecordLogs_EntityIDArray: MJUserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [MJIntegrationURLFormat_])
    IntegrationURLFormats_EntityIDArray: MJIntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [MJEntity_])
    Entities_ParentIDArray: MJEntity_[]; // Link to Entities
    
    @Field(() => [MJUserFavorite_])
    UserFavorites_EntityIDArray: MJUserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [MJCompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_EntityIDArray: MJCompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
    @Field(() => [MJApplicationEntity_])
    ApplicationEntities_EntityIDArray: MJApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [MJUserApplicationEntity_])
    UserApplicationEntities_EntityIDArray: MJUserApplicationEntity_[]; // Link to UserApplicationEntities
    
    @Field(() => [MJList_])
    Lists_EntityIDArray: MJList_[]; // Link to Lists
    
    @Field(() => [MJUserView_])
    UserViews_EntityIDArray: MJUserView_[]; // Link to UserViews
    
    @Field(() => [MJRecordChange_])
    RecordChanges_EntityIDArray: MJRecordChange_[]; // Link to RecordChanges
    
    @Field(() => [MJAuditLog_])
    AuditLogs_EntityIDArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJResourceType_])
    ResourceTypes_EntityIDArray: MJResourceType_[]; // Link to ResourceTypes
    
    @Field(() => [MJTaggedItem_])
    TaggedItems_EntityIDArray: MJTaggedItem_[]; // Link to TaggedItems
    
    @Field(() => [MJDatasetItem_])
    DatasetItems_EntityIDArray: MJDatasetItem_[]; // Link to DatasetItems
    
    @Field(() => [MJCompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_EntityIDArray: MJCompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
    @Field(() => [MJRecordMergeLog_])
    RecordMergeLogs_EntityIDArray: MJRecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [MJQueryField_])
    QueryFields_SourceEntityIDArray: MJQueryField_[]; // Link to QueryFields
    
    @Field(() => [MJConversation_])
    Conversations_LinkedEntityIDArray: MJConversation_[]; // Link to Conversations
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_EntityIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [MJDataContextItem_])
    DataContextItems_EntityIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [MJUser_])
    Users_LinkedEntityIDArray: MJUser_[]; // Link to Users
    
    @Field(() => [MJEntityRecordDocument_])
    EntityRecordDocuments_EntityIDArray: MJEntityRecordDocument_[]; // Link to EntityRecordDocuments
    
    @Field(() => [MJFileEntityRecordLink_])
    FileEntityRecordLinks_EntityIDArray: MJFileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
    @Field(() => [MJUserViewCategory_])
    UserViewCategories_EntityIDArray: MJUserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [MJEntitySetting_])
    EntitySettings_EntityIDArray: MJEntitySetting_[]; // Link to EntitySettings
    
    @Field(() => [MJDuplicateRun_])
    DuplicateRuns_EntityIDArray: MJDuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [MJEntityAction_])
    EntityActions_EntityIDArray: MJEntityAction_[]; // Link to EntityActions
    
    @Field(() => [MJTemplateParam_])
    TemplateParams_EntityIDArray: MJTemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [MJRecommendation_])
    Recommendations_SourceEntityIDArray: MJRecommendation_[]; // Link to Recommendations
    
    @Field(() => [MJRecommendationItem_])
    RecommendationItems_DestinationEntityIDArray: MJRecommendationItem_[]; // Link to RecommendationItems
    
    @Field(() => [MJEntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_EntityIDArray: MJEntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
    @Field(() => [MJQueryEntity_])
    QueryEntities_EntityIDArray: MJQueryEntity_[]; // Link to QueryEntities
    
    @Field(() => [MJAccessControlRule_])
    MJ_AccessControlRules_EntityIDArray: MJAccessControlRule_[]; // Link to MJ_AccessControlRules
    
    @Field(() => [MJRecordLink_])
    MJ_RecordLinks_SourceEntityIDArray: MJRecordLink_[]; // Link to MJ_RecordLinks
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_PrimaryScopeEntityIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_PrimaryScopeEntityIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJVersionLabel_])
    MJ_VersionLabels_EntityIDArray: MJVersionLabel_[]; // Link to MJ_VersionLabels
    
    @Field(() => [MJVersionLabelItem_])
    MJ_VersionLabelItems_EntityIDArray: MJVersionLabelItem_[]; // Link to MJ_VersionLabelItems
    
    @Field(() => [MJGeneratedCode_])
    GeneratedCodes_LinkedEntityIDArray: MJGeneratedCode_[]; // Link to GeneratedCodes
    
    @Field(() => [MJRecordLink_])
    MJ_RecordLinks_TargetEntityIDArray: MJRecordLink_[]; // Link to MJ_RecordLinks
    
    @Field(() => [MJTestRun_])
    MJ_TestRuns_TargetLogEntityIDArray: MJTestRun_[]; // Link to MJ_TestRuns
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_PrimaryScopeEntityIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class CreateMJEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate: string | null;

    @Field({ nullable: true })
    spUpdate: string | null;

    @Field({ nullable: true })
    spDelete: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder: string | null;

    @Field(() => Int, { nullable: true })
    AutoRowCountFrequency: number | null;

    @Field(() => Int, { nullable: true })
    RowCount: number | null;

    @Field({ nullable: true })
    RowCountRunAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DisplayName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class UpdateMJEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate?: string | null;

    @Field({ nullable: true })
    spUpdate?: string | null;

    @Field({ nullable: true })
    spDelete?: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch?: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName?: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport?: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRowCountFrequency?: number | null;

    @Field(() => Int, { nullable: true })
    RowCount?: number | null;

    @Field({ nullable: true })
    RowCountRunAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entities
//****************************************************************************
@ObjectType()
export class RunMJEntityViewResult {
    @Field(() => [MJEntity_])
    Results: MJEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntity_)
export class MJEntityResolverBase extends ResolverBase {
    @Query(() => RunMJEntityViewResult)
    async RunMJEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityViewResult)
    async RunMJEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityViewResult)
    async RunMJEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntity_, { nullable: true })
    async MJEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntity_ | null> {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntity_])
    async AllEntities(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities]` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityPermission_])
    async EntityPermissions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityRelationship_])
    async EntityRelationships_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityField_])
    async EntityFields_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAIAction_])
    async EntityAIActions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRecordLog_])
    async UserRecordLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Record Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJIntegrationURLFormat_])
    async IntegrationURLFormats_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntity_])
    async Entities_ParentIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ParentID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserFavorite_])
    async UserFavorites_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Favorites', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJApplicationEntity_])
    async ApplicationEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserApplicationEntity_])
    async UserApplicationEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async Lists_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async UserViews_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourceType_])
    async ResourceTypes_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Resource Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTaggedItem_])
    async TaggedItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Tagged Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDatasetItem_])
    async DatasetItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dataset Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordMergeLog_])
    async RecordMergeLogs_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryField_])
    async QueryFields_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [SourceEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [LinkedEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUser_])
    async Users_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [LinkedEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Users', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityRecordDocument_])
    async EntityRecordDocuments_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileEntityRecordLink_])
    async FileEntityRecordLinks_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewCategory_])
    async UserViewCategories_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User View Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntitySetting_])
    async EntitySettings_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async DuplicateRuns_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityAction_])
    async EntityActions_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateParam_])
    async TemplateParams_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecommendation_])
    async Recommendations_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [SourceEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Recommendations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecommendationItem_])
    async RecommendationItems_DestinationEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [DestinationEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Recommendation Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryEntity_])
    async QueryEntities_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAccessControlRule_])
    async MJ_AccessControlRules_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Access Control Rules', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAccessControlRules] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Access Control Rules', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Access Control Rules', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordLink_])
    async MJ_RecordLinks_SourceEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordLinks] WHERE [SourceEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_PrimaryScopeEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [PrimaryScopeEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_PrimaryScopeEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [PrimaryScopeEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabel_])
    async MJ_VersionLabels_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabels] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Labels', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelItem_])
    async MJ_VersionLabelItems_EntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelItems] WHERE [EntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async GeneratedCodes_LinkedEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [LinkedEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordLink_])
    async MJ_RecordLinks_TargetEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordLinks] WHERE [TargetEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRun_])
    async MJ_TestRuns_TargetLogEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRuns] WHERE [TargetLogEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_PrimaryScopeEntityIDArray(@Root() mjentity_: MJEntity_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [PrimaryScopeEntityID]='${mjentity_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntity_)
    async CreateMJEntity(
        @Arg('input', () => CreateMJEntityInput) input: CreateMJEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntity_)
    async UpdateMJEntity(
        @Arg('input', () => UpdateMJEntityInput) input: UpdateMJEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntity_)
    async DeleteMJEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Filters
//****************************************************************************
@ObjectType({ description: `Optional use. Maps Action Filters to specific EntityAction instances, specifying execution order and status. This allows for pre-processing before an Action actually is fired off, to check for various state/dirty/value conditions.` })
export class MJEntityActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionFilterID: string;
        
    @Field(() => Int, {description: `Order of filter execution.`}) 
    Sequence: number;
        
    @Field({description: `Status of the entity action filter (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    EntityAction: string;
        
    @Field() 
    ActionFilter: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class CreateMJEntityActionFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class UpdateMJEntityActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Filters
//****************************************************************************
@ObjectType()
export class RunMJEntityActionFilterViewResult {
    @Field(() => [MJEntityActionFilter_])
    Results: MJEntityActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionFilter_)
export class MJEntityActionFilterResolver extends ResolverBase {
    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionFilterViewResult)
    async RunMJEntityActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionFilter_, { nullable: true })
    async MJEntityActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionFilter_ | null> {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Action Filters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityActionFilter_)
    async CreateMJEntityActionFilter(
        @Arg('input', () => CreateMJEntityActionFilterInput) input: CreateMJEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionFilter_)
    async UpdateMJEntityActionFilter(
        @Arg('input', () => UpdateMJEntityActionFilterInput) input: UpdateMJEntityActionFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionFilter_)
    async DeleteMJEntityActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocation Types
//****************************************************************************
@ObjectType({ description: `Stores the possible invocation types of an action within the context of an entity. Examples would be: Record Created/Updated/Deleted/Accessed as well as things like View or List where you could run an EntityAction against an entire set of records in a view or list  either by user click or programmatically.` })
export class MJEntityActionInvocationType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the invocation type such as Record Created/Updated/etc.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the invocation type.`}) 
    Description?: string;
        
    @Field(() => Int, {description: `Order in which this invocation type appears in UI lists and menus.`}) 
    DisplaySequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityActionInvocation_])
    EntityActionInvocations_InvocationTypeIDArray: MJEntityActionInvocation_[]; // Link to EntityActionInvocations
    
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class CreateMJEntityActionInvocationTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInvocationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocation Types
//****************************************************************************
@ObjectType()
export class RunMJEntityActionInvocationTypeViewResult {
    @Field(() => [MJEntityActionInvocationType_])
    Results: MJEntityActionInvocationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionInvocationType_)
export class MJEntityActionInvocationTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationTypeViewResult)
    async RunMJEntityActionInvocationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocation Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionInvocationType_, { nullable: true })
    async MJEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionInvocationType_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocation Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocationTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocation Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Action Invocation Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionInvocation_])
    async EntityActionInvocations_InvocationTypeIDArray(@Root() mjentityactioninvocationtype_: MJEntityActionInvocationType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [InvocationTypeID]='${mjentityactioninvocationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityActionInvocationType_)
    async CreateMJEntityActionInvocationType(
        @Arg('input', () => CreateMJEntityActionInvocationTypeInput) input: CreateMJEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Invocation Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionInvocationType_)
    async UpdateMJEntityActionInvocationType(
        @Arg('input', () => UpdateMJEntityActionInvocationTypeInput) input: UpdateMJEntityActionInvocationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Invocation Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionInvocationType_)
    async DeleteMJEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocation Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocations
//****************************************************************************
@ObjectType({ description: `Links invocation types to entity actions  for example you might link a particular EntityAction to just Create Record and you might also have a second item in this table allowing the same Entity Action to be invoked from a User View or List, on demand.` })
export class MJEntityActionInvocation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    InvocationTypeID: string;
        
    @Field({description: `Status of the entity action invocation (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    EntityAction: string;
        
    @Field() 
    @MaxLength(510)
    InvocationType: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class CreateMJEntityActionInvocationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInvocationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocations
//****************************************************************************
@ObjectType()
export class RunMJEntityActionInvocationViewResult {
    @Field(() => [MJEntityActionInvocation_])
    Results: MJEntityActionInvocation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionInvocation_)
export class MJEntityActionInvocationResolver extends ResolverBase {
    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionInvocationViewResult)
    async RunMJEntityActionInvocationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionInvocation_, { nullable: true })
    async MJEntityActionInvocation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionInvocation_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Action Invocations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityActionInvocation_)
    async CreateMJEntityActionInvocation(
        @Arg('input', () => CreateMJEntityActionInvocationInput) input: CreateMJEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Invocations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionInvocation_)
    async UpdateMJEntityActionInvocation(
        @Arg('input', () => UpdateMJEntityActionInvocationInput) input: UpdateMJEntityActionInvocationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Invocations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionInvocation_)
    async DeleteMJEntityActionInvocation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Params
//****************************************************************************
@ObjectType({ description: `Stores paramater mappings to enable Entity Actions to automatically invoke Actions` })
export class MJEntityActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field({description: `Type of the value, which can be Static, Entity Object, or Script.`}) 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true, description: `Value of the parameter, used only when ValueType is Static or Script. When value is Script, any valid JavaScript code can be provided. The script will have access to an object called EntityActionContext. This object will have a property called EntityObject on it that will contain the BaseEntity derived sub-class with the current data for the entity object this action is operating against. The script must provide the parameter value to the EntityActionContext.result property. This scripting capabilty is designed for very small and simple code, for anything of meaningful complexity, create a sub-class instead.`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Additional comments regarding the parameter.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    EntityAction: string;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class CreateMJEntityActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class UpdateMJEntityActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Params
//****************************************************************************
@ObjectType()
export class RunMJEntityActionParamViewResult {
    @Field(() => [MJEntityActionParam_])
    Results: MJEntityActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityActionParam_)
export class MJEntityActionParamResolver extends ResolverBase {
    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionParamViewResult)
    async RunMJEntityActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityActionParam_, { nullable: true })
    async MJEntityActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityActionParam_ | null> {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Action Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityActionParam_)
    async CreateMJEntityActionParam(
        @Arg('input', () => CreateMJEntityActionParamInput) input: CreateMJEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityActionParam_)
    async UpdateMJEntityActionParam(
        @Arg('input', () => UpdateMJEntityActionParamInput) input: UpdateMJEntityActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityActionParam_)
    async DeleteMJEntityActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Actions
//****************************************************************************
@ObjectType({ description: `Links entities to actions - this is the main place where you define the actions that part of, or available, for a given entity.` })
export class MJEntityAction_ {
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Status of the entity action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [MJEntityActionInvocation_])
    EntityActionInvocations_EntityActionIDArray: MJEntityActionInvocation_[]; // Link to EntityActionInvocations
    
    @Field(() => [MJEntityActionFilter_])
    EntityActionFilters_EntityActionIDArray: MJEntityActionFilter_[]; // Link to EntityActionFilters
    
    @Field(() => [MJEntityActionParam_])
    EntityActionParams_EntityActionIDArray: MJEntityActionParam_[]; // Link to EntityActionParams
    
}

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class CreateMJEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class UpdateMJEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Actions
//****************************************************************************
@ObjectType()
export class RunMJEntityActionViewResult {
    @Field(() => [MJEntityAction_])
    Results: MJEntityAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityAction_)
export class MJEntityActionResolver extends ResolverBase {
    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityActionViewResult)
    async RunMJEntityActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityAction_, { nullable: true })
    async MJEntityAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityAction_ | null> {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityActionInvocation_])
    async EntityActionInvocations_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [EntityActionID]='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityActionFilter_])
    async EntityActionFilters_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [EntityActionID]='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityActionParam_])
    async EntityActionParams_EntityActionIDArray(@Root() mjentityaction_: MJEntityAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [EntityActionID]='${mjentityaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityAction_)
    async CreateMJEntityAction(
        @Arg('input', () => CreateMJEntityActionInput) input: CreateMJEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityAction_)
    async UpdateMJEntityAction(
        @Arg('input', () => UpdateMJEntityActionInput) input: UpdateMJEntityActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityAction_)
    async DeleteMJEntityAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity AI Actions
//****************************************************************************
@ObjectType({ description: `Tracks the AI actions that should be invoked based on changes to records within a given entity.` })
export class MJEntityAIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `The AI prompt template used when this action is triggered by entity changes.`}) 
    Prompt?: string;
        
    @Field({description: `The entity event that triggers this AI action (After Save, Before Delete, etc.).`}) 
    @MaxLength(30)
    TriggerEvent: string;
        
    @Field({description: `Message shown to users when this AI action is executed.`}) 
    UserMessage: string;
        
    @Field({description: `Where the AI output should be stored (Field, Message, File).`}) 
    @MaxLength(20)
    OutputType: string;
        
    @Field({nullable: true, description: `The field name where AI output should be stored if OutputType is Field.`}) 
    @MaxLength(100)
    OutputField?: string;
        
    @Field(() => Boolean, {description: `Whether to skip AI processing if the output field already contains data.`}) 
    SkipIfOutputFieldNotEmpty: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputEntityID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class CreateMJEntityAIActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class UpdateMJEntityAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField?: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity AI Actions
//****************************************************************************
@ObjectType()
export class RunMJEntityAIActionViewResult {
    @Field(() => [MJEntityAIAction_])
    Results: MJEntityAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityAIAction_)
export class MJEntityAIActionResolver extends ResolverBase {
    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityAIActionViewResult)
    async RunMJEntityAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity AI Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityAIAction_, { nullable: true })
    async MJEntityAIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityAIAction_ | null> {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity AI Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityAIAction_])
    async AllEntityAIActions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions]` + this.getRowLevelSecurityWhereClause(provider, 'Entity AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityAIAction_)
    async CreateMJEntityAIAction(
        @Arg('input', () => CreateMJEntityAIActionInput) input: CreateMJEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity AI Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityAIAction_)
    async UpdateMJEntityAIAction(
        @Arg('input', () => UpdateMJEntityAIActionInput) input: UpdateMJEntityAIActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity AI Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityAIAction_)
    async DeleteMJEntityAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity AI Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Fields
//****************************************************************************
@ObjectType({ description: `Mapping between entity fields and communication base message types with priority` })
export class MJEntityCommunicationField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityCommunicationMessageTypeID: string;
        
    @Field({description: `Name of the field in the entity that maps to the communication base message type`}) 
    @MaxLength(1000)
    FieldName: string;
        
    @Field(() => Int, {description: `Priority of the field for the communication base message type`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    EntityCommunicationMessageType: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class CreateMJEntityCommunicationFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class UpdateMJEntityCommunicationFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Fields
//****************************************************************************
@ObjectType()
export class RunMJEntityCommunicationFieldViewResult {
    @Field(() => [MJEntityCommunicationField_])
    Results: MJEntityCommunicationField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityCommunicationField_)
export class MJEntityCommunicationFieldResolver extends ResolverBase {
    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationFieldViewResult)
    async RunMJEntityCommunicationFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityCommunicationField_, { nullable: true })
    async MJEntityCommunicationField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityCommunicationField_ | null> {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Communication Fields', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityCommunicationField_)
    async CreateMJEntityCommunicationField(
        @Arg('input', () => CreateMJEntityCommunicationFieldInput) input: CreateMJEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Communication Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityCommunicationField_)
    async UpdateMJEntityCommunicationField(
        @Arg('input', () => UpdateMJEntityCommunicationFieldInput) input: UpdateMJEntityCommunicationFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Communication Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityCommunicationField_)
    async DeleteMJEntityCommunicationField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Message Types
//****************************************************************************
@ObjectType({ description: `Mapping between entities and communication base message types` })
export class MJEntityCommunicationMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    BaseMessageTypeID: string;
        
    @Field(() => Boolean, {description: `Indicates whether the message type is active`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    BaseMessageType: string;
        
    @Field(() => [MJEntityCommunicationField_])
    EntityCommunicationFields_EntityCommunicationMessageTypeIDArray: MJEntityCommunicationField_[]; // Link to EntityCommunicationFields
    
}

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class CreateMJEntityCommunicationMessageTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class UpdateMJEntityCommunicationMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Message Types
//****************************************************************************
@ObjectType()
export class RunMJEntityCommunicationMessageTypeViewResult {
    @Field(() => [MJEntityCommunicationMessageType_])
    Results: MJEntityCommunicationMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityCommunicationMessageType_)
export class MJEntityCommunicationMessageTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityCommunicationMessageTypeViewResult)
    async RunMJEntityCommunicationMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Message Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityCommunicationMessageType_, { nullable: true })
    async MJEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityCommunicationMessageType_ | null> {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Communication Message Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityCommunicationField_])
    async EntityCommunicationFields_EntityCommunicationMessageTypeIDArray(@Root() mjentitycommunicationmessagetype_: MJEntityCommunicationMessageType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [EntityCommunicationMessageTypeID]='${mjentitycommunicationmessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Communication Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityCommunicationMessageType_)
    async CreateMJEntityCommunicationMessageType(
        @Arg('input', () => CreateMJEntityCommunicationMessageTypeInput) input: CreateMJEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Communication Message Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityCommunicationMessageType_)
    async UpdateMJEntityCommunicationMessageType(
        @Arg('input', () => UpdateMJEntityCommunicationMessageTypeInput) input: UpdateMJEntityCommunicationMessageTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Communication Message Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityCommunicationMessageType_)
    async DeleteMJEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Message Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Runs
//****************************************************************************
@ObjectType({ description: `Records execution history of document generation processes for entity records, tracking status, timing, and output details.` })
export class MJEntityDocumentRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Can be Pending, In Progress, Completed, or Failed`}) 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Runs
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentRunViewResult {
    @Field(() => [MJEntityDocumentRun_])
    Results: MJEntityDocumentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentRun_)
export class MJEntityDocumentRunResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentRunViewResult)
    async RunMJEntityDocumentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentRun_, { nullable: true })
    async MJEntityDocumentRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentRun_ | null> {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Document Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityDocumentRun_)
    async CreateMJEntityDocumentRun(
        @Arg('input', () => CreateMJEntityDocumentRunInput) input: CreateMJEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentRun_)
    async UpdateMJEntityDocumentRun(
        @Arg('input', () => UpdateMJEntityDocumentRunInput) input: UpdateMJEntityDocumentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentRun_)
    async DeleteMJEntityDocumentRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Settings
//****************************************************************************
@ObjectType({ description: `Stores configuration for entity-specific document generation.` })
export class MJEntityDocumentSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `JSON configuration value for this document generation setting.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Settings
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentSettingViewResult {
    @Field(() => [MJEntityDocumentSetting_])
    Results: MJEntityDocumentSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentSetting_)
export class MJEntityDocumentSettingResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentSettingViewResult)
    async RunMJEntityDocumentSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentSetting_, { nullable: true })
    async MJEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentSetting_ | null> {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Document Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityDocumentSetting_)
    async CreateMJEntityDocumentSetting(
        @Arg('input', () => CreateMJEntityDocumentSettingInput) input: CreateMJEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentSetting_)
    async UpdateMJEntityDocumentSetting(
        @Arg('input', () => UpdateMJEntityDocumentSettingInput) input: UpdateMJEntityDocumentSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentSetting_)
    async DeleteMJEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Types
//****************************************************************************
@ObjectType({ description: `Defines types of documents that can be generated from entity data.` })
export class MJEntityDocumentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityDocument_])
    EntityDocuments_TypeIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Types
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentTypeViewResult {
    @Field(() => [MJEntityDocumentType_])
    Results: MJEntityDocumentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocumentType_)
export class MJEntityDocumentTypeResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentTypeViewResult)
    async RunMJEntityDocumentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocumentType_, { nullable: true })
    async MJEntityDocumentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocumentType_ | null> {
        this.CheckUserReadPermissions('Entity Document Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Document Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_TypeIDArray(@Root() mjentitydocumenttype_: MJEntityDocumentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TypeID]='${mjentitydocumenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityDocumentType_)
    async CreateMJEntityDocumentType(
        @Arg('input', () => CreateMJEntityDocumentTypeInput) input: CreateMJEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Document Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocumentType_)
    async UpdateMJEntityDocumentType(
        @Arg('input', () => UpdateMJEntityDocumentTypeInput) input: UpdateMJEntityDocumentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Document Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocumentType_)
    async DeleteMJEntityDocumentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Documents
//****************************************************************************
@ObjectType({ description: `Stores templates for converting structured entity data into unstructured documents.` })
export class MJEntityDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(500)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered a potential matching record. Value must be <= AbsoluteMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    PotentialMatchThreshold: number;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered an absolute matching record. Value must be >= PotentialMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    AbsoluteMatchThreshold: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [MJEntityDocumentRun_])
    EntityDocumentRuns_EntityDocumentIDArray: MJEntityDocumentRun_[]; // Link to EntityDocumentRuns
    
    @Field(() => [MJEntityDocumentSetting_])
    EntityDocumentSettings_EntityDocumentIDArray: MJEntityDocumentSetting_[]; // Link to EntityDocumentSettings
    
    @Field(() => [MJEntityRecordDocument_])
    EntityRecordDocuments_EntityDocumentIDArray: MJEntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class CreateMJEntityDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class UpdateMJEntityDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Documents
//****************************************************************************
@ObjectType()
export class RunMJEntityDocumentViewResult {
    @Field(() => [MJEntityDocument_])
    Results: MJEntityDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityDocument_)
export class MJEntityDocumentResolver extends ResolverBase {
    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityDocumentViewResult)
    async RunMJEntityDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityDocument_, { nullable: true })
    async MJEntityDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityDocument_ | null> {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Documents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityDocumentRun_])
    async EntityDocumentRuns_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [EntityDocumentID]='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Document Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocumentSetting_])
    async EntityDocumentSettings_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [EntityDocumentID]='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Document Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityRecordDocument_])
    async EntityRecordDocuments_EntityDocumentIDArray(@Root() mjentitydocument_: MJEntityDocument_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityDocumentID]='${mjentitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityDocument_)
    async CreateMJEntityDocument(
        @Arg('input', () => CreateMJEntityDocumentInput) input: CreateMJEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityDocument_)
    async UpdateMJEntityDocument(
        @Arg('input', () => UpdateMJEntityDocumentInput) input: UpdateMJEntityDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Documents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityDocument_)
    async DeleteMJEntityDocument(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Documents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Field Values
//****************************************************************************
@ObjectType({ description: `Defines allowed values for entity fields with value lists, supporting dropdowns, validations, and data integrity constraints. MJ CodeGen automatically maintains this for columns that have CHECK constraints with IN lists such as "Status IN (A, B, C)"` })
export class MJEntityFieldValue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityFieldID: string;
        
    @Field(() => Int, {description: `Display order for this value in dropdown lists and UI elements.`}) 
    Sequence: number;
        
    @Field({description: `The actual value stored in the database for this option.`}) 
    @MaxLength(510)
    Value: string;
        
    @Field({nullable: true, description: `Optional code identifier for this value, useful for programmatic access. If not specified, same as Value`}) 
    @MaxLength(100)
    Code?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    EntityField: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Field Values
//****************************************************************************
@InputType()
export class CreateMJEntityFieldValueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Field Values
//****************************************************************************
@InputType()
export class UpdateMJEntityFieldValueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Field Values
//****************************************************************************
@ObjectType()
export class RunMJEntityFieldValueViewResult {
    @Field(() => [MJEntityFieldValue_])
    Results: MJEntityFieldValue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityFieldValue_)
export class MJEntityFieldValueResolver extends ResolverBase {
    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldValueViewResult)
    async RunMJEntityFieldValueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Field Values';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityFieldValue_, { nullable: true })
    async MJEntityFieldValue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityFieldValue_ | null> {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Field Values', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityFieldValue_])
    async AllEntityFieldValues(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Field Values', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityFieldValue_)
    async CreateMJEntityFieldValue(
        @Arg('input', () => CreateMJEntityFieldValueInput) input: CreateMJEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Field Values', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityFieldValue_)
    async UpdateMJEntityFieldValue(
        @Arg('input', () => UpdateMJEntityFieldValueInput) input: UpdateMJEntityFieldValueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Field Values', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityFieldValue_)
    async DeleteMJEntityFieldValue(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Field Values', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Fields
//****************************************************************************
@ObjectType({ description: `List of all fields within each entity with metadata about each field` })
export class MJEntityField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of the field within the entity`}) 
    Sequence: number;
        
    @Field({description: `Name of the field within the database table`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `A user friendly alternative to the field name`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Descriptive text explaining the purpose of the field`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the column within the underlying view (first choice) or table (second choice), the Description column in the entity field definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity field definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field is part of the primary key for the entity (auto maintained by CodeGen)`}) 
    IsPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field must have unique values within the entity.`}) 
    IsUnique: boolean;
        
    @Field({nullable: true, description: `Used for generating custom tabs in the generated forms, only utilized if GeneratedFormSection=Category`}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({description: `SQL Data type (auto maintained by CodeGen)`}) 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `SQL data length (auto maintained by CodeGen)`}) 
    Length?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL precision (auto maintained by CodeGen)`}) 
    Precision?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL scale (auto maintained by CodeGen)`}) 
    Scale?: number;
        
    @Field(() => Boolean, {description: `Does the column allow null or not (auto maintained by CodeGen)`}) 
    AllowsNull: boolean;
        
    @Field({nullable: true, description: `If a default value is defined for the field it is stored here (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `If this field automatically increments within the table, this field is set to 1 (auto maintained by CodeGen)`}) 
    AutoIncrement: boolean;
        
    @Field({description: `Possible Values of None, List, ListOrUserEntry - the last option meaning that the list of possible values are options, but a user can enter anything else desired too.`}) 
    @MaxLength(40)
    ValueListType: string;
        
    @Field({nullable: true, description: `Defines extended behaviors for a field such as for Email, Web URLs, Code, etc.`}) 
    @MaxLength(100)
    ExtendedType?: string;
        
    @Field({nullable: true, description: `The type of code associated with this field. Only used when the ExtendedType field is set to "Code"`}) 
    @MaxLength(100)
    CodeType?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included by default in any new view created by a user.`}) 
    DefaultInView: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    ViewCellTemplate?: string;
        
    @Field(() => Int, {nullable: true, description: `Determines the default width for this field when included in a view`}) 
    DefaultColumnWidth?: number;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be considered updateable by the API and object model. For this field to have effect, the column type must be updateable (e.g. not part of the primary key and not auto-increment)`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, and if AllowUpdateAPI=1, the field can be edited within a view when the view is in edit mode.`}) 
    AllowUpdateInView: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be included in user search queries for both traditional and full text search`}) 
    IncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, CodeGen will automatically generate a Full Text Catalog/Index in the database and include this field in the search index.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    @MaxLength(1000)
    UserSearchParamFormatAPI?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included in the generated form by CodeGen. If set to 0, this field will be excluded from the generated form. For custom forms, this field has no effect as the layout is controlled independently.`}) 
    IncludeInGeneratedForm: boolean;
        
    @Field({description: `When set to Top, the field will be placed in a "top area" on the top of a generated form and visible regardless of which tab is displayed. When set to "category" Options: Top, Category, Details`}) 
    @MaxLength(20)
    GeneratedFormSection: string;
        
    @Field(() => Boolean, {description: `NULL`}) 
    IsVirtual: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be used as the "Name" field for the entity and will be used to display the name of the record in various places in the UI.`}) 
    IsNameField: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RelatedEntityID?: string;
        
    @Field({nullable: true, description: `Name of the field in the Related Entity that this field links to (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    RelatedEntityFieldName?: string;
        
    @Field(() => Boolean, {description: `If set to 1, the "Name" field of the Related Entity will be included in this entity as a virtual field`}) 
    IncludeRelatedEntityNameFieldInBaseView: boolean;
        
    @Field({nullable: true, description: `For foreign key fields, maps which field in the related entity contains the display name. This is used by CodeGen to automatically add in virtual fields for the "Name Field" of the related entity.`}) 
    @MaxLength(510)
    RelatedEntityNameFieldMap?: string;
        
    @Field({description: `Controls the generated form in the MJ Explorer UI - defaults to a search box, other option is a drop down. Possible values are Search and Dropdown`}) 
    @MaxLength(40)
    RelatedEntityDisplayType: string;
        
    @Field({nullable: true, description: `Optional, used for "Soft Keys" to link records to different entity/record combinations on a per-record basis (for example the FileEntityRecordLink table has an EntityID/RecordID field pair. For that entity, the RecordID specifies "EntityID" for this field. This information allows MJ to detect soft keys/links for dependency detection, merging and for preventing orphaned soft-linked records during delete operations.`}) 
    @MaxLength(200)
    EntityIDFieldName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `A comma-delimited string indicating the default scope for field visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for a simple method of filtering field defaults for visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the related entity information should be automatically updated from the database schema. When set to 0, relationships not part of the database schema can be manually defined at the application and AI agent level. Defaults to 1.`}) 
    AutoUpdateRelatedEntityInfo: boolean;
        
    @Field({description: `Determines whether values for the field should be included when the schema is packed. Options: Auto (include manually set or auto-derived values), None (exclude all values), All (include all distinct values from the table). Defaults to Auto.`}) 
    @MaxLength(20)
    ValuesToPackWithSchema: string;
        
    @Field({description: `Current status of the entity field - Active fields are available for use, Deprecated fields are discouraged but still functional, Disabled fields are not available for use`}) 
    @MaxLength(50)
    Status: string;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update IsNameField; when 0, user has locked this field`}) 
    AutoUpdateIsNameField: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update DefaultInView; when 0, user has locked this field`}) 
    AutoUpdateDefaultInView: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update Category; when 0, user has locked this field`}) 
    AutoUpdateCategory: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update DisplayName during CodeGen; when 0, user has locked this field`}) 
    AutoUpdateDisplayName: boolean;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update IncludeInUserSearchAPI during CodeGen; when 0, user has locked this field`}) 
    AutoUpdateIncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `When true, this field will be encrypted at rest using the specified EncryptionKeyID. Encrypted fields cannot be indexed or searched.`}) 
    Encrypt: boolean;
        
    @Field({nullable: true, description: `References the encryption key to use when Encrypt is true. Required if Encrypt is true.`}) 
    @MaxLength(16)
    EncryptionKeyID?: string;
        
    @Field(() => Boolean, {description: `When true, encrypted fields will be decrypted before returning via API. When false, behavior depends on SendEncryptedValue. Default is false (secure).`}) 
    AllowDecryptInAPI: boolean;
        
    @Field(() => Boolean, {description: `When AllowDecryptInAPI is false: if true, send encrypted ciphertext (e.g., $ENC$...); if false (default), send sentinel value, usually "[!ENCRYPTED$]", indicating a value exists but is protected. Most secure option is false.`}) 
    SendEncryptedValue: boolean;
        
    @Field(() => Boolean, {description: `When 1, indicates IsPrimaryKey was set via metadata (not a database constraint). Protects IsPrimaryKey from being cleared by schema sync.`}) 
    IsSoftPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `When 1, indicates RelatedEntityID/RelatedEntityFieldName were set via metadata (not a database constraint). Protects these fields from being cleared by schema sync.`}) 
    IsSoftForeignKey: boolean;
        
    @Field({nullable: true, description: `JSON configuration for additional fields to join from the related entity into this entity's base view. Supports modes: extend (add to NameField), override (replace NameField), disable (no joins). Schema: { mode?: string, fields?: [{ field: string, alias?: string }] }`}) 
    RelatedEntityJoinFields?: string;
        
    @Field({nullable: true}) 
    FieldCodeName?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    SchemaName: string;
        
    @Field() 
    @MaxLength(510)
    BaseTable: string;
        
    @Field() 
    @MaxLength(510)
    BaseView: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntitySchemaName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseView?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field(() => [MJEntityFieldValue_])
    EntityFieldValues_EntityFieldIDArray: MJEntityFieldValue_[]; // Link to EntityFieldValues
    
}

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class CreateMJEntityFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType: string | null;

    @Field({ nullable: true })
    CodeType: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIsNameField?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDefaultInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateCategory?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDisplayName?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    Encrypt?: boolean;

    @Field({ nullable: true })
    EncryptionKeyID: string | null;

    @Field(() => Boolean, { nullable: true })
    AllowDecryptInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    SendEncryptedValue?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftForeignKey?: boolean;

    @Field({ nullable: true })
    RelatedEntityJoinFields: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class UpdateMJEntityFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType?: string | null;

    @Field({ nullable: true })
    CodeType?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth?: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID?: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap?: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIsNameField?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDefaultInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateCategory?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDisplayName?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateIncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    Encrypt?: boolean;

    @Field({ nullable: true })
    EncryptionKeyID?: string | null;

    @Field(() => Boolean, { nullable: true })
    AllowDecryptInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    SendEncryptedValue?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsSoftForeignKey?: boolean;

    @Field({ nullable: true })
    RelatedEntityJoinFields?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Fields
//****************************************************************************
@ObjectType()
export class RunMJEntityFieldViewResult {
    @Field(() => [MJEntityField_])
    Results: MJEntityField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityField_)
export class MJEntityFieldResolver extends ResolverBase {
    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityFieldViewResult)
    async RunMJEntityFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityField_, { nullable: true })
    async MJEntityField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityField_ | null> {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Fields', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityField_])
    async AllEntityFields(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityFieldValue_])
    async EntityFieldValues_EntityFieldIDArray(@Root() mjentityfield_: MJEntityField_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [EntityFieldID]='${mjentityfield_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Field Values', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityField_)
    async CreateMJEntityField(
        @Arg('input', () => CreateMJEntityFieldInput) input: CreateMJEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityField_)
    async UpdateMJEntityField(
        @Arg('input', () => UpdateMJEntityFieldInput) input: UpdateMJEntityFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityField_)
    async DeleteMJEntityField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Permissions
//****************************************************************************
@ObjectType({ description: `Security settings for each entity` })
export class MJEntityPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field(() => Boolean, {description: `Whether the role/user can create new records in this entity.`}) 
    CanCreate: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can read/view records in this entity.`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can update existing records in this entity.`}) 
    CanUpdate: boolean;
        
    @Field(() => Boolean, {description: `Whether the role/user can delete records from this entity.`}) 
    CanDelete: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReadRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CreateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UpdateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DeleteRLSFilterID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    RoleName: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    RoleSQLName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CreateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ReadRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UpdateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DeleteRLSFilter?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class CreateMJEntityPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class UpdateMJEntityPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID?: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID?: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID?: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Permissions
//****************************************************************************
@ObjectType()
export class RunMJEntityPermissionViewResult {
    @Field(() => [MJEntityPermission_])
    Results: MJEntityPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityPermission_)
export class MJEntityPermissionResolver extends ResolverBase {
    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityPermissionViewResult)
    async RunMJEntityPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityPermission_, { nullable: true })
    async MJEntityPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityPermission_ | null> {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityPermission_])
    async AllEntityPermissions(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityPermission_)
    async CreateMJEntityPermission(
        @Arg('input', () => CreateMJEntityPermissionInput) input: CreateMJEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityPermission_)
    async UpdateMJEntityPermission(
        @Arg('input', () => UpdateMJEntityPermissionInput) input: UpdateMJEntityPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityPermission_)
    async DeleteMJEntityPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Record Documents
//****************************************************************************
@ObjectType({ description: `Stores the output for a given entity record for a specific Entity Document. For example if a "Person" entity had a particular template that outputted First and Last name like "#{{FirstName}}\n#{{LastName}}" the Entity Record Document would have a row for each entity record in the Person entity that was run through that particular document and have row values such as "#Jane\n#Doe" and "#Mark\n#Smith".` })
export class MJEntityRecordDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the entity record this document was generated for.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true, description: `The generated document text after template processing.`}) 
    DocumentText?: string;
        
    @Field() 
    @MaxLength(16)
    VectorIndexID: string;
        
    @Field({nullable: true, description: `Reference to the vector embedding of this document if AI search is enabled.`}) 
    @MaxLength(100)
    VectorID?: string;
        
    @Field({nullable: true, description: `JSON representation of the vector embedding for this document.`}) 
    VectorJSON?: string;
        
    @Field({description: `Timestamp of when the source entity record was last updated.`}) 
    @MaxLength(10)
    EntityRecordUpdatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
    @Field() 
    @MaxLength(510)
    VectorIndex: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class CreateMJEntityRecordDocumentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID: string | null;

    @Field({ nullable: true })
    VectorJSON: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class UpdateMJEntityRecordDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText?: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID?: string | null;

    @Field({ nullable: true })
    VectorJSON?: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Record Documents
//****************************************************************************
@ObjectType()
export class RunMJEntityRecordDocumentViewResult {
    @Field(() => [MJEntityRecordDocument_])
    Results: MJEntityRecordDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRecordDocument_)
export class MJEntityRecordDocumentResolver extends ResolverBase {
    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRecordDocumentViewResult)
    async RunMJEntityRecordDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Record Documents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRecordDocument_, { nullable: true })
    async MJEntityRecordDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRecordDocument_ | null> {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Record Documents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityRecordDocument_)
    async CreateMJEntityRecordDocument(
        @Arg('input', () => CreateMJEntityRecordDocumentInput) input: CreateMJEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Record Documents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRecordDocument_)
    async UpdateMJEntityRecordDocument(
        @Arg('input', () => UpdateMJEntityRecordDocumentInput) input: UpdateMJEntityRecordDocumentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Record Documents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRecordDocument_)
    async DeleteMJEntityRecordDocument(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Record Documents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationship Display Components
//****************************************************************************
@ObjectType({ description: `This table stores a list of components that are available for displaying relationships in the MJ Explorer UI` })
export class MJEntityRelationshipDisplayComponent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type of relationship the component displays. Valid values are "One to Many", "Many to Many", or "Both".`}) 
    @MaxLength(40)
    RelationshipType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityRelationship_])
    EntityRelationships_DisplayComponentIDArray: MJEntityRelationship_[]; // Link to EntityRelationships
    
}

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class CreateMJEntityRelationshipDisplayComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class UpdateMJEntityRelationshipDisplayComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationship Display Components
//****************************************************************************
@ObjectType()
export class RunMJEntityRelationshipDisplayComponentViewResult {
    @Field(() => [MJEntityRelationshipDisplayComponent_])
    Results: MJEntityRelationshipDisplayComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRelationshipDisplayComponent_)
export class MJEntityRelationshipDisplayComponentResolver extends ResolverBase {
    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipDisplayComponentViewResult)
    async RunMJEntityRelationshipDisplayComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationship Display Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRelationshipDisplayComponent_, { nullable: true })
    async MJEntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRelationshipDisplayComponent_ | null> {
        this.CheckUserReadPermissions('Entity Relationship Display Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationshipDisplayComponents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationship Display Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Relationship Display Components', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityRelationship_])
    async EntityRelationships_DisplayComponentIDArray(@Root() mjentityrelationshipdisplaycomponent_: MJEntityRelationshipDisplayComponent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayComponentID]='${mjentityrelationshipdisplaycomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async CreateMJEntityRelationshipDisplayComponent(
        @Arg('input', () => CreateMJEntityRelationshipDisplayComponentInput) input: CreateMJEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Relationship Display Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async UpdateMJEntityRelationshipDisplayComponent(
        @Arg('input', () => UpdateMJEntityRelationshipDisplayComponentInput) input: UpdateMJEntityRelationshipDisplayComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Relationship Display Components', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRelationshipDisplayComponent_)
    async DeleteMJEntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Relationship Display Components', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationships
//****************************************************************************
@ObjectType({ description: `Metadata about relationships between entities including display preferences for the UI` })
export class MJEntityRelationship_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Used for display order in generated forms and in other places in the UI where relationships for an entity are shown`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    RelatedEntityID: string;
        
    @Field(() => Boolean, {description: `Whether to include related records when fetching the parent entity via API.`}) 
    BundleInAPI: boolean;
        
    @Field(() => Boolean, {description: `Whether to include this relationship when querying all fields of the parent entity.`}) 
    IncludeInParentAllQuery: boolean;
        
    @Field({description: `The cardinality of the relationship (One To Many, Many To Many, One To One).`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `The primary key field of the parent entity in this relationship.`}) 
    @MaxLength(510)
    EntityKeyField?: string;
        
    @Field({description: `The foreign key field in the related entity that references the parent.`}) 
    @MaxLength(510)
    RelatedEntityJoinField: string;
        
    @Field({nullable: true, description: `For many-to-many relationships, the view containing the junction data.`}) 
    @MaxLength(510)
    JoinView?: string;
        
    @Field({nullable: true, description: `For many-to-many, the field in the junction table linking to the parent entity.`}) 
    @MaxLength(510)
    JoinEntityJoinField?: string;
        
    @Field({nullable: true, description: `For many-to-many, the field in the junction table linking to the related entity.`}) 
    @MaxLength(510)
    JoinEntityInverseJoinField?: string;
        
    @Field(() => Boolean, {description: `When unchecked the relationship will NOT be displayed on the generated form`}) 
    DisplayInForm: boolean;
        
    @Field({description: `Where to display this relationship in the UI relative to other entity elements.`}) 
    @MaxLength(100)
    DisplayLocation: string;
        
    @Field({nullable: true, description: `Optional, when specified this value overrides the related entity name for the label on the tab`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({description: `When Related Entity Icon - uses the icon from the related entity, if one exists. When Custom, uses the value in the DisplayIcon field in this record, and when None, no icon is displayed`}) 
    @MaxLength(100)
    DisplayIconType: string;
        
    @Field({nullable: true, description: `If specified, the icon `}) 
    @MaxLength(510)
    DisplayIcon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayUserViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayComponentID?: string;
        
    @Field({nullable: true, description: `If DisplayComponentID is specified, this field can optionally be used to track component-specific and relationship-specific configuration details that will be used by CodeGen to provide to the display component selected.`}) 
    DisplayComponentConfiguration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this relationship should be automatically updated by CodeGen. When set to 0, the record will not be modified by CodeGen. Defaults to 1.`}) 
    AutoUpdateFromSchema: boolean;
        
    @Field({nullable: true, description: `JSON array of additional field names to include when joining through this relationship (for junction tables, e.g., ["RoleName", "UserEmail"])`}) 
    AdditionalFieldsToInclude?: string;
        
    @Field(() => Boolean, {description: `When 1, allows system/LLM to auto-update AdditionalFieldsToInclude; when 0, user has locked this field`}) 
    AutoUpdateAdditionalFieldsToInclude: boolean;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntity: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseView: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityBaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DisplayUserViewName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class CreateMJEntityRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon: string | null;

    @Field({ nullable: true })
    DisplayComponentID: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field({ nullable: true })
    AdditionalFieldsToInclude: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateAdditionalFieldsToInclude?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class UpdateMJEntityRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField?: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView?: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField?: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField?: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon?: string | null;

    @Field({ nullable: true })
    DisplayComponentID?: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field({ nullable: true })
    AdditionalFieldsToInclude?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateAdditionalFieldsToInclude?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationships
//****************************************************************************
@ObjectType()
export class RunMJEntityRelationshipViewResult {
    @Field(() => [MJEntityRelationship_])
    Results: MJEntityRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntityRelationship_)
export class MJEntityRelationshipResolver extends ResolverBase {
    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntityRelationshipViewResult)
    async RunMJEntityRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntityRelationship_, { nullable: true })
    async MJEntityRelationship(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntityRelationship_ | null> {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Relationships', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJEntityRelationship_])
    async AllEntityRelationships(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships]` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntityRelationship_)
    async CreateMJEntityRelationship(
        @Arg('input', () => CreateMJEntityRelationshipInput) input: CreateMJEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntityRelationship_)
    async UpdateMJEntityRelationship(
        @Arg('input', () => UpdateMJEntityRelationshipInput) input: UpdateMJEntityRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntityRelationship_)
    async DeleteMJEntityRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Settings
//****************************************************************************
@ObjectType({ description: `Stores entity-specific configuration settings, allowing customization of how entities function.` })
export class MJEntitySetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The configuration value for this entity setting, often in JSON format.`}) 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class CreateMJEntitySettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class UpdateMJEntitySettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Settings
//****************************************************************************
@ObjectType()
export class RunMJEntitySettingViewResult {
    @Field(() => [MJEntitySetting_])
    Results: MJEntitySetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEntitySetting_)
export class MJEntitySettingResolver extends ResolverBase {
    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEntitySettingViewResult)
    async RunMJEntitySettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEntitySetting_, { nullable: true })
    async MJEntitySetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEntitySetting_ | null> {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Entity Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJEntitySetting_)
    async CreateMJEntitySetting(
        @Arg('input', () => CreateMJEntitySettingInput) input: CreateMJEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Entity Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEntitySetting_)
    async UpdateMJEntitySetting(
        @Arg('input', () => UpdateMJEntitySettingInput) input: UpdateMJEntitySettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Entity Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEntitySetting_)
    async DeleteMJEntitySetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Error Logs
//****************************************************************************
@ObjectType({ description: `Captures system errors, exceptions, and failures with stack traces, context, and debugging info.` })
export class MJErrorLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunDetailID?: string;
        
    @Field({nullable: true, description: `Error code for categorizing and handling specific error types.`}) 
    @MaxLength(40)
    Code?: string;
        
    @Field({nullable: true, description: `The primary error message describing what went wrong.`}) 
    Message?: string;
        
    @Field({nullable: true, description: `User or system process that encountered this error.`}) 
    @MaxLength(100)
    CreatedBy?: string;
        
    @Field({nullable: true}) 
    @MaxLength(20)
    Status?: string;
        
    @Field({nullable: true, description: `High-level category for grouping related errors (Database, API, Validation, etc.).`}) 
    @MaxLength(40)
    Category?: string;
        
    @Field({nullable: true, description: `Full error details including stack trace, inner exceptions, and context data.`}) 
    Details?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CompanyIntegrationRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(900)
    CompanyIntegrationRunDetail?: string;
        
}

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class CreateMJErrorLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    Details: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class UpdateMJErrorLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Error Logs
//****************************************************************************
@ObjectType()
export class RunMJErrorLogViewResult {
    @Field(() => [MJErrorLog_])
    Results: MJErrorLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJErrorLog_)
export class MJErrorLogResolver extends ResolverBase {
    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJErrorLogViewResult)
    async RunMJErrorLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Error Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJErrorLog_, { nullable: true })
    async MJErrorLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJErrorLog_ | null> {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Error Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJErrorLog_)
    async CreateMJErrorLog(
        @Arg('input', () => CreateMJErrorLogInput) input: CreateMJErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Error Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJErrorLog_)
    async UpdateMJErrorLog(
        @Arg('input', () => UpdateMJErrorLogInput) input: UpdateMJErrorLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Error Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJErrorLog_)
    async DeleteMJErrorLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Error Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Explorer Navigation Items
//****************************************************************************
@ObjectType({ description: `Table to store navigation items for MemberJunction Explorer` })
export class MJExplorerNavigationItem_ {
    @Field({description: `Unique identifier for each navigation item`}) 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int, {description: `Sequence number for the navigation item, must be unique and greater than 0`}) 
    Sequence: number;
        
    @Field({description: `Unique name of the navigation item displayed to the user`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The route for the navigation item relative to the app main URL, using Angular syntax like "entity/:entityName"`}) 
    @MaxLength(510)
    Route: string;
        
    @Field(() => Boolean, {description: `Indicates if the navigation item is active; allows turning off items in the UI without deleting them from the metadata`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `Controls if the navigation item is shown on the Home screen for MJ Explorer`}) 
    ShowInHomeScreen: boolean;
        
    @Field(() => Boolean, {description: `Controls if the item is shown in the left navigation drawer in the MJ Explorer app or not.`}) 
    ShowInNavigationDrawer: boolean;
        
    @Field({nullable: true, description: `Optional, CSS class for an icon to be displayed with the navigation item`}) 
    @MaxLength(200)
    IconCSSClass?: string;
        
    @Field({nullable: true, description: `Description of the navigation item, shown to the user on hover or in larger displays`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Administrator comments, not shown to the end user in MJ Explorer app`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class CreateMJExplorerNavigationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class UpdateMJExplorerNavigationItemInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Explorer Navigation Items
//****************************************************************************
@ObjectType()
export class RunMJExplorerNavigationItemViewResult {
    @Field(() => [MJExplorerNavigationItem_])
    Results: MJExplorerNavigationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJExplorerNavigationItem_)
export class MJExplorerNavigationItemResolver extends ResolverBase {
    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJExplorerNavigationItemViewResult)
    async RunMJExplorerNavigationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Explorer Navigation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJExplorerNavigationItem_, { nullable: true })
    async MJExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJExplorerNavigationItem_ | null> {
        this.CheckUserReadPermissions('Explorer Navigation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwExplorerNavigationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Explorer Navigation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Explorer Navigation Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJExplorerNavigationItem_)
    async CreateMJExplorerNavigationItem(
        @Arg('input', () => CreateMJExplorerNavigationItemInput) input: CreateMJExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Explorer Navigation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJExplorerNavigationItem_)
    async UpdateMJExplorerNavigationItem(
        @Arg('input', () => UpdateMJExplorerNavigationItemInput) input: UpdateMJExplorerNavigationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Explorer Navigation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJExplorerNavigationItem_)
    async DeleteMJExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Explorer Navigation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Categories
//****************************************************************************
@ObjectType({ description: `Organizes files into categories for classification, access control, and lifecycle management across the file storage system.` })
export class MJFileCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJFile_])
    Files_CategoryIDArray: MJFile_[]; // Link to Files
    
    @Field(() => [MJFileCategory_])
    FileCategories_ParentIDArray: MJFileCategory_[]; // Link to FileCategories
    
}

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class CreateMJFileCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class UpdateMJFileCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Categories
//****************************************************************************
@ObjectType()
export class RunMJFileCategoryViewResult {
    @Field(() => [MJFileCategory_])
    Results: MJFileCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileCategory_)
export class MJFileCategoryResolver extends ResolverBase {
    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileCategoryViewResult)
    async RunMJFileCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileCategory_, { nullable: true })
    async MJFileCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileCategory_ | null> {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('File Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJFile_])
    async Files_CategoryIDArray(@Root() mjfilecategory_: MJFileCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [CategoryID]='${mjfilecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Files', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileCategory_])
    async FileCategories_ParentIDArray(@Root() mjfilecategory_: MJFileCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ParentID]='${mjfilecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('File Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJFileCategory_)
    async CreateMJFileCategory(
        @Arg('input', () => CreateMJFileCategoryInput) input: CreateMJFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileCategory_)
    async UpdateMJFileCategory(
        @Arg('input', () => UpdateMJFileCategoryInput) input: UpdateMJFileCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileCategory_)
    async DeleteMJFileCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Entity Record Links
//****************************************************************************
@ObjectType({ description: `Associates files with entity records, enabling attachment management and document relationships throughout the system.` })
export class MJFileEntityRecordLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    FileID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the entity record this file is attached to.`}) 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    File: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class CreateMJFileEntityRecordLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class UpdateMJFileEntityRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Entity Record Links
//****************************************************************************
@ObjectType()
export class RunMJFileEntityRecordLinkViewResult {
    @Field(() => [MJFileEntityRecordLink_])
    Results: MJFileEntityRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileEntityRecordLink_)
export class MJFileEntityRecordLinkResolver extends ResolverBase {
    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileEntityRecordLinkViewResult)
    async RunMJFileEntityRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Entity Record Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileEntityRecordLink_, { nullable: true })
    async MJFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileEntityRecordLink_ | null> {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('File Entity Record Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJFileEntityRecordLink_)
    async CreateMJFileEntityRecordLink(
        @Arg('input', () => CreateMJFileEntityRecordLinkInput) input: CreateMJFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Entity Record Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileEntityRecordLink_)
    async UpdateMJFileEntityRecordLink(
        @Arg('input', () => UpdateMJFileEntityRecordLinkInput) input: UpdateMJFileEntityRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Entity Record Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileEntityRecordLink_)
    async DeleteMJFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Entity Record Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Storage Providers
//****************************************************************************
@ObjectType({ description: `Configures connections to file storage systems including local, cloud, and network storage with authentication and access rules.` })
export class MJFileStorageProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Identifier for the server-side driver implementation for this storage provider.`}) 
    @MaxLength(200)
    ServerDriverKey: string;
        
    @Field({description: `Identifier for the client-side driver implementation for this storage provider.`}) 
    @MaxLength(200)
    ClientDriverKey: string;
        
    @Field(() => Int, {description: `Priority order for selecting storage providers, lower numbers are preferred.`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Whether this storage provider is currently available for use.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this storage provider supports native full-text search across file names and content. Providers with native search APIs (Google Drive, SharePoint, Dropbox, Box) have this set to true.`}) 
    SupportsSearch: boolean;
        
    @Field({nullable: true, description: `Optional JSON configuration for providers that don't use Credential Engine. Used as fallback when CredentialID is not set on FileStorageAccount.`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `If true, this provider requires OAuth authentication. Enterprise OAuth integration via Credential Engine is planned but not yet implemented.`}) 
    RequiresOAuth: boolean;
        
    @Field(() => [MJFile_])
    Files_ProviderIDArray: MJFile_[]; // Link to Files
    
    @Field(() => [MJFileStorageAccount_])
    MJ_FileStorageAccounts_ProviderIDArray: MJFileStorageAccount_[]; // Link to MJ_FileStorageAccounts
    
    @Field(() => [MJAIConfiguration_])
    MJ_AIConfigurations_DefaultStorageProviderIDArray: MJAIConfiguration_[]; // Link to MJ_AIConfigurations
    
    @Field(() => [MJAIAgent_])
    AIAgents_AttachmentStorageProviderIDArray: MJAIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class CreateMJFileStorageProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSearch?: boolean;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    RequiresOAuth?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class UpdateMJFileStorageProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSearch?: boolean;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    RequiresOAuth?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Storage Providers
//****************************************************************************
@ObjectType()
export class RunMJFileStorageProviderViewResult {
    @Field(() => [MJFileStorageProvider_])
    Results: MJFileStorageProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileStorageProvider_)
export class MJFileStorageProviderResolver extends ResolverBase {
    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageProviderViewResult)
    async RunMJFileStorageProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Storage Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileStorageProvider_, { nullable: true })
    async MJFileStorageProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileStorageProvider_ | null> {
        this.CheckUserReadPermissions('File Storage Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Storage Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('File Storage Providers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJFile_])
    async Files_ProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ProviderID]='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Files', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileStorageAccount_])
    async MJ_FileStorageAccounts_ProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Storage Accounts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageAccounts] WHERE [ProviderID]='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Accounts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Storage Accounts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJ_AIConfigurations_DefaultStorageProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [DefaultStorageProviderID]='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async AIAgents_AttachmentStorageProviderIDArray(@Root() mjfilestorageprovider_: MJFileStorageProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [AttachmentStorageProviderID]='${mjfilestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJFileStorageProvider_)
    async CreateMJFileStorageProvider(
        @Arg('input', () => CreateMJFileStorageProviderInput) input: CreateMJFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('File Storage Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileStorageProvider_)
    async UpdateMJFileStorageProvider(
        @Arg('input', () => UpdateMJFileStorageProviderInput) input: UpdateMJFileStorageProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('File Storage Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileStorageProvider_)
    async DeleteMJFileStorageProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Storage Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Files
//****************************************************************************
@ObjectType({ description: `Manages file metadata, storage locations, and access control for all files stored within or referenced by the system.` })
export class MJFile_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(1000)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    ProviderID: string;
        
    @Field({nullable: true, description: `MIME type of the file content (e.g., image/jpeg, application/pdf).`}) 
    @MaxLength(510)
    ContentType?: string;
        
    @Field({nullable: true, description: `Storage provider-specific identifier or path for this file.`}) 
    @MaxLength(1000)
    ProviderKey?: string;
        
    @Field({description: `Pending, Uploading, Uploaded, Deleting, Deleted`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(100)
    Provider: string;
        
    @Field(() => [MJFileEntityRecordLink_])
    FileEntityRecordLinks_FileIDArray: MJFileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
    @Field(() => [MJAIPromptRunMedia_])
    MJ_AIPromptRunMedias_FileIDArray: MJAIPromptRunMedia_[]; // Link to MJ_AIPromptRunMedias
    
    @Field(() => [MJConversationDetailAttachment_])
    MJ_ConversationDetailAttachments_FileIDArray: MJConversationDetailAttachment_[]; // Link to MJ_ConversationDetailAttachments
    
    @Field(() => [MJAIAgentRunMedia_])
    MJ_AIAgentRunMedias_FileIDArray: MJAIAgentRunMedia_[]; // Link to MJ_AIAgentRunMedias
    
}

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class CreateMJFileInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType: string | null;

    @Field({ nullable: true })
    ProviderKey: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class UpdateMJFileInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType?: string | null;

    @Field({ nullable: true })
    ProviderKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Files
//****************************************************************************
@ObjectType()
export class RunMJFileViewResult {
    @Field(() => [MJFile_])
    Results: MJFile_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFile_)
export class MJFileResolver extends ResolverBase {
    @Query(() => RunMJFileViewResult)
    async RunMJFileViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileViewResult)
    async RunMJFileViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileViewResult)
    async RunMJFileDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Files';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFile_, { nullable: true })
    async MJFile(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFile_ | null> {
        this.CheckUserReadPermissions('Files', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Files', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Files', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJFileEntityRecordLink_])
    async FileEntityRecordLinks_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [FileID]='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRunMedia_])
    async MJ_AIPromptRunMedias_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRunMedias] WHERE [FileID]='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailAttachment_])
    async MJ_ConversationDetailAttachments_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailAttachments] WHERE [FileID]='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJ_AIAgentRunMedias_FileIDArray(@Root() mjfile_: MJFile_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunMedias] WHERE [FileID]='${mjfile_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJFile_)
    async CreateMJFile(
        @Arg('input', () => CreateMJFileInput) input: CreateMJFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Files', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFile_)
    async UpdateMJFile(
        @Arg('input', () => UpdateMJFileInput) input: UpdateMJFileInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Files', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFile_)
    async DeleteMJFile(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Files', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Code Categories
//****************************************************************************
@ObjectType({ description: `Categorization for generated code, including optional parent-child relationships.` })
export class MJGeneratedCodeCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category ID, allowing for hierarchical categorization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJGeneratedCodeCategory_])
    GeneratedCodeCategories_ParentIDArray: MJGeneratedCodeCategory_[]; // Link to GeneratedCodeCategories
    
    @Field(() => [MJGeneratedCode_])
    GeneratedCodes_CategoryIDArray: MJGeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class CreateMJGeneratedCodeCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class UpdateMJGeneratedCodeCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Code Categories
//****************************************************************************
@ObjectType()
export class RunMJGeneratedCodeCategoryViewResult {
    @Field(() => [MJGeneratedCodeCategory_])
    Results: MJGeneratedCodeCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJGeneratedCodeCategory_)
export class MJGeneratedCodeCategoryResolver extends ResolverBase {
    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeCategoryViewResult)
    async RunMJGeneratedCodeCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Code Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJGeneratedCodeCategory_, { nullable: true })
    async MJGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJGeneratedCodeCategory_ | null> {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Generated Code Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJGeneratedCodeCategory_])
    async GeneratedCodeCategories_ParentIDArray(@Root() mjgeneratedcodecategory_: MJGeneratedCodeCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ParentID]='${mjgeneratedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Generated Code Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJGeneratedCode_])
    async GeneratedCodes_CategoryIDArray(@Root() mjgeneratedcodecategory_: MJGeneratedCodeCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [CategoryID]='${mjgeneratedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Generated Codes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJGeneratedCodeCategory_)
    async CreateMJGeneratedCodeCategory(
        @Arg('input', () => CreateMJGeneratedCodeCategoryInput) input: CreateMJGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Generated Code Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJGeneratedCodeCategory_)
    async UpdateMJGeneratedCodeCategory(
        @Arg('input', () => UpdateMJGeneratedCodeCategoryInput) input: UpdateMJGeneratedCodeCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Generated Code Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJGeneratedCodeCategory_)
    async DeleteMJGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Code Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Codes
//****************************************************************************
@ObjectType({ description: `Stores LLM-generated code snippets, tracking their source, category, and validation status.` })
export class MJGeneratedCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `When the code was generated.`}) 
    @MaxLength(10)
    GeneratedAt: Date;
        
    @Field({description: `Reference to the category of generated code.`}) 
    @MaxLength(16)
    CategoryID: string;
        
    @Field({description: `AI model responsible for generating this code.`}) 
    @MaxLength(16)
    GeneratedByModelID: string;
        
    @Field({description: `Descriptive name of the generated code.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the generated code.`}) 
    Description?: string;
        
    @Field({description: `The actual generated code.`}) 
    Code: string;
        
    @Field({description: `Source material used to generate the code, e.g., a SQL CHECK constraint.`}) 
    Source: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `JSON containing the primary key(s) of the record this generated code is associated with.`}) 
    LinkedRecordPrimaryKey?: string;
        
    @Field({description: `Status of the generated code, e.g., Pending, Approved, or Rejected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Programming language of the generated code (TypeScript, SQL, HTML, CSS, JavaScript, Python, or Other).`}) 
    @MaxLength(100)
    Language: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Category: string;
        
    @Field() 
    @MaxLength(100)
    GeneratedByModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class CreateMJGeneratedCodeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;
}
    

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class UpdateMJGeneratedCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Codes
//****************************************************************************
@ObjectType()
export class RunMJGeneratedCodeViewResult {
    @Field(() => [MJGeneratedCode_])
    Results: MJGeneratedCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJGeneratedCode_)
export class MJGeneratedCodeResolver extends ResolverBase {
    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJGeneratedCodeViewResult)
    async RunMJGeneratedCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Codes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJGeneratedCode_, { nullable: true })
    async MJGeneratedCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJGeneratedCode_ | null> {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Generated Codes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJGeneratedCode_)
    async CreateMJGeneratedCode(
        @Arg('input', () => CreateMJGeneratedCodeInput) input: CreateMJGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Generated Codes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJGeneratedCode_)
    async UpdateMJGeneratedCode(
        @Arg('input', () => UpdateMJGeneratedCodeInput) input: UpdateMJGeneratedCodeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Generated Codes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJGeneratedCode_)
    async DeleteMJGeneratedCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Codes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integration URL Formats
//****************************************************************************
@ObjectType({ description: `Used to generate web links for end users to easily access resources in a source system. URL Formats support templating to inject various field values at run-time to take a user directly to a resource in a source system.` })
export class MJIntegrationURLFormat_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The URL Format for the given integration including the ability to include markup with fields from the integration`}) 
    @MaxLength(1000)
    URLFormat: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    FullURLFormat?: string;
        
}

//****************************************************************************
// INPUT TYPE for Integration URL Formats
//****************************************************************************
@InputType()
export class CreateMJIntegrationURLFormatInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Integration URL Formats
//****************************************************************************
@InputType()
export class UpdateMJIntegrationURLFormatInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integration URL Formats
//****************************************************************************
@ObjectType()
export class RunMJIntegrationURLFormatViewResult {
    @Field(() => [MJIntegrationURLFormat_])
    Results: MJIntegrationURLFormat_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJIntegrationURLFormat_)
export class MJIntegrationURLFormatResolver extends ResolverBase {
    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationURLFormatViewResult)
    async RunMJIntegrationURLFormatDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integration URL Formats';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJIntegrationURLFormat_, { nullable: true })
    async MJIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJIntegrationURLFormat_ | null> {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Integration URL Formats', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJIntegrationURLFormat_])
    async AllIntegrationURLFormats(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats]` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJIntegrationURLFormat_)
    async CreateMJIntegrationURLFormat(
        @Arg('input', () => CreateMJIntegrationURLFormatInput) input: CreateMJIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Integration URL Formats', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJIntegrationURLFormat_)
    async UpdateMJIntegrationURLFormat(
        @Arg('input', () => UpdateMJIntegrationURLFormatInput) input: UpdateMJIntegrationURLFormatInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Integration URL Formats', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJIntegrationURLFormat_)
    async DeleteMJIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integration URL Formats', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integrations
//****************************************************************************
@ObjectType({ description: `Catalog of all integrations that have been configured in the system.` })
export class MJIntegration_ {
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Description?: string;
        
    @Field({nullable: true, description: `Base URL for navigating to records in the external system from MemberJunction.`}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true, description: `The TypeScript/JavaScript class name implementing this integration.`}) 
    @MaxLength(200)
    ClassName?: string;
        
    @Field({nullable: true, description: `Module import path for the integration class in the codebase.`}) 
    @MaxLength(200)
    ImportPath?: string;
        
    @Field(() => Int, {description: `Maximum number of API requests to batch together, -1 for no limit.`}) 
    BatchMaxRequestCount: number;
        
    @Field(() => Int, {description: `Milliseconds to wait before sending a batch of requests, -1 to disable batching.`}) 
    BatchRequestWaitTime: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => [MJIntegrationURLFormat_])
    IntegrationURLFormats_IntegrationIDArray: MJIntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [MJCompanyIntegration_])
    CompanyIntegrations_IntegrationNameArray: MJCompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [MJRecordChange_])
    RecordChanges_IntegrationIDArray: MJRecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Integrations
//****************************************************************************
@InputType()
export class CreateMJIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    NavigationBaseURL: string | null;

    @Field({ nullable: true })
    ClassName: string | null;

    @Field({ nullable: true })
    ImportPath: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field({ nullable: true })
    ID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Integrations
//****************************************************************************
@InputType()
export class UpdateMJIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NavigationBaseURL?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field({ nullable: true })
    ImportPath?: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integrations
//****************************************************************************
@ObjectType()
export class RunMJIntegrationViewResult {
    @Field(() => [MJIntegration_])
    Results: MJIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJIntegration_)
export class MJIntegrationResolver extends ResolverBase {
    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJIntegrationViewResult)
    async RunMJIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJIntegration_, { nullable: true })
    async MJIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJIntegration_ | null> {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Integrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJIntegration_])
    async AllIntegrations(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations]` + this.getRowLevelSecurityWhereClause(provider, 'Integrations', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJIntegrationURLFormat_])
    async IntegrationURLFormats_IntegrationIDArray(@Root() mjintegration_: MJIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [IntegrationID]='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegration_])
    async CompanyIntegrations_IntegrationNameArray(@Root() mjintegration_: MJIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [IntegrationName]='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_IntegrationIDArray(@Root() mjintegration_: MJIntegration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [IntegrationID]='${mjintegration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJIntegration_)
    async CreateMJIntegration(
        @Arg('input', () => CreateMJIntegrationInput) input: CreateMJIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Integrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJIntegration_)
    async UpdateMJIntegration(
        @Arg('input', () => UpdateMJIntegrationInput) input: UpdateMJIntegrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Integrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJIntegration_)
    async DeleteMJIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Libraries
//****************************************************************************
@ObjectType({ description: `Stores information about the available libraries, including a list of classes/functions, type definitions, and sample code. You can add additional custom libraries here to make them avaialable to code generation features within the system.` })
export class MJLibrary_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Status of the library, only libraries marked as Active will be available for use by generated code. If a library was once active but no longer is, existing code that used the library will not be affected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Code showing the types and functions defined in the library to be used for reference by humans and AI`}) 
    TypeDefinitions?: string;
        
    @Field({nullable: true, description: `Examples of code use of the classes and/or functions from within the library`}) 
    SampleCode?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJActionLibrary_])
    ActionLibraries_LibraryIDArray: MJActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [MJLibraryItem_])
    LibraryItems_LibraryIDArray: MJLibraryItem_[]; // Link to LibraryItems
    
}

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class CreateMJLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions: string | null;

    @Field({ nullable: true })
    SampleCode: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class UpdateMJLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions?: string | null;

    @Field({ nullable: true })
    SampleCode?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Libraries
//****************************************************************************
@ObjectType()
export class RunMJLibraryViewResult {
    @Field(() => [MJLibrary_])
    Results: MJLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJLibrary_)
export class MJLibraryResolver extends ResolverBase {
    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryViewResult)
    async RunMJLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJLibrary_, { nullable: true })
    async MJLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJLibrary_ | null> {
        this.CheckUserReadPermissions('Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Libraries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJActionLibrary_])
    async ActionLibraries_LibraryIDArray(@Root() mjlibrary_: MJLibrary_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [LibraryID]='${mjlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Libraries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJLibraryItem_])
    async LibraryItems_LibraryIDArray(@Root() mjlibrary_: MJLibrary_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [LibraryID]='${mjlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Library Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJLibrary_)
    async CreateMJLibrary(
        @Arg('input', () => CreateMJLibraryInput) input: CreateMJLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJLibrary_)
    async UpdateMJLibrary(
        @Arg('input', () => UpdateMJLibraryInput) input: UpdateMJLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJLibrary_)
    async DeleteMJLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Library Items
//****************************************************************************
@ObjectType({ description: `Table to store individual library items` })
export class MJLibraryItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({description: `Type of the library item for example Class, Interface, etc.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class CreateMJLibraryItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class UpdateMJLibraryItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Library Items
//****************************************************************************
@ObjectType()
export class RunMJLibraryItemViewResult {
    @Field(() => [MJLibraryItem_])
    Results: MJLibraryItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJLibraryItem_)
export class MJLibraryItemResolver extends ResolverBase {
    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJLibraryItemViewResult)
    async RunMJLibraryItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Library Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJLibraryItem_, { nullable: true })
    async MJLibraryItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJLibraryItem_ | null> {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Library Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJLibraryItem_)
    async CreateMJLibraryItem(
        @Arg('input', () => CreateMJLibraryItemInput) input: CreateMJLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Library Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJLibraryItem_)
    async UpdateMJLibraryItem(
        @Arg('input', () => UpdateMJLibraryItemInput) input: UpdateMJLibraryItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Library Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJLibraryItem_)
    async DeleteMJLibraryItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Library Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Categories
//****************************************************************************
@ObjectType({ description: `Groups lists into categories for organization and navigation, supporting hierarchical categorization of user-created lists.` })
export class MJListCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJListCategory_])
    ListCategories_ParentIDArray: MJListCategory_[]; // Link to ListCategories
    
    @Field(() => [MJList_])
    Lists_CategoryIDArray: MJList_[]; // Link to Lists
    
}

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class CreateMJListCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class UpdateMJListCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Categories
//****************************************************************************
@ObjectType()
export class RunMJListCategoryViewResult {
    @Field(() => [MJListCategory_])
    Results: MJListCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListCategory_)
export class MJListCategoryResolver extends ResolverBase {
    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListCategoryViewResult)
    async RunMJListCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListCategory_, { nullable: true })
    async MJListCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListCategory_ | null> {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('List Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJListCategory_])
    async ListCategories_ParentIDArray(@Root() mjlistcategory_: MJListCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ParentID]='${mjlistcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('List Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async Lists_CategoryIDArray(@Root() mjlistcategory_: MJListCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CategoryID]='${mjlistcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJListCategory_)
    async CreateMJListCategory(
        @Arg('input', () => CreateMJListCategoryInput) input: CreateMJListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('List Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListCategory_)
    async UpdateMJListCategory(
        @Arg('input', () => UpdateMJListCategoryInput) input: UpdateMJListCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('List Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListCategory_)
    async DeleteMJListCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Details
//****************************************************************************
@ObjectType({ description: `Tracks the records within each list.` })
export class MJListDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ListID: string;
        
    @Field({description: `The ID of the record included in this list.`}) 
    @MaxLength(890)
    RecordID: string;
        
    @Field(() => Int, {description: `Order of this record within the list, for maintaining user-defined sorting.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the status of each individual list detail row to enable processing of various types and the use of the status column for filtering list detail rows within a list that are in a particular state.`}) 
    @MaxLength(60)
    Status: string;
        
    @Field({nullable: true, description: `Optional column that allows for tracking any additional data for each ListDetail row`}) 
    AdditionalData?: string;
        
    @Field() 
    @MaxLength(200)
    List: string;
        
}

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class CreateMJListDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class UpdateMJListDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Details
//****************************************************************************
@ObjectType()
export class RunMJListDetailViewResult {
    @Field(() => [MJListDetail_])
    Results: MJListDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListDetail_)
export class MJListDetailResolver extends ResolverBase {
    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListDetailViewResult)
    async RunMJListDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListDetail_, { nullable: true })
    async MJListDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListDetail_ | null> {
        this.CheckUserReadPermissions('List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('List Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJListDetail_)
    async CreateMJListDetail(
        @Arg('input', () => CreateMJListDetailInput) input: CreateMJListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('List Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListDetail_)
    async UpdateMJListDetail(
        @Arg('input', () => UpdateMJListDetailInput) input: UpdateMJListDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('List Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListDetail_)
    async DeleteMJListDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Lists
//****************************************************************************
@ObjectType({ description: `Static lists are useful for controlling a set of data for a given entity. These can be used programatically for applications like logging and tracking long-running tasks and also by end users for tracking any particular list of records they want to directly control the set.` })
export class MJList_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `Identifier for this list in an external system, used for synchronization.`}) 
    @MaxLength(200)
    ExternalSystemRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CompanyIntegration?: string;
        
    @Field(() => [MJListDetail_])
    ListDetails_ListIDArray: MJListDetail_[]; // Link to ListDetails
    
    @Field(() => [MJDuplicateRun_])
    DuplicateRuns_SourceListIDArray: MJDuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [MJListShare_])
    MJ_ListShares_ListIDArray: MJListShare_[]; // Link to MJ_ListShares
    
    @Field(() => [MJListInvitation_])
    MJ_ListInvitations_ListIDArray: MJListInvitation_[]; // Link to MJ_ListInvitations
    
}

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class CreateMJListInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class UpdateMJListInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Lists
//****************************************************************************
@ObjectType()
export class RunMJListViewResult {
    @Field(() => [MJList_])
    Results: MJList_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJList_)
export class MJListResolver extends ResolverBase {
    @Query(() => RunMJListViewResult)
    async RunMJListViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListViewResult)
    async RunMJListViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListViewResult)
    async RunMJListDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Lists';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJList_, { nullable: true })
    async MJList(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJList_ | null> {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Lists', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJListDetail_])
    async ListDetails_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ListID]='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('List Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async DuplicateRuns_SourceListIDArray(@Root() mjlist_: MJList_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [SourceListID]='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListShare_])
    async MJ_ListShares_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Shares', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListShares] WHERE [ListID]='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Shares', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Shares', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListInvitation_])
    async MJ_ListInvitations_ListIDArray(@Root() mjlist_: MJList_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Invitations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListInvitations] WHERE [ListID]='${mjlist_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Invitations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Invitations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJList_)
    async CreateMJList(
        @Arg('input', () => CreateMJListInput) input: CreateMJListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Lists', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJList_)
    async UpdateMJList(
        @Arg('input', () => UpdateMJListInput) input: UpdateMJListInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Lists', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJList_)
    async DeleteMJList(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Lists', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Access Control Rules
//****************************************************************************
@ObjectType({ description: `Generic ACL-style permission system that can control access to any entity record in the system with granular CRUD permissions.` })
export class MJAccessControlRule_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `Primary key value(s) of the record being protected - scalar for simple PKs or JSON for composite PKs`}) 
    @MaxLength(1000)
    RecordID: string;
        
    @Field({description: `Type of grantee receiving permission (User, Role, Everyone, Public). "Everyone" means all authenticated users whereas "Public" means any authenticated OR anonymous user.`}) 
    @MaxLength(100)
    GranteeType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    GranteeID?: string;
        
    @Field(() => Boolean, {description: `Permission to read/view the record`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Permission to create new related records`}) 
    CanCreate: boolean;
        
    @Field(() => Boolean, {description: `Permission to update/modify the record`}) 
    CanUpdate: boolean;
        
    @Field(() => Boolean, {description: `Permission to delete the record`}) 
    CanDelete: boolean;
        
    @Field(() => Boolean, {description: `Permission to share/grant permissions to other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `Optional expiration date/time for this access rule`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field() 
    @MaxLength(16)
    GrantedByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    GrantedByUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Access Control Rules
//****************************************************************************
@InputType()
export class CreateMJAccessControlRuleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    GranteeType?: string;

    @Field({ nullable: true })
    GranteeID: string | null;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field({ nullable: true })
    GrantedByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Access Control Rules
//****************************************************************************
@InputType()
export class UpdateMJAccessControlRuleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    GranteeType?: string;

    @Field({ nullable: true })
    GranteeID?: string | null;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field({ nullable: true })
    GrantedByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Access Control Rules
//****************************************************************************
@ObjectType()
export class RunMJAccessControlRuleViewResult {
    @Field(() => [MJAccessControlRule_])
    Results: MJAccessControlRule_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAccessControlRule_)
export class MJAccessControlRuleResolver extends ResolverBase {
    @Query(() => RunMJAccessControlRuleViewResult)
    async RunMJAccessControlRuleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAccessControlRuleViewResult)
    async RunMJAccessControlRuleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAccessControlRuleViewResult)
    async RunMJAccessControlRuleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Access Control Rules';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAccessControlRule_, { nullable: true })
    async MJAccessControlRule(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAccessControlRule_ | null> {
        this.CheckUserReadPermissions('MJ: Access Control Rules', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAccessControlRules] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Access Control Rules', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Access Control Rules', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAccessControlRule_)
    async CreateMJAccessControlRule(
        @Arg('input', () => CreateMJAccessControlRuleInput) input: CreateMJAccessControlRuleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Access Control Rules', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAccessControlRule_)
    async UpdateMJAccessControlRule(
        @Arg('input', () => UpdateMJAccessControlRuleInput) input: UpdateMJAccessControlRuleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Access Control Rules', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAccessControlRule_)
    async DeleteMJAccessControlRule(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Access Control Rules', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Artifact Types
//****************************************************************************
@ObjectType({ description: `Junction table linking AI Agents to the artifact types they can produce. An agent can produce zero to many artifact types.` })
export class MJAIAgentArtifactType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `AI Agent that can produce this artifact type`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Artifact type that this agent can produce`}) 
    @MaxLength(16)
    ArtifactTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional sequence for ordering multiple artifact types for an agent`}) 
    Sequence?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field() 
    @MaxLength(200)
    ArtifactType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Artifact Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentArtifactTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Artifact Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Artifact Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentArtifactTypeViewResult {
    @Field(() => [MJAIAgentArtifactType_])
    Results: MJAIAgentArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentArtifactType_)
export class MJAIAgentArtifactTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentArtifactTypeViewResult)
    async RunMJAIAgentArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentArtifactTypeViewResult)
    async RunMJAIAgentArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentArtifactTypeViewResult)
    async RunMJAIAgentArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Artifact Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentArtifactType_, { nullable: true })
    async MJAIAgentArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentArtifactTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Artifact Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentArtifactType_)
    async CreateMJAIAgentArtifactType(
        @Arg('input', () => CreateMJAIAgentArtifactTypeInput) input: CreateMJAIAgentArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Artifact Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentArtifactType_)
    async UpdateMJAIAgentArtifactType(
        @Arg('input', () => UpdateMJAIAgentArtifactTypeInput) input: UpdateMJAIAgentArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Artifact Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentArtifactType_)
    async DeleteMJAIAgentArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Artifact Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Configurations
//****************************************************************************
@ObjectType({ description: `Defines semantic configuration presets for agents, allowing users to select between different AI model configurations (e.g., Fast, Balanced, High Quality) when executing an agent. Each preset maps to an AI Configuration which controls model selection across all prompts.` })
export class MJAIAgentConfiguration_ {
    @Field({description: `Primary Key - Unique identifier for the agent configuration preset`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The agent this configuration preset belongs to`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Code-friendly name for the preset (e.g., HighPower, Fast, Balanced). Used in API calls and metadata references.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `User-friendly display name shown in UI (e.g., "High Quality", "Quick Draft", "Maximum Detail")`}) 
    @MaxLength(400)
    DisplayName: string;
        
    @Field({nullable: true, description: `Description shown to users explaining what this configuration does (e.g., "Uses Claude Opus for highest quality results")`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Foreign Key - Optional AI Configuration to use for this preset. If NULL, uses default configuration (prompts with ConfigurationID IS NULL)`}) 
    @MaxLength(16)
    AIConfigurationID?: string;
        
    @Field(() => Boolean, {description: `Whether this is the default preset for the agent. Should have exactly one default per agent.`}) 
    IsDefault: boolean;
        
    @Field(() => Int, {description: `Display order for UI. Lower numbers appear first. Typical values: 100 (Default), 200 (Fast), 300 (Balanced), 400 (High Quality)`}) 
    Priority: number;
        
    @Field({description: `Status of the preset: Pending (being configured), Active (available for use), Revoked (no longer available)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    AIConfiguration?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Configurations
//****************************************************************************
@InputType()
export class CreateMJAIAgentConfigurationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIConfigurationID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Configurations
//****************************************************************************
@InputType()
export class UpdateMJAIAgentConfigurationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIConfigurationID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Configurations
//****************************************************************************
@ObjectType()
export class RunMJAIAgentConfigurationViewResult {
    @Field(() => [MJAIAgentConfiguration_])
    Results: MJAIAgentConfiguration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentConfiguration_)
export class MJAIAgentConfigurationResolver extends ResolverBase {
    @Query(() => RunMJAIAgentConfigurationViewResult)
    async RunMJAIAgentConfigurationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentConfigurationViewResult)
    async RunMJAIAgentConfigurationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentConfigurationViewResult)
    async RunMJAIAgentConfigurationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Configurations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentConfiguration_, { nullable: true })
    async MJAIAgentConfiguration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentConfiguration_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentConfigurations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Configurations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentConfiguration_)
    async CreateMJAIAgentConfiguration(
        @Arg('input', () => CreateMJAIAgentConfigurationInput) input: CreateMJAIAgentConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Configurations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentConfiguration_)
    async UpdateMJAIAgentConfiguration(
        @Arg('input', () => UpdateMJAIAgentConfigurationInput) input: UpdateMJAIAgentConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Configurations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentConfiguration_)
    async DeleteMJAIAgentConfiguration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Configurations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Data Sources
//****************************************************************************
@ObjectType({ description: `Defines data sources that should be preloaded into the data parameter before agent execution. Supports both RunView and RunQuery sources with configurable caching.` })
export class MJAIAgentDataSource_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Variable name for the data in the data parameter (e.g., "ALL_ENTITIES"). Must be unique within an agent.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of what this data source provides`}) 
    Description?: string;
        
    @Field({description: `Type of data source: RunView or RunQuery. Determines which parameters are used.`}) 
    @MaxLength(40)
    SourceType: string;
        
    @Field({nullable: true, description: `Entity name for RunView data sources (e.g., "Entities", "AI Models")`}) 
    @MaxLength(510)
    EntityName?: string;
        
    @Field({nullable: true, description: `SQL WHERE clause filter for RunView data sources`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true, description: `SQL ORDER BY clause for RunView data sources`}) 
    @MaxLength(1000)
    OrderBy?: string;
        
    @Field({nullable: true, description: `JSON array of field names to return for RunView data sources (e.g., ["ID", "Name", "Description"])`}) 
    FieldsToRetrieve?: string;
        
    @Field({nullable: true, description: `Result type for RunView: simple (default) or entity_object`}) 
    @MaxLength(40)
    ResultType?: string;
        
    @Field({nullable: true, description: `Query name for RunQuery data sources`}) 
    @MaxLength(510)
    QueryName?: string;
        
    @Field({nullable: true, description: `Category path for RunQuery data sources (e.g., "/MJ/AI/Agents/")`}) 
    @MaxLength(1000)
    CategoryPath?: string;
        
    @Field({nullable: true, description: `JSON object of parameters for RunQuery data sources (e.g., {"organizationId": "123"})`}) 
    Parameters?: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of rows to return. Applies to both RunView and RunQuery.`}) 
    MaxRows?: number;
        
    @Field(() => Int, {description: `Execution order when multiple data sources are defined for an agent (lower numbers execute first)`}) 
    ExecutionOrder: number;
        
    @Field({description: `Status of the data source: Active or Disabled`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Cache policy: None (no caching), PerRun (cache for duration of agent run), PerAgent (cache across runs with timeout)`}) 
    @MaxLength(40)
    CachePolicy: string;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in seconds for PerAgent cache policy. Ignored for other cache policies.`}) 
    CacheTimeoutSeconds?: number;
        
    @Field({description: `Destination for the preloaded data: Data (for Nunjucks templates in prompts), Context (for actions only), or Payload (for agent state)`}) 
    @MaxLength(40)
    DestinationType: string;
        
    @Field({nullable: true, description: `Path within the destination where data should be injected. Supports nested paths using dot notation (e.g., "config.api.endpoints", "analysis.orders.recent"). If null, uses Name as root-level key.`}) 
    @MaxLength(1000)
    DestinationPath?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Data Sources
//****************************************************************************
@InputType()
export class CreateMJAIAgentDataSourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SourceType?: string;

    @Field({ nullable: true })
    EntityName: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;

    @Field({ nullable: true })
    FieldsToRetrieve: string | null;

    @Field({ nullable: true })
    ResultType?: string | null;

    @Field({ nullable: true })
    QueryName: string | null;

    @Field({ nullable: true })
    CategoryPath: string | null;

    @Field({ nullable: true })
    Parameters: string | null;

    @Field(() => Int, { nullable: true })
    MaxRows: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CachePolicy?: string;

    @Field(() => Int, { nullable: true })
    CacheTimeoutSeconds: number | null;

    @Field({ nullable: true })
    DestinationType?: string;

    @Field({ nullable: true })
    DestinationPath: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Data Sources
//****************************************************************************
@InputType()
export class UpdateMJAIAgentDataSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SourceType?: string;

    @Field({ nullable: true })
    EntityName?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field({ nullable: true })
    FieldsToRetrieve?: string | null;

    @Field({ nullable: true })
    ResultType?: string | null;

    @Field({ nullable: true })
    QueryName?: string | null;

    @Field({ nullable: true })
    CategoryPath?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => Int, { nullable: true })
    MaxRows?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CachePolicy?: string;

    @Field(() => Int, { nullable: true })
    CacheTimeoutSeconds?: number | null;

    @Field({ nullable: true })
    DestinationType?: string;

    @Field({ nullable: true })
    DestinationPath?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Data Sources
//****************************************************************************
@ObjectType()
export class RunMJAIAgentDataSourceViewResult {
    @Field(() => [MJAIAgentDataSource_])
    Results: MJAIAgentDataSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentDataSource_)
export class MJAIAgentDataSourceResolver extends ResolverBase {
    @Query(() => RunMJAIAgentDataSourceViewResult)
    async RunMJAIAgentDataSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentDataSourceViewResult)
    async RunMJAIAgentDataSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentDataSourceViewResult)
    async RunMJAIAgentDataSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Data Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentDataSource_, { nullable: true })
    async MJAIAgentDataSource(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentDataSource_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Data Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentDataSources] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Data Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Data Sources', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentDataSource_)
    async CreateMJAIAgentDataSource(
        @Arg('input', () => CreateMJAIAgentDataSourceInput) input: CreateMJAIAgentDataSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Data Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentDataSource_)
    async UpdateMJAIAgentDataSource(
        @Arg('input', () => UpdateMJAIAgentDataSourceInput) input: UpdateMJAIAgentDataSourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Data Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentDataSource_)
    async DeleteMJAIAgentDataSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Data Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Examples
//****************************************************************************
@ObjectType({ description: `Stores example input/output pairs for AI agents to learn from successful interactions. Examples are always agent-specific and support optional user/company scoping for personalized examples.` })
export class MJAIAgentExample_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The AI agent this example is associated with. Examples are always agent-specific.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({nullable: true, description: `Optional user scope. When populated, this example is specific to this user.`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Optional company scope. When populated, this example is specific to this company.`}) 
    @MaxLength(16)
    CompanyID?: string;
        
    @Field({description: `Quick categorization of the example: Preference (demonstrates user preference), Constraint (shows constraint compliance), Context (provides contextual example), Example (typical successful interaction - most common), or Issue (demonstrates handling of known issue).`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `The input text or prompt that was provided in this example interaction.`}) 
    ExampleInput: string;
        
    @Field({description: `The successful output or response that the agent provided for this example.`}) 
    ExampleOutput: string;
        
    @Field(() => Boolean, {description: `Indicates whether this example was automatically captured (1) or manually created (0).`}) 
    IsAutoGenerated: boolean;
        
    @Field({nullable: true, description: `Optional reference to the conversation where this example originated.`}) 
    @MaxLength(16)
    SourceConversationID?: string;
        
    @Field({nullable: true, description: `Optional reference to the specific conversation message that represents this example.`}) 
    @MaxLength(16)
    SourceConversationDetailID?: string;
        
    @Field({nullable: true, description: `Optional reference to the AI agent run that generated this example.`}) 
    @MaxLength(16)
    SourceAIAgentRunID?: string;
        
    @Field(() => Float, {nullable: true, description: `Optional success score (0-100) indicating the quality or effectiveness of this example based on user feedback or metrics.`}) 
    SuccessScore?: number;
        
    @Field({nullable: true, description: `Internal comments about this example, not included in agent context injection.`}) 
    Comments?: string;
        
    @Field({description: `Status of the example: Pending (awaiting review), Active (in use), or Revoked (disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON array of embedding vector for semantic search on ExampleInput field. Auto-generated when ExampleInput changes.`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `Reference to the AI model used to generate the embedding vector.`}) 
    @MaxLength(16)
    EmbeddingModelID?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying which entity type is used for primary scoping. NULL means this is a global example.`}) 
    @MaxLength(16)
    PrimaryScopeEntityID?: string;
        
    @Field({nullable: true, description: `The record ID within the primary scope entity. NULL means global example. When set with empty SecondaryScopes, indicates primary-scope-only example.`}) 
    @MaxLength(200)
    PrimaryScopeRecordID?: string;
        
    @Field({nullable: true, description: `JSON object containing additional scope dimensions. Empty/NULL with PrimaryScopeRecordID set = org-level example. Populated = fully-scoped example.`}) 
    SecondaryScopes?: string;
        
    @Field({nullable: true, description: `Timestamp of when this example was last accessed/used for agent context. Used for lifecycle management and cleanup.`}) 
    @MaxLength(10)
    LastAccessedAt?: Date;
        
    @Field(() => Int, {description: `Number of times this example has been accessed/used. Used for analytics and determining example value.`}) 
    AccessCount: number;
        
    @Field({nullable: true, description: `Optional expiration timestamp. Examples past this date are candidates for archival. NULL means no expiration.`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Company?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceConversation?: string;
        
    @Field({nullable: true}) 
    SourceConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceAIAgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmbeddingModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    PrimaryScopeEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Examples
//****************************************************************************
@InputType()
export class CreateMJAIAgentExampleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    CompanyID: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ExampleInput?: string;

    @Field({ nullable: true })
    ExampleOutput?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    SourceConversationID: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID: string | null;

    @Field(() => Float, { nullable: true })
    SuccessScore: number | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID: string | null;

    @Field({ nullable: true })
    SecondaryScopes: string | null;

    @Field({ nullable: true })
    LastAccessedAt: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Examples
//****************************************************************************
@InputType()
export class UpdateMJAIAgentExampleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    CompanyID?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ExampleInput?: string;

    @Field({ nullable: true })
    ExampleOutput?: string;

    @Field(() => Boolean, { nullable: true })
    IsAutoGenerated?: boolean;

    @Field({ nullable: true })
    SourceConversationID?: string | null;

    @Field({ nullable: true })
    SourceConversationDetailID?: string | null;

    @Field({ nullable: true })
    SourceAIAgentRunID?: string | null;

    @Field(() => Float, { nullable: true })
    SuccessScore?: number | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID?: string | null;

    @Field({ nullable: true })
    SecondaryScopes?: string | null;

    @Field({ nullable: true })
    LastAccessedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    AccessCount?: number;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Examples
//****************************************************************************
@ObjectType()
export class RunMJAIAgentExampleViewResult {
    @Field(() => [MJAIAgentExample_])
    Results: MJAIAgentExample_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentExample_)
export class MJAIAgentExampleResolver extends ResolverBase {
    @Query(() => RunMJAIAgentExampleViewResult)
    async RunMJAIAgentExampleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentExampleViewResult)
    async RunMJAIAgentExampleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentExampleViewResult)
    async RunMJAIAgentExampleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Examples';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentExample_, { nullable: true })
    async MJAIAgentExample(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentExample_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Examples', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentExample_)
    async CreateMJAIAgentExample(
        @Arg('input', () => CreateMJAIAgentExampleInput) input: CreateMJAIAgentExampleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Examples', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentExample_)
    async UpdateMJAIAgentExample(
        @Arg('input', () => UpdateMJAIAgentExampleInput) input: UpdateMJAIAgentExampleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Examples', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentExample_)
    async DeleteMJAIAgentExample(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Examples', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Modalities
//****************************************************************************
@ObjectType({ description: `Agent-level modality configuration. Allows agents to restrict or customize modality settings beyond what the model supports. Absence of a record means the agent uses model defaults (Text in/out assumed if no records exist).` })
export class MJAIAgentModality_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AgentID: string;
        
    @Field() 
    @MaxLength(16)
    ModalityID: string;
        
    @Field({description: `Whether this is an Input or Output modality for the agent.`}) 
    @MaxLength(20)
    Direction: string;
        
    @Field(() => Boolean, {description: `Whether this modality is allowed for this agent. Set to FALSE to disable a modality even if the underlying model supports it.`}) 
    IsAllowed: boolean;
        
    @Field(() => Int, {nullable: true, description: `Agent-specific maximum size in bytes. Overrides model and system defaults. Must be less than or equal to model limit.`}) 
    MaxSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `Agent-specific maximum count per message. Overrides model and system defaults. Must be less than or equal to model limit.`}) 
    MaxCountPerMessage?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field() 
    @MaxLength(100)
    Modality: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Modalities
//****************************************************************************
@InputType()
export class CreateMJAIAgentModalityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsAllowed?: boolean;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Modalities
//****************************************************************************
@InputType()
export class UpdateMJAIAgentModalityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsAllowed?: boolean;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Modalities
//****************************************************************************
@ObjectType()
export class RunMJAIAgentModalityViewResult {
    @Field(() => [MJAIAgentModality_])
    Results: MJAIAgentModality_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentModality_)
export class MJAIAgentModalityResolver extends ResolverBase {
    @Query(() => RunMJAIAgentModalityViewResult)
    async RunMJAIAgentModalityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModalityViewResult)
    async RunMJAIAgentModalityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentModalityViewResult)
    async RunMJAIAgentModalityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Modalities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentModality_, { nullable: true })
    async MJAIAgentModality(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentModality_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModalities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Modalities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentModality_)
    async CreateMJAIAgentModality(
        @Arg('input', () => CreateMJAIAgentModalityInput) input: CreateMJAIAgentModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Modalities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentModality_)
    async UpdateMJAIAgentModality(
        @Arg('input', () => UpdateMJAIAgentModalityInput) input: UpdateMJAIAgentModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Modalities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentModality_)
    async DeleteMJAIAgentModality(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Modalities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Permissions
//****************************************************************************
@ObjectType({ description: `Defines access control permissions for AI agents using an ACL (Access Control List) model. Permissions can be granted to individual users or roles.` })
export class MJAIAgentPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AgentID: string;
        
    @Field({nullable: true, description: `The role this permission is granted to. Either RoleID or UserID must be specified, but not both.`}) 
    @MaxLength(16)
    RoleID?: string;
        
    @Field({nullable: true, description: `The user this permission is granted to. Either RoleID or UserID must be specified, but not both.`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field(() => Boolean, {description: `Grants permission to view the agent configuration and details.`}) 
    CanView: boolean;
        
    @Field(() => Boolean, {description: `Grants permission to execute/run the agent. Typically implies CanView as well.`}) 
    CanRun: boolean;
        
    @Field(() => Boolean, {description: `Grants permission to modify the agent configuration, prompts, and settings. Typically implies CanView and CanRun as well.`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Grants permission to delete the agent. Typically implies all other permissions as well.`}) 
    CanDelete: boolean;
        
    @Field({nullable: true, description: `Optional comments explaining why this permission was granted or any special notes.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Permissions
//****************************************************************************
@InputType()
export class CreateMJAIAgentPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field(() => Boolean, { nullable: true })
    CanView?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRun?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Permissions
//****************************************************************************
@InputType()
export class UpdateMJAIAgentPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => Boolean, { nullable: true })
    CanView?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRun?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Permissions
//****************************************************************************
@ObjectType()
export class RunMJAIAgentPermissionViewResult {
    @Field(() => [MJAIAgentPermission_])
    Results: MJAIAgentPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentPermission_)
export class MJAIAgentPermissionResolver extends ResolverBase {
    @Query(() => RunMJAIAgentPermissionViewResult)
    async RunMJAIAgentPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPermissionViewResult)
    async RunMJAIAgentPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPermissionViewResult)
    async RunMJAIAgentPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentPermission_, { nullable: true })
    async MJAIAgentPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentPermission_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentPermission_)
    async CreateMJAIAgentPermission(
        @Arg('input', () => CreateMJAIAgentPermissionInput) input: CreateMJAIAgentPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentPermission_)
    async UpdateMJAIAgentPermission(
        @Arg('input', () => UpdateMJAIAgentPermissionInput) input: UpdateMJAIAgentPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentPermission_)
    async DeleteMJAIAgentPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Prompts
//****************************************************************************
@ObjectType({ description: `Links AI agents with the prompts they use, including execution order and context handling.` })
export class MJAIAgentPrompt_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the agent this prompt is associated with.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `References the prompt to be used by the agent.`}) 
    @MaxLength(16)
    PromptID: string;
        
    @Field({nullable: true, description: `The functional purpose of this prompt within the agent, such as "Initialize", "ProcessData", or "Summarize".`}) 
    Purpose?: string;
        
    @Field(() => Int, {description: `The sequence order in which this prompt should be executed within the agent's workflow.`}) 
    ExecutionOrder: number;
        
    @Field({nullable: true, description: `Optional reference to a specific configuration to use for this prompt. If NULL, uses the default configuration.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field({description: `The current status of this agent-prompt mapping. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Determines how conversation context is filtered for this prompt: Complete, Smart, None, RecentMessages, InitialMessages, or Custom.`}) 
    @MaxLength(100)
    ContextBehavior: string;
        
    @Field(() => Int, {nullable: true, description: `The number of messages to include when ContextBehavior is set to RecentMessages or InitialMessages.`}) 
    ContextMessageCount?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field() 
    @MaxLength(510)
    Prompt: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Prompts
//****************************************************************************
@InputType()
export class CreateMJAIAgentPromptInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    Purpose: string | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ContextBehavior?: string;

    @Field(() => Int, { nullable: true })
    ContextMessageCount: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Prompts
//****************************************************************************
@InputType()
export class UpdateMJAIAgentPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    Purpose?: string | null;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ContextBehavior?: string;

    @Field(() => Int, { nullable: true })
    ContextMessageCount?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Prompts
//****************************************************************************
@ObjectType()
export class RunMJAIAgentPromptViewResult {
    @Field(() => [MJAIAgentPrompt_])
    Results: MJAIAgentPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentPrompt_)
export class MJAIAgentPromptResolver extends ResolverBase {
    @Query(() => RunMJAIAgentPromptViewResult)
    async RunMJAIAgentPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPromptViewResult)
    async RunMJAIAgentPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentPromptViewResult)
    async RunMJAIAgentPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Prompts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentPrompt_, { nullable: true })
    async MJAIAgentPrompt(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentPrompt_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentPrompt_)
    async CreateMJAIAgentPrompt(
        @Arg('input', () => CreateMJAIAgentPromptInput) input: CreateMJAIAgentPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Prompts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentPrompt_)
    async UpdateMJAIAgentPrompt(
        @Arg('input', () => UpdateMJAIAgentPromptInput) input: UpdateMJAIAgentPromptInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Prompts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentPrompt_)
    async DeleteMJAIAgentPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Prompts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Relationships
//****************************************************************************
@ObjectType({ description: `Tracks relationships between AI agents for sub-agent orchestration` })
export class MJAIAgentRelationship_ {
    @Field({description: `Primary key for AI agent relationships`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to parent AIAgent that can invoke the sub-agent`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Foreign key to sub-agent AIAgent that can be invoked`}) 
    @MaxLength(16)
    SubAgentID: string;
        
    @Field({description: `Status of the relationship: Pending (awaiting approval), Active (can invoke), or Revoked (no longer allowed)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON configuration mapping sub-agent result payload paths to parent agent payload paths. Enables controlled merging of sub-agent results. Format: {"subAgentPath": "parentPath", "*": "captureAllPath"}. If null, sub-agent results are not automatically merged into parent payload.`}) 
    SubAgentOutputMapping?: string;
        
    @Field({nullable: true, description: `JSON mapping of parent payload paths to sub-agent initial payload paths. Enables structural data transfer from parent to related sub-agent. Format: {"parentPath": "subAgentPath", "parent.nested": "subAgent.field"}. Example: {"searchQuery": "query", "maxResults": "limit"}. If null, sub-agent starts with empty payload (default behavior).`}) 
    SubAgentInputMapping?: string;
        
    @Field({nullable: true, description: `JSON array of parent payload paths to send as LLM context to related sub-agent. Sub-agent receives this data in a formatted context message before its task message. Format: ["path1", "path2.nested", "path3.*", "*"]. Use "*" to send entire parent payload. Example: ["userPreferences", "priorFindings.summary", "sources[*]"]. If null, no parent context is sent (default behavior).`}) 
    SubAgentContextPaths?: string;
        
    @Field({description: `Specifies how conversation messages are passed from parent agent to related sub-agent. Valid values: 'None' (fresh start - only context and task message, default), 'All' (all parent conversation history), 'Latest' (most recent MaxMessages messages), 'Bookend' (first 2 messages + most recent MaxMessages-2 messages with indicator between). Stored on relationship because related sub-agents can have multiple parents with different message passing needs.`}) 
    @MaxLength(100)
    MessageMode: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of conversation messages to include when MessageMode is 'Latest' or 'Bookend'. NULL means no limit (ignored for 'None' and 'All' modes). Must be greater than 0 if specified. For 'Latest': keeps most recent N messages. For 'Bookend': keeps first 2 + most recent (N-2) messages.`}) 
    MaxMessages?: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SubAgent?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Relationships
//****************************************************************************
@InputType()
export class CreateMJAIAgentRelationshipInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    SubAgentID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SubAgentOutputMapping: string | null;

    @Field({ nullable: true })
    SubAgentInputMapping: string | null;

    @Field({ nullable: true })
    SubAgentContextPaths: string | null;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Relationships
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    SubAgentID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    SubAgentOutputMapping?: string | null;

    @Field({ nullable: true })
    SubAgentInputMapping?: string | null;

    @Field({ nullable: true })
    SubAgentContextPaths?: string | null;

    @Field({ nullable: true })
    MessageMode?: string;

    @Field(() => Int, { nullable: true })
    MaxMessages?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Relationships
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRelationshipViewResult {
    @Field(() => [MJAIAgentRelationship_])
    Results: MJAIAgentRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRelationship_)
export class MJAIAgentRelationshipResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRelationshipViewResult)
    async RunMJAIAgentRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRelationshipViewResult)
    async RunMJAIAgentRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRelationshipViewResult)
    async RunMJAIAgentRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Relationships';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRelationship_, { nullable: true })
    async MJAIAgentRelationship(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRelationship_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRelationships] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Relationships', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentRelationship_)
    async CreateMJAIAgentRelationship(
        @Arg('input', () => CreateMJAIAgentRelationshipInput) input: CreateMJAIAgentRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Relationships', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRelationship_)
    async UpdateMJAIAgentRelationship(
        @Arg('input', () => UpdateMJAIAgentRelationshipInput) input: UpdateMJAIAgentRelationshipInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Relationships', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRelationship_)
    async DeleteMJAIAgentRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Relationships', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Run Medias
//****************************************************************************
@ObjectType()
export class MJAIAgentRunMedia_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AgentRunID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SourcePromptRunMediaID?: string;
        
    @Field() 
    @MaxLength(16)
    ModalityID: string;
        
    @Field() 
    @MaxLength(200)
    MimeType: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FileName?: string;
        
    @Field(() => Int, {nullable: true}) 
    FileSizeBytes?: number;
        
    @Field(() => Int, {nullable: true}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true}) 
    Height?: number;
        
    @Field(() => Float, {nullable: true}) 
    DurationSeconds?: number;
        
    @Field({nullable: true}) 
    InlineData?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    FileID?: string;
        
    @Field({nullable: true}) 
    ThumbnailBase64?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Label?: string;
        
    @Field({nullable: true}) 
    Metadata?: string;
        
    @Field(() => Int) 
    DisplayOrder: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Agent notes describing what this media represents. Used for internal tracking and can be displayed in UI.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourcePromptRunMedia?: string;
        
    @Field() 
    @MaxLength(100)
    Modality: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    File?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Medias
//****************************************************************************
@InputType()
export class CreateMJAIAgentRunMediaInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field({ nullable: true })
    SourcePromptRunMediaID: string | null;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field({ nullable: true })
    FileID: string | null;

    @Field({ nullable: true })
    ThumbnailBase64: string | null;

    @Field({ nullable: true })
    Label: string | null;

    @Field({ nullable: true })
    Metadata: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Medias
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRunMediaInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field({ nullable: true })
    SourcePromptRunMediaID?: string | null;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field({ nullable: true })
    FileID?: string | null;

    @Field({ nullable: true })
    ThumbnailBase64?: string | null;

    @Field({ nullable: true })
    Label?: string | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Run Medias
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRunMediaViewResult {
    @Field(() => [MJAIAgentRunMedia_])
    Results: MJAIAgentRunMedia_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRunMedia_)
export class MJAIAgentRunMediaResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRunMediaViewResult)
    async RunMJAIAgentRunMediaViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunMediaViewResult)
    async RunMJAIAgentRunMediaViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunMediaViewResult)
    async RunMJAIAgentRunMediaDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Run Medias';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRunMedia_, { nullable: true })
    async MJAIAgentRunMedia(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRunMedia_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunMedias] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentRunMedia_)
    async CreateMJAIAgentRunMedia(
        @Arg('input', () => CreateMJAIAgentRunMediaInput) input: CreateMJAIAgentRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Run Medias', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRunMedia_)
    async UpdateMJAIAgentRunMedia(
        @Arg('input', () => UpdateMJAIAgentRunMediaInput) input: UpdateMJAIAgentRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Run Medias', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRunMedia_)
    async DeleteMJAIAgentRunMedia(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Run Medias', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Run Steps
//****************************************************************************
@ObjectType({ description: `Provides basic, step-by-step tracking of agent execution. Each step represents a discrete action within an agent run, such as prompt execution, tool usage, decision making, or sub-agent coordination.` })
export class MJAIAgentRunStep_ {
    @Field({description: `Unique identifier for this execution step`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the parent AIAgentRun that contains this step`}) 
    @MaxLength(16)
    AgentRunID: string;
        
    @Field(() => Int, {description: `Sequential number of this step within the agent run, starting from 1`}) 
    StepNumber: number;
        
    @Field({description: `Type of execution step: Prompt, Actions, Sub-Agent, Decision, Chat, Validation`}) 
    @MaxLength(100)
    StepType: string;
        
    @Field({description: `Human-readable name of what this step accomplishes`}) 
    @MaxLength(510)
    StepName: string;
        
    @Field({nullable: true, description: `ID of the specific target being executed (AIPrompt.ID, AIAction.ID, AIAgent.ID, etc.). NULL for steps that don't target a specific entity.`}) 
    @MaxLength(16)
    TargetID?: string;
        
    @Field({description: `Current execution status of this step: Running, Completed, Failed, Cancelled`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `Timestamp when this step began execution`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when this step completed. NULL while still running.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Whether this step completed successfully. NULL while running, TRUE/FALSE when completed.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if this step failed. NULL for successful steps.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON serialization of input data passed to this step for execution`}) 
    InputData?: string;
        
    @Field({nullable: true, description: `JSON serialization of the output data produced by this step`}) 
    OutputData?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `ID of the execution log/run record created for this step (ActionExecutionLog.ID for action steps, AIAgentRun.ID for subagent steps, AIPromptRun.ID for prompt steps)`}) 
    @MaxLength(16)
    TargetLogID?: string;
        
    @Field({nullable: true, description: `JSON serialization of the Payload state at the start of this step`}) 
    PayloadAtStart?: string;
        
    @Field({nullable: true, description: `JSON serialization of the Payload state at the end of this step`}) 
    PayloadAtEnd?: string;
        
    @Field({nullable: true, description: `Result of the final payload validation for this step. Pass indicates successful
validation, Retry means validation failed but will retry, Fail means validation failed
permanently, Warn means validation failed but execution continues.`}) 
    @MaxLength(50)
    FinalPayloadValidationResult?: string;
        
    @Field({nullable: true, description: `Validation error messages or warnings from final payload validation. Contains
detailed information about what validation rules failed.`}) 
    FinalPayloadValidationMessages?: string;
        
    @Field({nullable: true, description: `Optional reference to parent step for tracking hierarchical relationships like code->test->fix->code cycles`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this agent run step`}) 
    Comments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAIAgentRunStep_])
    MJ_AIAgentRunSteps_ParentIDArray: MJAIAgentRunStep_[]; // Link to MJ_AIAgentRunSteps
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Steps
//****************************************************************************
@InputType()
export class CreateMJAIAgentRunStepInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field(() => Int, { nullable: true })
    StepNumber?: number;

    @Field({ nullable: true })
    StepType?: string;

    @Field({ nullable: true })
    StepName?: string;

    @Field({ nullable: true })
    TargetID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    InputData: string | null;

    @Field({ nullable: true })
    OutputData: string | null;

    @Field({ nullable: true })
    TargetLogID: string | null;

    @Field({ nullable: true })
    PayloadAtStart: string | null;

    @Field({ nullable: true })
    PayloadAtEnd: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationResult: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMessages: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Run Steps
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRunStepInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentRunID?: string;

    @Field(() => Int, { nullable: true })
    StepNumber?: number;

    @Field({ nullable: true })
    StepType?: string;

    @Field({ nullable: true })
    StepName?: string;

    @Field({ nullable: true })
    TargetID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    InputData?: string | null;

    @Field({ nullable: true })
    OutputData?: string | null;

    @Field({ nullable: true })
    TargetLogID?: string | null;

    @Field({ nullable: true })
    PayloadAtStart?: string | null;

    @Field({ nullable: true })
    PayloadAtEnd?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationResult?: string | null;

    @Field({ nullable: true })
    FinalPayloadValidationMessages?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Run Steps
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRunStepViewResult {
    @Field(() => [MJAIAgentRunStep_])
    Results: MJAIAgentRunStep_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRunStep_)
export class MJAIAgentRunStepResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRunStepViewResult)
    async RunMJAIAgentRunStepViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunStepViewResult)
    async RunMJAIAgentRunStepViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunStepViewResult)
    async RunMJAIAgentRunStepDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Run Steps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRunStep_, { nullable: true })
    async MJAIAgentRunStep(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRunStep_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunSteps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRunStep_])
    async MJ_AIAgentRunSteps_ParentIDArray(@Root() mjaiagentrunstep_: MJAIAgentRunStep_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunSteps] WHERE [ParentID]='${mjaiagentrunstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentRunStep_)
    async CreateMJAIAgentRunStep(
        @Arg('input', () => CreateMJAIAgentRunStepInput) input: CreateMJAIAgentRunStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Run Steps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRunStep_)
    async UpdateMJAIAgentRunStep(
        @Arg('input', () => UpdateMJAIAgentRunStepInput) input: UpdateMJAIAgentRunStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Run Steps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRunStep_)
    async DeleteMJAIAgentRunStep(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Run Steps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Runs
//****************************************************************************
@ObjectType({ description: `Tracks individual execution runs of AI agents, including hierarchical sub-agent runs. Provides basic logging, state persistence, and resource tracking for agent executions. Supports pause/resume functionality through state serialization.` })
export class MJAIAgentRun_ {
    @Field({description: `Unique identifier for this agent run`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the AIAgent that is being executed in this run`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({nullable: true, description: `Reference to the parent agent run if this is a sub-agent execution. NULL for root-level agent runs. Enables hierarchical execution tracking.`}) 
    @MaxLength(16)
    ParentRunID?: string;
        
    @Field({description: `Current status of the agent run. Running -> Completed/Failed/Cancelled`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `Timestamp when the agent run began execution`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the agent run completed (successfully or with failure). NULL while running.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether the agent run completed successfully. NULL while running, TRUE/FALSE when completed.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if the agent run failed. NULL for successful runs.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `Identifier linking multiple agent runs that are part of the same conversation or user session`}) 
    @MaxLength(16)
    ConversationID?: string;
        
    @Field({nullable: true, description: `User context identifier for authentication and permissions during the agent run`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Final result or output from the agent execution, stored as JSON or text`}) 
    Result?: string;
        
    @Field({nullable: true, description: `JSON serialization of the complete agent state, including conversation context, variables, and execution state. Enables pause/resume functionality.`}) 
    AgentState?: string;
        
    @Field(() => Int, {nullable: true, description: `Total number of tokens consumed by all LLM calls during this agent run`}) 
    TotalTokensUsed?: number;
        
    @Field(() => Float, {nullable: true, description: `Total estimated cost for all AI model usage during this agent run`}) 
    TotalCost?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Total number of prompt/input tokens used across all AIPromptRun executions during this agent run. This provides a breakdown of the TotalTokensUsed field to help analyze the ratio of input vs output tokens consumed by the agent.`}) 
    TotalPromptTokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of completion/output tokens generated across all AIPromptRun executions during this agent run. This provides a breakdown of the TotalTokensUsed field to help analyze the ratio of input vs output tokens consumed by the agent.`}) 
    TotalCompletionTokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Total tokens used including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalTokensUsed. For parent agents, this includes the sum of all descendant agent tokens. Calculated as TotalPromptTokensUsedRollup + TotalCompletionTokensUsedRollup.`}) 
    TotalTokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total prompt/input tokens including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalPromptTokensUsed. For parent agents, this includes the sum of all descendant agent prompt tokens.`}) 
    TotalPromptTokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total completion/output tokens including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalCompletionTokensUsed. For parent agents, this includes the sum of all descendant agent completion tokens.`}) 
    TotalCompletionTokensUsedRollup?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost including this agent run and all sub-agent runs. For leaf agents (no sub-agents), this equals TotalCost. For parent agents, this includes the sum of all descendant agent costs. Note: This assumes all costs are in the same currency for accurate rollup.`}) 
    TotalCostRollup?: number;
        
    @Field({nullable: true, description: `Optional tracking of a specific conversation detail (e.g. a specific message) that spawned this agent run`}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field(() => Int, {nullable: true, description: `If a conversation detail spawned multiple agent runs, tracks the order of their spawn/execution`}) 
    ConversationDetailSequence?: number;
        
    @Field({nullable: true, description: `Reason for cancellation if the agent run was cancelled`}) 
    @MaxLength(60)
    CancellationReason?: string;
        
    @Field({nullable: true, description: `The final step type that concluded the agent run`}) 
    @MaxLength(60)
    FinalStep?: string;
        
    @Field({nullable: true, description: `JSON serialization of the final Payload state at the end of the agent run`}) 
    FinalPayload?: string;
        
    @Field({nullable: true, description: `Final message from the agent to the end user at the end of a run`}) 
    Message?: string;
        
    @Field({nullable: true, description: `Links to the previous run in a chain. Different from ParentRunID which is for sub-agent hierarchy.`}) 
    @MaxLength(16)
    LastRunID?: string;
        
    @Field({nullable: true, description: `The initial payload provided at the start of this run. Can be populated from the FinalPayload of the LastRun.`}) 
    StartingPayload?: string;
        
    @Field(() => Int, {description: `Total number of prompt iterations executed during this agent run. Incremented
each time the agent processes a prompt step.`}) 
    TotalPromptIterations: number;
        
    @Field({nullable: true, description: `The AI Configuration used for this agent execution. When set, this configuration was used for all prompts executed by this agent and its sub-agents.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field({nullable: true, description: `Runtime model override that was used for this execution. When set, this model took precedence over all other model selection methods.`}) 
    @MaxLength(16)
    OverrideModelID?: string;
        
    @Field({nullable: true, description: `Runtime vendor override that was used for this execution. When set along with OverrideModelID, this vendor was used to provide the model.`}) 
    @MaxLength(16)
    OverrideVendorID?: string;
        
    @Field({nullable: true, description: `JSON serialized data that was passed for template rendering and prompt execution. This data was passed to the agent's prompt as well as all sub-agents.`}) 
    Data?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether verbose logging was enabled during this agent execution. When true, detailed decision-making and execution flow was logged.`}) 
    Verbose?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Effort level that was actually used during this agent run execution (1-100, where 1=minimal effort, 100=maximum effort). This is the resolved effort level after applying the precedence hierarchy: runtime override > agent default > prompt defaults.`}) 
    EffortLevel?: number;
        
    @Field({nullable: true, description: `Optional name for the agent run to help identify and tag runs for easier reference`}) 
    @MaxLength(510)
    RunName?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this agent run`}) 
    Comments?: string;
        
    @Field({nullable: true, description: `Links to the scheduled job run that triggered this agent execution. NULL for manually-triggered agent runs. Enables tracking which scheduled jobs spawned which agent executions.`}) 
    @MaxLength(16)
    ScheduledJobRunID?: string;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this agent run to a test run if this execution was part of a test. Allows navigation from agent execution to test context.`}) 
    @MaxLength(16)
    TestRunID?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying which entity type is used for primary scoping (e.g., Organizations, Tenants)`}) 
    @MaxLength(16)
    PrimaryScopeEntityID?: string;
        
    @Field({nullable: true, description: `The record ID within the primary scope entity (e.g., the specific OrganizationID). Indexed for fast multi-tenant filtering.`}) 
    @MaxLength(200)
    PrimaryScopeRecordID?: string;
        
    @Field({nullable: true, description: `JSON object containing additional scope dimensions beyond the primary scope. Example: {"ContactID":"abc-123","TeamID":"team-456"}`}) 
    SecondaryScopes?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    ConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LastRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OverrideModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OverrideVendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    ScheduledJobRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TestRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    PrimaryScopeEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootLastRunID?: string;
        
    @Field(() => [MJAIAgentRunStep_])
    MJ_AIAgentRunSteps_AgentRunIDArray: MJAIAgentRunStep_[]; // Link to MJ_AIAgentRunSteps
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_ParentRunIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_SourceAIAgentRunIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_SourceAIAgentRunIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJAIAgentRunMedia_])
    MJ_AIAgentRunMedias_AgentRunIDArray: MJAIAgentRunMedia_[]; // Link to MJ_AIAgentRunMedias
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_AgentRunIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Runs
//****************************************************************************
@InputType()
export class CreateMJAIAgentRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ParentRunID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    Result: string | null;

    @Field({ nullable: true })
    AgentState: string | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsed?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsedRollup: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostRollup: number | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field(() => Int, { nullable: true })
    ConversationDetailSequence: number | null;

    @Field({ nullable: true })
    CancellationReason: string | null;

    @Field({ nullable: true })
    FinalStep: string | null;

    @Field({ nullable: true })
    FinalPayload: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    LastRunID: string | null;

    @Field({ nullable: true })
    StartingPayload: string | null;

    @Field(() => Int, { nullable: true })
    TotalPromptIterations?: number;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    OverrideModelID: string | null;

    @Field({ nullable: true })
    OverrideVendorID: string | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field(() => Boolean, { nullable: true })
    Verbose?: boolean | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;

    @Field({ nullable: true })
    RunName: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ScheduledJobRunID: string | null;

    @Field({ nullable: true })
    TestRunID: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID: string | null;

    @Field({ nullable: true })
    SecondaryScopes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Runs
//****************************************************************************
@InputType()
export class UpdateMJAIAgentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    ParentRunID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    Result?: string | null;

    @Field({ nullable: true })
    AgentState?: string | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsed?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TotalTokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TotalPromptTokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TotalCompletionTokensUsedRollup?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostRollup?: number | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field(() => Int, { nullable: true })
    ConversationDetailSequence?: number | null;

    @Field({ nullable: true })
    CancellationReason?: string | null;

    @Field({ nullable: true })
    FinalStep?: string | null;

    @Field({ nullable: true })
    FinalPayload?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    LastRunID?: string | null;

    @Field({ nullable: true })
    StartingPayload?: string | null;

    @Field(() => Int, { nullable: true })
    TotalPromptIterations?: number;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    OverrideModelID?: string | null;

    @Field({ nullable: true })
    OverrideVendorID?: string | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field(() => Boolean, { nullable: true })
    Verbose?: boolean | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field({ nullable: true })
    RunName?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ScheduledJobRunID?: string | null;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeEntityID?: string | null;

    @Field({ nullable: true })
    PrimaryScopeRecordID?: string | null;

    @Field({ nullable: true })
    SecondaryScopes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Runs
//****************************************************************************
@ObjectType()
export class RunMJAIAgentRunViewResult {
    @Field(() => [MJAIAgentRun_])
    Results: MJAIAgentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentRun_)
export class MJAIAgentRunResolver extends ResolverBase {
    @Query(() => RunMJAIAgentRunViewResult)
    async RunMJAIAgentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunViewResult)
    async RunMJAIAgentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentRunViewResult)
    async RunMJAIAgentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentRun_, { nullable: true })
    async MJAIAgentRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentRun_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRunStep_])
    async MJ_AIAgentRunSteps_AgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunSteps] WHERE [AgentRunID]='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Steps', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_ParentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ParentRunID]='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_SourceAIAgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [SourceAIAgentRunID]='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_SourceAIAgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [SourceAIAgentRunID]='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJ_AIAgentRunMedias_AgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunMedias] WHERE [AgentRunID]='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_AgentRunIDArray(@Root() mjaiagentrun_: MJAIAgentRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [AgentRunID]='${mjaiagentrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentRun_)
    async CreateMJAIAgentRun(
        @Arg('input', () => CreateMJAIAgentRunInput) input: CreateMJAIAgentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentRun_)
    async UpdateMJAIAgentRun(
        @Arg('input', () => UpdateMJAIAgentRunInput) input: UpdateMJAIAgentRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentRun_)
    async DeleteMJAIAgentRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Step Paths
//****************************************************************************
@ObjectType({ description: `Defines paths (edges) between steps in a flow-based AI agent execution graph` })
export class MJAIAgentStepPath_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    OriginStepID: string;
        
    @Field() 
    @MaxLength(16)
    DestinationStepID: string;
        
    @Field({nullable: true, description: `Boolean expression to evaluate. If null, path is always taken. Evaluated against payload and step results.`}) 
    Condition?: string;
        
    @Field(() => Int, {description: `Path evaluation priority. Higher values are evaluated first. Use 0 or negative values for default/fallback paths that execute when no other conditions match.`}) 
    Priority: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Description?: string;
        
    @Field({nullable: true}) 
    PathPoints?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    OriginStep: string;
        
    @Field() 
    @MaxLength(510)
    DestinationStep: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Step Paths
//****************************************************************************
@InputType()
export class CreateMJAIAgentStepPathInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    OriginStepID?: string;

    @Field({ nullable: true })
    DestinationStepID?: string;

    @Field({ nullable: true })
    Condition: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    PathPoints: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Step Paths
//****************************************************************************
@InputType()
export class UpdateMJAIAgentStepPathInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    OriginStepID?: string;

    @Field({ nullable: true })
    DestinationStepID?: string;

    @Field({ nullable: true })
    Condition?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    PathPoints?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Step Paths
//****************************************************************************
@ObjectType()
export class RunMJAIAgentStepPathViewResult {
    @Field(() => [MJAIAgentStepPath_])
    Results: MJAIAgentStepPath_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentStepPath_)
export class MJAIAgentStepPathResolver extends ResolverBase {
    @Query(() => RunMJAIAgentStepPathViewResult)
    async RunMJAIAgentStepPathViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepPathViewResult)
    async RunMJAIAgentStepPathViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepPathViewResult)
    async RunMJAIAgentStepPathDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Step Paths';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentStepPath_, { nullable: true })
    async MJAIAgentStepPath(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentStepPath_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentStepPaths] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIAgentStepPath_)
    async CreateMJAIAgentStepPath(
        @Arg('input', () => CreateMJAIAgentStepPathInput) input: CreateMJAIAgentStepPathInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Step Paths', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentStepPath_)
    async UpdateMJAIAgentStepPath(
        @Arg('input', () => UpdateMJAIAgentStepPathInput) input: UpdateMJAIAgentStepPathInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Step Paths', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentStepPath_)
    async DeleteMJAIAgentStepPath(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Step Paths', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Steps
//****************************************************************************
@ObjectType({ description: `Defines individual steps (nodes) in a flow-based AI agent execution graph` })
export class MJAIAgentStep_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AgentID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Type of step: Action (execute an action), Sub-Agent (delegate to another agent), or Prompt (run an AI prompt)`}) 
    @MaxLength(40)
    StepType: string;
        
    @Field(() => Boolean, {description: `If true, this step is executed when the agent starts`}) 
    StartingStep: boolean;
        
    @Field(() => Int, {nullable: true}) 
    TimeoutSeconds?: number;
        
    @Field(() => Int) 
    RetryCount: number;
        
    @Field() 
    @MaxLength(40)
    OnErrorBehavior: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ActionID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SubAgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    PromptID?: string;
        
    @Field({nullable: true, description: `JSON configuration for mapping action output parameters to payload paths. Example: {"outputParam1": "payload.customer.status", "*": "payload.lastResult"}`}) 
    ActionOutputMapping?: string;
        
    @Field(() => Int) 
    PositionX: number;
        
    @Field(() => Int) 
    PositionY: number;
        
    @Field(() => Int) 
    Width: number;
        
    @Field(() => Int) 
    Height: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Controls whether this step is executed. Active=normal execution, Pending=skip but may activate later, Disabled=never execute`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON configuration for mapping static values or payload paths to action input parameters. Example: {"param1": "staticValue", "param2": "payload.dynamicValue"}`}) 
    ActionInputMapping?: string;
        
    @Field({nullable: true, description: `Specifies what type of operation executes in the loop body. Values: Action, Sub-Agent, Prompt. Only used when StepType is ForEach or While.`}) 
    @MaxLength(100)
    LoopBodyType?: string;
        
    @Field({nullable: true, description: `JSON configuration object for step-specific settings. For loop steps: { type: "ForEach"|"While", collectionPath?, itemVariable?, indexVariable?, maxIterations?, continueOnError?, condition? }. For other step types: reserved for future use.`}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Action?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SubAgent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Prompt?: string;
        
    @Field(() => [MJAIAgentStepPath_])
    MJ_AIAgentStepPaths_DestinationStepIDArray: MJAIAgentStepPath_[]; // Link to MJ_AIAgentStepPaths
    
    @Field(() => [MJAIAgentStepPath_])
    MJ_AIAgentStepPaths_OriginStepIDArray: MJAIAgentStepPath_[]; // Link to MJ_AIAgentStepPaths
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Steps
//****************************************************************************
@InputType()
export class CreateMJAIAgentStepInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    StepType?: string;

    @Field(() => Boolean, { nullable: true })
    StartingStep?: boolean;

    @Field(() => Int, { nullable: true })
    TimeoutSeconds?: number | null;

    @Field(() => Int, { nullable: true })
    RetryCount?: number;

    @Field({ nullable: true })
    OnErrorBehavior?: string;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    SubAgentID: string | null;

    @Field({ nullable: true })
    PromptID: string | null;

    @Field({ nullable: true })
    ActionOutputMapping: string | null;

    @Field(() => Int, { nullable: true })
    PositionX?: number;

    @Field(() => Int, { nullable: true })
    PositionY?: number;

    @Field(() => Int, { nullable: true })
    Width?: number;

    @Field(() => Int, { nullable: true })
    Height?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActionInputMapping: string | null;

    @Field({ nullable: true })
    LoopBodyType: string | null;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Steps
//****************************************************************************
@InputType()
export class UpdateMJAIAgentStepInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    StepType?: string;

    @Field(() => Boolean, { nullable: true })
    StartingStep?: boolean;

    @Field(() => Int, { nullable: true })
    TimeoutSeconds?: number | null;

    @Field(() => Int, { nullable: true })
    RetryCount?: number;

    @Field({ nullable: true })
    OnErrorBehavior?: string;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    SubAgentID?: string | null;

    @Field({ nullable: true })
    PromptID?: string | null;

    @Field({ nullable: true })
    ActionOutputMapping?: string | null;

    @Field(() => Int, { nullable: true })
    PositionX?: number;

    @Field(() => Int, { nullable: true })
    PositionY?: number;

    @Field(() => Int, { nullable: true })
    Width?: number;

    @Field(() => Int, { nullable: true })
    Height?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActionInputMapping?: string | null;

    @Field({ nullable: true })
    LoopBodyType?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Steps
//****************************************************************************
@ObjectType()
export class RunMJAIAgentStepViewResult {
    @Field(() => [MJAIAgentStep_])
    Results: MJAIAgentStep_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentStep_)
export class MJAIAgentStepResolver extends ResolverBase {
    @Query(() => RunMJAIAgentStepViewResult)
    async RunMJAIAgentStepViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepViewResult)
    async RunMJAIAgentStepViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentStepViewResult)
    async RunMJAIAgentStepDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Steps';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentStep_, { nullable: true })
    async MJAIAgentStep(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentStep_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Steps', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentSteps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Steps', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Steps', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentStepPath_])
    async MJ_AIAgentStepPaths_DestinationStepIDArray(@Root() mjaiagentstep_: MJAIAgentStep_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentStepPaths] WHERE [DestinationStepID]='${mjaiagentstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentStepPath_])
    async MJ_AIAgentStepPaths_OriginStepIDArray(@Root() mjaiagentstep_: MJAIAgentStep_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Step Paths', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentStepPaths] WHERE [OriginStepID]='${mjaiagentstep_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Step Paths', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Step Paths', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentStep_)
    async CreateMJAIAgentStep(
        @Arg('input', () => CreateMJAIAgentStepInput) input: CreateMJAIAgentStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Steps', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentStep_)
    async UpdateMJAIAgentStep(
        @Arg('input', () => UpdateMJAIAgentStepInput) input: UpdateMJAIAgentStepInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Steps', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentStep_)
    async DeleteMJAIAgentStep(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Steps', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Agent Types
//****************************************************************************
@ObjectType({ description: `Defines types of AI agents with their system prompts and behavioral characteristics. Each agent type represents a category of agents that share common system-level instructions and capabilities.` })
export class MJAIAgentType_ {
    @Field({description: `Unique identifier for the agent type`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name of the agent type (e.g., "Base", "CustomerSupport", "DataAnalysis"). Used for programmatic identification and factory instantiation.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the agent type, its purpose, and typical use cases`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Reference to the AI Prompt that contains the system-level instructions for all agents of this type. This prompt will be blended with individual agent prompts.`}) 
    @MaxLength(16)
    SystemPromptID?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this agent type is available for use. Inactive types cannot be assigned to new agents.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The placeholder name used in the system prompt template where the agent prompt result should be injected. For example, if the system prompt contains "{{ agentPrompt }}", this field should contain "agentPrompt". This enables proper hierarchical prompt execution where the agent type's system prompt acts as the parent and the agent's specific prompt acts as the child.`}) 
    @MaxLength(510)
    AgentPromptPlaceholder?: string;
        
    @Field({nullable: true, description: `The class name used by the MemberJunction class factory to instantiate the specific agent type implementation. For example, "LoopAgentType" for a looping agent pattern. If not specified, defaults to using the agent type Name for the DriverClass lookup key.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Optional Angular component key name for a subclass of BaseFormSectionComponent that provides a custom form section for this agent type. When specified, this component will be dynamically loaded and displayed as the first expandable section in the AI Agent form. This allows agent types to have specialized UI elements. The class must be registered with the MemberJunction class factory via @RegisterClass`}) 
    @MaxLength(1000)
    UIFormSectionKey?: string;
        
    @Field({nullable: true, description: `Optional Angular component key name for a subclass of BaseFormComponent that will completely overrides the default AI Agent form for this agent type. When specified, this component will be used instead of the standard AI Agent form, allowing for completely custom form implementations. The class must be registered with the MemberJunction class factory via @RegisterClass. If both UIFormClass and UIFormSectionClass are specified, UIFormClass takes precedence.`}) 
    @MaxLength(1000)
    UIFormKey?: string;
        
    @Field(() => Boolean, {description: `Determines whether the custom form section (specified by UIFormSectionClass) should be expanded by default when the AI Agent form loads. True means the section starts expanded, False means it starts collapsed. Only applies when UIFormSectionClass is specified. Defaults to 1 (expanded).`}) 
    UIFormSectionExpandedByDefault: boolean;
        
    @Field({nullable: true, description: `JSON Schema defining the available prompt parameters for this agent type. Includes property definitions with types, defaults, and descriptions. Used by agents of this type to customize which prompt sections are included in the system prompt. The schema follows JSON Schema draft-07 format.`}) 
    PromptParamsSchema?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SystemPrompt?: string;
        
    @Field(() => [MJAIAgent_])
    AIAgents_TypeIDArray: MJAIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Types
//****************************************************************************
@InputType()
export class CreateMJAIAgentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SystemPromptID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    AgentPromptPlaceholder: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    UIFormSectionKey: string | null;

    @Field({ nullable: true })
    UIFormKey: string | null;

    @Field(() => Boolean, { nullable: true })
    UIFormSectionExpandedByDefault?: boolean;

    @Field({ nullable: true })
    PromptParamsSchema: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Agent Types
//****************************************************************************
@InputType()
export class UpdateMJAIAgentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SystemPromptID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    AgentPromptPlaceholder?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    UIFormSectionKey?: string | null;

    @Field({ nullable: true })
    UIFormKey?: string | null;

    @Field(() => Boolean, { nullable: true })
    UIFormSectionExpandedByDefault?: boolean;

    @Field({ nullable: true })
    PromptParamsSchema?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Agent Types
//****************************************************************************
@ObjectType()
export class RunMJAIAgentTypeViewResult {
    @Field(() => [MJAIAgentType_])
    Results: MJAIAgentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIAgentType_)
export class MJAIAgentTypeResolver extends ResolverBase {
    @Query(() => RunMJAIAgentTypeViewResult)
    async RunMJAIAgentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentTypeViewResult)
    async RunMJAIAgentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIAgentTypeViewResult)
    async RunMJAIAgentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Agent Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIAgentType_, { nullable: true })
    async MJAIAgentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIAgentType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Agent Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Agent Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgent_])
    async AIAgents_TypeIDArray(@Root() mjaiagenttype_: MJAIAgentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [TypeID]='${mjaiagenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIAgentType_)
    async CreateMJAIAgentType(
        @Arg('input', () => CreateMJAIAgentTypeInput) input: CreateMJAIAgentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Agent Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIAgentType_)
    async UpdateMJAIAgentType(
        @Arg('input', () => UpdateMJAIAgentTypeInput) input: UpdateMJAIAgentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Agent Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIAgentType_)
    async DeleteMJAIAgentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Agent Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Architectures
//****************************************************************************
@ObjectType({ description: `Master table of AI model architectures (Transformer, Diffusion, MoE, etc.) for model catalog enrichment and eval reporting.` })
export class MJAIArchitecture_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(100)
    Category: string;
        
    @Field({nullable: true, description: `Hierarchical relationship to parent architecture. Used for variants like Sparse Transformer being a child of Transformer.`}) 
    @MaxLength(16)
    ParentArchitectureID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    WikipediaURL?: string;
        
    @Field(() => Int, {nullable: true}) 
    YearIntroduced?: number;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    KeyPaper?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ParentArchitecture?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentArchitectureID?: string;
        
    @Field(() => [MJAIArchitecture_])
    MJ_AIArchitectures_ParentArchitectureIDArray: MJAIArchitecture_[]; // Link to MJ_AIArchitectures
    
    @Field(() => [MJAIModelArchitecture_])
    MJ_AIModelArchitectures_ArchitectureIDArray: MJAIModelArchitecture_[]; // Link to MJ_AIModelArchitectures
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Architectures
//****************************************************************************
@InputType()
export class CreateMJAIArchitectureInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    ParentArchitectureID: string | null;

    @Field({ nullable: true })
    WikipediaURL: string | null;

    @Field(() => Int, { nullable: true })
    YearIntroduced: number | null;

    @Field({ nullable: true })
    KeyPaper: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Architectures
//****************************************************************************
@InputType()
export class UpdateMJAIArchitectureInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    ParentArchitectureID?: string | null;

    @Field({ nullable: true })
    WikipediaURL?: string | null;

    @Field(() => Int, { nullable: true })
    YearIntroduced?: number | null;

    @Field({ nullable: true })
    KeyPaper?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Architectures
//****************************************************************************
@ObjectType()
export class RunMJAIArchitectureViewResult {
    @Field(() => [MJAIArchitecture_])
    Results: MJAIArchitecture_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIArchitecture_)
export class MJAIArchitectureResolver extends ResolverBase {
    @Query(() => RunMJAIArchitectureViewResult)
    async RunMJAIArchitectureViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIArchitectureViewResult)
    async RunMJAIArchitectureViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIArchitectureViewResult)
    async RunMJAIArchitectureDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Architectures';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIArchitecture_, { nullable: true })
    async MJAIArchitecture(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIArchitecture_ | null> {
        this.CheckUserReadPermissions('MJ: AI Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIArchitectures] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Architectures', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIArchitecture_])
    async MJ_AIArchitectures_ParentArchitectureIDArray(@Root() mjaiarchitecture_: MJAIArchitecture_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIArchitectures] WHERE [ParentArchitectureID]='${mjaiarchitecture_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Architectures', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelArchitecture_])
    async MJ_AIModelArchitectures_ArchitectureIDArray(@Root() mjaiarchitecture_: MJAIArchitecture_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelArchitectures] WHERE [ArchitectureID]='${mjaiarchitecture_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Architectures', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIArchitecture_)
    async CreateMJAIArchitecture(
        @Arg('input', () => CreateMJAIArchitectureInput) input: CreateMJAIArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Architectures', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIArchitecture_)
    async UpdateMJAIArchitecture(
        @Arg('input', () => UpdateMJAIArchitectureInput) input: UpdateMJAIArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Architectures', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIArchitecture_)
    async DeleteMJAIArchitecture(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Architectures', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Configuration Params
//****************************************************************************
@ObjectType({ description: `Stores configuration parameters that can be referenced by prompts and used to control execution behavior.` })
export class MJAIConfigurationParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConfigurationID: string;
        
    @Field({description: `The name of the configuration parameter.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The data type of the parameter (string, number, boolean, date, object).`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `The value of the parameter, stored as a string but interpreted according to the Type.`}) 
    Value: string;
        
    @Field({nullable: true, description: `Detailed description of the parameter and its usage.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Configuration: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Configuration Params
//****************************************************************************
@InputType()
export class CreateMJAIConfigurationParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConfigurationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Configuration Params
//****************************************************************************
@InputType()
export class UpdateMJAIConfigurationParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConfigurationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Configuration Params
//****************************************************************************
@ObjectType()
export class RunMJAIConfigurationParamViewResult {
    @Field(() => [MJAIConfigurationParam_])
    Results: MJAIConfigurationParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIConfigurationParam_)
export class MJAIConfigurationParamResolver extends ResolverBase {
    @Query(() => RunMJAIConfigurationParamViewResult)
    async RunMJAIConfigurationParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationParamViewResult)
    async RunMJAIConfigurationParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationParamViewResult)
    async RunMJAIConfigurationParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Configuration Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIConfigurationParam_, { nullable: true })
    async MJAIConfigurationParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIConfigurationParam_ | null> {
        this.CheckUserReadPermissions('MJ: AI Configuration Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurationParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configuration Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Configuration Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIConfigurationParam_)
    async CreateMJAIConfigurationParam(
        @Arg('input', () => CreateMJAIConfigurationParamInput) input: CreateMJAIConfigurationParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Configuration Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIConfigurationParam_)
    async UpdateMJAIConfigurationParam(
        @Arg('input', () => UpdateMJAIConfigurationParamInput) input: UpdateMJAIConfigurationParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Configuration Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIConfigurationParam_)
    async DeleteMJAIConfigurationParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Configuration Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Configurations
//****************************************************************************
@ObjectType({ description: `Stores configurations for AI prompt execution environments and settings.` })
export class MJAIConfiguration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The name of the configuration.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the configuration.`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this is the default configuration to use when none is specified.`}) 
    IsDefault: boolean;
        
    @Field({description: `The current status of the configuration. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Default prompt to use for context compression when not specified at the agent level.`}) 
    @MaxLength(16)
    DefaultPromptForContextCompressionID?: string;
        
    @Field({nullable: true, description: `Default prompt to use for context summarization when not specified at the agent level.`}) 
    @MaxLength(16)
    DefaultPromptForContextSummarizationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Default file storage provider for agent attachments. Used when an agent does not specify its own AttachmentStorageProviderID.`}) 
    @MaxLength(16)
    DefaultStorageProviderID?: string;
        
    @Field({nullable: true, description: `Default root path within the storage provider for agent attachments. Used when an agent does not specify its own AttachmentRootPath.`}) 
    @MaxLength(1000)
    DefaultStorageRootPath?: string;
        
    @Field({nullable: true, description: `Optional reference to a parent configuration. When set, this configuration inherits prompt-model mappings and parameters from its parent. Child configurations can override specific settings while inheriting defaults from the parent chain. Supports N-level deep inheritance.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultPromptForContextCompression?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultPromptForContextSummarization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DefaultStorageProvider?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAIConfigurationParam_])
    MJ_AIConfigurationParams_ConfigurationIDArray: MJAIConfigurationParam_[]; // Link to MJ_AIConfigurationParams
    
    @Field(() => [MJAIAgentPrompt_])
    MJ_AIAgentPrompts_ConfigurationIDArray: MJAIAgentPrompt_[]; // Link to MJ_AIAgentPrompts
    
    @Field(() => [MJAIAgentConfiguration_])
    MJ_AIAgentConfigurations_AIConfigurationIDArray: MJAIAgentConfiguration_[]; // Link to MJ_AIAgentConfigurations
    
    @Field(() => [MJAIPromptModel_])
    MJ_AIPromptModels_ConfigurationIDArray: MJAIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [MJAIResultCache_])
    AIResultCache_ConfigurationIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_ConfigurationIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_ConfigurationIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJAIConfiguration_])
    MJ_AIConfigurations_ParentIDArray: MJAIConfiguration_[]; // Link to MJ_AIConfigurations
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Configurations
//****************************************************************************
@InputType()
export class CreateMJAIConfigurationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DefaultPromptForContextCompressionID: string | null;

    @Field({ nullable: true })
    DefaultPromptForContextSummarizationID: string | null;

    @Field({ nullable: true })
    DefaultStorageProviderID: string | null;

    @Field({ nullable: true })
    DefaultStorageRootPath: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Configurations
//****************************************************************************
@InputType()
export class UpdateMJAIConfigurationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DefaultPromptForContextCompressionID?: string | null;

    @Field({ nullable: true })
    DefaultPromptForContextSummarizationID?: string | null;

    @Field({ nullable: true })
    DefaultStorageProviderID?: string | null;

    @Field({ nullable: true })
    DefaultStorageRootPath?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Configurations
//****************************************************************************
@ObjectType()
export class RunMJAIConfigurationViewResult {
    @Field(() => [MJAIConfiguration_])
    Results: MJAIConfiguration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIConfiguration_)
export class MJAIConfigurationResolver extends ResolverBase {
    @Query(() => RunMJAIConfigurationViewResult)
    async RunMJAIConfigurationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationViewResult)
    async RunMJAIConfigurationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIConfigurationViewResult)
    async RunMJAIConfigurationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Configurations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIConfiguration_, { nullable: true })
    async MJAIConfiguration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIConfiguration_ | null> {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Configurations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIConfigurationParam_])
    async MJ_AIConfigurationParams_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configuration Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurationParams] WHERE [ConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configuration Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configuration Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPrompt_])
    async MJ_AIAgentPrompts_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPrompts] WHERE [ConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentConfiguration_])
    async MJ_AIAgentConfigurations_AIConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentConfigurations] WHERE [AIConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptModel_])
    async MJ_AIPromptModels_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [ConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [ConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_ConfigurationIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ConfigurationID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIConfiguration_])
    async MJ_AIConfigurations_ParentIDArray(@Root() mjaiconfiguration_: MJAIConfiguration_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Configurations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIConfigurations] WHERE [ParentID]='${mjaiconfiguration_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Configurations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Configurations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIConfiguration_)
    async CreateMJAIConfiguration(
        @Arg('input', () => CreateMJAIConfigurationInput) input: CreateMJAIConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Configurations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIConfiguration_)
    async UpdateMJAIConfiguration(
        @Arg('input', () => UpdateMJAIConfigurationInput) input: UpdateMJAIConfigurationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Configurations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIConfiguration_)
    async DeleteMJAIConfiguration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Configurations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Credential Bindings
//****************************************************************************
@ObjectType({ description: `Junction table that binds credentials to AI entities (Vendors, ModelVendors, PromptModels). Decouples credential assignments from core AI entities to prevent MJ updates from overwriting customer configurations. Supports priority-based failover with multiple credentials per binding level.` })
export class MJAICredentialBinding_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the credential being bound.`}) 
    @MaxLength(16)
    CredentialID: string;
        
    @Field({description: `The type of AI entity this credential is bound to: Vendor (broadest), ModelVendor (model+vendor specific), or PromptModel (most specific). Resolution follows prompt  model  vendor hierarchy.`}) 
    @MaxLength(40)
    BindingType: string;
        
    @Field({nullable: true, description: `Reference to AIVendor when BindingType is Vendor. NULL otherwise.`}) 
    @MaxLength(16)
    AIVendorID?: string;
        
    @Field({nullable: true, description: `Reference to AIModelVendor when BindingType is ModelVendor. NULL otherwise.`}) 
    @MaxLength(16)
    AIModelVendorID?: string;
        
    @Field({nullable: true, description: `Reference to AIPromptModel when BindingType is PromptModel. NULL otherwise.`}) 
    @MaxLength(16)
    AIPromptModelID?: string;
        
    @Field(() => Int, {description: `Priority for credential selection when multiple bindings exist at the same level. Lower values have higher priority (0 is highest). Enables failover when primary credentials are unavailable.`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `When false, this binding is ignored during credential resolution. Allows temporary disabling without deletion.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(400)
    Credential: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    AIVendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    AIModelVendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AIPromptModel?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Credential Bindings
//****************************************************************************
@InputType()
export class CreateMJAICredentialBindingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CredentialID?: string;

    @Field({ nullable: true })
    BindingType?: string;

    @Field({ nullable: true })
    AIVendorID: string | null;

    @Field({ nullable: true })
    AIModelVendorID: string | null;

    @Field({ nullable: true })
    AIPromptModelID: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Credential Bindings
//****************************************************************************
@InputType()
export class UpdateMJAICredentialBindingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CredentialID?: string;

    @Field({ nullable: true })
    BindingType?: string;

    @Field({ nullable: true })
    AIVendorID?: string | null;

    @Field({ nullable: true })
    AIModelVendorID?: string | null;

    @Field({ nullable: true })
    AIPromptModelID?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Credential Bindings
//****************************************************************************
@ObjectType()
export class RunMJAICredentialBindingViewResult {
    @Field(() => [MJAICredentialBinding_])
    Results: MJAICredentialBinding_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAICredentialBinding_)
export class MJAICredentialBindingResolver extends ResolverBase {
    @Query(() => RunMJAICredentialBindingViewResult)
    async RunMJAICredentialBindingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAICredentialBindingViewResult)
    async RunMJAICredentialBindingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAICredentialBindingViewResult)
    async RunMJAICredentialBindingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Credential Bindings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAICredentialBinding_, { nullable: true })
    async MJAICredentialBinding(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAICredentialBinding_ | null> {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAICredentialBindings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAICredentialBinding_)
    async CreateMJAICredentialBinding(
        @Arg('input', () => CreateMJAICredentialBindingInput) input: CreateMJAICredentialBindingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Credential Bindings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAICredentialBinding_)
    async UpdateMJAICredentialBinding(
        @Arg('input', () => UpdateMJAICredentialBindingInput) input: UpdateMJAICredentialBindingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Credential Bindings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAICredentialBinding_)
    async DeleteMJAICredentialBinding(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Credential Bindings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Modalities
//****************************************************************************
@ObjectType({ description: `Master list of AI content modalities (Text, Image, Audio, Video, etc.) that models can accept as input or produce as output. New modalities can be added via INSERT without schema changes.` })
export class MJAIModality_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the modality (e.g., Text, Image, Audio, Video, File, Embedding).`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of this modality and its use cases.`}) 
    @MaxLength(1000)
    Description?: string;
        
    @Field({description: `Maps to ChatMessageContentBlock.type values: text, image_url, video_url, audio_url, file_url, embedding. Must match the TypeScript type definition.`}) 
    @MaxLength(100)
    ContentBlockType: string;
        
    @Field({nullable: true, description: `MIME type pattern for this modality (e.g., image/*, audio/*, video/*, text/*, application/*). Used for file type validation.`}) 
    @MaxLength(200)
    MIMETypePattern?: string;
        
    @Field({description: `Classification type: Content (human-readable text), Structured (JSON/embeddings), Binary (media files like images, audio, video).`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `System-wide default maximum size in bytes for this modality. Can be overridden at model or agent level. NULL means no size limit.`}) 
    DefaultMaxSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `System-wide default maximum count per message for this modality. Can be overridden at model or agent level. NULL means no count limit.`}) 
    DefaultMaxCountPerMessage?: number;
        
    @Field(() => Int, {description: `Display order for UI presentation. Lower numbers appear first.`}) 
    DisplayOrder: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIAgentModality_])
    MJ_AIAgentModalities_ModalityIDArray: MJAIAgentModality_[]; // Link to MJ_AIAgentModalities
    
    @Field(() => [MJAIModelModality_])
    MJ_AIModelModalities_ModalityIDArray: MJAIModelModality_[]; // Link to MJ_AIModelModalities
    
    @Field(() => [MJConversationDetailAttachment_])
    MJ_ConversationDetailAttachments_ModalityIDArray: MJConversationDetailAttachment_[]; // Link to MJ_ConversationDetailAttachments
    
    @Field(() => [MJAIModelType_])
    AIModelTypes_DefaultOutputModalityIDArray: MJAIModelType_[]; // Link to AIModelTypes
    
    @Field(() => [MJAIPromptRunMedia_])
    MJ_AIPromptRunMedias_ModalityIDArray: MJAIPromptRunMedia_[]; // Link to MJ_AIPromptRunMedias
    
    @Field(() => [MJAIModelType_])
    AIModelTypes_DefaultInputModalityIDArray: MJAIModelType_[]; // Link to AIModelTypes
    
    @Field(() => [MJAIAgentRunMedia_])
    MJ_AIAgentRunMedias_ModalityIDArray: MJAIAgentRunMedia_[]; // Link to MJ_AIAgentRunMedias
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Modalities
//****************************************************************************
@InputType()
export class CreateMJAIModalityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentBlockType?: string;

    @Field({ nullable: true })
    MIMETypePattern: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Int, { nullable: true })
    DefaultMaxSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    DefaultMaxCountPerMessage: number | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Modalities
//****************************************************************************
@InputType()
export class UpdateMJAIModalityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentBlockType?: string;

    @Field({ nullable: true })
    MIMETypePattern?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Int, { nullable: true })
    DefaultMaxSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    DefaultMaxCountPerMessage?: number | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Modalities
//****************************************************************************
@ObjectType()
export class RunMJAIModalityViewResult {
    @Field(() => [MJAIModality_])
    Results: MJAIModality_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModality_)
export class MJAIModalityResolver extends ResolverBase {
    @Query(() => RunMJAIModalityViewResult)
    async RunMJAIModalityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModalityViewResult)
    async RunMJAIModalityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModalityViewResult)
    async RunMJAIModalityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Modalities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModality_, { nullable: true })
    async MJAIModality(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModality_ | null> {
        this.CheckUserReadPermissions('MJ: AI Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModalities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Modalities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentModality_])
    async MJ_AIAgentModalities_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModalities] WHERE [ModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelModality_])
    async MJ_AIModelModalities_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelModalities] WHERE [ModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Modalities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailAttachment_])
    async MJ_ConversationDetailAttachments_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailAttachments] WHERE [ModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelType_])
    async AIModelTypes_DefaultOutputModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes] WHERE [DefaultOutputModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Model Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRunMedia_])
    async MJ_AIPromptRunMedias_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRunMedias] WHERE [ModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelType_])
    async AIModelTypes_DefaultInputModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes] WHERE [DefaultInputModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Model Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJ_AIAgentRunMedias_ModalityIDArray(@Root() mjaimodality_: MJAIModality_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunMedias] WHERE [ModalityID]='${mjaimodality_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModality_)
    async CreateMJAIModality(
        @Arg('input', () => CreateMJAIModalityInput) input: CreateMJAIModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Modalities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModality_)
    async UpdateMJAIModality(
        @Arg('input', () => UpdateMJAIModalityInput) input: UpdateMJAIModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Modalities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModality_)
    async DeleteMJAIModality(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Modalities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Architectures
//****************************************************************************
@ObjectType({ description: `Junction table linking AI models to their underlying architectures. Supports multiple architectures per model with ranking.` })
export class MJAIModelArchitecture_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ModelID: string;
        
    @Field() 
    @MaxLength(16)
    ArchitectureID: string;
        
    @Field(() => Int, {description: `Ranking of this architecture for the model. 1=Primary architecture, 2=Secondary, etc. Lower numbers indicate more dominant role.`}) 
    Rank: number;
        
    @Field(() => Float, {nullable: true, description: `Optional weight (0.0-1.0) indicating the mix ratio for hybrid architectures. E.g., 0.7 for 70% contribution.`}) 
    Weight?: number;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    Notes?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(200)
    Architecture: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Architectures
//****************************************************************************
@InputType()
export class CreateMJAIModelArchitectureInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ArchitectureID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field(() => Float, { nullable: true })
    Weight: number | null;

    @Field({ nullable: true })
    Notes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Architectures
//****************************************************************************
@InputType()
export class UpdateMJAIModelArchitectureInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ArchitectureID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field(() => Float, { nullable: true })
    Weight?: number | null;

    @Field({ nullable: true })
    Notes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Architectures
//****************************************************************************
@ObjectType()
export class RunMJAIModelArchitectureViewResult {
    @Field(() => [MJAIModelArchitecture_])
    Results: MJAIModelArchitecture_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelArchitecture_)
export class MJAIModelArchitectureResolver extends ResolverBase {
    @Query(() => RunMJAIModelArchitectureViewResult)
    async RunMJAIModelArchitectureViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelArchitectureViewResult)
    async RunMJAIModelArchitectureViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelArchitectureViewResult)
    async RunMJAIModelArchitectureDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Architectures';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelArchitecture_, { nullable: true })
    async MJAIModelArchitecture(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelArchitecture_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Architectures', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelArchitectures] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Architectures', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Architectures', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelArchitecture_)
    async CreateMJAIModelArchitecture(
        @Arg('input', () => CreateMJAIModelArchitectureInput) input: CreateMJAIModelArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Architectures', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelArchitecture_)
    async UpdateMJAIModelArchitecture(
        @Arg('input', () => UpdateMJAIModelArchitectureInput) input: UpdateMJAIModelArchitectureInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Architectures', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelArchitecture_)
    async DeleteMJAIModelArchitecture(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Architectures', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Costs
//****************************************************************************
@ObjectType({ description: `Stores historical and current pricing information for AI models across different vendors, with optional temporal tracking and support for different processing types` })
export class MJAIModelCost_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ModelID: string;
        
    @Field() 
    @MaxLength(16)
    VendorID: string;
        
    @Field({nullable: true, description: `Date and time with timezone when this pricing became effective. NULL disables temporal tracking. Defaults to current UTC time when record is created`}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Date and time with timezone when this pricing expired or will expire. NULL indicates currently active pricing`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Current status of this pricing record. Active=currently in use, Pending=scheduled for future, Expired=no longer valid, Invalid=data error`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `ISO 4217 three-letter currency code (e.g., USD, EUR, GBP) in uppercase`}) 
    @MaxLength(6)
    Currency: string;
        
    @Field() 
    @MaxLength(16)
    PriceTypeID: string;
        
    @Field(() => Float, {description: `Price per unit for input tokens/requests. Must be non-negative. Precision allows for micro-pricing scenarios`}) 
    InputPricePerUnit: number;
        
    @Field(() => Float, {description: `Price per unit for output tokens/responses. Must be non-negative. Often higher than input pricing`}) 
    OutputPricePerUnit: number;
        
    @Field() 
    @MaxLength(16)
    UnitTypeID: string;
        
    @Field({description: `Processing method that affects pricing. Realtime=immediate response, Batch=delayed processing often with discounts`}) 
    @MaxLength(40)
    ProcessingType: string;
        
    @Field({nullable: true, description: `Optional notes about pricing context, source, special conditions, or vendor-specific details`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field() 
    @MaxLength(200)
    PriceType: string;
        
    @Field() 
    @MaxLength(200)
    UnitType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Costs
//****************************************************************************
@InputType()
export class CreateMJAIModelCostInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Currency?: string;

    @Field({ nullable: true })
    PriceTypeID?: string;

    @Field(() => Float, { nullable: true })
    InputPricePerUnit?: number;

    @Field(() => Float, { nullable: true })
    OutputPricePerUnit?: number;

    @Field({ nullable: true })
    UnitTypeID?: string;

    @Field({ nullable: true })
    ProcessingType?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Costs
//****************************************************************************
@InputType()
export class UpdateMJAIModelCostInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Currency?: string;

    @Field({ nullable: true })
    PriceTypeID?: string;

    @Field(() => Float, { nullable: true })
    InputPricePerUnit?: number;

    @Field(() => Float, { nullable: true })
    OutputPricePerUnit?: number;

    @Field({ nullable: true })
    UnitTypeID?: string;

    @Field({ nullable: true })
    ProcessingType?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Costs
//****************************************************************************
@ObjectType()
export class RunMJAIModelCostViewResult {
    @Field(() => [MJAIModelCost_])
    Results: MJAIModelCost_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelCost_)
export class MJAIModelCostResolver extends ResolverBase {
    @Query(() => RunMJAIModelCostViewResult)
    async RunMJAIModelCostViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelCostViewResult)
    async RunMJAIModelCostViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelCostViewResult)
    async RunMJAIModelCostDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Costs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelCost_, { nullable: true })
    async MJAIModelCost(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelCost_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Costs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelCost_)
    async CreateMJAIModelCost(
        @Arg('input', () => CreateMJAIModelCostInput) input: CreateMJAIModelCostInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Costs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelCost_)
    async UpdateMJAIModelCost(
        @Arg('input', () => UpdateMJAIModelCostInput) input: UpdateMJAIModelCostInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Costs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelCost_)
    async DeleteMJAIModelCost(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Costs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Modalities
//****************************************************************************
@ObjectType({ description: `Junction table linking AI models to their supported input and output modalities with model-specific configuration. Used to extend beyond the default modalities inherited from AIModelType.` })
export class MJAIModelModality_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ModelID: string;
        
    @Field() 
    @MaxLength(16)
    ModalityID: string;
        
    @Field({description: `Whether this is an Input or Output modality for the model.`}) 
    @MaxLength(20)
    Direction: string;
        
    @Field(() => Boolean, {description: `Whether this modality is supported. Can be set to FALSE to explicitly disable an inherited modality.`}) 
    IsSupported: boolean;
        
    @Field(() => Boolean, {description: `For input modalities: whether this modality is required (e.g., text is usually required for LLMs). For outputs: not typically applicable.`}) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Comma-separated list of supported file formats/extensions (e.g., png,jpg,webp,gif for images or mp3,wav,m4a for audio).`}) 
    @MaxLength(1000)
    SupportedFormats?: string;
        
    @Field(() => Int, {nullable: true, description: `Model-specific maximum size in bytes. Overrides AIModality.DefaultMaxSizeBytes. NULL means use system default.`}) 
    MaxSizeBytes?: number;
        
    @Field(() => Int, {nullable: true, description: `Model-specific maximum count per message. Overrides AIModality.DefaultMaxCountPerMessage. NULL means use system default.`}) 
    MaxCountPerMessage?: number;
        
    @Field(() => Int, {nullable: true, description: `For image/video modalities: maximum dimension (width or height) in pixels supported by this model.`}) 
    MaxDimension?: number;
        
    @Field({nullable: true, description: `Additional notes or documentation about this model-modality configuration.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Modality: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Modalities
//****************************************************************************
@InputType()
export class CreateMJAIModelModalityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsSupported?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    SupportedFormats: string | null;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage: number | null;

    @Field(() => Int, { nullable: true })
    MaxDimension: number | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Modalities
//****************************************************************************
@InputType()
export class UpdateMJAIModelModalityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => Boolean, { nullable: true })
    IsSupported?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    SupportedFormats?: string | null;

    @Field(() => Int, { nullable: true })
    MaxSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    MaxCountPerMessage?: number | null;

    @Field(() => Int, { nullable: true })
    MaxDimension?: number | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Modalities
//****************************************************************************
@ObjectType()
export class RunMJAIModelModalityViewResult {
    @Field(() => [MJAIModelModality_])
    Results: MJAIModelModality_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelModality_)
export class MJAIModelModalityResolver extends ResolverBase {
    @Query(() => RunMJAIModelModalityViewResult)
    async RunMJAIModelModalityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelModalityViewResult)
    async RunMJAIModelModalityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelModalityViewResult)
    async RunMJAIModelModalityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Modalities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelModality_, { nullable: true })
    async MJAIModelModality(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelModality_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Modalities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelModalities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Modalities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Modalities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIModelModality_)
    async CreateMJAIModelModality(
        @Arg('input', () => CreateMJAIModelModalityInput) input: CreateMJAIModelModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Modalities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelModality_)
    async UpdateMJAIModelModality(
        @Arg('input', () => UpdateMJAIModelModalityInput) input: UpdateMJAIModelModalityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Modalities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelModality_)
    async DeleteMJAIModelModality(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Modalities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Price Types
//****************************************************************************
@ObjectType({ description: `Defines the different types of pricing metrics used by AI model vendors (e.g., Tokens, Minutes, Characters, API Calls)` })
export class MJAIModelPriceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Short, descriptive name for the price type (e.g., "Tokens", "Minutes", "Characters")`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this price type represents and how it is measured`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModelCost_])
    MJ_AIModelCosts_PriceTypeIDArray: MJAIModelCost_[]; // Link to MJ_AIModelCosts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Types
//****************************************************************************
@InputType()
export class CreateMJAIModelPriceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelPriceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Price Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelPriceTypeViewResult {
    @Field(() => [MJAIModelPriceType_])
    Results: MJAIModelPriceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelPriceType_)
export class MJAIModelPriceTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelPriceTypeViewResult)
    async RunMJAIModelPriceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceTypeViewResult)
    async RunMJAIModelPriceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceTypeViewResult)
    async RunMJAIModelPriceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Price Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelPriceType_, { nullable: true })
    async MJAIModelPriceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelPriceType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Price Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelPriceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Price Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Price Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelCost_])
    async MJ_AIModelCosts_PriceTypeIDArray(@Root() mjaimodelpricetype_: MJAIModelPriceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [PriceTypeID]='${mjaimodelpricetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelPriceType_)
    async CreateMJAIModelPriceType(
        @Arg('input', () => CreateMJAIModelPriceTypeInput) input: CreateMJAIModelPriceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Price Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelPriceType_)
    async UpdateMJAIModelPriceType(
        @Arg('input', () => UpdateMJAIModelPriceTypeInput) input: UpdateMJAIModelPriceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Price Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelPriceType_)
    async DeleteMJAIModelPriceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Price Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Price Unit Types
//****************************************************************************
@ObjectType({ description: `Defines the unit scales used for pricing (e.g., Per 1M Tokens, Per 1K Tokens, Per Minute). Includes driver class for normalization calculations` })
export class MJAIModelPriceUnitType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name for the pricing unit (e.g., "Per 1M Tokens", "Per 1K Tokens", "Per Minute")`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed explanation of the unit scale and any special considerations for this pricing unit`}) 
    Description?: string;
        
    @Field({description: `Fully qualified class name that handles cost calculations and unit normalization for this pricing unit (e.g., "TokenPer1M", "TokenPer1K")`}) 
    @MaxLength(510)
    DriverClass: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModelCost_])
    MJ_AIModelCosts_UnitTypeIDArray: MJAIModelCost_[]; // Link to MJ_AIModelCosts
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Unit Types
//****************************************************************************
@InputType()
export class CreateMJAIModelPriceUnitTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Price Unit Types
//****************************************************************************
@InputType()
export class UpdateMJAIModelPriceUnitTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Price Unit Types
//****************************************************************************
@ObjectType()
export class RunMJAIModelPriceUnitTypeViewResult {
    @Field(() => [MJAIModelPriceUnitType_])
    Results: MJAIModelPriceUnitType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelPriceUnitType_)
export class MJAIModelPriceUnitTypeResolver extends ResolverBase {
    @Query(() => RunMJAIModelPriceUnitTypeViewResult)
    async RunMJAIModelPriceUnitTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceUnitTypeViewResult)
    async RunMJAIModelPriceUnitTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelPriceUnitTypeViewResult)
    async RunMJAIModelPriceUnitTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Price Unit Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelPriceUnitType_, { nullable: true })
    async MJAIModelPriceUnitType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelPriceUnitType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Price Unit Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelPriceUnitTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Price Unit Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Price Unit Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelCost_])
    async MJ_AIModelCosts_UnitTypeIDArray(@Root() mjaimodelpriceunittype_: MJAIModelPriceUnitType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [UnitTypeID]='${mjaimodelpriceunittype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelPriceUnitType_)
    async CreateMJAIModelPriceUnitType(
        @Arg('input', () => CreateMJAIModelPriceUnitTypeInput) input: CreateMJAIModelPriceUnitTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Price Unit Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelPriceUnitType_)
    async UpdateMJAIModelPriceUnitType(
        @Arg('input', () => UpdateMJAIModelPriceUnitTypeInput) input: UpdateMJAIModelPriceUnitTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Price Unit Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelPriceUnitType_)
    async DeleteMJAIModelPriceUnitType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Price Unit Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Model Vendors
//****************************************************************************
@ObjectType({ description: `Associates AI models with vendors providing them, including vendor-specific implementation details.` })
export class MJAIModelVendor_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ModelID: string;
        
    @Field() 
    @MaxLength(16)
    VendorID: string;
        
    @Field(() => Int, {description: `Determines the priority rank of this vendor for the model. Higher values indicate higher priority.`}) 
    Priority: number;
        
    @Field({description: `The current status of this model-vendor combination. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `The name of the driver class implementing this model-vendor combination.`}) 
    @MaxLength(200)
    DriverClass?: string;
        
    @Field({nullable: true, description: `The import path for the driver class.`}) 
    @MaxLength(510)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `The name of the model to use with API calls, which might differ from the model name. If not provided, the model name will be used.`}) 
    @MaxLength(200)
    APIName?: string;
        
    @Field(() => Int, {nullable: true, description: `The maximum number of input tokens supported by this model-vendor implementation.`}) 
    MaxInputTokens?: number;
        
    @Field(() => Int, {nullable: true, description: `The maximum number of output tokens supported by this model-vendor implementation.`}) 
    MaxOutputTokens?: number;
        
    @Field({description: `A comma-delimited string indicating the supported response formats for this model-vendor implementation. Options include Any, Text, Markdown, JSON, and ModelSpecific.`}) 
    @MaxLength(200)
    SupportedResponseFormats: string;
        
    @Field(() => Boolean, {description: `Specifies if this model-vendor implementation supports the concept of an effort level.`}) 
    SupportsEffortLevel: boolean;
        
    @Field(() => Boolean, {description: `Specifies if this model-vendor implementation supports streaming responses.`}) 
    SupportsStreaming: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `References the type/role of the vendor for this model (e.g., model developer, inference provider)`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
    @Field(() => [MJAICredentialBinding_])
    MJ_AICredentialBindings_AIModelVendorIDArray: MJAICredentialBinding_[]; // Link to MJ_AICredentialBindings
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Model Vendors
//****************************************************************************
@InputType()
export class CreateMJAIModelVendorInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    MaxInputTokens: number | null;

    @Field(() => Int, { nullable: true })
    MaxOutputTokens: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsStreaming?: boolean;

    @Field({ nullable: true })
    TypeID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Model Vendors
//****************************************************************************
@InputType()
export class UpdateMJAIModelVendorInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    MaxInputTokens?: number | null;

    @Field(() => Int, { nullable: true })
    MaxOutputTokens?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsEffortLevel?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsStreaming?: boolean;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Model Vendors
//****************************************************************************
@ObjectType()
export class RunMJAIModelVendorViewResult {
    @Field(() => [MJAIModelVendor_])
    Results: MJAIModelVendor_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIModelVendor_)
export class MJAIModelVendorResolver extends ResolverBase {
    @Query(() => RunMJAIModelVendorViewResult)
    async RunMJAIModelVendorViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelVendorViewResult)
    async RunMJAIModelVendorViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIModelVendorViewResult)
    async RunMJAIModelVendorDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Model Vendors';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIModelVendor_, { nullable: true })
    async MJAIModelVendor(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIModelVendor_ | null> {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Model Vendors', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJ_AICredentialBindings_AIModelVendorIDArray(@Root() mjaimodelvendor_: MJAIModelVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAICredentialBindings] WHERE [AIModelVendorID]='${mjaimodelvendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIModelVendor_)
    async CreateMJAIModelVendor(
        @Arg('input', () => CreateMJAIModelVendorInput) input: CreateMJAIModelVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Model Vendors', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIModelVendor_)
    async UpdateMJAIModelVendor(
        @Arg('input', () => UpdateMJAIModelVendorInput) input: UpdateMJAIModelVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Model Vendors', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIModelVendor_)
    async DeleteMJAIModelVendor(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Model Vendors', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Models
//****************************************************************************
@ObjectType({ description: `Associates AI prompts with specific models and configurations, including execution details.` })
export class MJAIPromptModel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the AI prompt this model association applies to.`}) 
    @MaxLength(16)
    PromptID: string;
        
    @Field({description: `References the AI model to use for this prompt.`}) 
    @MaxLength(16)
    ModelID: string;
        
    @Field({nullable: true, description: `Optional reference to a specific vendor for the model. If NULL, uses the highest priority vendor for the model.`}) 
    @MaxLength(16)
    VendorID?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific configuration. If NULL, this model is available in all configurations.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field(() => Int, {description: `Priority of this model for the prompt. Higher values indicate higher priority.`}) 
    Priority: number;
        
    @Field(() => Int, {description: `Execution group for parallel processing. Models with the same group are executed in parallel.`}) 
    ExecutionGroup: number;
        
    @Field({nullable: true, description: `JSON-formatted parameters specific to this model (temperature, max tokens, etc.).`}) 
    ModelParameters?: string;
        
    @Field({description: `The current status of this model configuration. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Controls how this model participates in parallelization: None, StaticCount, or ConfigParam.`}) 
    @MaxLength(40)
    ParallelizationMode: string;
        
    @Field(() => Int, {description: `Number of parallel executions to perform with this model when ParallelizationMode is StaticCount.`}) 
    ParallelCount: number;
        
    @Field({nullable: true, description: `Name of a configuration parameter that contains the parallel count when ParallelizationMode is ConfigParam.`}) 
    @MaxLength(200)
    ParallelConfigParam?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Model-specific effort level override (1-100, where 1=minimal effort, 100=maximum effort). Allows customizing effort level per model - useful when a more capable model can use lower effort for tasks that require higher effort from lesser models. Takes precedence over agent and prompt effort levels but can be overridden by runtime parameters.`}) 
    EffortLevel?: number;
        
    @Field() 
    @MaxLength(510)
    Prompt: string;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
    @Field(() => [MJAICredentialBinding_])
    MJ_AICredentialBindings_AIPromptModelIDArray: MJAICredentialBinding_[]; // Link to MJ_AICredentialBindings
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Models
//****************************************************************************
@InputType()
export class CreateMJAIPromptModelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Int, { nullable: true })
    ExecutionGroup?: number;

    @Field({ nullable: true })
    ModelParameters: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number;

    @Field({ nullable: true })
    ParallelConfigParam: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Models
//****************************************************************************
@InputType()
export class UpdateMJAIPromptModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Int, { nullable: true })
    ExecutionGroup?: number;

    @Field({ nullable: true })
    ModelParameters?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ParallelizationMode?: string;

    @Field(() => Int, { nullable: true })
    ParallelCount?: number;

    @Field({ nullable: true })
    ParallelConfigParam?: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Models
//****************************************************************************
@ObjectType()
export class RunMJAIPromptModelViewResult {
    @Field(() => [MJAIPromptModel_])
    Results: MJAIPromptModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptModel_)
export class MJAIPromptModelResolver extends ResolverBase {
    @Query(() => RunMJAIPromptModelViewResult)
    async RunMJAIPromptModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptModelViewResult)
    async RunMJAIPromptModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptModelViewResult)
    async RunMJAIPromptModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Models';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptModel_, { nullable: true })
    async MJAIPromptModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptModel_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Models', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJ_AICredentialBindings_AIPromptModelIDArray(@Root() mjaipromptmodel_: MJAIPromptModel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAICredentialBindings] WHERE [AIPromptModelID]='${mjaipromptmodel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptModel_)
    async CreateMJAIPromptModel(
        @Arg('input', () => CreateMJAIPromptModelInput) input: CreateMJAIPromptModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Models', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptModel_)
    async UpdateMJAIPromptModel(
        @Arg('input', () => UpdateMJAIPromptModelInput) input: UpdateMJAIPromptModelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Models', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptModel_)
    async DeleteMJAIPromptModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Models', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Run Medias
//****************************************************************************
@ObjectType()
export class MJAIPromptRunMedia_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    PromptRunID: string;
        
    @Field() 
    @MaxLength(16)
    ModalityID: string;
        
    @Field() 
    @MaxLength(200)
    MimeType: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FileName?: string;
        
    @Field(() => Int, {nullable: true}) 
    FileSizeBytes?: number;
        
    @Field(() => Int, {nullable: true}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true}) 
    Height?: number;
        
    @Field(() => Float, {nullable: true}) 
    DurationSeconds?: number;
        
    @Field({nullable: true}) 
    InlineData?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    FileID?: string;
        
    @Field({nullable: true}) 
    ThumbnailBase64?: string;
        
    @Field({nullable: true}) 
    Metadata?: string;
        
    @Field(() => Int) 
    DisplayOrder: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Description of the media generated during prompt execution. Provides context for audit trail.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    PromptRun?: string;
        
    @Field() 
    @MaxLength(100)
    Modality: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    File?: string;
        
    @Field(() => [MJAIAgentRunMedia_])
    MJ_AIAgentRunMedias_SourcePromptRunMediaIDArray: MJAIAgentRunMedia_[]; // Link to MJ_AIAgentRunMedias
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Run Medias
//****************************************************************************
@InputType()
export class CreateMJAIPromptRunMediaInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptRunID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes: number | null;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field({ nullable: true })
    FileID: string | null;

    @Field({ nullable: true })
    ThumbnailBase64: string | null;

    @Field({ nullable: true })
    Metadata: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Run Medias
//****************************************************************************
@InputType()
export class UpdateMJAIPromptRunMediaInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptRunID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number | null;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field({ nullable: true })
    FileID?: string | null;

    @Field({ nullable: true })
    ThumbnailBase64?: string | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Run Medias
//****************************************************************************
@ObjectType()
export class RunMJAIPromptRunMediaViewResult {
    @Field(() => [MJAIPromptRunMedia_])
    Results: MJAIPromptRunMedia_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptRunMedia_)
export class MJAIPromptRunMediaResolver extends ResolverBase {
    @Query(() => RunMJAIPromptRunMediaViewResult)
    async RunMJAIPromptRunMediaViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunMediaViewResult)
    async RunMJAIPromptRunMediaViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunMediaViewResult)
    async RunMJAIPromptRunMediaDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Run Medias';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptRunMedia_, { nullable: true })
    async MJAIPromptRunMedia(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptRunMedia_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRunMedias] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRunMedia_])
    async MJ_AIAgentRunMedias_SourcePromptRunMediaIDArray(@Root() mjaipromptrunmedia_: MJAIPromptRunMedia_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRunMedias] WHERE [SourcePromptRunMediaID]='${mjaipromptrunmedia_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptRunMedia_)
    async CreateMJAIPromptRunMedia(
        @Arg('input', () => CreateMJAIPromptRunMediaInput) input: CreateMJAIPromptRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Run Medias', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptRunMedia_)
    async UpdateMJAIPromptRunMedia(
        @Arg('input', () => UpdateMJAIPromptRunMediaInput) input: UpdateMJAIPromptRunMediaInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Run Medias', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptRunMedia_)
    async DeleteMJAIPromptRunMedia(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Run Medias', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Prompt Runs
//****************************************************************************
@ObjectType({ description: `Tracks AI prompt executions including timings, inputs, outputs, and performance metrics.` })
export class MJAIPromptRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The prompt that was executed.`}) 
    @MaxLength(16)
    PromptID: string;
        
    @Field({description: `The AI model used for execution.`}) 
    @MaxLength(16)
    ModelID: string;
        
    @Field({description: `The vendor providing the model/inference.`}) 
    @MaxLength(16)
    VendorID: string;
        
    @Field({nullable: true, description: `If this prompt was run as part of an agent, references the agent.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `Optional configuration used for this execution.`}) 
    @MaxLength(16)
    ConfigurationID?: string;
        
    @Field({description: `When the prompt run started, with timezone offset information.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field({nullable: true, description: `When the prompt run completed, with timezone offset information.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total execution time in milliseconds.`}) 
    ExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `The input messages sent to the model, typically in JSON format.`}) 
    Messages?: string;
        
    @Field({nullable: true, description: `The output result from the model.`}) 
    Result?: string;
        
    @Field(() => Int, {nullable: true, description: `Total number of tokens used (prompt + completion).`}) 
    TokensUsed?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tokens in the prompt.`}) 
    TokensPrompt?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tokens in the completion/result.`}) 
    TokensCompletion?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost of this prompt run including its own cost plus all descendant costs. Calculated as Cost + DescendantCost. This value is stored (not computed) for query performance. Currency is specified in CostCurrency field.`}) 
    TotalCost?: number;
        
    @Field(() => Boolean, {description: `Whether the execution was successful.`}) 
    Success: boolean;
        
    @Field({nullable: true, description: `Error message if the execution failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `References the parent AIPromptRun.ID for hierarchical execution tracking. NULL for top-level runs, populated for parallel children and result selector runs.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Type of prompt run execution: Single (standard single prompt), ParallelParent (coordinator for parallel execution), ParallelChild (individual parallel execution), ResultSelector (result selection prompt that chooses best result)`}) 
    @MaxLength(40)
    RunType: string;
        
    @Field(() => Int, {nullable: true, description: `Execution order for parallel child runs and result selector runs. Used to track the sequence of execution within a parallel run group. NULL for single runs and parallel parent runs.`}) 
    ExecutionOrder?: number;
        
    @Field({nullable: true, description: `Optional reference to the AIAgentRun that initiated this prompt execution. Links prompt runs to their parent agent runs for comprehensive execution tracking.`}) 
    @MaxLength(16)
    AgentRunID?: string;
        
    @Field(() => Float, {nullable: true, description: `The cost of this specific prompt execution as reported by the AI provider. This does not include costs from child executions. The currency is specified in CostCurrency field.`}) 
    Cost?: number;
        
    @Field({nullable: true, description: `ISO 4217 currency code for the Cost field (e.g., USD, EUR, GBP). Different AI providers may use different currencies.`}) 
    @MaxLength(20)
    CostCurrency?: string;
        
    @Field(() => Int, {nullable: true, description: `Total tokens used including this execution and all child/grandchild executions. This provides a complete view of token usage for hierarchical prompt trees. Calculated as TokensPromptRollup + TokensCompletionRollup.`}) 
    TokensUsedRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total prompt/input tokens including this execution and all child/grandchild executions. For leaf nodes (no children), this equals TokensPrompt. For parent nodes, this includes the sum of all descendant prompt tokens.`}) 
    TokensPromptRollup?: number;
        
    @Field(() => Int, {nullable: true, description: `Total completion/output tokens including this execution and all child/grandchild executions. For leaf nodes (no children), this equals TokensCompletion. For parent nodes, this includes the sum of all descendant completion tokens.`}) 
    TokensCompletionRollup?: number;
        
    @Field(() => Float, {nullable: true, description: `The temperature parameter used for this prompt run, controlling randomness in the output (0.0 = deterministic, 2.0 = very random)`}) 
    Temperature?: number;
        
    @Field(() => Float, {nullable: true, description: `Top-p (nucleus) sampling parameter used for this run. Considers tokens with cumulative probability up to this value (0-1)`}) 
    TopP?: number;
        
    @Field(() => Int, {nullable: true, description: `Top-k sampling parameter used for this run. Limits sampling to the top K most likely tokens`}) 
    TopK?: number;
        
    @Field(() => Float, {nullable: true, description: `Minimum probability threshold used for token sampling (0-1). Tokens below this probability are filtered out`}) 
    MinP?: number;
        
    @Field(() => Float, {nullable: true, description: `Frequency penalty parameter used (-2.0 to 2.0). Positive values reduce repetition of tokens based on their frequency in the output`}) 
    FrequencyPenalty?: number;
        
    @Field(() => Float, {nullable: true, description: `Presence penalty parameter used (-2.0 to 2.0). Positive values encourage the model to talk about new topics`}) 
    PresencePenalty?: number;
        
    @Field(() => Int, {nullable: true, description: `Random seed used for reproducible outputs. When set, the same seed with identical inputs should produce the same output`}) 
    Seed?: number;
        
    @Field({nullable: true, description: `JSON array of stop sequences used. The model stops generating when any of these sequences are encountered`}) 
    StopSequences?: string;
        
    @Field({nullable: true, description: `The response format requested for this run (e.g., 'JSON', 'Text', 'Markdown')`}) 
    @MaxLength(100)
    ResponseFormat?: string;
        
    @Field(() => Boolean, {nullable: true, description: `Whether log probabilities were requested for this run`}) 
    LogProbs?: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of top log probabilities requested per token (if LogProbs is true)`}) 
    TopLogProbs?: number;
        
    @Field(() => Float, {nullable: true, description: `The total cost of all descendant (child and grandchild) prompt runs, excluding this run's own cost. For leaf nodes (no children), this is 0. Updated when child costs change.`}) 
    DescendantCost?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of validation attempts made (including the initial attempt)`}) 
    ValidationAttemptCount?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of validation attempts that passed validation`}) 
    SuccessfulValidationCount?: number;
        
    @Field(() => Boolean, {nullable: true, description: `Whether validation ultimately passed (1) or failed (0)`}) 
    FinalValidationPassed?: boolean;
        
    @Field({nullable: true, description: `Validation behavior used: Strict, Warn, or None`}) 
    @MaxLength(100)
    ValidationBehavior?: string;
        
    @Field({nullable: true, description: `Retry strategy used: Fixed, Linear, or Exponential`}) 
    @MaxLength(100)
    RetryStrategy?: string;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of retries configured on the prompt`}) 
    MaxRetriesConfigured?: number;
        
    @Field({nullable: true, description: `The final validation error message if validation failed`}) 
    @MaxLength(1000)
    FinalValidationError?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of validation errors on the final attempt`}) 
    ValidationErrorCount?: number;
        
    @Field({nullable: true, description: `Most frequent validation error across all attempts`}) 
    @MaxLength(510)
    CommonValidationError?: string;
        
    @Field({nullable: true, description: `Timestamp of the first validation attempt`}) 
    @MaxLength(10)
    FirstAttemptAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last validation attempt`}) 
    @MaxLength(10)
    LastAttemptAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total time spent on retries in milliseconds (excluding first attempt)`}) 
    TotalRetryDurationMS?: number;
        
    @Field({nullable: true, description: `JSON array containing detailed information about each validation attempt`}) 
    ValidationAttempts?: string;
        
    @Field({nullable: true, description: `JSON object containing summary information about the validation process`}) 
    ValidationSummary?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of failover attempts made during this prompt run`}) 
    FailoverAttempts?: number;
        
    @Field({nullable: true, description: `JSON array of error details from each failover attempt`}) 
    FailoverErrors?: string;
        
    @Field({nullable: true, description: `JSON array of duration in milliseconds for each failover attempt`}) 
    FailoverDurations?: string;
        
    @Field({nullable: true, description: `The AI Model ID that was originally attempted before any failovers`}) 
    @MaxLength(16)
    OriginalModelID?: string;
        
    @Field({nullable: true, description: `Timestamp when the original request started, before any failovers`}) 
    @MaxLength(10)
    OriginalRequestStartTime?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total time spent in failover attempts in milliseconds`}) 
    TotalFailoverDuration?: number;
        
    @Field({nullable: true, description: `If this run was initiated as a re-run of another prompt run, this field links back to the original run ID`}) 
    @MaxLength(16)
    RerunFromPromptRunID?: string;
        
    @Field({nullable: true, description: `JSON object containing detailed model selection information including all models considered, their scores, and the selection rationale`}) 
    ModelSelection?: string;
        
    @Field({description: `Current execution status of the prompt run. Valid values: Pending, Running, Completed, Failed, Cancelled`}) 
    @MaxLength(100)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates whether this prompt run was cancelled before completion`}) 
    Cancelled: boolean;
        
    @Field({nullable: true, description: `Detailed reason for cancellation if the prompt run was cancelled. Could be user_requested, timeout, error, or resource_limit`}) 
    CancellationReason?: string;
        
    @Field(() => Int, {nullable: true, description: `Power rank of the model that was selected for this run. Lower numbers indicate more powerful models`}) 
    ModelPowerRank?: number;
        
    @Field({nullable: true, description: `Strategy used for model selection. Valid values: Default (system default), Specific (specific models configured), ByPower (based on power ranking)`}) 
    @MaxLength(100)
    SelectionStrategy?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this result was served from cache rather than executing a new model call`}) 
    CacheHit: boolean;
        
    @Field({nullable: true, description: `Unique key used for caching this prompt result, typically a hash of the prompt and parameters`}) 
    @MaxLength(1000)
    CacheKey?: string;
        
    @Field({nullable: true, description: `ID of the AIPrompt used as a judge to evaluate and rank multiple parallel execution results`}) 
    @MaxLength(16)
    JudgeID?: string;
        
    @Field(() => Float, {nullable: true, description: `Score assigned by the judge prompt when evaluating multiple results. Higher scores indicate better results`}) 
    JudgeScore?: number;
        
    @Field(() => Boolean, {description: `Indicates whether this result was selected as the best result when multiple models were run in parallel`}) 
    WasSelectedResult: boolean;
        
    @Field(() => Boolean, {description: `Indicates whether streaming was enabled for this prompt execution`}) 
    StreamingEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds from request initiation to receiving the first token from the model`}) 
    FirstTokenTime?: number;
        
    @Field({nullable: true, description: `Detailed error information in JSON format if the prompt execution failed, including stack traces and error codes`}) 
    ErrorDetails?: string;
        
    @Field({nullable: true, description: `References the specific child prompt that was executed as part of hierarchical prompt composition. NULL for regular prompts or parent prompts that don't directly execute a child.`}) 
    @MaxLength(16)
    ChildPromptID?: string;
        
    @Field(() => Int, {nullable: true, description: `Queue time in milliseconds before the model started processing the request. Provider-specific timing metric.`}) 
    QueueTime?: number;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds for the model to ingest and process the prompt. Provider-specific timing metric.`}) 
    PromptTime?: number;
        
    @Field(() => Int, {nullable: true, description: `Time in milliseconds for the model to generate the completion/response tokens. Provider-specific timing metric.`}) 
    CompletionTime?: number;
        
    @Field({nullable: true, description: `JSON field containing provider-specific response metadata and details not captured in standard fields. Structure varies by AI provider.`}) 
    ModelSpecificResponseDetails?: string;
        
    @Field(() => Int, {nullable: true, description: `Effort level that was actually used during this prompt run execution (1-100, where 1=minimal effort, 100=maximum effort). This is the resolved effort level after applying the precedence hierarchy: runtime override > agent default > prompt default > provider default.`}) 
    EffortLevel?: number;
        
    @Field({nullable: true, description: `Optional name for the prompt run to help identify and tag runs for easier reference`}) 
    @MaxLength(510)
    RunName?: string;
        
    @Field({nullable: true, description: `Human-readable notes and comments about this prompt run`}) 
    Comments?: string;
        
    @Field({nullable: true, description: `Optional Foreign Key - Links this prompt run to a test run if this prompt execution was part of a test. Enables testing individual prompts for quality and consistency before agent integration.`}) 
    @MaxLength(16)
    TestRunID?: string;
        
    @Field() 
    @MaxLength(510)
    Prompt: string;
        
    @Field() 
    @MaxLength(100)
    Model: string;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OriginalModel?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RerunFromPromptRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Judge?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ChildPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TestRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootRerunFromPromptRunID?: string;
        
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_ParentIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJAIPromptRunMedia_])
    MJ_AIPromptRunMedias_PromptRunIDArray: MJAIPromptRunMedia_[]; // Link to MJ_AIPromptRunMedias
    
    @Field(() => [MJAIResultCache_])
    AIResultCache_PromptRunIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Runs
//****************************************************************************
@InputType()
export class CreateMJAIPromptRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ConfigurationID: string | null;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Int, { nullable: true })
    ExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Messages: string | null;

    @Field({ nullable: true })
    Result: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsed: number | null;

    @Field(() => Int, { nullable: true })
    TokensPrompt: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletion: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    RunType?: string;

    @Field(() => Int, { nullable: true })
    ExecutionOrder: number | null;

    @Field({ nullable: true })
    AgentRunID: string | null;

    @Field(() => Float, { nullable: true })
    Cost: number | null;

    @Field({ nullable: true })
    CostCurrency: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsedRollup: number | null;

    @Field(() => Int, { nullable: true })
    TokensPromptRollup: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletionRollup: number | null;

    @Field(() => Float, { nullable: true })
    Temperature: number | null;

    @Field(() => Float, { nullable: true })
    TopP: number | null;

    @Field(() => Int, { nullable: true })
    TopK: number | null;

    @Field(() => Float, { nullable: true })
    MinP: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty: number | null;

    @Field(() => Int, { nullable: true })
    Seed: number | null;

    @Field({ nullable: true })
    StopSequences: string | null;

    @Field({ nullable: true })
    ResponseFormat: string | null;

    @Field(() => Boolean, { nullable: true })
    LogProbs: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs: number | null;

    @Field(() => Float, { nullable: true })
    DescendantCost: number | null;

    @Field(() => Int, { nullable: true })
    ValidationAttemptCount: number | null;

    @Field(() => Int, { nullable: true })
    SuccessfulValidationCount: number | null;

    @Field(() => Boolean, { nullable: true })
    FinalValidationPassed: boolean | null;

    @Field({ nullable: true })
    ValidationBehavior: string | null;

    @Field({ nullable: true })
    RetryStrategy: string | null;

    @Field(() => Int, { nullable: true })
    MaxRetriesConfigured: number | null;

    @Field({ nullable: true })
    FinalValidationError: string | null;

    @Field(() => Int, { nullable: true })
    ValidationErrorCount: number | null;

    @Field({ nullable: true })
    CommonValidationError: string | null;

    @Field({ nullable: true })
    FirstAttemptAt: Date | null;

    @Field({ nullable: true })
    LastAttemptAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRetryDurationMS: number | null;

    @Field({ nullable: true })
    ValidationAttempts: string | null;

    @Field({ nullable: true })
    ValidationSummary: string | null;

    @Field(() => Int, { nullable: true })
    FailoverAttempts?: number | null;

    @Field({ nullable: true })
    FailoverErrors: string | null;

    @Field({ nullable: true })
    FailoverDurations: string | null;

    @Field({ nullable: true })
    OriginalModelID: string | null;

    @Field({ nullable: true })
    OriginalRequestStartTime: Date | null;

    @Field(() => Int, { nullable: true })
    TotalFailoverDuration: number | null;

    @Field({ nullable: true })
    RerunFromPromptRunID: string | null;

    @Field({ nullable: true })
    ModelSelection: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Cancelled?: boolean;

    @Field({ nullable: true })
    CancellationReason: string | null;

    @Field(() => Int, { nullable: true })
    ModelPowerRank: number | null;

    @Field({ nullable: true })
    SelectionStrategy: string | null;

    @Field(() => Boolean, { nullable: true })
    CacheHit?: boolean;

    @Field({ nullable: true })
    CacheKey: string | null;

    @Field({ nullable: true })
    JudgeID: string | null;

    @Field(() => Float, { nullable: true })
    JudgeScore: number | null;

    @Field(() => Boolean, { nullable: true })
    WasSelectedResult?: boolean;

    @Field(() => Boolean, { nullable: true })
    StreamingEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    FirstTokenTime: number | null;

    @Field({ nullable: true })
    ErrorDetails: string | null;

    @Field({ nullable: true })
    ChildPromptID: string | null;

    @Field(() => Int, { nullable: true })
    QueueTime: number | null;

    @Field(() => Int, { nullable: true })
    PromptTime: number | null;

    @Field(() => Int, { nullable: true })
    CompletionTime: number | null;

    @Field({ nullable: true })
    ModelSpecificResponseDetails: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel: number | null;

    @Field({ nullable: true })
    RunName: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    TestRunID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Prompt Runs
//****************************************************************************
@InputType()
export class UpdateMJAIPromptRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    PromptID?: string;

    @Field({ nullable: true })
    ModelID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ConfigurationID?: string | null;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    ExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Messages?: string | null;

    @Field({ nullable: true })
    Result?: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsed?: number | null;

    @Field(() => Int, { nullable: true })
    TokensPrompt?: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletion?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCost?: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    RunType?: string;

    @Field(() => Int, { nullable: true })
    ExecutionOrder?: number | null;

    @Field({ nullable: true })
    AgentRunID?: string | null;

    @Field(() => Float, { nullable: true })
    Cost?: number | null;

    @Field({ nullable: true })
    CostCurrency?: string | null;

    @Field(() => Int, { nullable: true })
    TokensUsedRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TokensPromptRollup?: number | null;

    @Field(() => Int, { nullable: true })
    TokensCompletionRollup?: number | null;

    @Field(() => Float, { nullable: true })
    Temperature?: number | null;

    @Field(() => Float, { nullable: true })
    TopP?: number | null;

    @Field(() => Int, { nullable: true })
    TopK?: number | null;

    @Field(() => Float, { nullable: true })
    MinP?: number | null;

    @Field(() => Float, { nullable: true })
    FrequencyPenalty?: number | null;

    @Field(() => Float, { nullable: true })
    PresencePenalty?: number | null;

    @Field(() => Int, { nullable: true })
    Seed?: number | null;

    @Field({ nullable: true })
    StopSequences?: string | null;

    @Field({ nullable: true })
    ResponseFormat?: string | null;

    @Field(() => Boolean, { nullable: true })
    LogProbs?: boolean | null;

    @Field(() => Int, { nullable: true })
    TopLogProbs?: number | null;

    @Field(() => Float, { nullable: true })
    DescendantCost?: number | null;

    @Field(() => Int, { nullable: true })
    ValidationAttemptCount?: number | null;

    @Field(() => Int, { nullable: true })
    SuccessfulValidationCount?: number | null;

    @Field(() => Boolean, { nullable: true })
    FinalValidationPassed?: boolean | null;

    @Field({ nullable: true })
    ValidationBehavior?: string | null;

    @Field({ nullable: true })
    RetryStrategy?: string | null;

    @Field(() => Int, { nullable: true })
    MaxRetriesConfigured?: number | null;

    @Field({ nullable: true })
    FinalValidationError?: string | null;

    @Field(() => Int, { nullable: true })
    ValidationErrorCount?: number | null;

    @Field({ nullable: true })
    CommonValidationError?: string | null;

    @Field({ nullable: true })
    FirstAttemptAt?: Date | null;

    @Field({ nullable: true })
    LastAttemptAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRetryDurationMS?: number | null;

    @Field({ nullable: true })
    ValidationAttempts?: string | null;

    @Field({ nullable: true })
    ValidationSummary?: string | null;

    @Field(() => Int, { nullable: true })
    FailoverAttempts?: number | null;

    @Field({ nullable: true })
    FailoverErrors?: string | null;

    @Field({ nullable: true })
    FailoverDurations?: string | null;

    @Field({ nullable: true })
    OriginalModelID?: string | null;

    @Field({ nullable: true })
    OriginalRequestStartTime?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalFailoverDuration?: number | null;

    @Field({ nullable: true })
    RerunFromPromptRunID?: string | null;

    @Field({ nullable: true })
    ModelSelection?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Cancelled?: boolean;

    @Field({ nullable: true })
    CancellationReason?: string | null;

    @Field(() => Int, { nullable: true })
    ModelPowerRank?: number | null;

    @Field({ nullable: true })
    SelectionStrategy?: string | null;

    @Field(() => Boolean, { nullable: true })
    CacheHit?: boolean;

    @Field({ nullable: true })
    CacheKey?: string | null;

    @Field({ nullable: true })
    JudgeID?: string | null;

    @Field(() => Float, { nullable: true })
    JudgeScore?: number | null;

    @Field(() => Boolean, { nullable: true })
    WasSelectedResult?: boolean;

    @Field(() => Boolean, { nullable: true })
    StreamingEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    FirstTokenTime?: number | null;

    @Field({ nullable: true })
    ErrorDetails?: string | null;

    @Field({ nullable: true })
    ChildPromptID?: string | null;

    @Field(() => Int, { nullable: true })
    QueueTime?: number | null;

    @Field(() => Int, { nullable: true })
    PromptTime?: number | null;

    @Field(() => Int, { nullable: true })
    CompletionTime?: number | null;

    @Field({ nullable: true })
    ModelSpecificResponseDetails?: string | null;

    @Field(() => Int, { nullable: true })
    EffortLevel?: number | null;

    @Field({ nullable: true })
    RunName?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    TestRunID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Prompt Runs
//****************************************************************************
@ObjectType()
export class RunMJAIPromptRunViewResult {
    @Field(() => [MJAIPromptRun_])
    Results: MJAIPromptRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIPromptRun_)
export class MJAIPromptRunResolver extends ResolverBase {
    @Query(() => RunMJAIPromptRunViewResult)
    async RunMJAIPromptRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunViewResult)
    async RunMJAIPromptRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIPromptRunViewResult)
    async RunMJAIPromptRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Prompt Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIPromptRun_, { nullable: true })
    async MJAIPromptRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIPromptRun_ | null> {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_ParentIDArray(@Root() mjaipromptrun_: MJAIPromptRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [ParentID]='${mjaipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRunMedia_])
    async MJ_AIPromptRunMedias_PromptRunIDArray(@Root() mjaipromptrun_: MJAIPromptRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Run Medias', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRunMedias] WHERE [PromptRunID]='${mjaipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Run Medias', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Run Medias', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_PromptRunIDArray(@Root() mjaipromptrun_: MJAIPromptRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [PromptRunID]='${mjaipromptrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIPromptRun_)
    async CreateMJAIPromptRun(
        @Arg('input', () => CreateMJAIPromptRunInput) input: CreateMJAIPromptRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Prompt Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIPromptRun_)
    async UpdateMJAIPromptRun(
        @Arg('input', () => UpdateMJAIPromptRunInput) input: UpdateMJAIPromptRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Prompt Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIPromptRun_)
    async DeleteMJAIPromptRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Prompt Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendor Type Definitions
//****************************************************************************
@ObjectType({ description: `Defines the possible types of AI vendors, such as Model Developer or Inference Provider.` })
export class MJAIVendorTypeDefinition_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The name of the vendor type.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the vendor type.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAIModelVendor_])
    MJ_AIModelVendors_TypeIDArray: MJAIModelVendor_[]; // Link to MJ_AIModelVendors
    
    @Field(() => [MJAIVendorType_])
    MJ_AIVendorTypes_TypeIDArray: MJAIVendorType_[]; // Link to MJ_AIVendorTypes
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Type Definitions
//****************************************************************************
@InputType()
export class CreateMJAIVendorTypeDefinitionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Type Definitions
//****************************************************************************
@InputType()
export class UpdateMJAIVendorTypeDefinitionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendor Type Definitions
//****************************************************************************
@ObjectType()
export class RunMJAIVendorTypeDefinitionViewResult {
    @Field(() => [MJAIVendorTypeDefinition_])
    Results: MJAIVendorTypeDefinition_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIVendorTypeDefinition_)
export class MJAIVendorTypeDefinitionResolver extends ResolverBase {
    @Query(() => RunMJAIVendorTypeDefinitionViewResult)
    async RunMJAIVendorTypeDefinitionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeDefinitionViewResult)
    async RunMJAIVendorTypeDefinitionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeDefinitionViewResult)
    async RunMJAIVendorTypeDefinitionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendor Type Definitions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIVendorTypeDefinition_, { nullable: true })
    async MJAIVendorTypeDefinition(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIVendorTypeDefinition_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendor Type Definitions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypeDefinitions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Type Definitions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Vendor Type Definitions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIModelVendor_])
    async MJ_AIModelVendors_TypeIDArray(@Root() mjaivendortypedefinition_: MJAIVendorTypeDefinition_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [TypeID]='${mjaivendortypedefinition_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIVendorType_])
    async MJ_AIVendorTypes_TypeIDArray(@Root() mjaivendortypedefinition_: MJAIVendorTypeDefinition_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypes] WHERE [TypeID]='${mjaivendortypedefinition_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendor Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIVendorTypeDefinition_)
    async CreateMJAIVendorTypeDefinition(
        @Arg('input', () => CreateMJAIVendorTypeDefinitionInput) input: CreateMJAIVendorTypeDefinitionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendor Type Definitions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIVendorTypeDefinition_)
    async UpdateMJAIVendorTypeDefinition(
        @Arg('input', () => UpdateMJAIVendorTypeDefinitionInput) input: UpdateMJAIVendorTypeDefinitionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendor Type Definitions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIVendorTypeDefinition_)
    async DeleteMJAIVendorTypeDefinition(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendor Type Definitions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendor Types
//****************************************************************************
@ObjectType({ description: `Associates vendors with their types (Model Developer, Inference Provider) and tracks the status of each role.` })
export class MJAIVendorType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    VendorID: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field(() => Int, {description: `Determines the priority rank of this type for the vendor. Higher values indicate higher priority.`}) 
    Rank: number;
        
    @Field({description: `The current status of this vendor type. Values include Active, Inactive, Deprecated, and Preview.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Vendor: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Types
//****************************************************************************
@InputType()
export class CreateMJAIVendorTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendor Types
//****************************************************************************
@InputType()
export class UpdateMJAIVendorTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VendorID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field(() => Int, { nullable: true })
    Rank?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendor Types
//****************************************************************************
@ObjectType()
export class RunMJAIVendorTypeViewResult {
    @Field(() => [MJAIVendorType_])
    Results: MJAIVendorType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIVendorType_)
export class MJAIVendorTypeResolver extends ResolverBase {
    @Query(() => RunMJAIVendorTypeViewResult)
    async RunMJAIVendorTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeViewResult)
    async RunMJAIVendorTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorTypeViewResult)
    async RunMJAIVendorTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendor Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIVendorType_, { nullable: true })
    async MJAIVendorType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIVendorType_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Vendor Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAIVendorType_)
    async CreateMJAIVendorType(
        @Arg('input', () => CreateMJAIVendorTypeInput) input: CreateMJAIVendorTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendor Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIVendorType_)
    async UpdateMJAIVendorType(
        @Arg('input', () => UpdateMJAIVendorTypeInput) input: UpdateMJAIVendorTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendor Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIVendorType_)
    async DeleteMJAIVendorType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendor Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: AI Vendors
//****************************************************************************
@ObjectType({ description: `Stores information about AI vendors providing models and/or inference services.` })
export class MJAIVendor_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The unique name of the vendor.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the vendor and their AI offerings.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Reference to the type of credential this vendor expects (e.g., API Key, GCP Service Account, Azure Service Principal). Used for type-based default credential resolution when no explicit binding exists, and for UI guidance when creating credentials.`}) 
    @MaxLength(16)
    CredentialTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CredentialType?: string;
        
    @Field(() => [MJAIPromptModel_])
    MJ_AIPromptModels_VendorIDArray: MJAIPromptModel_[]; // Link to MJ_AIPromptModels
    
    @Field(() => [MJAIResultCache_])
    AIResultCache_VendorIDArray: MJAIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [MJAIModelVendor_])
    MJ_AIModelVendors_VendorIDArray: MJAIModelVendor_[]; // Link to MJ_AIModelVendors
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_VendorIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJAIVendorType_])
    MJ_AIVendorTypes_VendorIDArray: MJAIVendorType_[]; // Link to MJ_AIVendorTypes
    
    @Field(() => [MJAIModelCost_])
    MJ_AIModelCosts_VendorIDArray: MJAIModelCost_[]; // Link to MJ_AIModelCosts
    
    @Field(() => [MJAICredentialBinding_])
    MJ_AICredentialBindings_AIVendorIDArray: MJAICredentialBinding_[]; // Link to MJ_AICredentialBindings
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_OverrideVendorIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: AI Vendors
//****************************************************************************
@InputType()
export class CreateMJAIVendorInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CredentialTypeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: AI Vendors
//****************************************************************************
@InputType()
export class UpdateMJAIVendorInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CredentialTypeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: AI Vendors
//****************************************************************************
@ObjectType()
export class RunMJAIVendorViewResult {
    @Field(() => [MJAIVendor_])
    Results: MJAIVendor_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAIVendor_)
export class MJAIVendorResolver extends ResolverBase {
    @Query(() => RunMJAIVendorViewResult)
    async RunMJAIVendorViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorViewResult)
    async RunMJAIVendorViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAIVendorViewResult)
    async RunMJAIVendorDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: AI Vendors';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAIVendor_, { nullable: true })
    async MJAIVendor(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAIVendor_ | null> {
        this.CheckUserReadPermissions('MJ: AI Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendors] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: AI Vendors', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIPromptModel_])
    async MJ_AIPromptModels_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Models', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptModels] WHERE [VendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Models', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Models', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIResultCache_])
    async AIResultCache_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [VendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Result Cache', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelVendor_])
    async MJ_AIModelVendors_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelVendors] WHERE [VendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [VendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIVendorType_])
    async MJ_AIVendorTypes_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendor Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendorTypes] WHERE [VendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendor Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendor Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIModelCost_])
    async MJ_AIModelCosts_VendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Model Costs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelCosts] WHERE [VendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Model Costs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Model Costs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJ_AICredentialBindings_AIVendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAICredentialBindings] WHERE [AIVendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_OverrideVendorIDArray(@Root() mjaivendor_: MJAIVendor_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [OverrideVendorID]='${mjaivendor_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAIVendor_)
    async CreateMJAIVendor(
        @Arg('input', () => CreateMJAIVendorInput) input: CreateMJAIVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: AI Vendors', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAIVendor_)
    async UpdateMJAIVendor(
        @Arg('input', () => UpdateMJAIVendorInput) input: UpdateMJAIVendorInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: AI Vendors', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAIVendor_)
    async DeleteMJAIVendor(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: AI Vendors', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Application Scopes
//****************************************************************************
@ObjectType({ description: `Defines the scope ceiling for each application with pattern-based rules. Controls which scopes and resource patterns an application can use, regardless of what API keys grant.` })
export class MJAPIApplicationScope_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the application this ceiling rule applies to.`}) 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field({description: `Reference to the scope this rule applies to.`}) 
    @MaxLength(16)
    ScopeID: string;
        
    @Field({nullable: true, description: `Glob pattern for matching resources (e.g., Users,Accounts or Skip* or *). NULL means match all resources.`}) 
    @MaxLength(1500)
    ResourcePattern?: string;
        
    @Field({description: `How to interpret the pattern: Include (grant if matches) or Exclude (grant if does NOT match).`}) 
    @MaxLength(40)
    PatternType: string;
        
    @Field(() => Boolean, {description: `If true, this rule explicitly DENIES access. Deny rules trump allow rules at the same priority level.`}) 
    IsDeny: boolean;
        
    @Field(() => Int, {description: `Rule evaluation order. Higher priority rules are evaluated first. Within same priority, deny rules are evaluated before allow rules.`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(200)
    Scope: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Application Scopes
//****************************************************************************
@InputType()
export class CreateMJAPIApplicationScopeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Application Scopes
//****************************************************************************
@InputType()
export class UpdateMJAPIApplicationScopeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern?: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Application Scopes
//****************************************************************************
@ObjectType()
export class RunMJAPIApplicationScopeViewResult {
    @Field(() => [MJAPIApplicationScope_])
    Results: MJAPIApplicationScope_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIApplicationScope_)
export class MJAPIApplicationScopeResolver extends ResolverBase {
    @Query(() => RunMJAPIApplicationScopeViewResult)
    async RunMJAPIApplicationScopeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationScopeViewResult)
    async RunMJAPIApplicationScopeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationScopeViewResult)
    async RunMJAPIApplicationScopeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Application Scopes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIApplicationScope_, { nullable: true })
    async MJAPIApplicationScope(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIApplicationScope_ | null> {
        this.CheckUserReadPermissions('MJ: API Application Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIApplicationScopes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Application Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Application Scopes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIApplicationScope_)
    async CreateMJAPIApplicationScope(
        @Arg('input', () => CreateMJAPIApplicationScopeInput) input: CreateMJAPIApplicationScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Application Scopes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIApplicationScope_)
    async UpdateMJAPIApplicationScope(
        @Arg('input', () => UpdateMJAPIApplicationScopeInput) input: UpdateMJAPIApplicationScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Application Scopes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIApplicationScope_)
    async DeleteMJAPIApplicationScope(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Application Scopes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Applications
//****************************************************************************
@ObjectType({ description: `Registry of applications that can consume MemberJunction APIs. Each application defines a scope ceiling that limits what API keys can access when used with that application.` })
export class MJAPIApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name identifying the application (e.g., MJAPI, MCPServer, Portal, CLI).`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Human-readable description of the application and its purpose.`}) 
    @MaxLength(1000)
    Description?: string;
        
    @Field(() => Boolean, {description: `Whether this application is currently active. Inactive applications reject all API key authentication.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJAPIKeyUsageLog_])
    MJ_APIKeyUsageLogs_ApplicationIDArray: MJAPIKeyUsageLog_[]; // Link to MJ_APIKeyUsageLogs
    
    @Field(() => [MJAPIApplicationScope_])
    MJ_APIApplicationScopes_ApplicationIDArray: MJAPIApplicationScope_[]; // Link to MJ_APIApplicationScopes
    
    @Field(() => [MJAPIKeyApplication_])
    MJ_APIKeyApplications_ApplicationIDArray: MJAPIKeyApplication_[]; // Link to MJ_APIKeyApplications
    
}

//****************************************************************************
// INPUT TYPE for MJ: API Applications
//****************************************************************************
@InputType()
export class CreateMJAPIApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Applications
//****************************************************************************
@InputType()
export class UpdateMJAPIApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Applications
//****************************************************************************
@ObjectType()
export class RunMJAPIApplicationViewResult {
    @Field(() => [MJAPIApplication_])
    Results: MJAPIApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIApplication_)
export class MJAPIApplicationResolver extends ResolverBase {
    @Query(() => RunMJAPIApplicationViewResult)
    async RunMJAPIApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationViewResult)
    async RunMJAPIApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIApplicationViewResult)
    async RunMJAPIApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIApplication_, { nullable: true })
    async MJAPIApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIApplication_ | null> {
        this.CheckUserReadPermissions('MJ: API Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAPIKeyUsageLog_])
    async MJ_APIKeyUsageLogs_ApplicationIDArray(@Root() mjapiapplication_: MJAPIApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Usage Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyUsageLogs] WHERE [ApplicationID]='${mjapiapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Usage Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Usage Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIApplicationScope_])
    async MJ_APIApplicationScopes_ApplicationIDArray(@Root() mjapiapplication_: MJAPIApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Application Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIApplicationScopes] WHERE [ApplicationID]='${mjapiapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Application Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Application Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKeyApplication_])
    async MJ_APIKeyApplications_ApplicationIDArray(@Root() mjapiapplication_: MJAPIApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyApplications] WHERE [ApplicationID]='${mjapiapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAPIApplication_)
    async CreateMJAPIApplication(
        @Arg('input', () => CreateMJAPIApplicationInput) input: CreateMJAPIApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIApplication_)
    async UpdateMJAPIApplication(
        @Arg('input', () => UpdateMJAPIApplicationInput) input: UpdateMJAPIApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIApplication_)
    async DeleteMJAPIApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Key Applications
//****************************************************************************
@ObjectType({ description: `Optional binding of API keys to specific applications. If no records exist for a key, it works with all applications. If records exist, the key only works with those specific applications.` })
export class MJAPIKeyApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the API key being bound to an application.`}) 
    @MaxLength(16)
    APIKeyID: string;
        
    @Field({description: `Reference to the application this key is authorized to use.`}) 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    APIKey: string;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Key Applications
//****************************************************************************
@InputType()
export class CreateMJAPIKeyApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Key Applications
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Key Applications
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyApplicationViewResult {
    @Field(() => [MJAPIKeyApplication_])
    Results: MJAPIKeyApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKeyApplication_)
export class MJAPIKeyApplicationResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyApplicationViewResult)
    async RunMJAPIKeyApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyApplicationViewResult)
    async RunMJAPIKeyApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyApplicationViewResult)
    async RunMJAPIKeyApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Key Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKeyApplication_, { nullable: true })
    async MJAPIKeyApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKeyApplication_ | null> {
        this.CheckUserReadPermissions('MJ: API Key Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Key Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIKeyApplication_)
    async CreateMJAPIKeyApplication(
        @Arg('input', () => CreateMJAPIKeyApplicationInput) input: CreateMJAPIKeyApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Key Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKeyApplication_)
    async UpdateMJAPIKeyApplication(
        @Arg('input', () => UpdateMJAPIKeyApplicationInput) input: UpdateMJAPIKeyApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Key Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKeyApplication_)
    async DeleteMJAPIKeyApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Key Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Key Scopes
//****************************************************************************
@ObjectType({ description: `Junction table linking API keys to their assigned permission scopes. Each key can have multiple scopes, and scopes can be shared across multiple keys.` })
export class MJAPIKeyScope_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    APIKeyID: string;
        
    @Field() 
    @MaxLength(16)
    ScopeID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Glob pattern for matching resources (e.g., Users,Accounts or Skip* or *). NULL means match all resources under this scope.`}) 
    @MaxLength(1500)
    ResourcePattern?: string;
        
    @Field({description: `How to interpret the pattern: Include (grant if matches) or Exclude (grant if does NOT match).`}) 
    @MaxLength(40)
    PatternType: string;
        
    @Field(() => Boolean, {description: `If true, this rule explicitly DENIES access. Deny rules trump allow rules at the same priority level.`}) 
    IsDeny: boolean;
        
    @Field(() => Int, {description: `Rule evaluation order. Higher priority rules are evaluated first. Within same priority, deny rules are evaluated before allow rules.`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(510)
    APIKey: string;
        
    @Field() 
    @MaxLength(200)
    Scope: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Key Scopes
//****************************************************************************
@InputType()
export class CreateMJAPIKeyScopeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Key Scopes
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyScopeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    ScopeID?: string;

    @Field({ nullable: true })
    ResourcePattern?: string | null;

    @Field({ nullable: true })
    PatternType?: string;

    @Field(() => Boolean, { nullable: true })
    IsDeny?: boolean;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Key Scopes
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyScopeViewResult {
    @Field(() => [MJAPIKeyScope_])
    Results: MJAPIKeyScope_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKeyScope_)
export class MJAPIKeyScopeResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyScopeViewResult)
    async RunMJAPIKeyScopeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyScopeViewResult)
    async RunMJAPIKeyScopeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyScopeViewResult)
    async RunMJAPIKeyScopeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Key Scopes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKeyScope_, { nullable: true })
    async MJAPIKeyScope(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKeyScope_ | null> {
        this.CheckUserReadPermissions('MJ: API Key Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyScopes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Key Scopes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIKeyScope_)
    async CreateMJAPIKeyScope(
        @Arg('input', () => CreateMJAPIKeyScopeInput) input: CreateMJAPIKeyScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Key Scopes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKeyScope_)
    async UpdateMJAPIKeyScope(
        @Arg('input', () => UpdateMJAPIKeyScopeInput) input: UpdateMJAPIKeyScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Key Scopes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKeyScope_)
    async DeleteMJAPIKeyScope(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Key Scopes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Key Usage Logs
//****************************************************************************
@ObjectType({ description: `Audit log tracking all API key usage for analytics, debugging, and security monitoring. Records each request including endpoint, response status, timing, and client information.` })
export class MJAPIKeyUsageLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    APIKeyID: string;
        
    @Field({description: `The API endpoint path that was accessed (e.g., /mcp, /graphql, /api/v1/entities).`}) 
    @MaxLength(1000)
    Endpoint: string;
        
    @Field({nullable: true, description: `The specific operation performed, such as the GraphQL operation name or MCP tool invoked (e.g., Get_Users_Record, Run_Agent).`}) 
    @MaxLength(510)
    Operation?: string;
        
    @Field({description: `HTTP method used for the request (GET, POST, PUT, DELETE, etc.).`}) 
    @MaxLength(20)
    Method: string;
        
    @Field(() => Int, {description: `HTTP response status code returned to the client (e.g., 200 for success, 401 for unauthorized, 500 for server error).`}) 
    StatusCode: number;
        
    @Field(() => Int, {nullable: true, description: `Total time in milliseconds to process the request and return a response. Useful for performance monitoring.`}) 
    ResponseTimeMs?: number;
        
    @Field({nullable: true, description: `Client IP address that made the request. Supports both IPv4 and IPv6 addresses (up to 45 characters).`}) 
    @MaxLength(90)
    IPAddress?: string;
        
    @Field({nullable: true, description: `User-Agent header from the HTTP request, identifying the client application or library making the API call.`}) 
    @MaxLength(1000)
    UserAgent?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The application through which this request was made (MJAPI, MCPServer, etc.).`}) 
    @MaxLength(16)
    ApplicationID?: string;
        
    @Field({nullable: true, description: `The specific resource that was requested (e.g., entity name, agent name, query name).`}) 
    @MaxLength(1000)
    RequestedResource?: string;
        
    @Field({nullable: true, description: `JSON array containing detailed evaluation of each scope rule checked during authorization.`}) 
    ScopesEvaluated?: string;
        
    @Field({description: `Final authorization result: Allowed, Denied, or NoScopesRequired (for operations that do not require scope checks).`}) 
    @MaxLength(40)
    AuthorizationResult: string;
        
    @Field({nullable: true, description: `When authorization is denied, explains why (e.g., app ceiling blocked, no matching key scope, explicit deny rule).`}) 
    @MaxLength(1000)
    DeniedReason?: string;
        
    @Field() 
    @MaxLength(510)
    APIKey: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Application?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: API Key Usage Logs
//****************************************************************************
@InputType()
export class CreateMJAPIKeyUsageLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    Endpoint?: string;

    @Field({ nullable: true })
    Operation: string | null;

    @Field({ nullable: true })
    Method?: string;

    @Field(() => Int, { nullable: true })
    StatusCode?: number;

    @Field(() => Int, { nullable: true })
    ResponseTimeMs: number | null;

    @Field({ nullable: true })
    IPAddress: string | null;

    @Field({ nullable: true })
    UserAgent: string | null;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field({ nullable: true })
    RequestedResource: string | null;

    @Field({ nullable: true })
    ScopesEvaluated: string | null;

    @Field({ nullable: true })
    AuthorizationResult?: string;

    @Field({ nullable: true })
    DeniedReason: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Key Usage Logs
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyUsageLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    APIKeyID?: string;

    @Field({ nullable: true })
    Endpoint?: string;

    @Field({ nullable: true })
    Operation?: string | null;

    @Field({ nullable: true })
    Method?: string;

    @Field(() => Int, { nullable: true })
    StatusCode?: number;

    @Field(() => Int, { nullable: true })
    ResponseTimeMs?: number | null;

    @Field({ nullable: true })
    IPAddress?: string | null;

    @Field({ nullable: true })
    UserAgent?: string | null;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field({ nullable: true })
    RequestedResource?: string | null;

    @Field({ nullable: true })
    ScopesEvaluated?: string | null;

    @Field({ nullable: true })
    AuthorizationResult?: string;

    @Field({ nullable: true })
    DeniedReason?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Key Usage Logs
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyUsageLogViewResult {
    @Field(() => [MJAPIKeyUsageLog_])
    Results: MJAPIKeyUsageLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKeyUsageLog_)
export class MJAPIKeyUsageLogResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyUsageLogViewResult)
    async RunMJAPIKeyUsageLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyUsageLogViewResult)
    async RunMJAPIKeyUsageLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyUsageLogViewResult)
    async RunMJAPIKeyUsageLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Key Usage Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKeyUsageLog_, { nullable: true })
    async MJAPIKeyUsageLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKeyUsageLog_ | null> {
        this.CheckUserReadPermissions('MJ: API Key Usage Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyUsageLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Usage Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Key Usage Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJAPIKeyUsageLog_)
    async CreateMJAPIKeyUsageLog(
        @Arg('input', () => CreateMJAPIKeyUsageLogInput) input: CreateMJAPIKeyUsageLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Key Usage Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKeyUsageLog_)
    async UpdateMJAPIKeyUsageLog(
        @Arg('input', () => UpdateMJAPIKeyUsageLogInput) input: UpdateMJAPIKeyUsageLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Key Usage Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKeyUsageLog_)
    async DeleteMJAPIKeyUsageLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Key Usage Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Keys
//****************************************************************************
@ObjectType({ description: `Stores API keys for programmatic access to MemberJunction services. Keys are stored as SHA-256 hashes for security. Each key is associated with a user context and can have multiple permission scopes assigned.` })
export class MJAPIKey_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `SHA-256 hash of the raw API key (64 hexadecimal characters). The raw key is only shown once at creation time and cannot be recovered.`}) 
    @MaxLength(128)
    Hash: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `User-friendly name for identifying the key purpose (e.g., Cowork Integration, CI/CD Pipeline, Mobile App).`}) 
    @MaxLength(510)
    Label: string;
        
    @Field({nullable: true, description: `Optional detailed description of the key's intended use, integration details, or other notes.`}) 
    @MaxLength(2000)
    Description?: string;
        
    @Field({description: `Current lifecycle status of the key. Active keys can be used for authentication; Revoked keys are permanently disabled.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional expiration timestamp. Keys with NULL expiration never expire. Expired keys are rejected during authentication.`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the most recent successful authentication using this key. Updated on each valid API request.`}) 
    @MaxLength(10)
    LastUsedAt?: Date;
        
    @Field() 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
    @Field(() => [MJAPIKeyUsageLog_])
    MJ_APIKeyUsageLogs_APIKeyIDArray: MJAPIKeyUsageLog_[]; // Link to MJ_APIKeyUsageLogs
    
    @Field(() => [MJAPIKeyScope_])
    MJ_APIKeyScopes_APIKeyIDArray: MJAPIKeyScope_[]; // Link to MJ_APIKeyScopes
    
    @Field(() => [MJAPIKeyApplication_])
    MJ_APIKeyApplications_APIKeyIDArray: MJAPIKeyApplication_[]; // Link to MJ_APIKeyApplications
    
}

//****************************************************************************
// INPUT TYPE for MJ: API Keys
//****************************************************************************
@InputType()
export class CreateMJAPIKeyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Hash?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Label?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field({ nullable: true })
    LastUsedAt: Date | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Keys
//****************************************************************************
@InputType()
export class UpdateMJAPIKeyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Hash?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Label?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field({ nullable: true })
    LastUsedAt?: Date | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Keys
//****************************************************************************
@ObjectType()
export class RunMJAPIKeyViewResult {
    @Field(() => [MJAPIKey_])
    Results: MJAPIKey_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIKey_)
export class MJAPIKeyResolver extends ResolverBase {
    @Query(() => RunMJAPIKeyViewResult)
    async RunMJAPIKeyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyViewResult)
    async RunMJAPIKeyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIKeyViewResult)
    async RunMJAPIKeyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Keys';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIKey_, { nullable: true })
    async MJAPIKey(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIKey_ | null> {
        this.CheckUserReadPermissions('MJ: API Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeys] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Keys', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAPIKeyUsageLog_])
    async MJ_APIKeyUsageLogs_APIKeyIDArray(@Root() mjapikey_: MJAPIKey_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Usage Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyUsageLogs] WHERE [APIKeyID]='${mjapikey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Usage Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Usage Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKeyScope_])
    async MJ_APIKeyScopes_APIKeyIDArray(@Root() mjapikey_: MJAPIKey_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyScopes] WHERE [APIKeyID]='${mjapikey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKeyApplication_])
    async MJ_APIKeyApplications_APIKeyIDArray(@Root() mjapikey_: MJAPIKey_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyApplications] WHERE [APIKeyID]='${mjapikey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAPIKey_)
    async CreateMJAPIKey(
        @Arg('input', () => CreateMJAPIKeyInput) input: CreateMJAPIKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Keys', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIKey_)
    async UpdateMJAPIKey(
        @Arg('input', () => UpdateMJAPIKeyInput) input: UpdateMJAPIKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Keys', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIKey_)
    async DeleteMJAPIKey(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Keys', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: API Scopes
//****************************************************************************
@ObjectType({ description: `Defines reusable permission scopes that can be assigned to API keys. Scopes follow a hierarchical naming convention (e.g., entities:read, agents:execute, admin:*) and are grouped by category for organizational purposes.` })
export class MJAPIScope_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique scope identifier following the pattern category:permission (e.g., entities:read, agents:execute, admin:*). Supports wildcard (*) for broad permissions.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `Grouping category for the scope (e.g., Entities, Agents, Admin). Used for organizing and filtering scopes in the UI.`}) 
    @MaxLength(200)
    Category: string;
        
    @Field({nullable: true, description: `Human-readable description explaining what permissions this scope grants.`}) 
    @MaxLength(1000)
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Reference to parent scope for hierarchical organization. NULL indicates a root-level scope.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Full hierarchical path of the scope (e.g., entity:runview, agent:execute). Used for matching during authorization.`}) 
    @MaxLength(1000)
    FullPath: string;
        
    @Field({nullable: true, description: `Type of resource this scope applies to (Entity, Agent, Query, Mutation, or NULL for abstract grouping scopes).`}) 
    @MaxLength(100)
    ResourceType?: string;
        
    @Field(() => Boolean, {description: `Whether this scope is currently active. Inactive scopes are ignored during authorization.`}) 
    IsActive: boolean;
        
    @Field({nullable: true, description: `JSON configuration for UI presentation. Schema: { "icon": "fa-solid fa-xxx", "color": "#hexcolor" }. Icon should be a Font Awesome class. Color should be a hex color code.`}) 
    UIConfig?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJAPIKeyScope_])
    MJ_APIKeyScopes_ScopeIDArray: MJAPIKeyScope_[]; // Link to MJ_APIKeyScopes
    
    @Field(() => [MJAPIApplicationScope_])
    MJ_APIApplicationScopes_ScopeIDArray: MJAPIApplicationScope_[]; // Link to MJ_APIApplicationScopes
    
    @Field(() => [MJAPIScope_])
    MJ_APIScopes_ParentIDArray: MJAPIScope_[]; // Link to MJ_APIScopes
    
}

//****************************************************************************
// INPUT TYPE for MJ: API Scopes
//****************************************************************************
@InputType()
export class CreateMJAPIScopeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    FullPath?: string;

    @Field({ nullable: true })
    ResourceType: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    UIConfig: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: API Scopes
//****************************************************************************
@InputType()
export class UpdateMJAPIScopeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    FullPath?: string;

    @Field({ nullable: true })
    ResourceType?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    UIConfig?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: API Scopes
//****************************************************************************
@ObjectType()
export class RunMJAPIScopeViewResult {
    @Field(() => [MJAPIScope_])
    Results: MJAPIScope_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJAPIScope_)
export class MJAPIScopeResolver extends ResolverBase {
    @Query(() => RunMJAPIScopeViewResult)
    async RunMJAPIScopeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIScopeViewResult)
    async RunMJAPIScopeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJAPIScopeViewResult)
    async RunMJAPIScopeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: API Scopes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJAPIScope_, { nullable: true })
    async MJAPIScope(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJAPIScope_ | null> {
        this.CheckUserReadPermissions('MJ: API Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIScopes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: API Scopes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAPIKeyScope_])
    async MJ_APIKeyScopes_ScopeIDArray(@Root() mjapiscope_: MJAPIScope_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Key Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeyScopes] WHERE [ScopeID]='${mjapiscope_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Key Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Key Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIApplicationScope_])
    async MJ_APIApplicationScopes_ScopeIDArray(@Root() mjapiscope_: MJAPIScope_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Application Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIApplicationScopes] WHERE [ScopeID]='${mjapiscope_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Application Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Application Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIScope_])
    async MJ_APIScopes_ParentIDArray(@Root() mjapiscope_: MJAPIScope_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Scopes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIScopes] WHERE [ParentID]='${mjapiscope_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Scopes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Scopes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJAPIScope_)
    async CreateMJAPIScope(
        @Arg('input', () => CreateMJAPIScopeInput) input: CreateMJAPIScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: API Scopes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJAPIScope_)
    async UpdateMJAPIScope(
        @Arg('input', () => UpdateMJAPIScopeInput) input: UpdateMJAPIScopeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: API Scopes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJAPIScope_)
    async DeleteMJAPIScope(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: API Scopes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for artifacts with granular access control (Read, Edit, Delete, Share)` })
export class MJArtifactPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ArtifactID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Boolean, {description: `Whether the user can view/read the artifact`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can modify the artifact or create new versions`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can delete the artifact`}) 
    CanDelete: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can share the artifact with other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `Foreign key to the User who shared this artifact (if shared)`}) 
    @MaxLength(16)
    SharedByUserID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Artifact: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Permissions
//****************************************************************************
@InputType()
export class CreateMJArtifactPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateMJArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunMJArtifactPermissionViewResult {
    @Field(() => [MJArtifactPermission_])
    Results: MJArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactPermission_)
export class MJArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunMJArtifactPermissionViewResult)
    async RunMJArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactPermissionViewResult)
    async RunMJArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactPermissionViewResult)
    async RunMJArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactPermission_, { nullable: true })
    async MJArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJArtifactPermission_)
    async CreateMJArtifactPermission(
        @Arg('input', () => CreateMJArtifactPermissionInput) input: CreateMJArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactPermission_)
    async UpdateMJArtifactPermission(
        @Arg('input', () => UpdateMJArtifactPermissionInput) input: UpdateMJArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactPermission_)
    async DeleteMJArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Types
//****************************************************************************
@ObjectType({ description: `Defines the types of artifacts that can be created within conversations` })
export class MJArtifactType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact type`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact type`}) 
    Description?: string;
        
    @Field({description: `MIME type or content identifier for this artifact type`}) 
    @MaxLength(200)
    ContentType: string;
        
    @Field(() => Boolean, {description: `Indicates if this artifact type is currently available for use`}) 
    IsEnabled: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Parent artifact type ID for hierarchical artifact type organization. Child types inherit ExtractRules from parent but can override.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `JSON array of extraction rules defining how to extract attributes from artifact content. Each rule has: name (string), description (string), type (TypeScript type), standardProperty ('name'|'description'|'displayMarkdown'|'displayHtml'|null), extractor (JavaScript code string). Child types inherit parent rules and can override by name.`}) 
    ExtractRules?: string;
        
    @Field({nullable: true, description: `Driver class name for the artifact viewer plugin. References Angular component registered with @RegisterClass decorator.`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class name for displaying this artifact type in the UI (e.g., fa-file-code, fa-chart-line)`}) 
    @MaxLength(510)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJConversationArtifact_])
    MJ_ConversationArtifacts_ArtifactTypeIDArray: MJConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
    @Field(() => [MJAIAgentArtifactType_])
    MJ_AIAgentArtifactTypes_ArtifactTypeIDArray: MJAIAgentArtifactType_[]; // Link to MJ_AIAgentArtifactTypes
    
    @Field(() => [MJArtifact_])
    MJ_Artifacts_TypeIDArray: MJArtifact_[]; // Link to MJ_Artifacts
    
    @Field(() => [MJArtifactType_])
    MJ_ArtifactTypes_ParentIDArray: MJArtifactType_[]; // Link to MJ_ArtifactTypes
    
    @Field(() => [MJAIAgent_])
    AIAgents_DefaultArtifactTypeIDArray: MJAIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class CreateMJArtifactTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    ExtractRules: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    Icon: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class UpdateMJArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    ExtractRules?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Types
//****************************************************************************
@ObjectType()
export class RunMJArtifactTypeViewResult {
    @Field(() => [MJArtifactType_])
    Results: MJArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactType_)
export class MJArtifactTypeResolver extends ResolverBase {
    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactTypeViewResult)
    async RunMJArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactType_, { nullable: true })
    async MJArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationArtifact_])
    async MJ_ConversationArtifacts_ArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ArtifactTypeID]='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentArtifactType_])
    async MJ_AIAgentArtifactTypes_ArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentArtifactTypes] WHERE [ArtifactTypeID]='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Artifact Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifact_])
    async MJ_Artifacts_TypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifacts] WHERE [TypeID]='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactType_])
    async MJ_ArtifactTypes_ParentIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactTypes] WHERE [ParentID]='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async AIAgents_DefaultArtifactTypeIDArray(@Root() mjartifacttype_: MJArtifactType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [DefaultArtifactTypeID]='${mjartifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJArtifactType_)
    async CreateMJArtifactType(
        @Arg('input', () => CreateMJArtifactTypeInput) input: CreateMJArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactType_)
    async UpdateMJArtifactType(
        @Arg('input', () => UpdateMJArtifactTypeInput) input: UpdateMJArtifactTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactType_)
    async DeleteMJArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Uses
//****************************************************************************
@ObjectType({ description: `Audit trail of artifact usage for security and analytics. Tracks each time an artifact is viewed, opened, shared, saved, or exported by users.` })
export class MJArtifactUse_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The specific version of the artifact being used.`}) 
    @MaxLength(16)
    ArtifactVersionID: string;
        
    @Field({description: `The user performing the action.`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Type of usage: Viewed (artifact displayed), Opened (artifact accessed), Shared (artifact shared with others), Saved (artifact bookmarked), or Exported (artifact downloaded).`}) 
    @MaxLength(40)
    UsageType: string;
        
    @Field({nullable: true, description: `Optional JSON context with additional metadata about the usage event (e.g., source page, referrer, device info).`}) 
    UsageContext?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ArtifactVersion?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Uses
//****************************************************************************
@InputType()
export class CreateMJArtifactUseInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UsageType?: string;

    @Field({ nullable: true })
    UsageContext: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Uses
//****************************************************************************
@InputType()
export class UpdateMJArtifactUseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UsageType?: string;

    @Field({ nullable: true })
    UsageContext?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Uses
//****************************************************************************
@ObjectType()
export class RunMJArtifactUseViewResult {
    @Field(() => [MJArtifactUse_])
    Results: MJArtifactUse_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactUse_)
export class MJArtifactUseResolver extends ResolverBase {
    @Query(() => RunMJArtifactUseViewResult)
    async RunMJArtifactUseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactUseViewResult)
    async RunMJArtifactUseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactUseViewResult)
    async RunMJArtifactUseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Uses';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactUse_, { nullable: true })
    async MJArtifactUse(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactUse_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Uses', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactUses] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Uses', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Uses', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJArtifactUse_)
    async CreateMJArtifactUse(
        @Arg('input', () => CreateMJArtifactUseInput) input: CreateMJArtifactUseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Uses', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactUse_)
    async UpdateMJArtifactUse(
        @Arg('input', () => UpdateMJArtifactUseInput) input: UpdateMJArtifactUseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Uses', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactUse_)
    async DeleteMJArtifactUse(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Uses', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Version Attributes
//****************************************************************************
@ObjectType({ description: `Stores extracted attribute values from artifact content based on ArtifactType ExtractRules. Prevents re-running extraction logic on every access.` })
export class MJArtifactVersionAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The artifact version this attribute belongs to`}) 
    @MaxLength(16)
    ArtifactVersionID: string;
        
    @Field({description: `Name of the extracted attribute (matches ExtractRule.name)`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `TypeScript type definition of the value (e.g., 'string', 'number', 'Date', 'Array<{x: number, y: string}>')`}) 
    @MaxLength(1000)
    Type: string;
        
    @Field({nullable: true, description: `JSON-serialized extracted value`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Maps this attribute to a standard property for UI rendering: 'name', 'description', 'displayMarkdown', 'displayHtml', or NULL for custom attributes`}) 
    @MaxLength(100)
    StandardProperty?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ArtifactVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Version Attributes
//****************************************************************************
@InputType()
export class CreateMJArtifactVersionAttributeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    StandardProperty: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Version Attributes
//****************************************************************************
@InputType()
export class UpdateMJArtifactVersionAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    StandardProperty?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Version Attributes
//****************************************************************************
@ObjectType()
export class RunMJArtifactVersionAttributeViewResult {
    @Field(() => [MJArtifactVersionAttribute_])
    Results: MJArtifactVersionAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactVersionAttribute_)
export class MJArtifactVersionAttributeResolver extends ResolverBase {
    @Query(() => RunMJArtifactVersionAttributeViewResult)
    async RunMJArtifactVersionAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionAttributeViewResult)
    async RunMJArtifactVersionAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionAttributeViewResult)
    async RunMJArtifactVersionAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Version Attributes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactVersionAttribute_, { nullable: true })
    async MJArtifactVersionAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactVersionAttribute_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Version Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactVersionAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Version Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Version Attributes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJArtifactVersionAttribute_)
    async CreateMJArtifactVersionAttribute(
        @Arg('input', () => CreateMJArtifactVersionAttributeInput) input: CreateMJArtifactVersionAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Version Attributes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactVersionAttribute_)
    async UpdateMJArtifactVersionAttribute(
        @Arg('input', () => UpdateMJArtifactVersionAttributeInput) input: UpdateMJArtifactVersionAttributeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Version Attributes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactVersionAttribute_)
    async DeleteMJArtifactVersionAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Version Attributes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Versions
//****************************************************************************
@ObjectType({ description: `Version history for artifacts, tracking all changes over time` })
export class MJArtifactVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number for this artifact`}) 
    VersionNumber: number;
        
    @Field({nullable: true, description: `The content of the artifact at this version`}) 
    Content?: string;
        
    @Field({nullable: true, description: `JSON configuration for this version`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `SHA-256 hash of the Content field for duplicate detection and version comparison`}) 
    @MaxLength(1000)
    ContentHash?: string;
        
    @Field({nullable: true, description: `Name of this artifact version. Can differ from Artifact.Name as it may evolve with versions.`}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true, description: `Description of this artifact version. Can differ from Artifact.Description as it may evolve with versions.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(510)
    Artifact: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJArtifactVersionAttribute_])
    MJ_ArtifactVersionAttributes_ArtifactVersionIDArray: MJArtifactVersionAttribute_[]; // Link to MJ_ArtifactVersionAttributes
    
    @Field(() => [MJCollectionArtifact_])
    MJ_CollectionArtifacts_ArtifactVersionIDArray: MJCollectionArtifact_[]; // Link to MJ_CollectionArtifacts
    
    @Field(() => [MJConversationDetailArtifact_])
    MJ_ConversationDetailArtifacts_ArtifactVersionIDArray: MJConversationDetailArtifact_[]; // Link to MJ_ConversationDetailArtifacts
    
    @Field(() => [MJArtifactUse_])
    MJ_ArtifactUses_ArtifactVersionIDArray: MJArtifactUse_[]; // Link to MJ_ArtifactUses
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Versions
//****************************************************************************
@InputType()
export class CreateMJArtifactVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ContentHash: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Versions
//****************************************************************************
@InputType()
export class UpdateMJArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ArtifactID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ContentHash?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Versions
//****************************************************************************
@ObjectType()
export class RunMJArtifactVersionViewResult {
    @Field(() => [MJArtifactVersion_])
    Results: MJArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifactVersion_)
export class MJArtifactVersionResolver extends ResolverBase {
    @Query(() => RunMJArtifactVersionViewResult)
    async RunMJArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionViewResult)
    async RunMJArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactVersionViewResult)
    async RunMJArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifactVersion_, { nullable: true })
    async MJArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifact Versions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJArtifactVersionAttribute_])
    async MJ_ArtifactVersionAttributes_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Version Attributes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactVersionAttributes] WHERE [ArtifactVersionID]='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Version Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Version Attributes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionArtifact_])
    async MJ_CollectionArtifacts_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionArtifacts] WHERE [ArtifactVersionID]='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailArtifact_])
    async MJ_ConversationDetailArtifacts_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailArtifacts] WHERE [ArtifactVersionID]='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactUse_])
    async MJ_ArtifactUses_ArtifactVersionIDArray(@Root() mjartifactversion_: MJArtifactVersion_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Uses', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactUses] WHERE [ArtifactVersionID]='${mjartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Uses', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Uses', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJArtifactVersion_)
    async CreateMJArtifactVersion(
        @Arg('input', () => CreateMJArtifactVersionInput) input: CreateMJArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifact Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifactVersion_)
    async UpdateMJArtifactVersion(
        @Arg('input', () => UpdateMJArtifactVersionInput) input: UpdateMJArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifact Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifactVersion_)
    async DeleteMJArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifacts
//****************************************************************************
@ObjectType({ description: `Independent content items (code, documents, charts) that can be linked to multiple conversations and collections. Supports versioning and sharing.` })
export class MJArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field({description: `Display name for the artifact`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact contents and purpose`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Controls artifact visibility in user-facing lists. "Always" shows in all lists, "System Only" hides from normal views (for system-generated artifacts like agent routing payloads).`}) 
    @MaxLength(40)
    Visibility: string;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJArtifactVersion_])
    MJ_ArtifactVersions_ArtifactIDArray: MJArtifactVersion_[]; // Link to MJ_ArtifactVersions
    
    @Field(() => [MJCollectionArtifact_])
    MJ_CollectionArtifacts_ArtifactIDArray: MJCollectionArtifact_[]; // Link to MJ_CollectionArtifacts
    
    @Field(() => [MJArtifactPermission_])
    MJ_ArtifactPermissions_ArtifactIDArray: MJArtifactPermission_[]; // Link to MJ_ArtifactPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifacts
//****************************************************************************
@InputType()
export class CreateMJArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Visibility?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifacts
//****************************************************************************
@InputType()
export class UpdateMJArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Visibility?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifacts
//****************************************************************************
@ObjectType()
export class RunMJArtifactViewResult {
    @Field(() => [MJArtifact_])
    Results: MJArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJArtifact_)
export class MJArtifactResolver extends ResolverBase {
    @Query(() => RunMJArtifactViewResult)
    async RunMJArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactViewResult)
    async RunMJArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJArtifactViewResult)
    async RunMJArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJArtifact_, { nullable: true })
    async MJArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJArtifactVersion_])
    async MJ_ArtifactVersions_ArtifactIDArray(@Root() mjartifact_: MJArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactVersions] WHERE [ArtifactID]='${mjartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionArtifact_])
    async MJ_CollectionArtifacts_ArtifactIDArray(@Root() mjartifact_: MJArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionArtifacts] WHERE [ArtifactID]='${mjartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactPermission_])
    async MJ_ArtifactPermissions_ArtifactIDArray(@Root() mjartifact_: MJArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactPermissions] WHERE [ArtifactID]='${mjartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJArtifact_)
    async CreateMJArtifact(
        @Arg('input', () => CreateMJArtifactInput) input: CreateMJArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJArtifact_)
    async UpdateMJArtifact(
        @Arg('input', () => UpdateMJArtifactInput) input: UpdateMJArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJArtifact_)
    async DeleteMJArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Collection Artifacts
//****************************************************************************
@ObjectType({ description: `Links collections to specific artifact versions. Each collection can contain multiple versions of the same artifact.` })
export class MJCollectionArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CollectionID: string;
        
    @Field(() => Int, {description: `Sequence number for ordering artifacts within a collection`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Required. Specific version of the artifact saved to this collection. Collections store version-specific artifacts to enable proper version tracking and Links tab filtering.`}) 
    @MaxLength(16)
    ArtifactVersionID: string;
        
    @Field() 
    @MaxLength(510)
    Collection: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ArtifactVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Collection Artifacts
//****************************************************************************
@InputType()
export class CreateMJCollectionArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    ArtifactVersionID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Collection Artifacts
//****************************************************************************
@InputType()
export class UpdateMJCollectionArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Collection Artifacts
//****************************************************************************
@ObjectType()
export class RunMJCollectionArtifactViewResult {
    @Field(() => [MJCollectionArtifact_])
    Results: MJCollectionArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCollectionArtifact_)
export class MJCollectionArtifactResolver extends ResolverBase {
    @Query(() => RunMJCollectionArtifactViewResult)
    async RunMJCollectionArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionArtifactViewResult)
    async RunMJCollectionArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionArtifactViewResult)
    async RunMJCollectionArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Collection Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCollectionArtifact_, { nullable: true })
    async MJCollectionArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCollectionArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Collection Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCollectionArtifact_)
    async CreateMJCollectionArtifact(
        @Arg('input', () => CreateMJCollectionArtifactInput) input: CreateMJCollectionArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Collection Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCollectionArtifact_)
    async UpdateMJCollectionArtifact(
        @Arg('input', () => UpdateMJCollectionArtifactInput) input: UpdateMJCollectionArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Collection Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCollectionArtifact_)
    async DeleteMJCollectionArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Collection Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Collection Permissions
//****************************************************************************
@ObjectType({ description: `Manages sharing permissions for collections, allowing granular access control` })
export class MJCollectionPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CollectionID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Boolean, {description: `Always 1 - users must have read permission to access a shared collection`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Can share this collection with others (but cannot grant more permissions than they have)`}) 
    CanShare: boolean;
        
    @Field(() => Boolean, {description: `Can add/remove artifacts to/from this collection`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Can delete the collection, child collections, and artifacts`}) 
    CanDelete: boolean;
        
    @Field({nullable: true, description: `The user who shared this collection (NULL if shared by owner)`}) 
    @MaxLength(16)
    SharedByUserID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Collection: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Collection Permissions
//****************************************************************************
@InputType()
export class CreateMJCollectionPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Collection Permissions
//****************************************************************************
@InputType()
export class UpdateMJCollectionPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CollectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Collection Permissions
//****************************************************************************
@ObjectType()
export class RunMJCollectionPermissionViewResult {
    @Field(() => [MJCollectionPermission_])
    Results: MJCollectionPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCollectionPermission_)
export class MJCollectionPermissionResolver extends ResolverBase {
    @Query(() => RunMJCollectionPermissionViewResult)
    async RunMJCollectionPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionPermissionViewResult)
    async RunMJCollectionPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionPermissionViewResult)
    async RunMJCollectionPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Collection Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCollectionPermission_, { nullable: true })
    async MJCollectionPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCollectionPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Collection Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJCollectionPermission_)
    async CreateMJCollectionPermission(
        @Arg('input', () => CreateMJCollectionPermissionInput) input: CreateMJCollectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Collection Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCollectionPermission_)
    async UpdateMJCollectionPermission(
        @Arg('input', () => UpdateMJCollectionPermissionInput) input: UpdateMJCollectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Collection Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCollectionPermission_)
    async DeleteMJCollectionPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Collection Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Collections
//****************************************************************************
@ObjectType({ description: `Organizational folders for storing and categorizing artifacts. Supports nested folder structure for hierarchical organization.` })
export class MJCollection_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Display name for the collection`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the collection purpose`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display`}) 
    @MaxLength(100)
    Icon?: string;
        
    @Field({nullable: true, description: `Hex color code for UI display (#RRGGBB format)`}) 
    @MaxLength(14)
    Color?: string;
        
    @Field(() => Int, {nullable: true, description: `Display sequence for ordering collections in UI`}) 
    Sequence?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `The user who owns this collection and has full permissions`}) 
    @MaxLength(16)
    OwnerID?: string;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Owner?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJCollectionArtifact_])
    MJ_CollectionArtifacts_CollectionIDArray: MJCollectionArtifact_[]; // Link to MJ_CollectionArtifacts
    
    @Field(() => [MJCollectionPermission_])
    MJ_CollectionPermissions_CollectionIDArray: MJCollectionPermission_[]; // Link to MJ_CollectionPermissions
    
    @Field(() => [MJCollection_])
    MJ_Collections_ParentIDArray: MJCollection_[]; // Link to MJ_Collections
    
}

//****************************************************************************
// INPUT TYPE for MJ: Collections
//****************************************************************************
@InputType()
export class CreateMJCollectionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;

    @Field({ nullable: true })
    OwnerID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Collections
//****************************************************************************
@InputType()
export class UpdateMJCollectionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field({ nullable: true })
    OwnerID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Collections
//****************************************************************************
@ObjectType()
export class RunMJCollectionViewResult {
    @Field(() => [MJCollection_])
    Results: MJCollection_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCollection_)
export class MJCollectionResolver extends ResolverBase {
    @Query(() => RunMJCollectionViewResult)
    async RunMJCollectionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionViewResult)
    async RunMJCollectionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCollectionViewResult)
    async RunMJCollectionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Collections';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCollection_, { nullable: true })
    async MJCollection(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCollection_ | null> {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollections] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Collections', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCollectionArtifact_])
    async MJ_CollectionArtifacts_CollectionIDArray(@Root() mjcollection_: MJCollection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionArtifacts] WHERE [CollectionID]='${mjcollection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionPermission_])
    async MJ_CollectionPermissions_CollectionIDArray(@Root() mjcollection_: MJCollection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionPermissions] WHERE [CollectionID]='${mjcollection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollection_])
    async MJ_Collections_ParentIDArray(@Root() mjcollection_: MJCollection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollections] WHERE [ParentID]='${mjcollection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCollection_)
    async CreateMJCollection(
        @Arg('input', () => CreateMJCollectionInput) input: CreateMJCollectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Collections', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCollection_)
    async UpdateMJCollection(
        @Arg('input', () => UpdateMJCollectionInput) input: UpdateMJCollectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Collections', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCollection_)
    async DeleteMJCollection(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Collections', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Dependencies
//****************************************************************************
@ObjectType({ description: `Tracks component-to-component dependencies for composition` })
export class MJComponentDependency_ {
    @Field({description: `Primary key for component dependency`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to parent Component that has the dependency`}) 
    @MaxLength(16)
    ComponentID: string;
        
    @Field({description: `Foreign key to the Component that is depended upon`}) 
    @MaxLength(16)
    DependencyComponentID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    Component: string;
        
    @Field() 
    @MaxLength(1000)
    DependencyComponent: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Component Dependencies
//****************************************************************************
@InputType()
export class CreateMJComponentDependencyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    DependencyComponentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Dependencies
//****************************************************************************
@InputType()
export class UpdateMJComponentDependencyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    DependencyComponentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Dependencies
//****************************************************************************
@ObjectType()
export class RunMJComponentDependencyViewResult {
    @Field(() => [MJComponentDependency_])
    Results: MJComponentDependency_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentDependency_)
export class MJComponentDependencyResolver extends ResolverBase {
    @Query(() => RunMJComponentDependencyViewResult)
    async RunMJComponentDependencyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentDependencyViewResult)
    async RunMJComponentDependencyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentDependencyViewResult)
    async RunMJComponentDependencyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Dependencies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentDependency_, { nullable: true })
    async MJComponentDependency(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentDependency_ | null> {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentDependencies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Dependencies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJComponentDependency_)
    async CreateMJComponentDependency(
        @Arg('input', () => CreateMJComponentDependencyInput) input: CreateMJComponentDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Dependencies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentDependency_)
    async UpdateMJComponentDependency(
        @Arg('input', () => UpdateMJComponentDependencyInput) input: UpdateMJComponentDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Dependencies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentDependency_)
    async DeleteMJComponentDependency(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Dependencies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Libraries
//****************************************************************************
@ObjectType({ description: `Catalog of third-party JavaScript libraries that components can depend on` })
export class MJComponentLibrary_ {
    @Field({description: `Primary key for the component library`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `NPM-style package name (e.g., recharts, lodash, @memberjunction/lib-name)`}) 
    @MaxLength(1000)
    Name: string;
        
    @Field({nullable: true, description: `User-friendly display name for the library`}) 
    @MaxLength(1000)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Library version number`}) 
    @MaxLength(200)
    Version?: string;
        
    @Field({nullable: true, description: `Global variable name when loaded (e.g., _ for lodash, React for react)`}) 
    @MaxLength(510)
    GlobalVariable?: string;
        
    @Field({nullable: true, description: `Library category: Core, Runtime, UI, Charting, Utility, or Other`}) 
    @MaxLength(200)
    Category?: string;
        
    @Field({nullable: true, description: `CDN URL for loading the library JavaScript`}) 
    @MaxLength(2000)
    CDNUrl?: string;
        
    @Field({nullable: true, description: `Optional CDN URL for loading library CSS`}) 
    @MaxLength(2000)
    CDNCssUrl?: string;
        
    @Field({nullable: true, description: `Description of the library and its capabilities`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the component library. Active: fully supported; Deprecated: works but shows console warning; Disabled: throws error if used`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON configuration for library-specific lint rules that are applied during component validation. This field contains structured rules that define how components using this library should be validated, including DOM element requirements, initialization patterns, lifecycle methods, and common error patterns. Example structure: {"initialization": {"constructorName": "Chart", "elementType": "canvas"}, "lifecycle": {"requiredMethods": ["render"], "cleanupMethods": ["destroy"]}}. The linter dynamically applies these rules based on the libraries referenced in a component spec, enabling extensible validation without hardcoding library-specific logic.`}) 
    LintRules?: string;
        
    @Field({nullable: true, description: `JSON object defining dependencies for this component library. Format: { "libraryName": "versionSpec", ... }. Version specifications follow NPM-style syntax (e.g., "~1.0.0", "^1.2.3", "2.3.4"). Dependencies are loaded before this library to ensure proper execution context.`}) 
    Dependencies?: string;
        
    @Field({description: `Controls how the library can be used: Direct (by components), Dependency (only as dependency), or Both`}) 
    @MaxLength(100)
    UsageType: string;
        
    @Field(() => [MJComponentLibraryLink_])
    MJ_ComponentLibraryLinks_LibraryIDArray: MJComponentLibraryLink_[]; // Link to MJ_ComponentLibraryLinks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Component Libraries
//****************************************************************************
@InputType()
export class CreateMJComponentLibraryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Version: string | null;

    @Field({ nullable: true })
    GlobalVariable: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    CDNUrl: string | null;

    @Field({ nullable: true })
    CDNCssUrl: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LintRules: string | null;

    @Field({ nullable: true })
    Dependencies: string | null;

    @Field({ nullable: true })
    UsageType?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Libraries
//****************************************************************************
@InputType()
export class UpdateMJComponentLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Version?: string | null;

    @Field({ nullable: true })
    GlobalVariable?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    CDNUrl?: string | null;

    @Field({ nullable: true })
    CDNCssUrl?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LintRules?: string | null;

    @Field({ nullable: true })
    Dependencies?: string | null;

    @Field({ nullable: true })
    UsageType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Libraries
//****************************************************************************
@ObjectType()
export class RunMJComponentLibraryViewResult {
    @Field(() => [MJComponentLibrary_])
    Results: MJComponentLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentLibrary_)
export class MJComponentLibraryResolver extends ResolverBase {
    @Query(() => RunMJComponentLibraryViewResult)
    async RunMJComponentLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryViewResult)
    async RunMJComponentLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryViewResult)
    async RunMJComponentLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Libraries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentLibrary_, { nullable: true })
    async MJComponentLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentLibrary_ | null> {
        this.CheckUserReadPermissions('MJ: Component Libraries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Libraries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJComponentLibraryLink_])
    async MJ_ComponentLibraryLinks_LibraryIDArray(@Root() mjcomponentlibrary_: MJComponentLibrary_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraryLinks] WHERE [LibraryID]='${mjcomponentlibrary_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Library Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJComponentLibrary_)
    async CreateMJComponentLibrary(
        @Arg('input', () => CreateMJComponentLibraryInput) input: CreateMJComponentLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Libraries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentLibrary_)
    async UpdateMJComponentLibrary(
        @Arg('input', () => UpdateMJComponentLibraryInput) input: UpdateMJComponentLibraryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Libraries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentLibrary_)
    async DeleteMJComponentLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Libraries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Library Links
//****************************************************************************
@ObjectType({ description: `Links components to their third-party library dependencies` })
export class MJComponentLibraryLink_ {
    @Field({description: `Primary key for component-library relationship`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to Component that depends on the library`}) 
    @MaxLength(16)
    ComponentID: string;
        
    @Field({description: `Foreign key to ComponentLibrary that the component depends on`}) 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({nullable: true, description: `Minimum version requirement using semantic versioning (e.g., ^1.0.0, ~2.5.0)`}) 
    @MaxLength(200)
    MinVersion?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    Component: string;
        
    @Field() 
    @MaxLength(1000)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Component Library Links
//****************************************************************************
@InputType()
export class CreateMJComponentLibraryLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    MinVersion: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Library Links
//****************************************************************************
@InputType()
export class UpdateMJComponentLibraryLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ComponentID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    MinVersion?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Library Links
//****************************************************************************
@ObjectType()
export class RunMJComponentLibraryLinkViewResult {
    @Field(() => [MJComponentLibraryLink_])
    Results: MJComponentLibraryLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentLibraryLink_)
export class MJComponentLibraryLinkResolver extends ResolverBase {
    @Query(() => RunMJComponentLibraryLinkViewResult)
    async RunMJComponentLibraryLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryLinkViewResult)
    async RunMJComponentLibraryLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentLibraryLinkViewResult)
    async RunMJComponentLibraryLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Library Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentLibraryLink_, { nullable: true })
    async MJComponentLibraryLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentLibraryLink_ | null> {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraryLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Library Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJComponentLibraryLink_)
    async CreateMJComponentLibraryLink(
        @Arg('input', () => CreateMJComponentLibraryLinkInput) input: CreateMJComponentLibraryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Library Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentLibraryLink_)
    async UpdateMJComponentLibraryLink(
        @Arg('input', () => UpdateMJComponentLibraryLinkInput) input: UpdateMJComponentLibraryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Library Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentLibraryLink_)
    async DeleteMJComponentLibraryLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Library Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Component Registries
//****************************************************************************
@ObjectType({ description: `Registry catalog for component sources, similar to NPM registry but supporting multiple sources` })
export class MJComponentRegistry_ {
    @Field({description: `Primary key for the component registry`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the registry (e.g., MemberJunction Registry, NPM, Internal Registry)`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the registry and its purpose`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Registry endpoint URI (e.g., https://registry.memberjunction.org)`}) 
    @MaxLength(1000)
    URI?: string;
        
    @Field({nullable: true, description: `Type of registry: public, private, or internal`}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true, description: `API version supported by the registry for compatibility`}) 
    @MaxLength(100)
    APIVersion?: string;
        
    @Field({nullable: true, description: `Current status of the registry: active, deprecated, or offline`}) 
    @MaxLength(100)
    Status?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJComponent_])
    MJ_Components_SourceRegistryIDArray: MJComponent_[]; // Link to MJ_Components
    
}

//****************************************************************************
// INPUT TYPE for MJ: Component Registries
//****************************************************************************
@InputType()
export class CreateMJComponentRegistryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    URI: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    APIVersion: string | null;

    @Field({ nullable: true })
    Status: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Component Registries
//****************************************************************************
@InputType()
export class UpdateMJComponentRegistryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    URI?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    APIVersion?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Component Registries
//****************************************************************************
@ObjectType()
export class RunMJComponentRegistryViewResult {
    @Field(() => [MJComponentRegistry_])
    Results: MJComponentRegistry_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponentRegistry_)
export class MJComponentRegistryResolver extends ResolverBase {
    @Query(() => RunMJComponentRegistryViewResult)
    async RunMJComponentRegistryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentRegistryViewResult)
    async RunMJComponentRegistryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentRegistryViewResult)
    async RunMJComponentRegistryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Component Registries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponentRegistry_, { nullable: true })
    async MJComponentRegistry(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponentRegistry_ | null> {
        this.CheckUserReadPermissions('MJ: Component Registries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentRegistries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Registries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Component Registries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJComponent_])
    async MJ_Components_SourceRegistryIDArray(@Root() mjcomponentregistry_: MJComponentRegistry_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponents] WHERE [SourceRegistryID]='${mjcomponentregistry_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Components', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJComponentRegistry_)
    async CreateMJComponentRegistry(
        @Arg('input', () => CreateMJComponentRegistryInput) input: CreateMJComponentRegistryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Component Registries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponentRegistry_)
    async UpdateMJComponentRegistry(
        @Arg('input', () => UpdateMJComponentRegistryInput) input: UpdateMJComponentRegistryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Component Registries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponentRegistry_)
    async DeleteMJComponentRegistry(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Component Registries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Components
//****************************************************************************
@ObjectType({ description: `Main catalog of reusable components with versioning and registry support` })
export class MJComponent_ {
    @Field({description: `Immutable UUID that remains the same across all systems`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `Hierarchical namespace path (e.g., dashboards/sales for local, @memberjunction/dashboards/financial for external)`}) 
    Namespace?: string;
        
    @Field({description: `Component name within the namespace (e.g., revenue-tracker)`}) 
    @MaxLength(1000)
    Name: string;
        
    @Field({description: `Semantic version number (e.g., 1.0.0, 1.2.3-beta)`}) 
    @MaxLength(100)
    Version: string;
        
    @Field(() => Int, {description: `Numeric sequence for sorting versions`}) 
    VersionSequence: number;
        
    @Field({nullable: true, description: `User-friendly display title for the component`}) 
    @MaxLength(2000)
    Title?: string;
        
    @Field({nullable: true, description: `[READ-ONLY] Detailed description of the component functionality. This field is automatically synchronized from the Specification.description field and should not be edited directly. To update this value, edit the component spec file.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Component type: report, dashboard, form, table, chart, navigation, search, widget, utility, or other`}) 
    @MaxLength(510)
    Type?: string;
        
    @Field({nullable: true, description: `Publication status: draft, published, or deprecated`}) 
    @MaxLength(100)
    Status?: string;
        
    @Field({nullable: true, description: `Name of the component developer or author`}) 
    @MaxLength(510)
    DeveloperName?: string;
        
    @Field({nullable: true, description: `Contact email for the component developer`}) 
    @MaxLength(510)
    DeveloperEmail?: string;
        
    @Field({nullable: true, description: `Organization name of the component developer`}) 
    @MaxLength(510)
    DeveloperOrganization?: string;
        
    @Field({nullable: true, description: `Foreign key to ComponentRegistry - NULL for local components, populated for replicated ones`}) 
    @MaxLength(16)
    SourceRegistryID?: string;
        
    @Field({nullable: true, description: `Timestamp when the component was replicated from external registry (NULL for local components)`}) 
    @MaxLength(10)
    ReplicatedAt?: Date;
        
    @Field({nullable: true, description: `Last synchronization timestamp with the source registry`}) 
    @MaxLength(10)
    LastSyncedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Complete JSON specification object for the component`}) 
    Specification: string;
        
    @Field({nullable: true, description: `[READ-ONLY] Functional requirements describing what the component should accomplish. This field is automatically synchronized from the Specification.functionalRequirements field and should not be edited directly. To update this value, edit the component spec file.`}) 
    FunctionalRequirements?: string;
        
    @Field({nullable: true, description: `[READ-ONLY] Technical design describing how the component is implemented. This field is automatically synchronized from the Specification.technicalDesign field and should not be edited directly. To update this value, edit the component spec file.`}) 
    TechnicalDesign?: string;
        
    @Field({nullable: true, description: `Vector embedding of the functional requirements for similarity search`}) 
    FunctionalRequirementsVector?: string;
        
    @Field({nullable: true, description: `Vector embedding of the technical design for similarity search`}) 
    TechnicalDesignVector?: string;
        
    @Field(() => Boolean, {description: `Indicates if the component has custom properties defined in its specification. Components with custom props cannot be used directly by deterministic containers.`}) 
    HasCustomProps: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the component has custom events defined in its specification. Components with custom events may have limited functionality in generic containers.`}) 
    HasCustomEvents: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the component requires data access (utilities object with md, rv, rq). Used to determine if component needs data context.`}) 
    RequiresData: boolean;
        
    @Field(() => Int, {description: `Number of component dependencies defined in the specification. Used to assess component complexity.`}) 
    DependencyCount: number;
        
    @Field({nullable: true, description: `The ID of the AI model used to generate the vector embedding for the technical design`}) 
    TechnicalDesignVectorEmbeddingModelID?: string;
        
    @Field({nullable: true, description: `The ID of the AI model used to generate the vector embedding for the functional requirements`}) 
    FunctionalRequirementsVectorEmbeddingModelID?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the component has any custom properties that are marked as required. This is auto-calculated based on the component's properties array to identify components with mandatory custom configuration.`}) 
    HasRequiredCustomProps: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceRegistry?: string;
        
    @Field(() => [MJComponentDependency_])
    MJ_ComponentDependencies_DependencyComponentIDArray: MJComponentDependency_[]; // Link to MJ_ComponentDependencies
    
    @Field(() => [MJComponentLibraryLink_])
    MJ_ComponentLibraryLinks_ComponentIDArray: MJComponentLibraryLink_[]; // Link to MJ_ComponentLibraryLinks
    
    @Field(() => [MJComponentDependency_])
    MJ_ComponentDependencies_ComponentIDArray: MJComponentDependency_[]; // Link to MJ_ComponentDependencies
    
}

//****************************************************************************
// INPUT TYPE for MJ: Components
//****************************************************************************
@InputType()
export class CreateMJComponentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Namespace: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field(() => Int, { nullable: true })
    VersionSequence?: number;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    DeveloperName: string | null;

    @Field({ nullable: true })
    DeveloperEmail: string | null;

    @Field({ nullable: true })
    DeveloperOrganization: string | null;

    @Field({ nullable: true })
    SourceRegistryID: string | null;

    @Field({ nullable: true })
    ReplicatedAt: Date | null;

    @Field({ nullable: true })
    LastSyncedAt: Date | null;

    @Field({ nullable: true })
    Specification?: string;

    @Field({ nullable: true })
    FunctionalRequirements: string | null;

    @Field({ nullable: true })
    TechnicalDesign: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVector: string | null;

    @Field({ nullable: true })
    TechnicalDesignVector: string | null;

    @Field(() => Boolean, { nullable: true })
    HasCustomProps?: boolean;

    @Field(() => Boolean, { nullable: true })
    HasCustomEvents?: boolean;

    @Field(() => Boolean, { nullable: true })
    RequiresData?: boolean;

    @Field(() => Int, { nullable: true })
    DependencyCount?: number;

    @Field({ nullable: true })
    TechnicalDesignVectorEmbeddingModelID: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVectorEmbeddingModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    HasRequiredCustomProps?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Components
//****************************************************************************
@InputType()
export class UpdateMJComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Namespace?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Version?: string;

    @Field(() => Int, { nullable: true })
    VersionSequence?: number;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    DeveloperName?: string | null;

    @Field({ nullable: true })
    DeveloperEmail?: string | null;

    @Field({ nullable: true })
    DeveloperOrganization?: string | null;

    @Field({ nullable: true })
    SourceRegistryID?: string | null;

    @Field({ nullable: true })
    ReplicatedAt?: Date | null;

    @Field({ nullable: true })
    LastSyncedAt?: Date | null;

    @Field({ nullable: true })
    Specification?: string;

    @Field({ nullable: true })
    FunctionalRequirements?: string | null;

    @Field({ nullable: true })
    TechnicalDesign?: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVector?: string | null;

    @Field({ nullable: true })
    TechnicalDesignVector?: string | null;

    @Field(() => Boolean, { nullable: true })
    HasCustomProps?: boolean;

    @Field(() => Boolean, { nullable: true })
    HasCustomEvents?: boolean;

    @Field(() => Boolean, { nullable: true })
    RequiresData?: boolean;

    @Field(() => Int, { nullable: true })
    DependencyCount?: number;

    @Field({ nullable: true })
    TechnicalDesignVectorEmbeddingModelID?: string | null;

    @Field({ nullable: true })
    FunctionalRequirementsVectorEmbeddingModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    HasRequiredCustomProps?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Components
//****************************************************************************
@ObjectType()
export class RunMJComponentViewResult {
    @Field(() => [MJComponent_])
    Results: MJComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJComponent_)
export class MJComponentResolver extends ResolverBase {
    @Query(() => RunMJComponentViewResult)
    async RunMJComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentViewResult)
    async RunMJComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJComponentViewResult)
    async RunMJComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Components';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJComponent_, { nullable: true })
    async MJComponent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJComponent_ | null> {
        this.CheckUserReadPermissions('MJ: Components', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Components', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Components', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJComponentDependency_])
    async MJ_ComponentDependencies_DependencyComponentIDArray(@Root() mjcomponent_: MJComponent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentDependencies] WHERE [DependencyComponentID]='${mjcomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJComponentLibraryLink_])
    async MJ_ComponentLibraryLinks_ComponentIDArray(@Root() mjcomponent_: MJComponent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Library Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentLibraryLinks] WHERE [ComponentID]='${mjcomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Library Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Library Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJComponentDependency_])
    async MJ_ComponentDependencies_ComponentIDArray(@Root() mjcomponent_: MJComponent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Component Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwComponentDependencies] WHERE [ComponentID]='${mjcomponent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Component Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Component Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJComponent_)
    async CreateMJComponent(
        @Arg('input', () => CreateMJComponentInput) input: CreateMJComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Components', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJComponent_)
    async UpdateMJComponent(
        @Arg('input', () => UpdateMJComponentInput) input: UpdateMJComponentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Components', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJComponent_)
    async DeleteMJComponent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Components', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for conversation artifacts` })
export class MJConversationArtifactPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the artifact this permission applies to`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field({description: `User this permission applies to`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Level of access granted (Read, Edit, Owner)`}) 
    @MaxLength(40)
    AccessLevel: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactPermissionViewResult {
    @Field(() => [MJConversationArtifactPermission_])
    Results: MJConversationArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifactPermission_)
export class MJConversationArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactPermissionViewResult)
    async RunMJConversationArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifactPermission_, { nullable: true })
    async MJConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationArtifactPermission_)
    async CreateMJConversationArtifactPermission(
        @Arg('input', () => CreateMJConversationArtifactPermissionInput) input: CreateMJConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifactPermission_)
    async UpdateMJConversationArtifactPermission(
        @Arg('input', () => UpdateMJConversationArtifactPermissionInput) input: UpdateMJConversationArtifactPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifactPermission_)
    async DeleteMJConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType({ description: `Stores versions of conversation artifacts` })
export class MJConversationArtifactVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the parent artifact`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number (starting from 1) for this artifact`}) 
    Version: number;
        
    @Field({description: `JSON configuration and metadata for this artifact version`}) 
    Configuration: string;
        
    @Field({nullable: true, description: `Actual content of the artifact, if stored separately from configuration`}) 
    Content?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
    @Field(() => [MJConversationDetail_])
    ConversationDetails_ArtifactVersionIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactVersionViewResult {
    @Field(() => [MJConversationArtifactVersion_])
    Results: MJConversationArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifactVersion_)
export class MJConversationArtifactVersionResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactVersionViewResult)
    async RunMJConversationArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifactVersion_, { nullable: true })
    async MJConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_ArtifactVersionIDArray(@Root() mjconversationartifactversion_: MJConversationArtifactVersion_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ArtifactVersionID]='${mjconversationartifactversion_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversationArtifactVersion_)
    async CreateMJConversationArtifactVersion(
        @Arg('input', () => CreateMJConversationArtifactVersionInput) input: CreateMJConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifactVersion_)
    async UpdateMJConversationArtifactVersion(
        @Arg('input', () => UpdateMJConversationArtifactVersionInput) input: UpdateMJConversationArtifactVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifact Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifactVersion_)
    async DeleteMJConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType({ description: `Stores metadata for artifacts created within conversations` })
export class MJConversationArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Extended description of the artifact`}) 
    Description?: string;
        
    @Field({description: `Reference to the conversation this artifact belongs to`}) 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({description: `Reference to the type of artifact`}) 
    @MaxLength(16)
    ArtifactTypeID: string;
        
    @Field({description: `Controls who can view this artifact (None, SpecificUsers, Everyone, Public)`}) 
    @MaxLength(100)
    SharingScope: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field() 
    @MaxLength(200)
    ArtifactType: string;
        
    @Field(() => [MJConversationArtifactPermission_])
    MJ_ConversationArtifactPermissions_ConversationArtifactIDArray: MJConversationArtifactPermission_[]; // Link to MJ_ConversationArtifactPermissions
    
    @Field(() => [MJConversationArtifactVersion_])
    MJ_ConversationArtifactVersions_ConversationArtifactIDArray: MJConversationArtifactVersion_[]; // Link to MJ_ConversationArtifactVersions
    
    @Field(() => [MJConversationDetail_])
    ConversationDetails_ArtifactIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class CreateMJConversationArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class UpdateMJConversationArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType()
export class RunMJConversationArtifactViewResult {
    @Field(() => [MJConversationArtifact_])
    Results: MJConversationArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationArtifact_)
export class MJConversationArtifactResolver extends ResolverBase {
    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationArtifactViewResult)
    async RunMJConversationArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationArtifact_, { nullable: true })
    async MJConversationArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJConversationArtifactPermission_])
    async MJ_ConversationArtifactPermissions_ConversationArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ConversationArtifactID]='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationArtifactVersion_])
    async MJ_ConversationArtifactVersions_ConversationArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ConversationArtifactID]='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_ArtifactIDArray(@Root() mjconversationartifact_: MJConversationArtifact_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ArtifactID]='${mjconversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJConversationArtifact_)
    async CreateMJConversationArtifact(
        @Arg('input', () => CreateMJConversationArtifactInput) input: CreateMJConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationArtifact_)
    async UpdateMJConversationArtifact(
        @Arg('input', () => UpdateMJConversationArtifactInput) input: UpdateMJConversationArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationArtifact_)
    async DeleteMJConversationArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Detail Artifacts
//****************************************************************************
@ObjectType({ description: `Junction table tracking many-to-many relationship between conversation messages and artifact versions, with directionality tracking` })
export class MJConversationDetailArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to ConversationDetail - the conversation message associated with this artifact`}) 
    @MaxLength(16)
    ConversationDetailID: string;
        
    @Field({description: `Foreign key to ArtifactVersion - the specific artifact version linked to this conversation message`}) 
    @MaxLength(16)
    ArtifactVersionID: string;
        
    @Field({description: `Direction of artifact flow: Input (fed to agent) or Output (produced by agent)`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    ConversationDetail: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ArtifactVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Artifacts
//****************************************************************************
@InputType()
export class CreateMJConversationDetailArtifactInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Direction?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Artifacts
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ArtifactVersionID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Detail Artifacts
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailArtifactViewResult {
    @Field(() => [MJConversationDetailArtifact_])
    Results: MJConversationDetailArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetailArtifact_)
export class MJConversationDetailArtifactResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailArtifactViewResult)
    async RunMJConversationDetailArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailArtifactViewResult)
    async RunMJConversationDetailArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailArtifactViewResult)
    async RunMJConversationDetailArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Detail Artifacts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetailArtifact_, { nullable: true })
    async MJConversationDetailArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetailArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Detail Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Detail Artifacts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationDetailArtifact_)
    async CreateMJConversationDetailArtifact(
        @Arg('input', () => CreateMJConversationDetailArtifactInput) input: CreateMJConversationDetailArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Detail Artifacts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetailArtifact_)
    async UpdateMJConversationDetailArtifact(
        @Arg('input', () => UpdateMJConversationDetailArtifactInput) input: UpdateMJConversationDetailArtifactInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Detail Artifacts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetailArtifact_)
    async DeleteMJConversationDetailArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Detail Artifacts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Detail Attachments
//****************************************************************************
@ObjectType({ description: `Stores attachments (images, videos, audio, documents) for conversation messages. Supports both inline base64 storage for small files and reference to MJStorage for large files.` })
export class MJConversationDetailAttachment_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConversationDetailID: string;
        
    @Field({description: `The modality type of this attachment (Image, Audio, Video, File, etc.). References the AIModality table.`}) 
    @MaxLength(16)
    ModalityID: string;
        
    @Field({description: `MIME type of the attachment (e.g., image/png, video/mp4, audio/mp3).`}) 
    @MaxLength(200)
    MimeType: string;
        
    @Field({nullable: true, description: `Original filename of the attachment. Supports long cloud storage paths up to 4000 characters.`}) 
    @MaxLength(8000)
    FileName?: string;
        
    @Field(() => Int, {description: `Size of the attachment in bytes.`}) 
    FileSizeBytes: number;
        
    @Field(() => Int, {nullable: true, description: `Width in pixels for images and videos.`}) 
    Width?: number;
        
    @Field(() => Int, {nullable: true, description: `Height in pixels for images and videos.`}) 
    Height?: number;
        
    @Field(() => Int, {nullable: true, description: `Duration in seconds for audio and video files.`}) 
    DurationSeconds?: number;
        
    @Field({nullable: true, description: `Base64-encoded file data for small attachments stored inline. Mutually exclusive with FileID - exactly one must be populated.`}) 
    InlineData?: string;
        
    @Field({nullable: true, description: `Reference to File entity for large attachments stored in MJStorage. Mutually exclusive with InlineData - exactly one must be populated.`}) 
    @MaxLength(16)
    FileID?: string;
        
    @Field(() => Int, {description: `Display order for multiple attachments in a message. Lower numbers appear first.`}) 
    DisplayOrder: number;
        
    @Field({nullable: true, description: `Base64-encoded thumbnail image for quick preview display. Max 200px on longest side.`}) 
    ThumbnailBase64?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Description of the attachment providing context about its content and purpose.`}) 
    Description?: string;
        
    @Field() 
    ConversationDetail: string;
        
    @Field() 
    @MaxLength(100)
    Modality: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    File?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Attachments
//****************************************************************************
@InputType()
export class CreateMJConversationDetailAttachmentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number;

    @Field(() => Int, { nullable: true })
    Width: number | null;

    @Field(() => Int, { nullable: true })
    Height: number | null;

    @Field(() => Int, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InlineData: string | null;

    @Field({ nullable: true })
    FileID: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    ThumbnailBase64: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Attachments
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailAttachmentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    ModalityID?: string;

    @Field({ nullable: true })
    MimeType?: string;

    @Field({ nullable: true })
    FileName?: string | null;

    @Field(() => Int, { nullable: true })
    FileSizeBytes?: number;

    @Field(() => Int, { nullable: true })
    Width?: number | null;

    @Field(() => Int, { nullable: true })
    Height?: number | null;

    @Field(() => Int, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InlineData?: string | null;

    @Field({ nullable: true })
    FileID?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field({ nullable: true })
    ThumbnailBase64?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Detail Attachments
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailAttachmentViewResult {
    @Field(() => [MJConversationDetailAttachment_])
    Results: MJConversationDetailAttachment_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetailAttachment_)
export class MJConversationDetailAttachmentResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailAttachmentViewResult)
    async RunMJConversationDetailAttachmentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailAttachmentViewResult)
    async RunMJConversationDetailAttachmentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailAttachmentViewResult)
    async RunMJConversationDetailAttachmentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Detail Attachments';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetailAttachment_, { nullable: true })
    async MJConversationDetailAttachment(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetailAttachment_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Detail Attachments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailAttachments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Attachments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Detail Attachments', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationDetailAttachment_)
    async CreateMJConversationDetailAttachment(
        @Arg('input', () => CreateMJConversationDetailAttachmentInput) input: CreateMJConversationDetailAttachmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Detail Attachments', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetailAttachment_)
    async UpdateMJConversationDetailAttachment(
        @Arg('input', () => UpdateMJConversationDetailAttachmentInput) input: UpdateMJConversationDetailAttachmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Detail Attachments', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetailAttachment_)
    async DeleteMJConversationDetailAttachment(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Detail Attachments', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Detail Ratings
//****************************************************************************
@ObjectType({ description: `Stores per-user ratings for conversation messages, supporting multi-user conversations where each user can independently rate messages.` })
export class MJConversationDetailRating_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The conversation message being rated.`}) 
    @MaxLength(16)
    ConversationDetailID: string;
        
    @Field({description: `The user providing the rating.`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Int, {description: `Rating on a 1-10 scale where 1 is thumbs down and 10 is thumbs up.`}) 
    Rating: number;
        
    @Field({nullable: true, description: `Optional textual feedback from the user about this message.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    ConversationDetail: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Ratings
//****************************************************************************
@InputType()
export class CreateMJConversationDetailRatingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    Rating?: number;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Detail Ratings
//****************************************************************************
@InputType()
export class UpdateMJConversationDetailRatingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationDetailID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    Rating?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Detail Ratings
//****************************************************************************
@ObjectType()
export class RunMJConversationDetailRatingViewResult {
    @Field(() => [MJConversationDetailRating_])
    Results: MJConversationDetailRating_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJConversationDetailRating_)
export class MJConversationDetailRatingResolver extends ResolverBase {
    @Query(() => RunMJConversationDetailRatingViewResult)
    async RunMJConversationDetailRatingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailRatingViewResult)
    async RunMJConversationDetailRatingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJConversationDetailRatingViewResult)
    async RunMJConversationDetailRatingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Detail Ratings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJConversationDetailRating_, { nullable: true })
    async MJConversationDetailRating(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJConversationDetailRating_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Detail Ratings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailRatings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Ratings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Conversation Detail Ratings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJConversationDetailRating_)
    async CreateMJConversationDetailRating(
        @Arg('input', () => CreateMJConversationDetailRatingInput) input: CreateMJConversationDetailRatingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Conversation Detail Ratings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJConversationDetailRating_)
    async UpdateMJConversationDetailRating(
        @Arg('input', () => UpdateMJConversationDetailRatingInput) input: UpdateMJConversationDetailRatingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Conversation Detail Ratings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJConversationDetailRating_)
    async DeleteMJConversationDetailRating(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Detail Ratings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Credential Categories
//****************************************************************************
@ObjectType({ description: `Hierarchical organization for credentials. Allows grouping credentials by service type, department, or any organizational structure.` })
export class MJCredentialCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name for the category.`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the category.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category for hierarchical organization. NULL for root categories.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display (e.g., fa-solid fa-folder).`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJCredentialCategory_])
    MJ_CredentialCategories_ParentIDArray: MJCredentialCategory_[]; // Link to MJ_CredentialCategories
    
    @Field(() => [MJCredential_])
    MJ_Credentials_CategoryIDArray: MJCredential_[]; // Link to MJ_Credentials
    
}

//****************************************************************************
// INPUT TYPE for MJ: Credential Categories
//****************************************************************************
@InputType()
export class CreateMJCredentialCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    IconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Credential Categories
//****************************************************************************
@InputType()
export class UpdateMJCredentialCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Credential Categories
//****************************************************************************
@ObjectType()
export class RunMJCredentialCategoryViewResult {
    @Field(() => [MJCredentialCategory_])
    Results: MJCredentialCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCredentialCategory_)
export class MJCredentialCategoryResolver extends ResolverBase {
    @Query(() => RunMJCredentialCategoryViewResult)
    async RunMJCredentialCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialCategoryViewResult)
    async RunMJCredentialCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialCategoryViewResult)
    async RunMJCredentialCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Credential Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCredentialCategory_, { nullable: true })
    async MJCredentialCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCredentialCategory_ | null> {
        this.CheckUserReadPermissions('MJ: Credential Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCredentialCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credential Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Credential Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCredentialCategory_])
    async MJ_CredentialCategories_ParentIDArray(@Root() mjcredentialcategory_: MJCredentialCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Credential Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCredentialCategories] WHERE [ParentID]='${mjcredentialcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credential Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Credential Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCredential_])
    async MJ_Credentials_CategoryIDArray(@Root() mjcredentialcategory_: MJCredentialCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Credentials', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCredentials] WHERE [CategoryID]='${mjcredentialcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credentials', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Credentials', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCredentialCategory_)
    async CreateMJCredentialCategory(
        @Arg('input', () => CreateMJCredentialCategoryInput) input: CreateMJCredentialCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Credential Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCredentialCategory_)
    async UpdateMJCredentialCategory(
        @Arg('input', () => UpdateMJCredentialCategoryInput) input: UpdateMJCredentialCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Credential Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCredentialCategory_)
    async DeleteMJCredentialCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Credential Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Credential Types
//****************************************************************************
@ObjectType({ description: `Defines credential templates for different services (e.g., OpenAI, SendGrid). Uses JSON Schema to define required fields and validation rules.` })
export class MJCredentialType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name for the credential type (e.g., OpenAI, SendGrid, AWS S3).`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the credential type.`}) 
    Description?: string;
        
    @Field({description: `High-level category: AI, Communication, Storage, Authentication, Database, or Integration.`}) 
    @MaxLength(100)
    Category: string;
        
    @Field({description: `JSON Schema defining the required fields for this credential type. Includes field names, types, validation rules, and UI hints.`}) 
    FieldSchema: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display (e.g., fa-brands fa-openai).`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field({nullable: true, description: `Optional URL endpoint to validate credentials against the service provider.`}) 
    @MaxLength(1000)
    ValidationEndpoint?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJCredential_])
    MJ_Credentials_CredentialTypeIDArray: MJCredential_[]; // Link to MJ_Credentials
    
    @Field(() => [MJMCPServer_])
    MJ_MCPServers_CredentialTypeIDArray: MJMCPServer_[]; // Link to MJ_MCPServers
    
    @Field(() => [MJAIVendor_])
    MJ_AIVendors_CredentialTypeIDArray: MJAIVendor_[]; // Link to MJ_AIVendors
    
}

//****************************************************************************
// INPUT TYPE for MJ: Credential Types
//****************************************************************************
@InputType()
export class CreateMJCredentialTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    FieldSchema?: string;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    ValidationEndpoint: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Credential Types
//****************************************************************************
@InputType()
export class UpdateMJCredentialTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Category?: string;

    @Field({ nullable: true })
    FieldSchema?: string;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    ValidationEndpoint?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Credential Types
//****************************************************************************
@ObjectType()
export class RunMJCredentialTypeViewResult {
    @Field(() => [MJCredentialType_])
    Results: MJCredentialType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCredentialType_)
export class MJCredentialTypeResolver extends ResolverBase {
    @Query(() => RunMJCredentialTypeViewResult)
    async RunMJCredentialTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialTypeViewResult)
    async RunMJCredentialTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialTypeViewResult)
    async RunMJCredentialTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Credential Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCredentialType_, { nullable: true })
    async MJCredentialType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCredentialType_ | null> {
        this.CheckUserReadPermissions('MJ: Credential Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCredentialTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credential Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Credential Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJCredential_])
    async MJ_Credentials_CredentialTypeIDArray(@Root() mjcredentialtype_: MJCredentialType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Credentials', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCredentials] WHERE [CredentialTypeID]='${mjcredentialtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credentials', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Credentials', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServer_])
    async MJ_MCPServers_CredentialTypeIDArray(@Root() mjcredentialtype_: MJCredentialType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Servers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServers] WHERE [CredentialTypeID]='${mjcredentialtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Servers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Servers', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIVendor_])
    async MJ_AIVendors_CredentialTypeIDArray(@Root() mjcredentialtype_: MJCredentialType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Vendors', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIVendors] WHERE [CredentialTypeID]='${mjcredentialtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Vendors', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Vendors', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCredentialType_)
    async CreateMJCredentialType(
        @Arg('input', () => CreateMJCredentialTypeInput) input: CreateMJCredentialTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Credential Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCredentialType_)
    async UpdateMJCredentialType(
        @Arg('input', () => UpdateMJCredentialTypeInput) input: UpdateMJCredentialTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Credential Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCredentialType_)
    async DeleteMJCredentialType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Credential Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Credentials
//****************************************************************************
@ObjectType({ description: `Stores credential instances with encrypted values. All access should go through CredentialEngine for proper audit logging.` })
export class MJCredential_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the credential type that defines the schema for this credential.`}) 
    @MaxLength(16)
    CredentialTypeID: string;
        
    @Field({nullable: true, description: `Optional category for organizational grouping.`}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `Human-readable name for this credential (e.g., Production SendGrid, Development OpenAI).`}) 
    @MaxLength(400)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of this credential instance.`}) 
    Description?: string;
        
    @Field({description: `Encrypted JSON blob containing all credential values. This field uses MemberJunction field-level encryption.`}) 
    Values: string;
        
    @Field(() => Boolean, {description: `If true, this is the default credential for its type when no specific credential is requested.`}) 
    IsDefault: boolean;
        
    @Field(() => Boolean, {description: `If false, the credential is disabled and will not be used.`}) 
    IsActive: boolean;
        
    @Field({nullable: true, description: `Optional expiration date. Expired credentials are treated as inactive.`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last successful validation against the provider.`}) 
    @MaxLength(10)
    LastValidatedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp of the last time this credential was used.`}) 
    @MaxLength(10)
    LastUsedAt?: Date;
        
    @Field({nullable: true, description: `Optional Font Awesome icon class to override the type icon for this specific credential.`}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    CredentialType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field(() => [MJOAuthToken_])
    MJ_OAuthTokens_CredentialIDArray: MJOAuthToken_[]; // Link to MJ_OAuthTokens
    
    @Field(() => [MJFileStorageAccount_])
    MJ_FileStorageAccounts_CredentialIDArray: MJFileStorageAccount_[]; // Link to MJ_FileStorageAccounts
    
    @Field(() => [MJMCPServerConnection_])
    MJ_MCPServerConnections_CredentialIDArray: MJMCPServerConnection_[]; // Link to MJ_MCPServerConnections
    
    @Field(() => [MJAICredentialBinding_])
    MJ_AICredentialBindings_CredentialIDArray: MJAICredentialBinding_[]; // Link to MJ_AICredentialBindings
    
}

//****************************************************************************
// INPUT TYPE for MJ: Credentials
//****************************************************************************
@InputType()
export class CreateMJCredentialInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    CredentialTypeID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Values?: string;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field({ nullable: true })
    LastValidatedAt: Date | null;

    @Field({ nullable: true })
    LastUsedAt: Date | null;

    @Field({ nullable: true })
    IconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Credentials
//****************************************************************************
@InputType()
export class UpdateMJCredentialInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CredentialTypeID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Values?: string;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field({ nullable: true })
    LastValidatedAt?: Date | null;

    @Field({ nullable: true })
    LastUsedAt?: Date | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Credentials
//****************************************************************************
@ObjectType()
export class RunMJCredentialViewResult {
    @Field(() => [MJCredential_])
    Results: MJCredential_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJCredential_)
export class MJCredentialResolver extends ResolverBase {
    @Query(() => RunMJCredentialViewResult)
    async RunMJCredentialViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialViewResult)
    async RunMJCredentialViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJCredentialViewResult)
    async RunMJCredentialDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Credentials';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJCredential_, { nullable: true })
    async MJCredential(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJCredential_ | null> {
        this.CheckUserReadPermissions('MJ: Credentials', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCredentials] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Credentials', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Credentials', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJOAuthToken_])
    async MJ_OAuthTokens_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Tokens', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthTokens] WHERE [CredentialID]='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Tokens', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Tokens', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJFileStorageAccount_])
    async MJ_FileStorageAccounts_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: File Storage Accounts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageAccounts] WHERE [CredentialID]='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Accounts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: File Storage Accounts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnection_])
    async MJ_MCPServerConnections_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnections] WHERE [CredentialID]='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAICredentialBinding_])
    async MJ_AICredentialBindings_CredentialIDArray(@Root() mjcredential_: MJCredential_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Credential Bindings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAICredentialBindings] WHERE [CredentialID]='${mjcredential_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Credential Bindings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Credential Bindings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJCredential_)
    async CreateMJCredential(
        @Arg('input', () => CreateMJCredentialInput) input: CreateMJCredentialInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Credentials', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJCredential_)
    async UpdateMJCredential(
        @Arg('input', () => UpdateMJCredentialInput) input: UpdateMJCredentialInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Credentials', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJCredential_)
    async DeleteMJCredential(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Credentials', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Category Links
//****************************************************************************
@ObjectType({ description: `Allows users to organize shared dashboards into their own category structure. Creates a link/reference to a dashboard without duplicating it. Users can optionally provide a custom display name and control ordering within their folders.` })
export class MJDashboardCategoryLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DashboardID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `The category in the user's personal folder structure. NULL means the dashboard appears at root level.`}) 
    @MaxLength(16)
    DashboardCategoryID?: string;
        
    @Field({nullable: true, description: `Optional user-friendly alias for the dashboard within this user's view. If NULL, uses the original dashboard name.`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field(() => Int, {description: `Display order of this dashboard within the user's category. Lower values appear first.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Dashboard: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DashboardCategory?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Links
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    DashboardCategoryID: string | null;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Links
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    DashboardCategoryID?: string | null;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Category Links
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryLinkViewResult {
    @Field(() => [MJDashboardCategoryLink_])
    Results: MJDashboardCategoryLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategoryLink_)
export class MJDashboardCategoryLinkResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryLinkViewResult)
    async RunMJDashboardCategoryLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryLinkViewResult)
    async RunMJDashboardCategoryLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryLinkViewResult)
    async RunMJDashboardCategoryLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Category Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategoryLink_, { nullable: true })
    async MJDashboardCategoryLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategoryLink_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardCategoryLink_)
    async CreateMJDashboardCategoryLink(
        @Arg('input', () => CreateMJDashboardCategoryLinkInput) input: CreateMJDashboardCategoryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Category Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategoryLink_)
    async UpdateMJDashboardCategoryLink(
        @Arg('input', () => UpdateMJDashboardCategoryLinkInput) input: UpdateMJDashboardCategoryLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Category Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategoryLink_)
    async DeleteMJDashboardCategoryLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Category Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Category Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for dashboard categories (folders). Permissions cascade to all dashboards within the category. Enables sharing entire folders of dashboards with granular access control.` })
export class MJDashboardCategoryPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DashboardCategoryID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Boolean, {description: `Whether the user can view dashboards within this category`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can modify dashboards within this category`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can add new dashboards to or remove dashboards from this category`}) 
    CanAddRemove: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can share this category with other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `The user who granted this permission. NULL if shared by the category owner.`}) 
    @MaxLength(16)
    SharedByUserID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    DashboardCategory: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Permissions
//****************************************************************************
@InputType()
export class CreateMJDashboardCategoryPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardCategoryID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanAddRemove?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Category Permissions
//****************************************************************************
@InputType()
export class UpdateMJDashboardCategoryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardCategoryID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanAddRemove?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Category Permissions
//****************************************************************************
@ObjectType()
export class RunMJDashboardCategoryPermissionViewResult {
    @Field(() => [MJDashboardCategoryPermission_])
    Results: MJDashboardCategoryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardCategoryPermission_)
export class MJDashboardCategoryPermissionResolver extends ResolverBase {
    @Query(() => RunMJDashboardCategoryPermissionViewResult)
    async RunMJDashboardCategoryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryPermissionViewResult)
    async RunMJDashboardCategoryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardCategoryPermissionViewResult)
    async RunMJDashboardCategoryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Category Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardCategoryPermission_, { nullable: true })
    async MJDashboardCategoryPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardCategoryPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardCategoryPermission_)
    async CreateMJDashboardCategoryPermission(
        @Arg('input', () => CreateMJDashboardCategoryPermissionInput) input: CreateMJDashboardCategoryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Category Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardCategoryPermission_)
    async UpdateMJDashboardCategoryPermission(
        @Arg('input', () => UpdateMJDashboardCategoryPermissionInput) input: UpdateMJDashboardCategoryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Category Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardCategoryPermission_)
    async DeleteMJDashboardCategoryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Category Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Part Types
//****************************************************************************
@ObjectType({ description: `Stores available panel types for metadata-driven dashboards. Each panel type defines a driver class for rendering content and an optional config dialog for setup UI.` })
export class MJDashboardPartType_ {
    @Field({description: `Primary key`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name for the panel type (e.g., View, Query, Artifact, WebURL, Custom)`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this panel type displays and its capabilities`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for the panel type (e.g., fa-solid fa-table)`}) 
    @MaxLength(200)
    Icon?: string;
        
    @Field({description: `The @RegisterClass name for the panel renderer component that extends DashboardBasePanelRenderer`}) 
    @MaxLength(510)
    DriverClass: string;
        
    @Field({nullable: true, description: `The @RegisterClass name for the configuration dialog component that extends DashboardBasePanelConfigDialog`}) 
    @MaxLength(510)
    ConfigDialogClass?: string;
        
    @Field({nullable: true, description: `JSON object containing default configuration values for new panels of this type`}) 
    DefaultConfig?: string;
        
    @Field(() => Int, {description: `Display order in panel type selection UI (lower numbers appear first)`}) 
    SortOrder: number;
        
    @Field(() => Boolean, {description: `Whether this panel type is currently available for use`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Part Types
//****************************************************************************
@InputType()
export class CreateMJDashboardPartTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    ConfigDialogClass: string | null;

    @Field({ nullable: true })
    DefaultConfig: string | null;

    @Field(() => Int, { nullable: true })
    SortOrder?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Part Types
//****************************************************************************
@InputType()
export class UpdateMJDashboardPartTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    ConfigDialogClass?: string | null;

    @Field({ nullable: true })
    DefaultConfig?: string | null;

    @Field(() => Int, { nullable: true })
    SortOrder?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Part Types
//****************************************************************************
@ObjectType()
export class RunMJDashboardPartTypeViewResult {
    @Field(() => [MJDashboardPartType_])
    Results: MJDashboardPartType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardPartType_)
export class MJDashboardPartTypeResolver extends ResolverBase {
    @Query(() => RunMJDashboardPartTypeViewResult)
    async RunMJDashboardPartTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPartTypeViewResult)
    async RunMJDashboardPartTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPartTypeViewResult)
    async RunMJDashboardPartTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Part Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardPartType_, { nullable: true })
    async MJDashboardPartType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardPartType_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Part Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardPartTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Part Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Part Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardPartType_)
    async CreateMJDashboardPartType(
        @Arg('input', () => CreateMJDashboardPartTypeInput) input: CreateMJDashboardPartTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Part Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardPartType_)
    async UpdateMJDashboardPartType(
        @Arg('input', () => UpdateMJDashboardPartTypeInput) input: UpdateMJDashboardPartTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Part Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardPartType_)
    async DeleteMJDashboardPartType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Part Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard Permissions
//****************************************************************************
@ObjectType({ description: `Manages user permissions for dashboards with granular access control (Read, Edit, Delete, Share). Each record grants a specific user access to a dashboard with configurable permission levels.` })
export class MJDashboardPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DashboardID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Boolean, {description: `Whether the user can view the dashboard and its contents`}) 
    CanRead: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can modify the dashboard layout, add/remove parts, or change settings`}) 
    CanEdit: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can delete the dashboard entirely`}) 
    CanDelete: boolean;
        
    @Field(() => Boolean, {description: `Whether the user can share the dashboard with other users`}) 
    CanShare: boolean;
        
    @Field({nullable: true, description: `The user who granted this permission. NULL if shared by the dashboard owner.`}) 
    @MaxLength(16)
    SharedByUserID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Dashboard: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SharedByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Permissions
//****************************************************************************
@InputType()
export class CreateMJDashboardPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard Permissions
//****************************************************************************
@InputType()
export class UpdateMJDashboardPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanEdit?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanShare?: boolean;

    @Field({ nullable: true })
    SharedByUserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard Permissions
//****************************************************************************
@ObjectType()
export class RunMJDashboardPermissionViewResult {
    @Field(() => [MJDashboardPermission_])
    Results: MJDashboardPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardPermission_)
export class MJDashboardPermissionResolver extends ResolverBase {
    @Query(() => RunMJDashboardPermissionViewResult)
    async RunMJDashboardPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPermissionViewResult)
    async RunMJDashboardPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardPermissionViewResult)
    async RunMJDashboardPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardPermission_, { nullable: true })
    async MJDashboardPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardPermission_)
    async CreateMJDashboardPermission(
        @Arg('input', () => CreateMJDashboardPermissionInput) input: CreateMJDashboardPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardPermission_)
    async UpdateMJDashboardPermission(
        @Arg('input', () => UpdateMJDashboardPermissionInput) input: UpdateMJDashboardPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardPermission_)
    async DeleteMJDashboardPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard User Preferences
//****************************************************************************
@ObjectType({ description: `Stores dashboard preferences for users and system defaults. The absence of a record for a dashboard means it is not shown.` })
export class MJDashboardUserPreference_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `User that these preferences belong to, NULL for system defaults`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({description: `Dashboard that this preference refers to`}) 
    @MaxLength(16)
    DashboardID: string;
        
    @Field({description: `Scope of the preference (Global or App)`}) 
    @MaxLength(40)
    Scope: string;
        
    @Field({nullable: true, description: `Application that this preference applies to (only for App scope)`}) 
    @MaxLength(16)
    ApplicationID?: string;
        
    @Field(() => Int, {description: `Order in which to display the dashboard`}) 
    DisplayOrder: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field() 
    @MaxLength(510)
    Dashboard: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Application?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User Preferences
//****************************************************************************
@InputType()
export class CreateMJDashboardUserPreferenceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User Preferences
//****************************************************************************
@InputType()
export class UpdateMJDashboardUserPreferenceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    ApplicationID?: string | null;

    @Field(() => Int, { nullable: true })
    DisplayOrder?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard User Preferences
//****************************************************************************
@ObjectType()
export class RunMJDashboardUserPreferenceViewResult {
    @Field(() => [MJDashboardUserPreference_])
    Results: MJDashboardUserPreference_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardUserPreference_)
export class MJDashboardUserPreferenceResolver extends ResolverBase {
    @Query(() => RunMJDashboardUserPreferenceViewResult)
    async RunMJDashboardUserPreferenceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserPreferenceViewResult)
    async RunMJDashboardUserPreferenceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserPreferenceViewResult)
    async RunMJDashboardUserPreferenceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard User Preferences';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardUserPreference_, { nullable: true })
    async MJDashboardUserPreference(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardUserPreference_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardUserPreference_)
    async CreateMJDashboardUserPreference(
        @Arg('input', () => CreateMJDashboardUserPreferenceInput) input: CreateMJDashboardUserPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard User Preferences', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardUserPreference_)
    async UpdateMJDashboardUserPreference(
        @Arg('input', () => UpdateMJDashboardUserPreferenceInput) input: UpdateMJDashboardUserPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard User Preferences', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardUserPreference_)
    async DeleteMJDashboardUserPreference(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard User Preferences', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Dashboard User States
//****************************************************************************
@ObjectType({ description: `Stores user-specific dashboard state information` })
export class MJDashboardUserState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Dashboard that this state applies to`}) 
    @MaxLength(16)
    DashboardID: string;
        
    @Field({description: `User that this state belongs to`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `JSON object containing user-specific dashboard state`}) 
    UserState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Dashboard: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User States
//****************************************************************************
@InputType()
export class CreateMJDashboardUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UserState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Dashboard User States
//****************************************************************************
@InputType()
export class UpdateMJDashboardUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DashboardID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    UserState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Dashboard User States
//****************************************************************************
@ObjectType()
export class RunMJDashboardUserStateViewResult {
    @Field(() => [MJDashboardUserState_])
    Results: MJDashboardUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJDashboardUserState_)
export class MJDashboardUserStateResolver extends ResolverBase {
    @Query(() => RunMJDashboardUserStateViewResult)
    async RunMJDashboardUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserStateViewResult)
    async RunMJDashboardUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJDashboardUserStateViewResult)
    async RunMJDashboardUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Dashboard User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJDashboardUserState_, { nullable: true })
    async MJDashboardUserState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJDashboardUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Dashboard User States', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJDashboardUserState_)
    async CreateMJDashboardUserState(
        @Arg('input', () => CreateMJDashboardUserStateInput) input: CreateMJDashboardUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Dashboard User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJDashboardUserState_)
    async UpdateMJDashboardUserState(
        @Arg('input', () => UpdateMJDashboardUserStateInput) input: UpdateMJDashboardUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Dashboard User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJDashboardUserState_)
    async DeleteMJDashboardUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Dashboard User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Encryption Algorithms
//****************************************************************************
@ObjectType({ description: `Defines available encryption algorithms and their configuration parameters. AES-256-GCM is the recommended algorithm for new implementations.` })
export class MJEncryptionAlgorithm_ {
    @Field({description: `Unique identifier for the algorithm.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Algorithm name (e.g., AES-256-GCM). Must match the format used in encrypted values.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of the algorithm and when to use it.`}) 
    Description?: string;
        
    @Field({description: `Node.js crypto module algorithm identifier (e.g., aes-256-gcm).`}) 
    @MaxLength(100)
    NodeCryptoName: string;
        
    @Field(() => Int, {description: `Required key length in bits (e.g., 256 for AES-256).`}) 
    KeyLengthBits: number;
        
    @Field(() => Int, {description: `Required initialization vector length in bytes (e.g., 12 for GCM, 16 for CBC).`}) 
    IVLengthBytes: number;
        
    @Field(() => Boolean, {description: `Whether this algorithm provides Authenticated Encryption with Associated Data (AEAD). AEAD algorithms like GCM detect tampering.`}) 
    IsAEAD: boolean;
        
    @Field(() => Boolean, {description: `Whether this algorithm is available for use.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEncryptionKey_])
    MJ_EncryptionKeys_EncryptionAlgorithmIDArray: MJEncryptionKey_[]; // Link to MJ_EncryptionKeys
    
}

//****************************************************************************
// INPUT TYPE for MJ: Encryption Algorithms
//****************************************************************************
@InputType()
export class CreateMJEncryptionAlgorithmInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    NodeCryptoName?: string;

    @Field(() => Int, { nullable: true })
    KeyLengthBits?: number;

    @Field(() => Int, { nullable: true })
    IVLengthBytes?: number;

    @Field(() => Boolean, { nullable: true })
    IsAEAD?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Encryption Algorithms
//****************************************************************************
@InputType()
export class UpdateMJEncryptionAlgorithmInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NodeCryptoName?: string;

    @Field(() => Int, { nullable: true })
    KeyLengthBits?: number;

    @Field(() => Int, { nullable: true })
    IVLengthBytes?: number;

    @Field(() => Boolean, { nullable: true })
    IsAEAD?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Encryption Algorithms
//****************************************************************************
@ObjectType()
export class RunMJEncryptionAlgorithmViewResult {
    @Field(() => [MJEncryptionAlgorithm_])
    Results: MJEncryptionAlgorithm_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEncryptionAlgorithm_)
export class MJEncryptionAlgorithmResolver extends ResolverBase {
    @Query(() => RunMJEncryptionAlgorithmViewResult)
    async RunMJEncryptionAlgorithmViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionAlgorithmViewResult)
    async RunMJEncryptionAlgorithmViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionAlgorithmViewResult)
    async RunMJEncryptionAlgorithmDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Encryption Algorithms';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEncryptionAlgorithm_, { nullable: true })
    async MJEncryptionAlgorithm(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEncryptionAlgorithm_ | null> {
        this.CheckUserReadPermissions('MJ: Encryption Algorithms', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEncryptionAlgorithms] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Algorithms', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Encryption Algorithms', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEncryptionKey_])
    async MJ_EncryptionKeys_EncryptionAlgorithmIDArray(@Root() mjencryptionalgorithm_: MJEncryptionAlgorithm_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Encryption Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEncryptionKeys] WHERE [EncryptionAlgorithmID]='${mjencryptionalgorithm_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Encryption Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEncryptionAlgorithm_)
    async CreateMJEncryptionAlgorithm(
        @Arg('input', () => CreateMJEncryptionAlgorithmInput) input: CreateMJEncryptionAlgorithmInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Encryption Algorithms', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEncryptionAlgorithm_)
    async UpdateMJEncryptionAlgorithm(
        @Arg('input', () => UpdateMJEncryptionAlgorithmInput) input: UpdateMJEncryptionAlgorithmInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Encryption Algorithms', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEncryptionAlgorithm_)
    async DeleteMJEncryptionAlgorithm(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Encryption Algorithms', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Encryption Key Sources
//****************************************************************************
@ObjectType({ description: `Defines sources for retrieving encryption keys (environment variables, vault services, config files, etc.). Key sources are pluggable providers that implement the EncryptionKeySourceBase class.` })
export class MJEncryptionKeySource_ {
    @Field({description: `Unique identifier for the key source.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name for this key source (e.g., Environment Variable, AWS KMS).`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Human-readable description of this key source and usage instructions.`}) 
    Description?: string;
        
    @Field({description: `TypeScript class name that implements EncryptionKeySourceBase (e.g., EnvVarKeySource).`}) 
    @MaxLength(510)
    DriverClass: string;
        
    @Field({nullable: true, description: `Package path where the driver class is exported (e.g., @memberjunction/encryption).`}) 
    @MaxLength(1000)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `JSON template describing the configuration options for this key source.`}) 
    ConfigTemplate?: string;
        
    @Field(() => Boolean, {description: `Whether this key source is available for use.`}) 
    IsActive: boolean;
        
    @Field({description: `Current status: Active, Inactive, or Deprecated.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEncryptionKey_])
    MJ_EncryptionKeys_EncryptionKeySourceIDArray: MJEncryptionKey_[]; // Link to MJ_EncryptionKeys
    
}

//****************************************************************************
// INPUT TYPE for MJ: Encryption Key Sources
//****************************************************************************
@InputType()
export class CreateMJEncryptionKeySourceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    ConfigTemplate: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Encryption Key Sources
//****************************************************************************
@InputType()
export class UpdateMJEncryptionKeySourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    ConfigTemplate?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Encryption Key Sources
//****************************************************************************
@ObjectType()
export class RunMJEncryptionKeySourceViewResult {
    @Field(() => [MJEncryptionKeySource_])
    Results: MJEncryptionKeySource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEncryptionKeySource_)
export class MJEncryptionKeySourceResolver extends ResolverBase {
    @Query(() => RunMJEncryptionKeySourceViewResult)
    async RunMJEncryptionKeySourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeySourceViewResult)
    async RunMJEncryptionKeySourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeySourceViewResult)
    async RunMJEncryptionKeySourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Encryption Key Sources';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEncryptionKeySource_, { nullable: true })
    async MJEncryptionKeySource(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEncryptionKeySource_ | null> {
        this.CheckUserReadPermissions('MJ: Encryption Key Sources', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEncryptionKeySources] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Key Sources', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Encryption Key Sources', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEncryptionKey_])
    async MJ_EncryptionKeys_EncryptionKeySourceIDArray(@Root() mjencryptionkeysource_: MJEncryptionKeySource_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Encryption Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEncryptionKeys] WHERE [EncryptionKeySourceID]='${mjencryptionkeysource_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Encryption Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEncryptionKeySource_)
    async CreateMJEncryptionKeySource(
        @Arg('input', () => CreateMJEncryptionKeySourceInput) input: CreateMJEncryptionKeySourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Encryption Key Sources', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEncryptionKeySource_)
    async UpdateMJEncryptionKeySource(
        @Arg('input', () => UpdateMJEncryptionKeySourceInput) input: UpdateMJEncryptionKeySourceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Encryption Key Sources', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEncryptionKeySource_)
    async DeleteMJEncryptionKeySource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Encryption Key Sources', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Encryption Keys
//****************************************************************************
@ObjectType({ description: `Defines encryption keys used for field-level encryption. Keys are NOT stored in the database - only references to external key sources. Configure one or more keys and assign them to entity fields.` })
export class MJEncryptionKey_ {
    @Field({description: `Unique identifier for the encryption key configuration.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name for this key (e.g., PII Master Key, API Secrets Key).`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Description of this key purpose and scope.`}) 
    Description?: string;
        
    @Field({description: `References the key source that provides the key material.`}) 
    @MaxLength(16)
    EncryptionKeySourceID: string;
        
    @Field({description: `References the algorithm to use for encryption/decryption.`}) 
    @MaxLength(16)
    EncryptionAlgorithmID: string;
        
    @Field({description: `Source-specific lookup value (e.g., environment variable name, vault path).`}) 
    @MaxLength(1000)
    KeyLookupValue: string;
        
    @Field({description: `Version string for key rotation tracking. Incremented during rotation.`}) 
    @MaxLength(40)
    KeyVersion: string;
        
    @Field({description: `Prefix marker for encrypted values (default: $ENC$).`}) 
    @MaxLength(40)
    Marker: string;
        
    @Field(() => Boolean, {description: `Whether this key can be used for new encryption operations.`}) 
    IsActive: boolean;
        
    @Field({description: `Current status: Active, Inactive, Rotating, or Expired.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `When the current key version was activated.`}) 
    @MaxLength(10)
    ActivatedAt?: Date;
        
    @Field({nullable: true, description: `Optional expiration date. Keys past this date cannot be used for new encryption.`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    EncryptionKeySource: string;
        
    @Field() 
    @MaxLength(100)
    EncryptionAlgorithm: string;
        
    @Field(() => [MJEntityField_])
    EntityFields_EncryptionKeyIDArray: MJEntityField_[]; // Link to EntityFields
    
}

//****************************************************************************
// INPUT TYPE for MJ: Encryption Keys
//****************************************************************************
@InputType()
export class CreateMJEncryptionKeyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EncryptionKeySourceID?: string;

    @Field({ nullable: true })
    EncryptionAlgorithmID?: string;

    @Field({ nullable: true })
    KeyLookupValue?: string;

    @Field({ nullable: true })
    KeyVersion?: string;

    @Field({ nullable: true })
    Marker?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActivatedAt: Date | null;

    @Field({ nullable: true })
    ExpiresAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Encryption Keys
//****************************************************************************
@InputType()
export class UpdateMJEncryptionKeyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EncryptionKeySourceID?: string;

    @Field({ nullable: true })
    EncryptionAlgorithmID?: string;

    @Field({ nullable: true })
    KeyLookupValue?: string;

    @Field({ nullable: true })
    KeyVersion?: string;

    @Field({ nullable: true })
    Marker?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ActivatedAt?: Date | null;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Encryption Keys
//****************************************************************************
@ObjectType()
export class RunMJEncryptionKeyViewResult {
    @Field(() => [MJEncryptionKey_])
    Results: MJEncryptionKey_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEncryptionKey_)
export class MJEncryptionKeyResolver extends ResolverBase {
    @Query(() => RunMJEncryptionKeyViewResult)
    async RunMJEncryptionKeyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeyViewResult)
    async RunMJEncryptionKeyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEncryptionKeyViewResult)
    async RunMJEncryptionKeyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Encryption Keys';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEncryptionKey_, { nullable: true })
    async MJEncryptionKey(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEncryptionKey_ | null> {
        this.CheckUserReadPermissions('MJ: Encryption Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEncryptionKeys] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Encryption Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Encryption Keys', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityField_])
    async EntityFields_EncryptionKeyIDArray(@Root() mjencryptionkey_: MJEncryptionKey_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [EncryptionKeyID]='${mjencryptionkey_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEncryptionKey_)
    async CreateMJEncryptionKey(
        @Arg('input', () => CreateMJEncryptionKeyInput) input: CreateMJEncryptionKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Encryption Keys', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEncryptionKey_)
    async UpdateMJEncryptionKey(
        @Arg('input', () => UpdateMJEncryptionKeyInput) input: UpdateMJEncryptionKeyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Encryption Keys', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEncryptionKey_)
    async DeleteMJEncryptionKey(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Encryption Keys', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Environments
//****************************************************************************
@ObjectType({ description: `Top-level container for organizing conversations, artifacts, and collections. Provides isolation and grouping for different teams, clients, or functional areas.` })
export class MJEnvironment_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name for the environment`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the environment purpose and scope`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `Indicates if this is the default environment for the organization`}) 
    IsDefault: boolean;
        
    @Field({nullable: true, description: `JSON configuration for environment-specific settings and features`}) 
    Settings?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJProject_])
    MJ_Projects_EnvironmentIDArray: MJProject_[]; // Link to MJ_Projects
    
    @Field(() => [MJCollection_])
    MJ_Collections_EnvironmentIDArray: MJCollection_[]; // Link to MJ_Collections
    
    @Field(() => [MJArtifact_])
    MJ_Artifacts_EnvironmentIDArray: MJArtifact_[]; // Link to MJ_Artifacts
    
    @Field(() => [MJTask_])
    MJ_Tasks_EnvironmentIDArray: MJTask_[]; // Link to MJ_Tasks
    
    @Field(() => [MJDashboard_])
    Dashboards_EnvironmentIDArray: MJDashboard_[]; // Link to Dashboards
    
    @Field(() => [MJReport_])
    Reports_EnvironmentIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJConversation_])
    Conversations_EnvironmentIDArray: MJConversation_[]; // Link to Conversations
    
}

//****************************************************************************
// INPUT TYPE for MJ: Environments
//****************************************************************************
@InputType()
export class CreateMJEnvironmentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Settings: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Environments
//****************************************************************************
@InputType()
export class UpdateMJEnvironmentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    Settings?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Environments
//****************************************************************************
@ObjectType()
export class RunMJEnvironmentViewResult {
    @Field(() => [MJEnvironment_])
    Results: MJEnvironment_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJEnvironment_)
export class MJEnvironmentResolver extends ResolverBase {
    @Query(() => RunMJEnvironmentViewResult)
    async RunMJEnvironmentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEnvironmentViewResult)
    async RunMJEnvironmentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJEnvironmentViewResult)
    async RunMJEnvironmentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Environments';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJEnvironment_, { nullable: true })
    async MJEnvironment(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJEnvironment_ | null> {
        this.CheckUserReadPermissions('MJ: Environments', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEnvironments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Environments', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Environments', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJProject_])
    async MJ_Projects_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Projects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwProjects] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Projects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Projects', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollection_])
    async MJ_Collections_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollections] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifact_])
    async MJ_Artifacts_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifacts] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async Dashboards_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_EnvironmentIDArray(@Root() mjenvironment_: MJEnvironment_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [EnvironmentID]='${mjenvironment_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJEnvironment_)
    async CreateMJEnvironment(
        @Arg('input', () => CreateMJEnvironmentInput) input: CreateMJEnvironmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Environments', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJEnvironment_)
    async UpdateMJEnvironment(
        @Arg('input', () => UpdateMJEnvironmentInput) input: UpdateMJEnvironmentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Environments', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJEnvironment_)
    async DeleteMJEnvironment(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Environments', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: File Storage Accounts
//****************************************************************************
@ObjectType({ description: `Enterprise-level file storage accounts. Each account represents a configured connection to a storage provider (e.g., Marketing Dropbox, Engineering Google Drive) with credentials managed centrally.` })
export class MJFileStorageAccount_ {
    @Field({description: `Primary key`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name for the storage account (e.g., Marketing Files, Engineering Docs). Must be unique per provider.`}) 
    @MaxLength(400)
    Name: string;
        
    @Field({nullable: true, description: `Optional description providing additional context about the account purpose or contents.`}) 
    Description?: string;
        
    @Field({description: `Foreign key to FileStorageProvider indicating which storage service this account uses (Dropbox, Google Drive, S3, etc.).`}) 
    @MaxLength(16)
    ProviderID: string;
        
    @Field({description: `Foreign key to Credential containing the authentication details (OAuth tokens, API keys, etc.) for this account. Credentials are decrypted at runtime by the Credential Engine.`}) 
    @MaxLength(16)
    CredentialID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Provider: string;
        
    @Field() 
    @MaxLength(400)
    Credential: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: File Storage Accounts
//****************************************************************************
@InputType()
export class CreateMJFileStorageAccountInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    CredentialID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: File Storage Accounts
//****************************************************************************
@InputType()
export class UpdateMJFileStorageAccountInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    CredentialID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: File Storage Accounts
//****************************************************************************
@ObjectType()
export class RunMJFileStorageAccountViewResult {
    @Field(() => [MJFileStorageAccount_])
    Results: MJFileStorageAccount_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJFileStorageAccount_)
export class MJFileStorageAccountResolver extends ResolverBase {
    @Query(() => RunMJFileStorageAccountViewResult)
    async RunMJFileStorageAccountViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageAccountViewResult)
    async RunMJFileStorageAccountViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJFileStorageAccountViewResult)
    async RunMJFileStorageAccountDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: File Storage Accounts';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJFileStorageAccount_, { nullable: true })
    async MJFileStorageAccount(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJFileStorageAccount_ | null> {
        this.CheckUserReadPermissions('MJ: File Storage Accounts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageAccounts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: File Storage Accounts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: File Storage Accounts', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJFileStorageAccount_)
    async CreateMJFileStorageAccount(
        @Arg('input', () => CreateMJFileStorageAccountInput) input: CreateMJFileStorageAccountInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: File Storage Accounts', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJFileStorageAccount_)
    async UpdateMJFileStorageAccount(
        @Arg('input', () => UpdateMJFileStorageAccountInput) input: UpdateMJFileStorageAccountInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: File Storage Accounts', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJFileStorageAccount_)
    async DeleteMJFileStorageAccount(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: File Storage Accounts', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: List Invitations
//****************************************************************************
@ObjectType({ description: `Tracks pending invitations for users to access lists, including external users via email.` })
export class MJListInvitation_ {
    @Field({description: `Unique identifier for the invitation.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The list the user is being invited to.`}) 
    @MaxLength(16)
    ListID: string;
        
    @Field({description: `Email address of the invitee.`}) 
    @MaxLength(510)
    Email: string;
        
    @Field({description: `The role to be assigned upon acceptance (Editor or Viewer).`}) 
    @MaxLength(100)
    Role: string;
        
    @Field({description: `Security token for validating the invitation.`}) 
    @MaxLength(200)
    Token: string;
        
    @Field({description: `When the invitation expires.`}) 
    @MaxLength(8)
    ExpiresAt: Date;
        
    @Field({description: `The user who created the invitation.`}) 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field({description: `Status of the invitation (Pending, Accepted, Expired, Revoked).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    List: string;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: List Invitations
//****************************************************************************
@InputType()
export class CreateMJListInvitationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: List Invitations
//****************************************************************************
@InputType()
export class UpdateMJListInvitationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: List Invitations
//****************************************************************************
@ObjectType()
export class RunMJListInvitationViewResult {
    @Field(() => [MJListInvitation_])
    Results: MJListInvitation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListInvitation_)
export class MJListInvitationResolver extends ResolverBase {
    @Query(() => RunMJListInvitationViewResult)
    async RunMJListInvitationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListInvitationViewResult)
    async RunMJListInvitationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListInvitationViewResult)
    async RunMJListInvitationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: List Invitations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListInvitation_, { nullable: true })
    async MJListInvitation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListInvitation_ | null> {
        this.CheckUserReadPermissions('MJ: List Invitations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListInvitations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Invitations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: List Invitations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJListInvitation_)
    async CreateMJListInvitation(
        @Arg('input', () => CreateMJListInvitationInput) input: CreateMJListInvitationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: List Invitations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListInvitation_)
    async UpdateMJListInvitation(
        @Arg('input', () => UpdateMJListInvitationInput) input: UpdateMJListInvitationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: List Invitations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListInvitation_)
    async DeleteMJListInvitation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: List Invitations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: List Shares
//****************************************************************************
@ObjectType({ description: `Manages user access and permissions for shared lists.` })
export class MJListShare_ {
    @Field({description: `Unique identifier for the share record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The list being shared.`}) 
    @MaxLength(16)
    ListID: string;
        
    @Field({description: `The user receiving access to the list.`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `The permission level granted (Editor or Viewer).`}) 
    @MaxLength(100)
    Role: string;
        
    @Field({description: `Current status of the share (Active or Pending).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    List: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: List Shares
//****************************************************************************
@InputType()
export class CreateMJListShareInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: List Shares
//****************************************************************************
@InputType()
export class UpdateMJListShareInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: List Shares
//****************************************************************************
@ObjectType()
export class RunMJListShareViewResult {
    @Field(() => [MJListShare_])
    Results: MJListShare_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJListShare_)
export class MJListShareResolver extends ResolverBase {
    @Query(() => RunMJListShareViewResult)
    async RunMJListShareViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListShareViewResult)
    async RunMJListShareViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJListShareViewResult)
    async RunMJListShareDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: List Shares';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJListShare_, { nullable: true })
    async MJListShare(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJListShare_ | null> {
        this.CheckUserReadPermissions('MJ: List Shares', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListShares] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Shares', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: List Shares', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJListShare_)
    async CreateMJListShare(
        @Arg('input', () => CreateMJListShareInput) input: CreateMJListShareInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: List Shares', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJListShare_)
    async UpdateMJListShare(
        @Arg('input', () => UpdateMJListShareInput) input: UpdateMJListShareInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: List Shares', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJListShare_)
    async DeleteMJListShare(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: List Shares', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Connection Permissions
//****************************************************************************
@ObjectType()
export class MJMCPServerConnectionPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerConnectionID: string;
        
    @Field({nullable: true, description: `FK to User (mutually exclusive with RoleID)`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `FK to Role (mutually exclusive with UserID)`}) 
    @MaxLength(16)
    RoleID?: string;
        
    @Field(() => Boolean, {description: `Can invoke tools via this connection`}) 
    CanExecute: boolean;
        
    @Field(() => Boolean, {description: `Can modify connection settings`}) 
    CanModify: boolean;
        
    @Field(() => Boolean, {description: `Can see credential info (but not decrypt)`}) 
    CanViewCredentials: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Role?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Permissions
//****************************************************************************
@InputType()
export class CreateMJMCPServerConnectionPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field(() => Boolean, { nullable: true })
    CanExecute?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanModify?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanViewCredentials?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Permissions
//****************************************************************************
@InputType()
export class UpdateMJMCPServerConnectionPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field(() => Boolean, { nullable: true })
    CanExecute?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanModify?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanViewCredentials?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Connection Permissions
//****************************************************************************
@ObjectType()
export class RunMJMCPServerConnectionPermissionViewResult {
    @Field(() => [MJMCPServerConnectionPermission_])
    Results: MJMCPServerConnectionPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerConnectionPermission_)
export class MJMCPServerConnectionPermissionResolver extends ResolverBase {
    @Query(() => RunMJMCPServerConnectionPermissionViewResult)
    async RunMJMCPServerConnectionPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionPermissionViewResult)
    async RunMJMCPServerConnectionPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionPermissionViewResult)
    async RunMJMCPServerConnectionPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Connection Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerConnectionPermission_, { nullable: true })
    async MJMCPServerConnectionPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerConnectionPermission_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJMCPServerConnectionPermission_)
    async CreateMJMCPServerConnectionPermission(
        @Arg('input', () => CreateMJMCPServerConnectionPermissionInput) input: CreateMJMCPServerConnectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Connection Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerConnectionPermission_)
    async UpdateMJMCPServerConnectionPermission(
        @Arg('input', () => UpdateMJMCPServerConnectionPermissionInput) input: UpdateMJMCPServerConnectionPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Connection Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerConnectionPermission_)
    async DeleteMJMCPServerConnectionPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Connection Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Connection Tools
//****************************************************************************
@ObjectType()
export class MJMCPServerConnectionTool_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerConnectionID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerToolID: string;
        
    @Field(() => Boolean, {description: `Whether this tool is enabled for the connection`}) 
    IsEnabled: boolean;
        
    @Field({nullable: true, description: `JSON default values for tool inputs`}) 
    DefaultInputValues?: string;
        
    @Field(() => Int, {nullable: true, description: `Override rate limit for this specific tool`}) 
    MaxCallsPerMinute?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    MCPServerTool?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Tools
//****************************************************************************
@InputType()
export class CreateMJMCPServerConnectionToolInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    DefaultInputValues: string | null;

    @Field(() => Int, { nullable: true })
    MaxCallsPerMinute: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connection Tools
//****************************************************************************
@InputType()
export class UpdateMJMCPServerConnectionToolInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field({ nullable: true })
    DefaultInputValues?: string | null;

    @Field(() => Int, { nullable: true })
    MaxCallsPerMinute?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Connection Tools
//****************************************************************************
@ObjectType()
export class RunMJMCPServerConnectionToolViewResult {
    @Field(() => [MJMCPServerConnectionTool_])
    Results: MJMCPServerConnectionTool_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerConnectionTool_)
export class MJMCPServerConnectionToolResolver extends ResolverBase {
    @Query(() => RunMJMCPServerConnectionToolViewResult)
    async RunMJMCPServerConnectionToolViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionToolViewResult)
    async RunMJMCPServerConnectionToolViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionToolViewResult)
    async RunMJMCPServerConnectionToolDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Connection Tools';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerConnectionTool_, { nullable: true })
    async MJMCPServerConnectionTool(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerConnectionTool_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionTools] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Connection Tools', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJMCPServerConnectionTool_)
    async CreateMJMCPServerConnectionTool(
        @Arg('input', () => CreateMJMCPServerConnectionToolInput) input: CreateMJMCPServerConnectionToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Connection Tools', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerConnectionTool_)
    async UpdateMJMCPServerConnectionTool(
        @Arg('input', () => UpdateMJMCPServerConnectionToolInput) input: UpdateMJMCPServerConnectionToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Connection Tools', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerConnectionTool_)
    async DeleteMJMCPServerConnectionTool(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Connection Tools', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Connections
//****************************************************************************
@ObjectType()
export class MJMCPServerConnection_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerID: string;
        
    @Field({description: `Connection name (unique per company)`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `FK to Credential entity (uses existing credential types)`}) 
    @MaxLength(16)
    CredentialID?: string;
        
    @Field({nullable: true, description: `Custom header name for API key auth (default: X-API-Key)`}) 
    @MaxLength(200)
    CustomHeaderName?: string;
        
    @Field({nullable: true, description: `Optional company association. NULL means the connection is global and available to all companies. Non-NULL restricts the connection to that specific company.`}) 
    @MaxLength(16)
    CompanyID?: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field(() => Boolean, {description: `Auto-sync tools when connecting`}) 
    AutoSyncTools: boolean;
        
    @Field(() => Boolean, {description: `Auto-generate MJ Actions for discovered tools`}) 
    AutoGenerateActions: boolean;
        
    @Field(() => Boolean, {description: `Log all tool calls to execution log`}) 
    LogToolCalls: boolean;
        
    @Field(() => Boolean, {description: `Include input parameters in logs`}) 
    LogInputParameters: boolean;
        
    @Field(() => Boolean, {description: `Include output content in logs`}) 
    LogOutputContent: boolean;
        
    @Field(() => Int, {nullable: true, description: `Max output size to log in bytes (default: 100KB)`}) 
    MaxOutputLogSize?: number;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    LastConnectedAt?: Date;
        
    @Field({nullable: true}) 
    LastErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON object of environment variables for Stdio transport`}) 
    EnvironmentVars?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServer: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    Credential?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Company?: string;
        
    @Field(() => [MJMCPServerConnectionTool_])
    MJ_MCPServerConnectionTools_MCPServerConnectionIDArray: MJMCPServerConnectionTool_[]; // Link to MJ_MCPServerConnectionTools
    
    @Field(() => [MJMCPToolExecutionLog_])
    MJ_MCPToolExecutionLogs_MCPServerConnectionIDArray: MJMCPToolExecutionLog_[]; // Link to MJ_MCPToolExecutionLogs
    
    @Field(() => [MJOAuthClientRegistration_])
    MJ_OAuthClientRegistrations_MCPServerConnectionIDArray: MJOAuthClientRegistration_[]; // Link to MJ_OAuthClientRegistrations
    
    @Field(() => [MJOAuthToken_])
    MJ_OAuthTokens_MCPServerConnectionIDArray: MJOAuthToken_[]; // Link to MJ_OAuthTokens
    
    @Field(() => [MJOAuthAuthorizationState_])
    MJ_OAuthAuthorizationStates_MCPServerConnectionIDArray: MJOAuthAuthorizationState_[]; // Link to MJ_OAuthAuthorizationStates
    
    @Field(() => [MJMCPServerConnectionPermission_])
    MJ_MCPServerConnectionPermissions_MCPServerConnectionIDArray: MJMCPServerConnectionPermission_[]; // Link to MJ_MCPServerConnectionPermissions
    
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connections
//****************************************************************************
@InputType()
export class CreateMJMCPServerConnectionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CredentialID: string | null;

    @Field({ nullable: true })
    CustomHeaderName: string | null;

    @Field({ nullable: true })
    CompanyID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoSyncTools?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoGenerateActions?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogToolCalls?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogInputParameters?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogOutputContent?: boolean;

    @Field(() => Int, { nullable: true })
    MaxOutputLogSize?: number | null;

    @Field({ nullable: true })
    LastConnectedAt: Date | null;

    @Field({ nullable: true })
    LastErrorMessage: string | null;

    @Field({ nullable: true })
    EnvironmentVars: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Connections
//****************************************************************************
@InputType()
export class UpdateMJMCPServerConnectionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CredentialID?: string | null;

    @Field({ nullable: true })
    CustomHeaderName?: string | null;

    @Field({ nullable: true })
    CompanyID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    AutoSyncTools?: boolean;

    @Field(() => Boolean, { nullable: true })
    AutoGenerateActions?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogToolCalls?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogInputParameters?: boolean;

    @Field(() => Boolean, { nullable: true })
    LogOutputContent?: boolean;

    @Field(() => Int, { nullable: true })
    MaxOutputLogSize?: number | null;

    @Field({ nullable: true })
    LastConnectedAt?: Date | null;

    @Field({ nullable: true })
    LastErrorMessage?: string | null;

    @Field({ nullable: true })
    EnvironmentVars?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Connections
//****************************************************************************
@ObjectType()
export class RunMJMCPServerConnectionViewResult {
    @Field(() => [MJMCPServerConnection_])
    Results: MJMCPServerConnection_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerConnection_)
export class MJMCPServerConnectionResolver extends ResolverBase {
    @Query(() => RunMJMCPServerConnectionViewResult)
    async RunMJMCPServerConnectionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionViewResult)
    async RunMJMCPServerConnectionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerConnectionViewResult)
    async RunMJMCPServerConnectionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Connections';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerConnection_, { nullable: true })
    async MJMCPServerConnection(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerConnection_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnections] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Connections', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJMCPServerConnectionTool_])
    async MJ_MCPServerConnectionTools_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionTools] WHERE [MCPServerConnectionID]='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPToolExecutionLog_])
    async MJ_MCPToolExecutionLogs_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPToolExecutionLogs] WHERE [MCPServerConnectionID]='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthClientRegistration_])
    async MJ_OAuthClientRegistrations_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Client Registrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthClientRegistrations] WHERE [MCPServerConnectionID]='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Client Registrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Client Registrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthToken_])
    async MJ_OAuthTokens_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Tokens', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthTokens] WHERE [MCPServerConnectionID]='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Tokens', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Tokens', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthAuthorizationState_])
    async MJ_OAuthAuthorizationStates_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Authorization States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthAuthorizationStates] WHERE [MCPServerConnectionID]='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Authorization States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Authorization States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnectionPermission_])
    async MJ_MCPServerConnectionPermissions_MCPServerConnectionIDArray(@Root() mjmcpserverconnection_: MJMCPServerConnection_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionPermissions] WHERE [MCPServerConnectionID]='${mjmcpserverconnection_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJMCPServerConnection_)
    async CreateMJMCPServerConnection(
        @Arg('input', () => CreateMJMCPServerConnectionInput) input: CreateMJMCPServerConnectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Connections', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerConnection_)
    async UpdateMJMCPServerConnection(
        @Arg('input', () => UpdateMJMCPServerConnectionInput) input: UpdateMJMCPServerConnectionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Connections', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerConnection_)
    async DeleteMJMCPServerConnection(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Connections', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Server Tools
//****************************************************************************
@ObjectType()
export class MJMCPServerTool_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerID: string;
        
    @Field({description: `Tool identifier from the MCP server`}) 
    @MaxLength(510)
    ToolName: string;
        
    @Field({nullable: true, description: `Human-readable title for the tool`}) 
    @MaxLength(510)
    ToolTitle?: string;
        
    @Field({nullable: true}) 
    ToolDescription?: string;
        
    @Field({description: `JSON Schema for tool input parameters`}) 
    InputSchema: string;
        
    @Field({nullable: true, description: `JSON Schema for tool output (if provided)`}) 
    OutputSchema?: string;
        
    @Field({nullable: true, description: `JSON with tool hints (readOnlyHint, destructiveHint, etc.)`}) 
    Annotations?: string;
        
    @Field({description: `Tool status: Active, Inactive, or Deprecated`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    DiscoveredAt: Date;
        
    @Field() 
    @MaxLength(10)
    LastSeenAt: Date;
        
    @Field({nullable: true, description: `FK to auto-generated Action (if promoted)`}) 
    @MaxLength(16)
    GeneratedActionID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    GeneratedActionCategoryID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServer: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    GeneratedAction?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    GeneratedActionCategory?: string;
        
    @Field(() => [MJMCPServerConnectionTool_])
    MJ_MCPServerConnectionTools_MCPServerToolIDArray: MJMCPServerConnectionTool_[]; // Link to MJ_MCPServerConnectionTools
    
    @Field(() => [MJMCPToolExecutionLog_])
    MJ_MCPToolExecutionLogs_MCPServerToolIDArray: MJMCPToolExecutionLog_[]; // Link to MJ_MCPToolExecutionLogs
    
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Tools
//****************************************************************************
@InputType()
export class CreateMJMCPServerToolInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    ToolTitle: string | null;

    @Field({ nullable: true })
    ToolDescription: string | null;

    @Field({ nullable: true })
    InputSchema?: string;

    @Field({ nullable: true })
    OutputSchema: string | null;

    @Field({ nullable: true })
    Annotations: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DiscoveredAt?: Date;

    @Field({ nullable: true })
    LastSeenAt?: Date;

    @Field({ nullable: true })
    GeneratedActionID: string | null;

    @Field({ nullable: true })
    GeneratedActionCategoryID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Server Tools
//****************************************************************************
@InputType()
export class UpdateMJMCPServerToolInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    ToolTitle?: string | null;

    @Field({ nullable: true })
    ToolDescription?: string | null;

    @Field({ nullable: true })
    InputSchema?: string;

    @Field({ nullable: true })
    OutputSchema?: string | null;

    @Field({ nullable: true })
    Annotations?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    DiscoveredAt?: Date;

    @Field({ nullable: true })
    LastSeenAt?: Date;

    @Field({ nullable: true })
    GeneratedActionID?: string | null;

    @Field({ nullable: true })
    GeneratedActionCategoryID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Server Tools
//****************************************************************************
@ObjectType()
export class RunMJMCPServerToolViewResult {
    @Field(() => [MJMCPServerTool_])
    Results: MJMCPServerTool_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServerTool_)
export class MJMCPServerToolResolver extends ResolverBase {
    @Query(() => RunMJMCPServerToolViewResult)
    async RunMJMCPServerToolViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerToolViewResult)
    async RunMJMCPServerToolViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerToolViewResult)
    async RunMJMCPServerToolDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Server Tools';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServerTool_, { nullable: true })
    async MJMCPServerTool(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServerTool_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerTools] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Server Tools', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJMCPServerConnectionTool_])
    async MJ_MCPServerConnectionTools_MCPServerToolIDArray(@Root() mjmcpservertool_: MJMCPServerTool_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionTools] WHERE [MCPServerToolID]='${mjmcpservertool_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPToolExecutionLog_])
    async MJ_MCPToolExecutionLogs_MCPServerToolIDArray(@Root() mjmcpservertool_: MJMCPServerTool_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPToolExecutionLogs] WHERE [MCPServerToolID]='${mjmcpservertool_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJMCPServerTool_)
    async CreateMJMCPServerTool(
        @Arg('input', () => CreateMJMCPServerToolInput) input: CreateMJMCPServerToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Server Tools', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServerTool_)
    async UpdateMJMCPServerTool(
        @Arg('input', () => UpdateMJMCPServerToolInput) input: UpdateMJMCPServerToolInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Server Tools', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServerTool_)
    async DeleteMJMCPServerTool(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Server Tools', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Servers
//****************************************************************************
@ObjectType()
export class MJMCPServer_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique display name for the MCP server`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Server endpoint URL for HTTP/SSE/WebSocket transports`}) 
    @MaxLength(2000)
    ServerURL?: string;
        
    @Field({nullable: true, description: `Executable path for Stdio transport`}) 
    @MaxLength(1000)
    Command?: string;
        
    @Field({nullable: true, description: `JSON array of command arguments for Stdio transport`}) 
    CommandArgs?: string;
        
    @Field({description: `Transport type: StreamableHTTP, SSE, Stdio, or WebSocket`}) 
    @MaxLength(100)
    TransportType: string;
        
    @Field({description: `Default auth type: None, Bearer, APIKey, OAuth2, Basic, or Custom`}) 
    @MaxLength(100)
    DefaultAuthType: string;
        
    @Field({nullable: true, description: `Expected credential type for this server`}) 
    @MaxLength(16)
    CredentialTypeID?: string;
        
    @Field({description: `Server status: Active, Inactive, or Deprecated`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    LastSyncAt?: Date;
        
    @Field(() => Int, {nullable: true}) 
    RateLimitPerMinute?: number;
        
    @Field(() => Int, {nullable: true}) 
    RateLimitPerHour?: number;
        
    @Field(() => Int, {nullable: true}) 
    ConnectionTimeoutMs?: number;
        
    @Field(() => Int, {nullable: true}) 
    RequestTimeoutMs?: number;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    DocumentationURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    IconClass?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Authorization server issuer URL for OAuth 2.1 authentication (e.g., https://auth.example.com).`}) 
    @MaxLength(2000)
    OAuthIssuerURL?: string;
        
    @Field({nullable: true, description: `Space-delimited OAuth scopes to request (e.g., "read write admin").`}) 
    @MaxLength(1000)
    OAuthScopes?: string;
        
    @Field(() => Int, {nullable: true, description: `Cache TTL for authorization server metadata in minutes. Default 1440 (24 hours).`}) 
    OAuthMetadataCacheTTLMinutes?: number;
        
    @Field({nullable: true, description: `Pre-configured OAuth client ID (when DCR is not supported).`}) 
    @MaxLength(510)
    OAuthClientID?: string;
        
    @Field({nullable: true, description: `Pre-configured OAuth client secret (encrypted at rest, when DCR is not supported).`}) 
    OAuthClientSecretEncrypted?: string;
        
    @Field(() => Boolean, {description: `Whether to require PKCE for OAuth flows. Always true for OAuth 2.1 compliance.`}) 
    OAuthRequirePKCE: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CredentialType?: string;
        
    @Field(() => [MJOAuthClientRegistration_])
    MJ_OAuthClientRegistrations_MCPServerIDArray: MJOAuthClientRegistration_[]; // Link to MJ_OAuthClientRegistrations
    
    @Field(() => [MJMCPServerTool_])
    MJ_MCPServerTools_MCPServerIDArray: MJMCPServerTool_[]; // Link to MJ_MCPServerTools
    
    @Field(() => [MJMCPServerConnection_])
    MJ_MCPServerConnections_MCPServerIDArray: MJMCPServerConnection_[]; // Link to MJ_MCPServerConnections
    
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Servers
//****************************************************************************
@InputType()
export class CreateMJMCPServerInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerURL: string | null;

    @Field({ nullable: true })
    Command: string | null;

    @Field({ nullable: true })
    CommandArgs: string | null;

    @Field({ nullable: true })
    TransportType?: string;

    @Field({ nullable: true })
    DefaultAuthType?: string;

    @Field({ nullable: true })
    CredentialTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LastSyncAt: Date | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerMinute: number | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerHour: number | null;

    @Field(() => Int, { nullable: true })
    ConnectionTimeoutMs?: number | null;

    @Field(() => Int, { nullable: true })
    RequestTimeoutMs?: number | null;

    @Field({ nullable: true })
    DocumentationURL: string | null;

    @Field({ nullable: true })
    IconClass: string | null;

    @Field({ nullable: true })
    OAuthIssuerURL: string | null;

    @Field({ nullable: true })
    OAuthScopes: string | null;

    @Field(() => Int, { nullable: true })
    OAuthMetadataCacheTTLMinutes?: number | null;

    @Field({ nullable: true })
    OAuthClientID: string | null;

    @Field({ nullable: true })
    OAuthClientSecretEncrypted: string | null;

    @Field(() => Boolean, { nullable: true })
    OAuthRequirePKCE?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Servers
//****************************************************************************
@InputType()
export class UpdateMJMCPServerInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerURL?: string | null;

    @Field({ nullable: true })
    Command?: string | null;

    @Field({ nullable: true })
    CommandArgs?: string | null;

    @Field({ nullable: true })
    TransportType?: string;

    @Field({ nullable: true })
    DefaultAuthType?: string;

    @Field({ nullable: true })
    CredentialTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    LastSyncAt?: Date | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerMinute?: number | null;

    @Field(() => Int, { nullable: true })
    RateLimitPerHour?: number | null;

    @Field(() => Int, { nullable: true })
    ConnectionTimeoutMs?: number | null;

    @Field(() => Int, { nullable: true })
    RequestTimeoutMs?: number | null;

    @Field({ nullable: true })
    DocumentationURL?: string | null;

    @Field({ nullable: true })
    IconClass?: string | null;

    @Field({ nullable: true })
    OAuthIssuerURL?: string | null;

    @Field({ nullable: true })
    OAuthScopes?: string | null;

    @Field(() => Int, { nullable: true })
    OAuthMetadataCacheTTLMinutes?: number | null;

    @Field({ nullable: true })
    OAuthClientID?: string | null;

    @Field({ nullable: true })
    OAuthClientSecretEncrypted?: string | null;

    @Field(() => Boolean, { nullable: true })
    OAuthRequirePKCE?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Servers
//****************************************************************************
@ObjectType()
export class RunMJMCPServerViewResult {
    @Field(() => [MJMCPServer_])
    Results: MJMCPServer_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPServer_)
export class MJMCPServerResolver extends ResolverBase {
    @Query(() => RunMJMCPServerViewResult)
    async RunMJMCPServerViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerViewResult)
    async RunMJMCPServerViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPServerViewResult)
    async RunMJMCPServerDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Servers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPServer_, { nullable: true })
    async MJMCPServer(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPServer_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Servers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServers] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Servers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Servers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJOAuthClientRegistration_])
    async MJ_OAuthClientRegistrations_MCPServerIDArray(@Root() mjmcpserver_: MJMCPServer_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Client Registrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthClientRegistrations] WHERE [MCPServerID]='${mjmcpserver_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Client Registrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Client Registrations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerTool_])
    async MJ_MCPServerTools_MCPServerIDArray(@Root() mjmcpserver_: MJMCPServer_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Tools', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerTools] WHERE [MCPServerID]='${mjmcpserver_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Tools', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Tools', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnection_])
    async MJ_MCPServerConnections_MCPServerIDArray(@Root() mjmcpserver_: MJMCPServer_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnections] WHERE [MCPServerID]='${mjmcpserver_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJMCPServer_)
    async CreateMJMCPServer(
        @Arg('input', () => CreateMJMCPServerInput) input: CreateMJMCPServerInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Servers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPServer_)
    async UpdateMJMCPServer(
        @Arg('input', () => UpdateMJMCPServerInput) input: UpdateMJMCPServerInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Servers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPServer_)
    async DeleteMJMCPServer(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Servers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: MCP Tool Execution Logs
//****************************************************************************
@ObjectType()
export class MJMCPToolExecutionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerConnectionID: string;
        
    @Field({nullable: true, description: `FK to MCP Server Tool (null if tool not cached)`}) 
    @MaxLength(16)
    MCPServerToolID?: string;
        
    @Field({description: `Tool name (stored directly for resilience)`}) 
    @MaxLength(510)
    ToolName: string;
        
    @Field({description: `FK to User who initiated the call`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Execution duration in milliseconds`}) 
    DurationMs?: number;
        
    @Field(() => Boolean) 
    Success: boolean;
        
    @Field({nullable: true}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON of input parameters (if logging enabled)`}) 
    InputParameters?: string;
        
    @Field({nullable: true, description: `JSON of output content (if logging enabled)`}) 
    OutputContent?: string;
        
    @Field(() => Boolean, {description: `Whether output was truncated due to size`}) 
    OutputTruncated: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    MCPServerTool?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: MCP Tool Execution Logs
//****************************************************************************
@InputType()
export class CreateMJMCPToolExecutionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID: string | null;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    DurationMs: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    InputParameters: string | null;

    @Field({ nullable: true })
    OutputContent: string | null;

    @Field(() => Boolean, { nullable: true })
    OutputTruncated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: MCP Tool Execution Logs
//****************************************************************************
@InputType()
export class UpdateMJMCPToolExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerToolID?: string | null;

    @Field({ nullable: true })
    ToolName?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    DurationMs?: number | null;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    InputParameters?: string | null;

    @Field({ nullable: true })
    OutputContent?: string | null;

    @Field(() => Boolean, { nullable: true })
    OutputTruncated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: MCP Tool Execution Logs
//****************************************************************************
@ObjectType()
export class RunMJMCPToolExecutionLogViewResult {
    @Field(() => [MJMCPToolExecutionLog_])
    Results: MJMCPToolExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJMCPToolExecutionLog_)
export class MJMCPToolExecutionLogResolver extends ResolverBase {
    @Query(() => RunMJMCPToolExecutionLogViewResult)
    async RunMJMCPToolExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPToolExecutionLogViewResult)
    async RunMJMCPToolExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJMCPToolExecutionLogViewResult)
    async RunMJMCPToolExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: MCP Tool Execution Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJMCPToolExecutionLog_, { nullable: true })
    async MJMCPToolExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJMCPToolExecutionLog_ | null> {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPToolExecutionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJMCPToolExecutionLog_)
    async CreateMJMCPToolExecutionLog(
        @Arg('input', () => CreateMJMCPToolExecutionLogInput) input: CreateMJMCPToolExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: MCP Tool Execution Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJMCPToolExecutionLog_)
    async UpdateMJMCPToolExecutionLog(
        @Arg('input', () => UpdateMJMCPToolExecutionLogInput) input: UpdateMJMCPToolExecutionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: MCP Tool Execution Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJMCPToolExecutionLog_)
    async DeleteMJMCPToolExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: MCP Tool Execution Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@ObjectType({ description: `Caches OAuth 2.0 Authorization Server Metadata (RFC 8414) to reduce discovery requests.` })
export class MJOAuthAuthServerMetadataCache_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Authorization server issuer identifier URL.`}) 
    @MaxLength(2000)
    IssuerURL: string;
        
    @Field({description: `URL of the authorization endpoint.`}) 
    @MaxLength(2000)
    AuthorizationEndpoint: string;
        
    @Field({description: `URL of the token endpoint.`}) 
    @MaxLength(2000)
    TokenEndpoint: string;
        
    @Field({nullable: true, description: `URL of the dynamic client registration endpoint (RFC 7591).`}) 
    @MaxLength(2000)
    RegistrationEndpoint?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    RevocationEndpoint?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    JwksURI?: string;
        
    @Field({nullable: true}) 
    ScopesSupported?: string;
        
    @Field() 
    ResponseTypesSupported: string;
        
    @Field({nullable: true}) 
    GrantTypesSupported?: string;
        
    @Field({nullable: true}) 
    TokenEndpointAuthMethods?: string;
        
    @Field({nullable: true}) 
    CodeChallengeMethodsSupported?: string;
        
    @Field({description: `Full authorization server metadata JSON for debugging and extensibility.`}) 
    MetadataJSON: string;
        
    @Field() 
    @MaxLength(10)
    CachedAt: Date;
        
    @Field() 
    @MaxLength(10)
    ExpiresAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@InputType()
export class CreateMJOAuthAuthServerMetadataCacheInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    AuthorizationEndpoint?: string;

    @Field({ nullable: true })
    TokenEndpoint?: string;

    @Field({ nullable: true })
    RegistrationEndpoint: string | null;

    @Field({ nullable: true })
    RevocationEndpoint: string | null;

    @Field({ nullable: true })
    JwksURI: string | null;

    @Field({ nullable: true })
    ScopesSupported: string | null;

    @Field({ nullable: true })
    ResponseTypesSupported?: string;

    @Field({ nullable: true })
    GrantTypesSupported: string | null;

    @Field({ nullable: true })
    TokenEndpointAuthMethods: string | null;

    @Field({ nullable: true })
    CodeChallengeMethodsSupported: string | null;

    @Field({ nullable: true })
    MetadataJSON?: string;

    @Field({ nullable: true })
    CachedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@InputType()
export class UpdateMJOAuthAuthServerMetadataCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    AuthorizationEndpoint?: string;

    @Field({ nullable: true })
    TokenEndpoint?: string;

    @Field({ nullable: true })
    RegistrationEndpoint?: string | null;

    @Field({ nullable: true })
    RevocationEndpoint?: string | null;

    @Field({ nullable: true })
    JwksURI?: string | null;

    @Field({ nullable: true })
    ScopesSupported?: string | null;

    @Field({ nullable: true })
    ResponseTypesSupported?: string;

    @Field({ nullable: true })
    GrantTypesSupported?: string | null;

    @Field({ nullable: true })
    TokenEndpointAuthMethods?: string | null;

    @Field({ nullable: true })
    CodeChallengeMethodsSupported?: string | null;

    @Field({ nullable: true })
    MetadataJSON?: string;

    @Field({ nullable: true })
    CachedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Auth Server Metadata Caches
//****************************************************************************
@ObjectType()
export class RunMJOAuthAuthServerMetadataCacheViewResult {
    @Field(() => [MJOAuthAuthServerMetadataCache_])
    Results: MJOAuthAuthServerMetadataCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthAuthServerMetadataCache_)
export class MJOAuthAuthServerMetadataCacheResolver extends ResolverBase {
    @Query(() => RunMJOAuthAuthServerMetadataCacheViewResult)
    async RunMJOAuthAuthServerMetadataCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthServerMetadataCacheViewResult)
    async RunMJOAuthAuthServerMetadataCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthServerMetadataCacheViewResult)
    async RunMJOAuthAuthServerMetadataCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Auth Server Metadata Caches';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthAuthServerMetadataCache_, { nullable: true })
    async MJOAuthAuthServerMetadataCache(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthAuthServerMetadataCache_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Auth Server Metadata Caches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthAuthServerMetadataCaches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Auth Server Metadata Caches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Auth Server Metadata Caches', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthAuthServerMetadataCache_)
    async CreateMJOAuthAuthServerMetadataCache(
        @Arg('input', () => CreateMJOAuthAuthServerMetadataCacheInput) input: CreateMJOAuthAuthServerMetadataCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Auth Server Metadata Caches', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthAuthServerMetadataCache_)
    async UpdateMJOAuthAuthServerMetadataCache(
        @Arg('input', () => UpdateMJOAuthAuthServerMetadataCacheInput) input: UpdateMJOAuthAuthServerMetadataCacheInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Auth Server Metadata Caches', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthAuthServerMetadataCache_)
    async DeleteMJOAuthAuthServerMetadataCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Auth Server Metadata Caches', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Authorization States
//****************************************************************************
@ObjectType({ description: `Tracks in-progress OAuth authorization flows with PKCE data for security.` })
export class MJOAuthAuthorizationState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerConnectionID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Cryptographic state parameter for CSRF protection.`}) 
    @MaxLength(256)
    StateParameter: string;
        
    @Field({description: `PKCE code verifier for token exchange (stored securely, never sent to auth server).`}) 
    @MaxLength(256)
    CodeVerifier: string;
        
    @Field({description: `PKCE code challenge sent to authorization server.`}) 
    @MaxLength(256)
    CodeChallenge: string;
        
    @Field() 
    @MaxLength(2000)
    RedirectURI: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    RequestedScopes?: string;
        
    @Field({description: `Flow status: Pending, Completed, Failed, or Expired.`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    AuthorizationURL: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ErrorCode?: string;
        
    @Field({nullable: true}) 
    ErrorDescription?: string;
        
    @Field() 
    @MaxLength(10)
    InitiatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    ExpiresAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field({nullable: true, description: `URL to redirect the user to after OAuth completion. If set, the OAuth callback will redirect here instead of showing a static HTML page.`}) 
    @MaxLength(2000)
    FrontendReturnURL?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServerConnection: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Authorization States
//****************************************************************************
@InputType()
export class CreateMJOAuthAuthorizationStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StateParameter?: string;

    @Field({ nullable: true })
    CodeVerifier?: string;

    @Field({ nullable: true })
    CodeChallenge?: string;

    @Field({ nullable: true })
    RedirectURI?: string;

    @Field({ nullable: true })
    RequestedScopes: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AuthorizationURL?: string;

    @Field({ nullable: true })
    ErrorCode: string | null;

    @Field({ nullable: true })
    ErrorDescription: string | null;

    @Field({ nullable: true })
    InitiatedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field({ nullable: true })
    FrontendReturnURL: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Authorization States
//****************************************************************************
@InputType()
export class UpdateMJOAuthAuthorizationStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    StateParameter?: string;

    @Field({ nullable: true })
    CodeVerifier?: string;

    @Field({ nullable: true })
    CodeChallenge?: string;

    @Field({ nullable: true })
    RedirectURI?: string;

    @Field({ nullable: true })
    RequestedScopes?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AuthorizationURL?: string;

    @Field({ nullable: true })
    ErrorCode?: string | null;

    @Field({ nullable: true })
    ErrorDescription?: string | null;

    @Field({ nullable: true })
    InitiatedAt?: Date;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field({ nullable: true })
    FrontendReturnURL?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Authorization States
//****************************************************************************
@ObjectType()
export class RunMJOAuthAuthorizationStateViewResult {
    @Field(() => [MJOAuthAuthorizationState_])
    Results: MJOAuthAuthorizationState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthAuthorizationState_)
export class MJOAuthAuthorizationStateResolver extends ResolverBase {
    @Query(() => RunMJOAuthAuthorizationStateViewResult)
    async RunMJOAuthAuthorizationStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthorizationStateViewResult)
    async RunMJOAuthAuthorizationStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthAuthorizationStateViewResult)
    async RunMJOAuthAuthorizationStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Authorization States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthAuthorizationState_, { nullable: true })
    async MJOAuthAuthorizationState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthAuthorizationState_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Authorization States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthAuthorizationStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Authorization States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Authorization States', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthAuthorizationState_)
    async CreateMJOAuthAuthorizationState(
        @Arg('input', () => CreateMJOAuthAuthorizationStateInput) input: CreateMJOAuthAuthorizationStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Authorization States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthAuthorizationState_)
    async UpdateMJOAuthAuthorizationState(
        @Arg('input', () => UpdateMJOAuthAuthorizationStateInput) input: UpdateMJOAuthAuthorizationStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Authorization States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthAuthorizationState_)
    async DeleteMJOAuthAuthorizationState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Authorization States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Client Registrations
//****************************************************************************
@ObjectType({ description: `Stores OAuth Dynamic Client Registration (DCR) results per RFC 7591.` })
export class MJOAuthClientRegistration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The MCP Server Connection this registration belongs to.`}) 
    @MaxLength(16)
    MCPServerConnectionID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerID: string;
        
    @Field() 
    @MaxLength(2000)
    IssuerURL: string;
        
    @Field({description: `OAuth client ID assigned by the authorization server.`}) 
    @MaxLength(1000)
    ClientID: string;
        
    @Field({nullable: true, description: `OAuth client secret (encrypted at rest) for confidential clients.`}) 
    ClientSecretEncrypted?: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    ClientIDIssuedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    ClientSecretExpiresAt?: Date;
        
    @Field({nullable: true}) 
    RegistrationAccessToken?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    RegistrationClientURI?: string;
        
    @Field() 
    RedirectURIs: string;
        
    @Field() 
    GrantTypes: string;
        
    @Field() 
    ResponseTypes: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    Scope?: string;
        
    @Field({description: `Registration status: Active, Expired, or Revoked.`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `Full DCR response JSON for debugging and extensibility.`}) 
    RegistrationResponse: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServerConnection: string;
        
    @Field() 
    @MaxLength(510)
    MCPServer: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Client Registrations
//****************************************************************************
@InputType()
export class CreateMJOAuthClientRegistrationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    ClientID?: string;

    @Field({ nullable: true })
    ClientSecretEncrypted: string | null;

    @Field({ nullable: true })
    ClientIDIssuedAt: Date | null;

    @Field({ nullable: true })
    ClientSecretExpiresAt: Date | null;

    @Field({ nullable: true })
    RegistrationAccessToken: string | null;

    @Field({ nullable: true })
    RegistrationClientURI: string | null;

    @Field({ nullable: true })
    RedirectURIs?: string;

    @Field({ nullable: true })
    GrantTypes?: string;

    @Field({ nullable: true })
    ResponseTypes?: string;

    @Field({ nullable: true })
    Scope: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    RegistrationResponse?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Client Registrations
//****************************************************************************
@InputType()
export class UpdateMJOAuthClientRegistrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    MCPServerID?: string;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    ClientID?: string;

    @Field({ nullable: true })
    ClientSecretEncrypted?: string | null;

    @Field({ nullable: true })
    ClientIDIssuedAt?: Date | null;

    @Field({ nullable: true })
    ClientSecretExpiresAt?: Date | null;

    @Field({ nullable: true })
    RegistrationAccessToken?: string | null;

    @Field({ nullable: true })
    RegistrationClientURI?: string | null;

    @Field({ nullable: true })
    RedirectURIs?: string;

    @Field({ nullable: true })
    GrantTypes?: string;

    @Field({ nullable: true })
    ResponseTypes?: string;

    @Field({ nullable: true })
    Scope?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    RegistrationResponse?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Client Registrations
//****************************************************************************
@ObjectType()
export class RunMJOAuthClientRegistrationViewResult {
    @Field(() => [MJOAuthClientRegistration_])
    Results: MJOAuthClientRegistration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthClientRegistration_)
export class MJOAuthClientRegistrationResolver extends ResolverBase {
    @Query(() => RunMJOAuthClientRegistrationViewResult)
    async RunMJOAuthClientRegistrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthClientRegistrationViewResult)
    async RunMJOAuthClientRegistrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthClientRegistrationViewResult)
    async RunMJOAuthClientRegistrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Client Registrations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthClientRegistration_, { nullable: true })
    async MJOAuthClientRegistration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthClientRegistration_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Client Registrations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthClientRegistrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Client Registrations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Client Registrations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthClientRegistration_)
    async CreateMJOAuthClientRegistration(
        @Arg('input', () => CreateMJOAuthClientRegistrationInput) input: CreateMJOAuthClientRegistrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Client Registrations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthClientRegistration_)
    async UpdateMJOAuthClientRegistration(
        @Arg('input', () => UpdateMJOAuthClientRegistrationInput) input: UpdateMJOAuthClientRegistrationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Client Registrations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthClientRegistration_)
    async DeleteMJOAuthClientRegistration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Client Registrations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: O Auth Tokens
//****************************************************************************
@ObjectType({ description: `Stores OAuth token metadata for MCP server connections. Actual tokens are stored via CredentialEngine for consistent encryption and audit logging.` })
export class MJOAuthToken_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    MCPServerConnectionID: string;
        
    @Field({nullable: true, description: `Foreign key to Credential table where the OAuth tokens (access and refresh) are stored securely via CredentialEngine.`}) 
    @MaxLength(16)
    CredentialID?: string;
        
    @Field() 
    @MaxLength(100)
    TokenType: string;
        
    @Field({description: `When the access token expires.`}) 
    @MaxLength(10)
    ExpiresAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    Scope?: string;
        
    @Field() 
    @MaxLength(2000)
    IssuerURL: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    LastRefreshAt?: Date;
        
    @Field(() => Int, {description: `Number of times the token has been refreshed.`}) 
    RefreshCount: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    MCPServerConnection: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    Credential?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: O Auth Tokens
//****************************************************************************
@InputType()
export class CreateMJOAuthTokenInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    CredentialID: string | null;

    @Field({ nullable: true })
    TokenType?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    Scope: string | null;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    LastRefreshAt: Date | null;

    @Field(() => Int, { nullable: true })
    RefreshCount?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: O Auth Tokens
//****************************************************************************
@InputType()
export class UpdateMJOAuthTokenInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    MCPServerConnectionID?: string;

    @Field({ nullable: true })
    CredentialID?: string | null;

    @Field({ nullable: true })
    TokenType?: string;

    @Field({ nullable: true })
    ExpiresAt?: Date;

    @Field({ nullable: true })
    Scope?: string | null;

    @Field({ nullable: true })
    IssuerURL?: string;

    @Field({ nullable: true })
    LastRefreshAt?: Date | null;

    @Field(() => Int, { nullable: true })
    RefreshCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: O Auth Tokens
//****************************************************************************
@ObjectType()
export class RunMJOAuthTokenViewResult {
    @Field(() => [MJOAuthToken_])
    Results: MJOAuthToken_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOAuthToken_)
export class MJOAuthTokenResolver extends ResolverBase {
    @Query(() => RunMJOAuthTokenViewResult)
    async RunMJOAuthTokenViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthTokenViewResult)
    async RunMJOAuthTokenViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOAuthTokenViewResult)
    async RunMJOAuthTokenDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: O Auth Tokens';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOAuthToken_, { nullable: true })
    async MJOAuthToken(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOAuthToken_ | null> {
        this.CheckUserReadPermissions('MJ: O Auth Tokens', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthTokens] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Tokens', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: O Auth Tokens', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJOAuthToken_)
    async CreateMJOAuthToken(
        @Arg('input', () => CreateMJOAuthTokenInput) input: CreateMJOAuthTokenInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: O Auth Tokens', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOAuthToken_)
    async UpdateMJOAuthToken(
        @Arg('input', () => UpdateMJOAuthTokenInput) input: UpdateMJOAuthTokenInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: O Auth Tokens', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOAuthToken_)
    async DeleteMJOAuthToken(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: O Auth Tokens', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Projects
//****************************************************************************
@ObjectType({ description: `Container for grouping related conversations around a common topic, client, or initiative. Supports nesting for sub-projects.` })
export class MJProject_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Display name for the project`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the project goals and scope`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Hex color code for project badges in UI (#RRGGBB format)`}) 
    @MaxLength(14)
    Color?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for UI display`}) 
    @MaxLength(100)
    Icon?: string;
        
    @Field(() => Boolean, {description: `Indicates if this project is archived and should be hidden from active lists`}) 
    IsArchived: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJProject_])
    MJ_Projects_ParentIDArray: MJProject_[]; // Link to MJ_Projects
    
    @Field(() => [MJConversation_])
    Conversations_ProjectIDArray: MJConversation_[]; // Link to Conversations
    
    @Field(() => [MJTask_])
    MJ_Tasks_ProjectIDArray: MJTask_[]; // Link to MJ_Tasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Projects
//****************************************************************************
@InputType()
export class CreateMJProjectInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Projects
//****************************************************************************
@InputType()
export class UpdateMJProjectInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Projects
//****************************************************************************
@ObjectType()
export class RunMJProjectViewResult {
    @Field(() => [MJProject_])
    Results: MJProject_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJProject_)
export class MJProjectResolver extends ResolverBase {
    @Query(() => RunMJProjectViewResult)
    async RunMJProjectViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJProjectViewResult)
    async RunMJProjectViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJProjectViewResult)
    async RunMJProjectDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Projects';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJProject_, { nullable: true })
    async MJProject(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJProject_ | null> {
        this.CheckUserReadPermissions('MJ: Projects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwProjects] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Projects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Projects', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJProject_])
    async MJ_Projects_ParentIDArray(@Root() mjproject_: MJProject_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Projects', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwProjects] WHERE [ParentID]='${mjproject_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Projects', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Projects', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_ProjectIDArray(@Root() mjproject_: MJProject_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [ProjectID]='${mjproject_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_ProjectIDArray(@Root() mjproject_: MJProject_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [ProjectID]='${mjproject_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJProject_)
    async CreateMJProject(
        @Arg('input', () => CreateMJProjectInput) input: CreateMJProjectInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Projects', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJProject_)
    async UpdateMJProject(
        @Arg('input', () => UpdateMJProjectInput) input: UpdateMJProjectInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Projects', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJProject_)
    async DeleteMJProject(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Projects', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Public Links
//****************************************************************************
@ObjectType({ description: `Shareable links for external access to artifacts and other resources. Supports password protection and expiration.` })
export class MJPublicLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Type of resource being shared (Artifact, Conversation, Collection)`}) 
    @MaxLength(100)
    ResourceType: string;
        
    @Field() 
    @MaxLength(16)
    ResourceID: string;
        
    @Field({description: `Unique token for accessing the shared resource via URL`}) 
    @MaxLength(510)
    Token: string;
        
    @Field({nullable: true, description: `SHA256 hash of optional password for additional security`}) 
    @MaxLength(510)
    PasswordHash?: string;
        
    @Field({nullable: true, description: `Optional expiration date/time for this public link`}) 
    @MaxLength(10)
    ExpiresAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of times this link can be viewed`}) 
    MaxViews?: number;
        
    @Field(() => Int, {description: `Current count of how many times this link has been viewed`}) 
    CurrentViews: number;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Boolean, {description: `Indicates if this link is currently active and accessible`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Public Links
//****************************************************************************
@InputType()
export class CreateMJPublicLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ResourceType?: string;

    @Field({ nullable: true })
    ResourceID?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    PasswordHash: string | null;

    @Field({ nullable: true })
    ExpiresAt: Date | null;

    @Field(() => Int, { nullable: true })
    MaxViews: number | null;

    @Field(() => Int, { nullable: true })
    CurrentViews?: number;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Public Links
//****************************************************************************
@InputType()
export class UpdateMJPublicLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceType?: string;

    @Field({ nullable: true })
    ResourceID?: string;

    @Field({ nullable: true })
    Token?: string;

    @Field({ nullable: true })
    PasswordHash?: string | null;

    @Field({ nullable: true })
    ExpiresAt?: Date | null;

    @Field(() => Int, { nullable: true })
    MaxViews?: number | null;

    @Field(() => Int, { nullable: true })
    CurrentViews?: number;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Public Links
//****************************************************************************
@ObjectType()
export class RunMJPublicLinkViewResult {
    @Field(() => [MJPublicLink_])
    Results: MJPublicLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJPublicLink_)
export class MJPublicLinkResolver extends ResolverBase {
    @Query(() => RunMJPublicLinkViewResult)
    async RunMJPublicLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJPublicLinkViewResult)
    async RunMJPublicLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJPublicLinkViewResult)
    async RunMJPublicLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Public Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJPublicLink_, { nullable: true })
    async MJPublicLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJPublicLink_ | null> {
        this.CheckUserReadPermissions('MJ: Public Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwPublicLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Public Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Public Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJPublicLink_)
    async CreateMJPublicLink(
        @Arg('input', () => CreateMJPublicLinkInput) input: CreateMJPublicLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Public Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJPublicLink_)
    async UpdateMJPublicLink(
        @Arg('input', () => UpdateMJPublicLinkInput) input: UpdateMJPublicLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Public Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJPublicLink_)
    async DeleteMJPublicLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Public Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Query Parameters
//****************************************************************************
@ObjectType({ description: `Stores parameter definitions for parameterized queries that use Nunjucks templates. Each parameter represents a dynamic value that can be passed when executing the query. Parameters are automatically extracted from the query template by the QueryEntityServer using LLM analysis, or can be manually defined. The combination of parameter metadata and validation filters creates a self-documenting, type-safe query execution system.` })
export class MJQueryParameter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field({description: `The name of the parameter as it appears in the Nunjucks template. This must match exactly with the parameter reference in the SQL template. For example, if the template contains {{ userEmail | required | email }}, the Name would be "userEmail". Parameter names should follow JavaScript identifier rules: start with a letter, and contain only letters, numbers, and underscores.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `The data type of the parameter used for validation and type conversion. Valid values are: "string" for text values, "number" for integers or decimals, "date" for date/datetime values (ISO 8601 format expected), "boolean" for true/false values, and "array" for multiple values (typically used with IN clauses). The type determines which validation filters can be applied and how the parameter is processed.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean, {nullable: true, description: `Indicates whether this parameter must be provided when executing the query. When true, the query execution will fail if the parameter is not supplied and no DefaultValue is set. This is automatically determined by the presence of the "required" filter in the template, but can be manually overridden. Required parameters ensure data integrity and prevent unintended query behavior.`}) 
    IsRequired?: boolean;
        
    @Field({nullable: true, description: `The default value to use when the parameter is not provided during query execution. This value must be compatible with the parameter Type. For arrays, use JSON format like ["value1","value2"]. Default values allow queries to have sensible fallbacks while still accepting custom inputs. If a parameter is required (IsRequired=true), the default value is ignored.`}) 
    DefaultValue?: string;
        
    @Field({nullable: true, description: `Human-readable description explaining the purpose and usage of this parameter. This is typically generated by LLM analysis of the query context but can be manually edited. Good descriptions include: what the parameter filters or controls, valid value ranges or formats, business meaning, and any special considerations. This text is shown in UI to help users understand what value to provide.`}) 
    Description?: string;
        
    @Field({nullable: true, description: `A concrete example value demonstrating the proper format for this parameter. Generated by LLM based on the query context and validation filters. For example: "john@example.com" for an email parameter, "2024-01-15" for a date, or "["active","pending"]" for a status array. Sample values help users understand the expected format and can be used in API documentation.`}) 
    SampleValue?: string;
        
    @Field({nullable: true, description: `JSON array of Nunjucks filter definitions that validate and transform the parameter value. Each filter is an object with "name" and optional "args" properties. Filters are applied in order and can include: validation (required, email, min, max), transformation (trim, upper, lower), SQL safety (sqlsafe, sqljoin), and type conversion (number, date). Example: [{"name":"required"},{"name":"email"},{"name":"sqlsafe"}]. The filter chain ensures type safety and prevents SQL injection.`}) 
    ValidationFilters?: string;
        
    @Field({description: `Indicates how this parameter was identified and added to the system. "AI" means it was automatically detected by LLM analysis of the query template, including extraction of parameter name, type inference from filters, and generation of description. "Manual" means it was explicitly defined by a user. This helps track which parameters might need human review and provides transparency about the source of metadata.`}) 
    @MaxLength(100)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was about this parameter detection. Only populated when DetectionMethod="AI". Higher scores indicate the LLM was more confident about the parameter name, type, and usage. Scores above 0.80 are generally reliable, 0.60-0.80 may benefit from human review, and below 0.60 should be manually verified. This helps prioritize which auto-detected parameters need human attention.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Query Parameters
//****************************************************************************
@InputType()
export class CreateMJQueryParameterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SampleValue: string | null;

    @Field({ nullable: true })
    ValidationFilters: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Query Parameters
//****************************************************************************
@InputType()
export class UpdateMJQueryParameterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SampleValue?: string | null;

    @Field({ nullable: true })
    ValidationFilters?: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Query Parameters
//****************************************************************************
@ObjectType()
export class RunMJQueryParameterViewResult {
    @Field(() => [MJQueryParameter_])
    Results: MJQueryParameter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryParameter_)
export class MJQueryParameterResolver extends ResolverBase {
    @Query(() => RunMJQueryParameterViewResult)
    async RunMJQueryParameterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryParameterViewResult)
    async RunMJQueryParameterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryParameterViewResult)
    async RunMJQueryParameterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Query Parameters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryParameter_, { nullable: true })
    async MJQueryParameter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryParameter_ | null> {
        this.CheckUserReadPermissions('MJ: Query Parameters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryParameters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Parameters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Query Parameters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryParameter_)
    async CreateMJQueryParameter(
        @Arg('input', () => CreateMJQueryParameterInput) input: CreateMJQueryParameterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Query Parameters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryParameter_)
    async UpdateMJQueryParameter(
        @Arg('input', () => UpdateMJQueryParameterInput) input: UpdateMJQueryParameterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Query Parameters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryParameter_)
    async DeleteMJQueryParameter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Query Parameters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Record Links
//****************************************************************************
@ObjectType({ description: `Generic linking table that can connect any two records in the system, providing a flexible relationship management system.` })
export class MJRecordLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    SourceEntityID: string;
        
    @Field({description: `Primary key value(s) of the source record - scalar for simple PKs or JSON KeyValuePair array for composite PKs`}) 
    @MaxLength(1000)
    SourceRecordID: string;
        
    @Field() 
    @MaxLength(16)
    TargetEntityID: string;
        
    @Field({description: `Primary key value(s) of the target record - scalar for simple PKs or JSON KeyValuePair array for composite PKs`}) 
    @MaxLength(1000)
    TargetRecordID: string;
        
    @Field({nullable: true, description: `Application-specific relationship type describing how the records are related`}) 
    @MaxLength(100)
    LinkType?: string;
        
    @Field(() => Int, {nullable: true, description: `Display sequence for ordering linked records in UI`}) 
    Sequence?: number;
        
    @Field({nullable: true, description: `JSON field for storing additional link-specific metadata`}) 
    Metadata?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    SourceEntity: string;
        
    @Field() 
    @MaxLength(510)
    TargetEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Record Links
//****************************************************************************
@InputType()
export class CreateMJRecordLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceRecordID?: string;

    @Field({ nullable: true })
    TargetEntityID?: string;

    @Field({ nullable: true })
    TargetRecordID?: string;

    @Field({ nullable: true })
    LinkType: string | null;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;

    @Field({ nullable: true })
    Metadata: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Record Links
//****************************************************************************
@InputType()
export class UpdateMJRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceRecordID?: string;

    @Field({ nullable: true })
    TargetEntityID?: string;

    @Field({ nullable: true })
    TargetRecordID?: string;

    @Field({ nullable: true })
    LinkType?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field({ nullable: true })
    Metadata?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Record Links
//****************************************************************************
@ObjectType()
export class RunMJRecordLinkViewResult {
    @Field(() => [MJRecordLink_])
    Results: MJRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordLink_)
export class MJRecordLinkResolver extends ResolverBase {
    @Query(() => RunMJRecordLinkViewResult)
    async RunMJRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordLinkViewResult)
    async RunMJRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordLinkViewResult)
    async RunMJRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Record Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordLink_, { nullable: true })
    async MJRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordLink_ | null> {
        this.CheckUserReadPermissions('MJ: Record Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Record Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJRecordLink_)
    async CreateMJRecordLink(
        @Arg('input', () => CreateMJRecordLinkInput) input: CreateMJRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Record Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordLink_)
    async UpdateMJRecordLink(
        @Arg('input', () => UpdateMJRecordLinkInput) input: UpdateMJRecordLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Record Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordLink_)
    async DeleteMJRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Record Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report User States
//****************************************************************************
@ObjectType({ description: `Tracks individual user state within interactive reports` })
export class MJReportUserState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `JSON serialized state of user interaction with the report`}) 
    ReportState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class CreateMJReportUserStateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class UpdateMJReportUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report User States
//****************************************************************************
@ObjectType()
export class RunMJReportUserStateViewResult {
    @Field(() => [MJReportUserState_])
    Results: MJReportUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportUserState_)
export class MJReportUserStateResolver extends ResolverBase {
    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportUserStateViewResult)
    async RunMJReportUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report User States';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportUserState_, { nullable: true })
    async MJReportUserState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Report User States', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJReportUserState_)
    async CreateMJReportUserState(
        @Arg('input', () => CreateMJReportUserStateInput) input: CreateMJReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report User States', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportUserState_)
    async UpdateMJReportUserState(
        @Arg('input', () => UpdateMJReportUserStateInput) input: UpdateMJReportUserStateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report User States', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportUserState_)
    async DeleteMJReportUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report User States', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Versions
//****************************************************************************
@ObjectType({ description: `Stores iterations of report logic, structure, and layout changes` })
export class MJReportVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field(() => Int, {description: `Report version number, sequential per report starting at 1`}) 
    VersionNumber: number;
        
    @Field({description: `Name of this report version`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of this report version`}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON configuration of report structure, layout and logic`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `Indicates if the data context was updated in this version`}) 
    DataContextUpdated: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class CreateMJReportVersionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class UpdateMJReportVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Versions
//****************************************************************************
@ObjectType()
export class RunMJReportVersionViewResult {
    @Field(() => [MJReportVersion_])
    Results: MJReportVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportVersion_)
export class MJReportVersionResolver extends ResolverBase {
    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportVersionViewResult)
    async RunMJReportVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Versions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportVersion_, { nullable: true })
    async MJReportVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Report Versions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJReportVersion_)
    async CreateMJReportVersion(
        @Arg('input', () => CreateMJReportVersionInput) input: CreateMJReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Report Versions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportVersion_)
    async UpdateMJReportVersion(
        @Arg('input', () => UpdateMJReportVersionInput) input: UpdateMJReportVersionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Report Versions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportVersion_)
    async DeleteMJReportVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Versions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Job Runs
//****************************************************************************
@ObjectType({ description: `Records execution history for scheduled jobs. Provides uniform tracking across all job types. Each record represents one execution attempt of a scheduled job.` })
export class MJScheduledJobRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ScheduledJobID: string;
        
    @Field({description: `Timestamp when this job execution began. Set immediately before calling the job plugin's Execute method.`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when this job execution completed (successfully or with failure). NULL while the job is still running.`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field({description: `Current status of the job execution. Running=currently executing, Completed=finished (check Success for outcome), Failed=exception during execution, Cancelled=manually cancelled, Timeout=exceeded maximum execution time.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Boolean, {nullable: true, description: `Whether the job execution completed successfully. NULL while running, TRUE if successful, FALSE if failed. This is the job-level success from the plugin's Execute method, separate from domain-specific success tracking.`}) 
    Success?: boolean;
        
    @Field({nullable: true, description: `Error message if the job failed. NULL for successful runs. Contains exception messages or error details from the plugin's Execute method.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `Job-type specific execution details stored as JSON. May include references to domain-specific run records (e.g., {"AgentRunID": "...", "TokensUsed": 5000}), performance metrics, or other execution metadata. Schema is defined by the job type plugin.`}) 
    Details?: string;
        
    @Field({nullable: true, description: `User context under which the job was executed. Typically the OwnerUserID from the schedule, but can be overridden in job-specific configuration.`}) 
    @MaxLength(16)
    ExecutedByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when this execution was queued (for ConcurrencyMode=Queue). NULL for immediate executions. When set, indicates this run is waiting for a previous execution to complete before starting.`}) 
    @MaxLength(10)
    QueuedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(400)
    ScheduledJob: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExecutedByUser?: string;
        
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_ScheduledJobRunIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Runs
//****************************************************************************
@InputType()
export class CreateMJScheduledJobRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ScheduledJobID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Success: boolean | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    ExecutedByUserID: string | null;

    @Field({ nullable: true })
    QueuedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Runs
//****************************************************************************
@InputType()
export class UpdateMJScheduledJobRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledJobID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    Success?: boolean | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    ExecutedByUserID?: string | null;

    @Field({ nullable: true })
    QueuedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Job Runs
//****************************************************************************
@ObjectType()
export class RunMJScheduledJobRunViewResult {
    @Field(() => [MJScheduledJobRun_])
    Results: MJScheduledJobRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledJobRun_)
export class MJScheduledJobRunResolver extends ResolverBase {
    @Query(() => RunMJScheduledJobRunViewResult)
    async RunMJScheduledJobRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobRunViewResult)
    async RunMJScheduledJobRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobRunViewResult)
    async RunMJScheduledJobRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Job Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledJobRun_, { nullable: true })
    async MJScheduledJobRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledJobRun_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Job Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Job Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_ScheduledJobRunIDArray(@Root() mjscheduledjobrun_: MJScheduledJobRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [ScheduledJobRunID]='${mjscheduledjobrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledJobRun_)
    async CreateMJScheduledJobRun(
        @Arg('input', () => CreateMJScheduledJobRunInput) input: CreateMJScheduledJobRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Job Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledJobRun_)
    async UpdateMJScheduledJobRun(
        @Arg('input', () => UpdateMJScheduledJobRunInput) input: UpdateMJScheduledJobRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Job Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledJobRun_)
    async DeleteMJScheduledJobRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Job Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Job Types
//****************************************************************************
@ObjectType({ description: `Defines types of schedulable jobs and their plugin implementations. Each job type represents a different kind of work that can be scheduled (e.g., Agents, Actions, Reports).` })
export class MJScheduledJobType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name identifying this job type (e.g., Agent, Action, Report).`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Human-readable description of what this job type does and when it should be used.`}) 
    Description?: string;
        
    @Field({description: `TypeScript class name that implements BaseScheduledJob for this job type. Used by ClassFactory to instantiate the correct plugin at runtime.`}) 
    @MaxLength(510)
    DriverClass: string;
        
    @Field({nullable: true, description: `Name of the entity that stores execution records for this job type (e.g., "MJ: AI Agent Runs", "Action Execution Logs"). Used for generic UI linking to domain-specific run records. NULL if job type uses ScheduledJobRun as its only execution record.`}) 
    @MaxLength(510)
    DomainRunEntity?: string;
        
    @Field({nullable: true, description: `Name of the foreign key field in the DomainRunEntity that links back to ScheduledJobRun (e.g., "ScheduleID"). Used for querying related domain runs. NULL if DomainRunEntity is NULL.`}) 
    @MaxLength(200)
    DomainRunEntityFKey?: string;
        
    @Field(() => Boolean, {description: `Indicates whether this job type supports sending notifications on completion or failure.`}) 
    NotificationsAvailable: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJScheduledJob_])
    MJ_ScheduledJobs_JobTypeIDArray: MJScheduledJob_[]; // Link to MJ_ScheduledJobs
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Types
//****************************************************************************
@InputType()
export class CreateMJScheduledJobTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DomainRunEntity: string | null;

    @Field({ nullable: true })
    DomainRunEntityFKey: string | null;

    @Field(() => Boolean, { nullable: true })
    NotificationsAvailable?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Job Types
//****************************************************************************
@InputType()
export class UpdateMJScheduledJobTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DomainRunEntity?: string | null;

    @Field({ nullable: true })
    DomainRunEntityFKey?: string | null;

    @Field(() => Boolean, { nullable: true })
    NotificationsAvailable?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Job Types
//****************************************************************************
@ObjectType()
export class RunMJScheduledJobTypeViewResult {
    @Field(() => [MJScheduledJobType_])
    Results: MJScheduledJobType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledJobType_)
export class MJScheduledJobTypeResolver extends ResolverBase {
    @Query(() => RunMJScheduledJobTypeViewResult)
    async RunMJScheduledJobTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobTypeViewResult)
    async RunMJScheduledJobTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobTypeViewResult)
    async RunMJScheduledJobTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Job Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledJobType_, { nullable: true })
    async MJScheduledJobType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledJobType_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Job Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Job Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJScheduledJob_])
    async MJ_ScheduledJobs_JobTypeIDArray(@Root() mjscheduledjobtype_: MJScheduledJobType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobs] WHERE [JobTypeID]='${mjscheduledjobtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledJobType_)
    async CreateMJScheduledJobType(
        @Arg('input', () => CreateMJScheduledJobTypeInput) input: CreateMJScheduledJobTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Job Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledJobType_)
    async UpdateMJScheduledJobType(
        @Arg('input', () => UpdateMJScheduledJobTypeInput) input: UpdateMJScheduledJobTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Job Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledJobType_)
    async DeleteMJScheduledJobType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Job Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Scheduled Jobs
//****************************************************************************
@ObjectType({ description: `Defines schedules for automated job execution across all schedulable types. Each record represents a scheduled job with its cron expression, configuration, and execution tracking.` })
export class MJScheduledJob_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    JobTypeID: string;
        
    @Field({description: `Human-readable name for this scheduled job. Should clearly identify what the job does.`}) 
    @MaxLength(400)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the job's purpose, what it does, and any important notes about its execution.`}) 
    Description?: string;
        
    @Field({description: `Cron expression defining when the job should execute (e.g., "0 30 9 * * MON-FRI" for weekdays at 9:30 AM). Uses standard cron syntax with seconds precision.`}) 
    @MaxLength(240)
    CronExpression: string;
        
    @Field({description: `IANA timezone identifier for interpreting the cron expression (e.g., "America/Chicago", "UTC"). Ensures consistent scheduling across different server locations.`}) 
    @MaxLength(128)
    Timezone: string;
        
    @Field({nullable: true, description: `Optional start date/time for when this schedule becomes active. Job will not execute before this time. NULL means active immediately upon creation.`}) 
    @MaxLength(10)
    StartAt?: Date;
        
    @Field({nullable: true, description: `Optional end date/time for when this schedule expires. Job will not execute after this time. NULL means no expiration.`}) 
    @MaxLength(10)
    EndAt?: Date;
        
    @Field({description: `Current status of the schedule. Pending=created but not yet active, Active=currently running on schedule, Paused=temporarily stopped, Disabled=manually disabled, Expired=past EndAt date.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Job-type specific configuration stored as JSON. Schema is defined by the ScheduledJobType plugin. For Agents: includes AgentID, StartingPayload, InitialMessage, etc. For Actions: includes ActionID and parameter mappings.`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `User who owns this schedule. Used as the execution context if no specific user is configured in the job-specific configuration.`}) 
    @MaxLength(16)
    OwnerUserID?: string;
        
    @Field({nullable: true, description: `Timestamp of the most recent execution. Updated after each run. Used for monitoring and dashboard displays.`}) 
    @MaxLength(10)
    LastRunAt?: Date;
        
    @Field({nullable: true, description: `Calculated timestamp of when this job should next execute based on the cron expression. Updated after each run. Used by scheduler to determine which jobs are due.`}) 
    @MaxLength(10)
    NextRunAt?: Date;
        
    @Field(() => Int, {description: `Total number of times this schedule has been executed, including both successful and failed runs.`}) 
    RunCount: number;
        
    @Field(() => Int, {description: `Number of times this schedule has executed successfully (Success = true in ScheduledJobRun).`}) 
    SuccessCount: number;
        
    @Field(() => Int, {description: `Number of times this schedule has executed but failed (Success = false in ScheduledJobRun).`}) 
    FailureCount: number;
        
    @Field(() => Boolean, {description: `Whether to send notifications when the job completes successfully.`}) 
    NotifyOnSuccess: boolean;
        
    @Field(() => Boolean, {description: `Whether to send notifications when the job fails. Defaults to true for alerting on failures.`}) 
    NotifyOnFailure: boolean;
        
    @Field({nullable: true, description: `User to notify about job execution results. If NULL and notifications are enabled, falls back to OwnerUserID.`}) 
    @MaxLength(16)
    NotifyUserID?: string;
        
    @Field(() => Boolean, {description: `Whether to send email notifications. Requires NotifyOnSuccess or NotifyOnFailure to also be enabled.`}) 
    NotifyViaEmail: boolean;
        
    @Field(() => Boolean, {description: `Whether to send in-app notifications. Requires NotifyOnSuccess or NotifyOnFailure to also be enabled. Defaults to true.`}) 
    NotifyViaInApp: boolean;
        
    @Field({nullable: true, description: `Unique token used for distributed locking across multiple server instances. Set when a server claims the job for execution. Prevents duplicate executions in multi-server environments.`}) 
    @MaxLength(16)
    LockToken?: string;
        
    @Field({nullable: true, description: `Timestamp when the lock was acquired. Used with ExpectedCompletionAt to detect stale locks from crashed server instances.`}) 
    @MaxLength(10)
    LockedAt?: Date;
        
    @Field({nullable: true, description: `Identifier of the server instance that currently holds the lock (e.g., "hostname-12345"). Used for troubleshooting and monitoring which server is executing which job.`}) 
    @MaxLength(510)
    LockedByInstance?: string;
        
    @Field({nullable: true, description: `Expected completion time for the current execution. If current time exceeds this and lock still exists, the lock is considered stale and can be claimed by another instance. Handles crashed server cleanup.`}) 
    @MaxLength(10)
    ExpectedCompletionAt?: Date;
        
    @Field({description: `Controls behavior when a new execution is scheduled while a previous execution is still running. Skip=do not start new execution (default), Queue=wait for current to finish then execute, Concurrent=allow multiple simultaneous executions.`}) 
    @MaxLength(40)
    ConcurrencyMode: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    JobType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    OwnerUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    NotifyUser?: string;
        
    @Field(() => [MJScheduledJobRun_])
    MJ_ScheduledJobRuns_ScheduledJobIDArray: MJScheduledJobRun_[]; // Link to MJ_ScheduledJobRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Jobs
//****************************************************************************
@InputType()
export class CreateMJScheduledJobInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    JobTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CronExpression?: string;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    StartAt: Date | null;

    @Field({ nullable: true })
    EndAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OwnerUserID: string | null;

    @Field({ nullable: true })
    LastRunAt: Date | null;

    @Field({ nullable: true })
    NextRunAt: Date | null;

    @Field(() => Int, { nullable: true })
    RunCount?: number;

    @Field(() => Int, { nullable: true })
    SuccessCount?: number;

    @Field(() => Int, { nullable: true })
    FailureCount?: number;

    @Field(() => Boolean, { nullable: true })
    NotifyOnSuccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyOnFailure?: boolean;

    @Field({ nullable: true })
    NotifyUserID: string | null;

    @Field(() => Boolean, { nullable: true })
    NotifyViaEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyViaInApp?: boolean;

    @Field({ nullable: true })
    LockToken: string | null;

    @Field({ nullable: true })
    LockedAt: Date | null;

    @Field({ nullable: true })
    LockedByInstance: string | null;

    @Field({ nullable: true })
    ExpectedCompletionAt: Date | null;

    @Field({ nullable: true })
    ConcurrencyMode?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Scheduled Jobs
//****************************************************************************
@InputType()
export class UpdateMJScheduledJobInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    JobTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CronExpression?: string;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    StartAt?: Date | null;

    @Field({ nullable: true })
    EndAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OwnerUserID?: string | null;

    @Field({ nullable: true })
    LastRunAt?: Date | null;

    @Field({ nullable: true })
    NextRunAt?: Date | null;

    @Field(() => Int, { nullable: true })
    RunCount?: number;

    @Field(() => Int, { nullable: true })
    SuccessCount?: number;

    @Field(() => Int, { nullable: true })
    FailureCount?: number;

    @Field(() => Boolean, { nullable: true })
    NotifyOnSuccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyOnFailure?: boolean;

    @Field({ nullable: true })
    NotifyUserID?: string | null;

    @Field(() => Boolean, { nullable: true })
    NotifyViaEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    NotifyViaInApp?: boolean;

    @Field({ nullable: true })
    LockToken?: string | null;

    @Field({ nullable: true })
    LockedAt?: Date | null;

    @Field({ nullable: true })
    LockedByInstance?: string | null;

    @Field({ nullable: true })
    ExpectedCompletionAt?: Date | null;

    @Field({ nullable: true })
    ConcurrencyMode?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Scheduled Jobs
//****************************************************************************
@ObjectType()
export class RunMJScheduledJobViewResult {
    @Field(() => [MJScheduledJob_])
    Results: MJScheduledJob_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledJob_)
export class MJScheduledJobResolver extends ResolverBase {
    @Query(() => RunMJScheduledJobViewResult)
    async RunMJScheduledJobViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobViewResult)
    async RunMJScheduledJobViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledJobViewResult)
    async RunMJScheduledJobDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Scheduled Jobs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledJob_, { nullable: true })
    async MJScheduledJob(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledJob_ | null> {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJScheduledJobRun_])
    async MJ_ScheduledJobRuns_ScheduledJobIDArray(@Root() mjscheduledjob_: MJScheduledJob_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Job Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobRuns] WHERE [ScheduledJobID]='${mjscheduledjob_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Job Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledJob_)
    async CreateMJScheduledJob(
        @Arg('input', () => CreateMJScheduledJobInput) input: CreateMJScheduledJobInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Scheduled Jobs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledJob_)
    async UpdateMJScheduledJob(
        @Arg('input', () => UpdateMJScheduledJobInput) input: UpdateMJScheduledJobInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Scheduled Jobs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledJob_)
    async DeleteMJScheduledJob(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Scheduled Jobs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Task Dependencies
//****************************************************************************
@ObjectType({ description: `Defines dependencies between tasks to create a directed acyclic graph (DAG) for workflow orchestration` })
export class MJTaskDependency_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TaskID: string;
        
    @Field() 
    @MaxLength(16)
    DependsOnTaskID: string;
        
    @Field({description: `Type of dependency relationship (Prerequisite, Corequisite, Optional)`}) 
    @MaxLength(100)
    DependencyType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Task: string;
        
    @Field() 
    @MaxLength(510)
    DependsOnTask: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Task Dependencies
//****************************************************************************
@InputType()
export class CreateMJTaskDependencyInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TaskID?: string;

    @Field({ nullable: true })
    DependsOnTaskID?: string;

    @Field({ nullable: true })
    DependencyType?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Task Dependencies
//****************************************************************************
@InputType()
export class UpdateMJTaskDependencyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TaskID?: string;

    @Field({ nullable: true })
    DependsOnTaskID?: string;

    @Field({ nullable: true })
    DependencyType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Task Dependencies
//****************************************************************************
@ObjectType()
export class RunMJTaskDependencyViewResult {
    @Field(() => [MJTaskDependency_])
    Results: MJTaskDependency_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaskDependency_)
export class MJTaskDependencyResolver extends ResolverBase {
    @Query(() => RunMJTaskDependencyViewResult)
    async RunMJTaskDependencyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskDependencyViewResult)
    async RunMJTaskDependencyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskDependencyViewResult)
    async RunMJTaskDependencyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Task Dependencies';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaskDependency_, { nullable: true })
    async MJTaskDependency(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaskDependency_ | null> {
        this.CheckUserReadPermissions('MJ: Task Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaskDependencies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Task Dependencies', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTaskDependency_)
    async CreateMJTaskDependency(
        @Arg('input', () => CreateMJTaskDependencyInput) input: CreateMJTaskDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Task Dependencies', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTaskDependency_)
    async UpdateMJTaskDependency(
        @Arg('input', () => UpdateMJTaskDependencyInput) input: UpdateMJTaskDependencyInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Task Dependencies', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTaskDependency_)
    async DeleteMJTaskDependency(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Task Dependencies', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Task Types
//****************************************************************************
@ObjectType({ description: `Categorization system for different types of tasks that can be created and managed within the system` })
export class MJTaskType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name for the task type`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this task type represents and when it should be used`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJTask_])
    MJ_Tasks_TypeIDArray: MJTask_[]; // Link to MJ_Tasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Task Types
//****************************************************************************
@InputType()
export class CreateMJTaskTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Task Types
//****************************************************************************
@InputType()
export class UpdateMJTaskTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Task Types
//****************************************************************************
@ObjectType()
export class RunMJTaskTypeViewResult {
    @Field(() => [MJTaskType_])
    Results: MJTaskType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaskType_)
export class MJTaskTypeResolver extends ResolverBase {
    @Query(() => RunMJTaskTypeViewResult)
    async RunMJTaskTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskTypeViewResult)
    async RunMJTaskTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskTypeViewResult)
    async RunMJTaskTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Task Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaskType_, { nullable: true })
    async MJTaskType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaskType_ | null> {
        this.CheckUserReadPermissions('MJ: Task Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaskTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Task Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_TypeIDArray(@Root() mjtasktype_: MJTaskType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [TypeID]='${mjtasktype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTaskType_)
    async CreateMJTaskType(
        @Arg('input', () => CreateMJTaskTypeInput) input: CreateMJTaskTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Task Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTaskType_)
    async UpdateMJTaskType(
        @Arg('input', () => UpdateMJTaskTypeInput) input: UpdateMJTaskTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Task Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTaskType_)
    async DeleteMJTaskType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Task Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Tasks
//****************************************************************************
@ObjectType({ description: `Core task management entity supporting multi-agent and multi-human collaboration with dependency tracking` })
export class MJTask_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Display name for the task`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the task requirements and objectives`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ProjectID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({description: `Current status of the task (Pending, In Progress, Complete, Cancelled, Failed, Blocked, Deferred)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Completion percentage for tracking progress (0-100)`}) 
    PercentComplete?: number;
        
    @Field({nullable: true, description: `Due date and time for task completion`}) 
    @MaxLength(10)
    DueAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when work on the task began`}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the task was completed`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Project?: string;
        
    @Field({nullable: true}) 
    ConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJTaskDependency_])
    MJ_TaskDependencies_DependsOnTaskIDArray: MJTaskDependency_[]; // Link to MJ_TaskDependencies
    
    @Field(() => [MJTaskDependency_])
    MJ_TaskDependencies_TaskIDArray: MJTaskDependency_[]; // Link to MJ_TaskDependencies
    
    @Field(() => [MJTask_])
    MJ_Tasks_ParentIDArray: MJTask_[]; // Link to MJ_Tasks
    
}

//****************************************************************************
// INPUT TYPE for MJ: Tasks
//****************************************************************************
@InputType()
export class CreateMJTaskInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    PercentComplete?: number | null;

    @Field({ nullable: true })
    DueAt: Date | null;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    CompletedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Tasks
//****************************************************************************
@InputType()
export class UpdateMJTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field({ nullable: true })
    ProjectID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    PercentComplete?: number | null;

    @Field({ nullable: true })
    DueAt?: Date | null;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Tasks
//****************************************************************************
@ObjectType()
export class RunMJTaskViewResult {
    @Field(() => [MJTask_])
    Results: MJTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTask_)
export class MJTaskResolver extends ResolverBase {
    @Query(() => RunMJTaskViewResult)
    async RunMJTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskViewResult)
    async RunMJTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaskViewResult)
    async RunMJTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Tasks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTask_, { nullable: true })
    async MJTask(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTask_ | null> {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Tasks', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTaskDependency_])
    async MJ_TaskDependencies_DependsOnTaskIDArray(@Root() mjtask_: MJTask_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Task Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaskDependencies] WHERE [DependsOnTaskID]='${mjtask_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Task Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTaskDependency_])
    async MJ_TaskDependencies_TaskIDArray(@Root() mjtask_: MJTask_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Task Dependencies', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaskDependencies] WHERE [TaskID]='${mjtask_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Task Dependencies', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Task Dependencies', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_ParentIDArray(@Root() mjtask_: MJTask_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [ParentID]='${mjtask_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTask_)
    async CreateMJTask(
        @Arg('input', () => CreateMJTaskInput) input: CreateMJTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Tasks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTask_)
    async UpdateMJTask(
        @Arg('input', () => UpdateMJTaskInput) input: UpdateMJTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Tasks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTask_)
    async DeleteMJTask(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Tasks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Rubrics
//****************************************************************************
@ObjectType({ description: `Reusable evaluation criteria (rubrics) for consistent scoring across tests. Rubrics define structured evaluation dimensions and can include LLM prompts for automated judgment. Particularly useful for LLM-as-judge patterns where consistent evaluation criteria are critical.` })
export class MJTestRubric_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The test type this rubric applies to (e.g., Agent Eval, Code Generation)`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field({description: `Unique name for the rubric (e.g., "Component Quality Rubric v1", "Agent Response Quality")`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of what this rubric evaluates and when to use it`}) 
    Description?: string;
        
    @Field({nullable: true, description: `LLM prompt template for automated judgment. Can include placeholders for test inputs/outputs (e.g., "Evaluate the following React component for correctness, UX, and maintainability...")`}) 
    PromptTemplate?: string;
        
    @Field({nullable: true, description: `JSON object defining structured evaluation criteria with dimensions, weights, and scoring guidance (e.g., {correctness: {weight: 0.4, description: "..."}, ux: {weight: 0.3, description: "..."}})`}) 
    Criteria?: string;
        
    @Field({nullable: true, description: `Version identifier for the rubric. Allows tracking changes and comparing results across rubric versions.`}) 
    @MaxLength(100)
    Version?: string;
        
    @Field({description: `Status of the rubric: Pending (under development), Active (available for use), Disabled (deprecated)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Rubrics
//****************************************************************************
@InputType()
export class CreateMJTestRubricInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    PromptTemplate: string | null;

    @Field({ nullable: true })
    Criteria: string | null;

    @Field({ nullable: true })
    Version: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Rubrics
//****************************************************************************
@InputType()
export class UpdateMJTestRubricInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    PromptTemplate?: string | null;

    @Field({ nullable: true })
    Criteria?: string | null;

    @Field({ nullable: true })
    Version?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Rubrics
//****************************************************************************
@ObjectType()
export class RunMJTestRubricViewResult {
    @Field(() => [MJTestRubric_])
    Results: MJTestRubric_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRubric_)
export class MJTestRubricResolver extends ResolverBase {
    @Query(() => RunMJTestRubricViewResult)
    async RunMJTestRubricViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRubricViewResult)
    async RunMJTestRubricViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRubricViewResult)
    async RunMJTestRubricDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Rubrics';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRubric_, { nullable: true })
    async MJTestRubric(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRubric_ | null> {
        this.CheckUserReadPermissions('MJ: Test Rubrics', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRubrics] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Rubrics', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Rubrics', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestRubric_)
    async CreateMJTestRubric(
        @Arg('input', () => CreateMJTestRubricInput) input: CreateMJTestRubricInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Rubrics', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRubric_)
    async UpdateMJTestRubric(
        @Arg('input', () => UpdateMJTestRubricInput) input: UpdateMJTestRubricInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Rubrics', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRubric_)
    async DeleteMJTestRubric(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Rubrics', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Run Feedbacks
//****************************************************************************
@ObjectType({ description: `Human-in-the-loop feedback on test run results. Allows human reviewers to validate, correct, or override automated test results. Essential for training and improving automated evaluation criteria.` })
export class MJTestRunFeedback_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The test run being reviewed`}) 
    @MaxLength(16)
    TestRunID: string;
        
    @Field({description: `Foreign Key - The user providing the feedback`}) 
    @MaxLength(16)
    ReviewerUserID: string;
        
    @Field(() => Int, {nullable: true, description: `Numeric rating from 1 (poor) to 10 (excellent). Allows quantitative tracking of result quality.`}) 
    Rating?: number;
        
    @Field(() => Boolean, {nullable: true, description: `Boolean indicating if the automated test result was correct. Can override automated Pass/Fail status.`}) 
    IsCorrect?: boolean;
        
    @Field({nullable: true, description: `Summary of corrections or adjustments made by the human reviewer`}) 
    CorrectionSummary?: string;
        
    @Field({nullable: true, description: `Free-form comments from the reviewer about the test result, quality, or issues found`}) 
    Comments?: string;
        
    @Field({description: `Timestamp when the feedback was provided`}) 
    @MaxLength(10)
    ReviewedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    TestRun: string;
        
    @Field() 
    @MaxLength(200)
    ReviewerUser: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Run Feedbacks
//****************************************************************************
@InputType()
export class CreateMJTestRunFeedbackInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TestRunID?: string;

    @Field({ nullable: true })
    ReviewerUserID?: string;

    @Field(() => Int, { nullable: true })
    Rating: number | null;

    @Field(() => Boolean, { nullable: true })
    IsCorrect: boolean | null;

    @Field({ nullable: true })
    CorrectionSummary: string | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ReviewedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Run Feedbacks
//****************************************************************************
@InputType()
export class UpdateMJTestRunFeedbackInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TestRunID?: string;

    @Field({ nullable: true })
    ReviewerUserID?: string;

    @Field(() => Int, { nullable: true })
    Rating?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsCorrect?: boolean | null;

    @Field({ nullable: true })
    CorrectionSummary?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ReviewedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Run Feedbacks
//****************************************************************************
@ObjectType()
export class RunMJTestRunFeedbackViewResult {
    @Field(() => [MJTestRunFeedback_])
    Results: MJTestRunFeedback_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRunFeedback_)
export class MJTestRunFeedbackResolver extends ResolverBase {
    @Query(() => RunMJTestRunFeedbackViewResult)
    async RunMJTestRunFeedbackViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunFeedbackViewResult)
    async RunMJTestRunFeedbackViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunFeedbackViewResult)
    async RunMJTestRunFeedbackDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Run Feedbacks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRunFeedback_, { nullable: true })
    async MJTestRunFeedback(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRunFeedback_ | null> {
        this.CheckUserReadPermissions('MJ: Test Run Feedbacks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRunFeedbacks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Feedbacks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Run Feedbacks', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestRunFeedback_)
    async CreateMJTestRunFeedback(
        @Arg('input', () => CreateMJTestRunFeedbackInput) input: CreateMJTestRunFeedbackInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Run Feedbacks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRunFeedback_)
    async UpdateMJTestRunFeedback(
        @Arg('input', () => UpdateMJTestRunFeedbackInput) input: UpdateMJTestRunFeedbackInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Run Feedbacks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRunFeedback_)
    async DeleteMJTestRunFeedback(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Run Feedbacks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Runs
//****************************************************************************
@ObjectType({ description: `Execution instance of a single test. Captures inputs, outputs, results, and links to the target being tested (e.g., Agent Run). Can be part of a suite run or standalone. The TargetLogID links to type-specific execution logs (AgentRun, WorkflowRun, etc.) which contain the detailed trace information.` })
export class MJTestRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The test definition that was executed`}) 
    @MaxLength(16)
    TestID: string;
        
    @Field({nullable: true, description: `Foreign Key - Optional parent suite run if this test was part of a suite execution. NULL for standalone test runs.`}) 
    @MaxLength(16)
    TestSuiteRunID?: string;
        
    @Field({description: `Foreign Key - The user who triggered the test run (could be system user for automated runs)`}) 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field(() => Int, {nullable: true, description: `Execution sequence within the suite run. Indicates order of execution for tests in the same suite.`}) 
    Sequence?: number;
        
    @Field({nullable: true, description: `Optional sub-category or variant label for the test target. Use this to distinguish between different test scenarios within the same entity type (e.g., "Summarization", "Classification", "Code Review" for AI Agent tests). The entity type itself should be specified via TargetLogEntityID.`}) 
    @MaxLength(200)
    TargetType?: string;
        
    @Field({nullable: true, description: `ID of the target execution log (e.g., AIAgentRun.ID, WorkflowRun.ID). This is a soft FK - the actual entity depends on TargetType. The target entity should have a reverse FK back to TestRun for bidirectional navigation.`}) 
    @MaxLength(16)
    TargetLogID?: string;
        
    @Field({description: `Current status of the test run: Pending (queued), Running (in progress), Passed (all checks passed), Failed (at least one check failed), Skipped (not executed), Error (execution error before validation), Timeout (execution exceeded time limit and was cancelled)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp when the test run started execution`}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the test run completed`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Float, {nullable: true, description: `Execution time in seconds for this test`}) 
    DurationSeconds?: number;
        
    @Field({nullable: true, description: `JSON object with the actual inputs used for this test run (may differ from test definition if parameterized)`}) 
    InputData?: string;
        
    @Field({nullable: true, description: `JSON object with the expected outputs/outcomes for this test run`}) 
    ExpectedOutputData?: string;
        
    @Field({nullable: true, description: `JSON object with the actual outputs produced by the test execution`}) 
    ActualOutputData?: string;
        
    @Field(() => Int, {nullable: true, description: `Number of validation checks that passed`}) 
    PassedChecks?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of validation checks that failed`}) 
    FailedChecks?: number;
        
    @Field(() => Int, {nullable: true, description: `Total number of validation checks performed`}) 
    TotalChecks?: number;
        
    @Field(() => Float, {nullable: true, description: `Overall test score from 0.0000 to 1.0000 (0-100%). Calculated by test driver based on passed/failed checks and weights.`}) 
    Score?: number;
        
    @Field(() => Float, {nullable: true, description: `Cost in USD for running this test (e.g., LLM token costs, compute resources)`}) 
    CostUSD?: number;
        
    @Field({nullable: true, description: `Error message if the test encountered an execution error`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true, description: `JSON object with detailed results including individual check results, metrics, oracle outputs, and diagnostic information`}) 
    ResultDetails?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Detailed execution log capturing status messages, diagnostic output, and driver-specific information streamed during test execution. Format is timestamped log lines.`}) 
    Log?: string;
        
    @Field({nullable: true, description: `JSON array of user-assigned tags/labels for this test run. Used for categorization, filtering, and comparing runs with different configurations. Inherits from parent suite run tags if not explicitly set.`}) 
    Tags?: string;
        
    @Field({nullable: true, description: `Hostname of the machine that executed this test. Used for identifying the execution environment and debugging infrastructure-specific issues.`}) 
    @MaxLength(510)
    MachineName?: string;
        
    @Field({nullable: true, description: `Unique machine identifier (typically MAC address) for the execution host. Enables deduplication and tracking of test execution across different machines.`}) 
    @MaxLength(510)
    MachineID?: string;
        
    @Field({nullable: true, description: `Denormalized user name who ran the test. Stored separately from RunByUserID to enable cross-server aggregation where user IDs differ but names remain consistent.`}) 
    @MaxLength(510)
    RunByUserName?: string;
        
    @Field({nullable: true, description: `Denormalized email address of the user who ran the test. Primary identifier for cross-server aggregation since email addresses are unique across MemberJunction instances.`}) 
    @MaxLength(510)
    RunByUserEmail?: string;
        
    @Field({nullable: true, description: `JSON object containing extensible execution context: osType, osVersion, nodeVersion, timezone, locale, ipAddress, and CI/CD metadata (ciProvider, pipelineId, buildNumber, branch, prNumber). Allows detailed environment tracking without schema changes.`}) 
    RunContextDetails?: string;
        
    @Field({nullable: true, description: `Foreign key to Entity table identifying the type of entity referenced by TargetLogID. When populated, TargetLogID is a record ID in this entity. Used for linking test runs to AI Agent Runs, Workflow Runs, or other entity types being tested.`}) 
    @MaxLength(16)
    TargetLogEntityID?: string;
        
    @Field({nullable: true, description: `JSON object containing the final resolved variable values used during test execution. Includes both the resolved values and the source of each value (run, suite, test, or type level). Stored for reproducibility and auditing.`}) 
    ResolvedVariables?: string;
        
    @Field() 
    @MaxLength(510)
    Test: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TestSuiteRun?: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TargetLogEntity?: string;
        
    @Field(() => [MJTestRunFeedback_])
    MJ_TestRunFeedbacks_TestRunIDArray: MJTestRunFeedback_[]; // Link to MJ_TestRunFeedbacks
    
    @Field(() => [MJAIPromptRun_])
    MJ_AIPromptRuns_TestRunIDArray: MJAIPromptRun_[]; // Link to MJ_AIPromptRuns
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_TestRunIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJConversation_])
    Conversations_TestRunIDArray: MJConversation_[]; // Link to Conversations
    
    @Field(() => [MJConversationDetail_])
    ConversationDetails_TestRunIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Runs
//****************************************************************************
@InputType()
export class CreateMJTestRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field({ nullable: true })
    TestSuiteRunID: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => Int, { nullable: true })
    Sequence: number | null;

    @Field({ nullable: true })
    TargetType: string | null;

    @Field({ nullable: true })
    TargetLogID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds: number | null;

    @Field({ nullable: true })
    InputData: string | null;

    @Field({ nullable: true })
    ExpectedOutputData: string | null;

    @Field({ nullable: true })
    ActualOutputData: string | null;

    @Field(() => Int, { nullable: true })
    PassedChecks: number | null;

    @Field(() => Int, { nullable: true })
    FailedChecks: number | null;

    @Field(() => Int, { nullable: true })
    TotalChecks: number | null;

    @Field(() => Float, { nullable: true })
    Score: number | null;

    @Field(() => Float, { nullable: true })
    CostUSD: number | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    ResultDetails: string | null;

    @Field({ nullable: true })
    Log: string | null;

    @Field({ nullable: true })
    Tags: string | null;

    @Field({ nullable: true })
    MachineName: string | null;

    @Field({ nullable: true })
    MachineID: string | null;

    @Field({ nullable: true })
    RunByUserName: string | null;

    @Field({ nullable: true })
    RunByUserEmail: string | null;

    @Field({ nullable: true })
    RunContextDetails: string | null;

    @Field({ nullable: true })
    TargetLogEntityID: string | null;

    @Field({ nullable: true })
    ResolvedVariables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Runs
//****************************************************************************
@InputType()
export class UpdateMJTestRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field({ nullable: true })
    TestSuiteRunID?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number | null;

    @Field({ nullable: true })
    TargetType?: string | null;

    @Field({ nullable: true })
    TargetLogID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Float, { nullable: true })
    DurationSeconds?: number | null;

    @Field({ nullable: true })
    InputData?: string | null;

    @Field({ nullable: true })
    ExpectedOutputData?: string | null;

    @Field({ nullable: true })
    ActualOutputData?: string | null;

    @Field(() => Int, { nullable: true })
    PassedChecks?: number | null;

    @Field(() => Int, { nullable: true })
    FailedChecks?: number | null;

    @Field(() => Int, { nullable: true })
    TotalChecks?: number | null;

    @Field(() => Float, { nullable: true })
    Score?: number | null;

    @Field(() => Float, { nullable: true })
    CostUSD?: number | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    ResultDetails?: string | null;

    @Field({ nullable: true })
    Log?: string | null;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field({ nullable: true })
    MachineName?: string | null;

    @Field({ nullable: true })
    MachineID?: string | null;

    @Field({ nullable: true })
    RunByUserName?: string | null;

    @Field({ nullable: true })
    RunByUserEmail?: string | null;

    @Field({ nullable: true })
    RunContextDetails?: string | null;

    @Field({ nullable: true })
    TargetLogEntityID?: string | null;

    @Field({ nullable: true })
    ResolvedVariables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Runs
//****************************************************************************
@ObjectType()
export class RunMJTestRunViewResult {
    @Field(() => [MJTestRun_])
    Results: MJTestRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestRun_)
export class MJTestRunResolver extends ResolverBase {
    @Query(() => RunMJTestRunViewResult)
    async RunMJTestRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunViewResult)
    async RunMJTestRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestRunViewResult)
    async RunMJTestRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestRun_, { nullable: true })
    async MJTestRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestRun_ | null> {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRunFeedback_])
    async MJ_TestRunFeedbacks_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Run Feedbacks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRunFeedbacks] WHERE [TestRunID]='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Feedbacks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Run Feedbacks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPromptRun_])
    async MJ_AIPromptRuns_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Prompt Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptRuns] WHERE [TestRunID]='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Prompt Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Prompt Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [TestRunID]='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [TestRunID]='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_TestRunIDArray(@Root() mjtestrun_: MJTestRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [TestRunID]='${mjtestrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestRun_)
    async CreateMJTestRun(
        @Arg('input', () => CreateMJTestRunInput) input: CreateMJTestRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestRun_)
    async UpdateMJTestRun(
        @Arg('input', () => UpdateMJTestRunInput) input: UpdateMJTestRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestRun_)
    async DeleteMJTestRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Suite Runs
//****************************************************************************
@ObjectType({ description: `Execution instance of a test suite. Captures who ran it, when, in what environment, and aggregates results from all tests in the suite. Supports versioning via GitCommit and AgentVersion fields to track system state during execution.` })
export class MJTestSuiteRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The test suite that was executed`}) 
    @MaxLength(16)
    SuiteID: string;
        
    @Field({description: `Foreign Key - The user who triggered the suite run (could be system user for automated runs)`}) 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field({nullable: true, description: `Environment where tests were executed (e.g., "dev", "staging", "prod", "ci")`}) 
    @MaxLength(100)
    Environment?: string;
        
    @Field({nullable: true, description: `How the run was triggered (e.g., "manual", "ci", "scheduled", "shadow", "release")`}) 
    @MaxLength(100)
    TriggerType?: string;
        
    @Field({nullable: true, description: `Git commit SHA of the code version being tested. Enables correlation between test results and code changes.`}) 
    @MaxLength(200)
    GitCommit?: string;
        
    @Field({nullable: true, description: `Version of the agent or system being tested (e.g., "skip-agent-2.1.0", "workflow-engine-3.4.2"). Enables version comparison and regression detection.`}) 
    @MaxLength(200)
    AgentVersion?: string;
        
    @Field({description: `Current status of the suite run: Pending (queued), Running (in progress), Completed (finished successfully), Failed (suite-level failure), Cancelled (stopped by user)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp when the suite run started execution`}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true, description: `Timestamp when the suite run completed (successfully or with failures)`}) 
    @MaxLength(10)
    CompletedAt?: Date;
        
    @Field(() => Int, {nullable: true, description: `Total number of tests executed in this suite run`}) 
    TotalTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that passed all checks`}) 
    PassedTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that failed at least one check`}) 
    FailedTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that were skipped (not executed)`}) 
    SkippedTests?: number;
        
    @Field(() => Int, {nullable: true, description: `Number of tests that encountered execution errors (different from failing validation)`}) 
    ErrorTests?: number;
        
    @Field(() => Float, {nullable: true, description: `Total execution time in seconds for the entire suite`}) 
    TotalDurationSeconds?: number;
        
    @Field(() => Float, {nullable: true, description: `Total cost in USD for running the entire suite (sum of all test costs)`}) 
    TotalCostUSD?: number;
        
    @Field({nullable: true, description: `JSON snapshot of the runtime configuration used for this suite run`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `JSON object with aggregated results and statistics from the suite run`}) 
    ResultSummary?: string;
        
    @Field({nullable: true, description: `Error message if the suite-level execution failed (before individual tests could run)`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON array of user-assigned tags/labels for this suite run. Used for categorization, filtering, and comparing runs with different configurations (e.g., ["Opus 4.5", "New Prompt v3", "Production Config"]).`}) 
    Tags?: string;
        
    @Field({nullable: true, description: `Hostname of the machine that executed this suite. Used for identifying the execution environment and debugging infrastructure-specific issues.`}) 
    @MaxLength(510)
    MachineName?: string;
        
    @Field({nullable: true, description: `Unique machine identifier (typically MAC address) for the execution host. Enables deduplication and tracking of suite execution across different machines.`}) 
    @MaxLength(510)
    MachineID?: string;
        
    @Field({nullable: true, description: `Denormalized user name who ran the suite. Stored separately from RunByUserID to enable cross-server aggregation where user IDs differ but names remain consistent.`}) 
    @MaxLength(510)
    RunByUserName?: string;
        
    @Field({nullable: true, description: `Denormalized email address of the user who ran the suite. Primary identifier for cross-server aggregation since email addresses are unique across MemberJunction instances.`}) 
    @MaxLength(510)
    RunByUserEmail?: string;
        
    @Field({nullable: true, description: `JSON object containing extensible execution context: osType, osVersion, nodeVersion, timezone, locale, ipAddress, and CI/CD metadata (ciProvider, pipelineId, buildNumber, branch, prNumber). Allows detailed environment tracking without schema changes.`}) 
    RunContextDetails?: string;
        
    @Field({nullable: true, description: `JSON object containing the variable values provided at suite run level. These values were applied to all tests in the suite run and can be seen on individual TestRun.ResolvedVariables with source="suite".`}) 
    ResolvedVariables?: string;
        
    @Field() 
    @MaxLength(510)
    Suite: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJTestRun_])
    MJ_TestRuns_TestSuiteRunIDArray: MJTestRun_[]; // Link to MJ_TestRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Runs
//****************************************************************************
@InputType()
export class CreateMJTestSuiteRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    Environment: string | null;

    @Field({ nullable: true })
    TriggerType: string | null;

    @Field({ nullable: true })
    GitCommit: string | null;

    @Field({ nullable: true })
    AgentVersion: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    CompletedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalTests: number | null;

    @Field(() => Int, { nullable: true })
    PassedTests: number | null;

    @Field(() => Int, { nullable: true })
    FailedTests: number | null;

    @Field(() => Int, { nullable: true })
    SkippedTests: number | null;

    @Field(() => Int, { nullable: true })
    ErrorTests: number | null;

    @Field(() => Float, { nullable: true })
    TotalDurationSeconds: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostUSD: number | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    ResultSummary: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Tags: string | null;

    @Field({ nullable: true })
    MachineName: string | null;

    @Field({ nullable: true })
    MachineID: string | null;

    @Field({ nullable: true })
    RunByUserName: string | null;

    @Field({ nullable: true })
    RunByUserEmail: string | null;

    @Field({ nullable: true })
    RunContextDetails: string | null;

    @Field({ nullable: true })
    ResolvedVariables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Runs
//****************************************************************************
@InputType()
export class UpdateMJTestSuiteRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    Environment?: string | null;

    @Field({ nullable: true })
    TriggerType?: string | null;

    @Field({ nullable: true })
    GitCommit?: string | null;

    @Field({ nullable: true })
    AgentVersion?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    CompletedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalTests?: number | null;

    @Field(() => Int, { nullable: true })
    PassedTests?: number | null;

    @Field(() => Int, { nullable: true })
    FailedTests?: number | null;

    @Field(() => Int, { nullable: true })
    SkippedTests?: number | null;

    @Field(() => Int, { nullable: true })
    ErrorTests?: number | null;

    @Field(() => Float, { nullable: true })
    TotalDurationSeconds?: number | null;

    @Field(() => Float, { nullable: true })
    TotalCostUSD?: number | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    ResultSummary?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field({ nullable: true })
    MachineName?: string | null;

    @Field({ nullable: true })
    MachineID?: string | null;

    @Field({ nullable: true })
    RunByUserName?: string | null;

    @Field({ nullable: true })
    RunByUserEmail?: string | null;

    @Field({ nullable: true })
    RunContextDetails?: string | null;

    @Field({ nullable: true })
    ResolvedVariables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Suite Runs
//****************************************************************************
@ObjectType()
export class RunMJTestSuiteRunViewResult {
    @Field(() => [MJTestSuiteRun_])
    Results: MJTestSuiteRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestSuiteRun_)
export class MJTestSuiteRunResolver extends ResolverBase {
    @Query(() => RunMJTestSuiteRunViewResult)
    async RunMJTestSuiteRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteRunViewResult)
    async RunMJTestSuiteRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteRunViewResult)
    async RunMJTestSuiteRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Suite Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestSuiteRun_, { nullable: true })
    async MJTestSuiteRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestSuiteRun_ | null> {
        this.CheckUserReadPermissions('MJ: Test Suite Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuiteRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Suite Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRun_])
    async MJ_TestRuns_TestSuiteRunIDArray(@Root() mjtestsuiterun_: MJTestSuiteRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRuns] WHERE [TestSuiteRunID]='${mjtestsuiterun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestSuiteRun_)
    async CreateMJTestSuiteRun(
        @Arg('input', () => CreateMJTestSuiteRunInput) input: CreateMJTestSuiteRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Suite Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestSuiteRun_)
    async UpdateMJTestSuiteRun(
        @Arg('input', () => UpdateMJTestSuiteRunInput) input: UpdateMJTestSuiteRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Suite Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestSuiteRun_)
    async DeleteMJTestSuiteRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Suite Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Suite Tests
//****************************************************************************
@ObjectType({ description: `Junction table linking tests to test suites. Allows many-to-many relationship where a test can belong to multiple suites and a suite can contain multiple tests. Includes sequence for execution order and configuration overrides specific to this suite-test pairing.` })
export class MJTestSuiteTest_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The test suite this relationship belongs to`}) 
    @MaxLength(16)
    SuiteID: string;
        
    @Field({description: `Foreign Key - The test included in this suite`}) 
    @MaxLength(16)
    TestID: string;
        
    @Field(() => Int, {description: `Execution sequence within the suite. Lower numbers run first. Tests with same sequence may run in parallel.`}) 
    Sequence: number;
        
    @Field({description: `Status of this test within this suite: Active (will run), Disabled (temporarily excluded), Skip (documented exclusion)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON object to override test configuration for this specific suite. Allows same test to run with different parameters in different suites.`}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Suite: string;
        
    @Field() 
    @MaxLength(510)
    Test: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Tests
//****************************************************************************
@InputType()
export class CreateMJTestSuiteTestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Suite Tests
//****************************************************************************
@InputType()
export class UpdateMJTestSuiteTestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SuiteID?: string;

    @Field({ nullable: true })
    TestID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Suite Tests
//****************************************************************************
@ObjectType()
export class RunMJTestSuiteTestViewResult {
    @Field(() => [MJTestSuiteTest_])
    Results: MJTestSuiteTest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestSuiteTest_)
export class MJTestSuiteTestResolver extends ResolverBase {
    @Query(() => RunMJTestSuiteTestViewResult)
    async RunMJTestSuiteTestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteTestViewResult)
    async RunMJTestSuiteTestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteTestViewResult)
    async RunMJTestSuiteTestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Suite Tests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestSuiteTest_, { nullable: true })
    async MJTestSuiteTest(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestSuiteTest_ | null> {
        this.CheckUserReadPermissions('MJ: Test Suite Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuiteTests] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Suite Tests', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTestSuiteTest_)
    async CreateMJTestSuiteTest(
        @Arg('input', () => CreateMJTestSuiteTestInput) input: CreateMJTestSuiteTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Suite Tests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestSuiteTest_)
    async UpdateMJTestSuiteTest(
        @Arg('input', () => UpdateMJTestSuiteTestInput) input: UpdateMJTestSuiteTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Suite Tests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestSuiteTest_)
    async DeleteMJTestSuiteTest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Suite Tests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Suites
//****************************************************************************
@ObjectType({ description: `Hierarchical organization of tests into suites. Test suites can contain other suites (via ParentID) and tests (via TestSuiteTest junction table). Suites provide logical grouping for running batches of related tests.` })
export class MJTestSuite_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `Optional parent suite ID for hierarchical organization. NULL for root-level suites.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Name of the test suite (e.g., "Skip Component Generation Suite", "Agent Memory Tests")`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this suite tests and its purpose`}) 
    Description?: string;
        
    @Field({description: `Status of the suite: Pending (being configured), Active (available for use), Disabled (archived/not in use)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON array of tags for categorization and filtering (e.g., ["smoke", "regression", "nightly"])`}) 
    Tags?: string;
        
    @Field({nullable: true, description: `JSON configuration object for suite-level settings (e.g., environment defaults, retry policies, notification settings)`}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Maximum total execution time in milliseconds for the entire suite. If NULL, no suite-level timeout applies (individual test timeouts still apply). When exceeded, current test is cancelled and remaining tests are skipped.`}) 
    MaxExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `JSON object containing variable values to apply to all tests in this suite. These values override test-level defaults but can be overridden by run-level values.`}) 
    Variables?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJTestSuite_])
    MJ_TestSuites_ParentIDArray: MJTestSuite_[]; // Link to MJ_TestSuites
    
    @Field(() => [MJTestSuiteTest_])
    MJ_TestSuiteTests_SuiteIDArray: MJTestSuiteTest_[]; // Link to MJ_TestSuiteTests
    
    @Field(() => [MJTestSuiteRun_])
    MJ_TestSuiteRuns_SuiteIDArray: MJTestSuiteRun_[]; // Link to MJ_TestSuiteRuns
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Suites
//****************************************************************************
@InputType()
export class CreateMJTestSuiteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Tags: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Variables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Suites
//****************************************************************************
@InputType()
export class UpdateMJTestSuiteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Variables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Suites
//****************************************************************************
@ObjectType()
export class RunMJTestSuiteViewResult {
    @Field(() => [MJTestSuite_])
    Results: MJTestSuite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestSuite_)
export class MJTestSuiteResolver extends ResolverBase {
    @Query(() => RunMJTestSuiteViewResult)
    async RunMJTestSuiteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteViewResult)
    async RunMJTestSuiteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestSuiteViewResult)
    async RunMJTestSuiteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Suites';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestSuite_, { nullable: true })
    async MJTestSuite(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestSuite_ | null> {
        this.CheckUserReadPermissions('MJ: Test Suites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuites] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Suites', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestSuite_])
    async MJ_TestSuites_ParentIDArray(@Root() mjtestsuite_: MJTestSuite_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuites] WHERE [ParentID]='${mjtestsuite_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suites', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteTest_])
    async MJ_TestSuiteTests_SuiteIDArray(@Root() mjtestsuite_: MJTestSuite_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuiteTests] WHERE [SuiteID]='${mjtestsuite_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Tests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteRun_])
    async MJ_TestSuiteRuns_SuiteIDArray(@Root() mjtestsuite_: MJTestSuite_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuiteRuns] WHERE [SuiteID]='${mjtestsuite_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestSuite_)
    async CreateMJTestSuite(
        @Arg('input', () => CreateMJTestSuiteInput) input: CreateMJTestSuiteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Suites', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestSuite_)
    async UpdateMJTestSuite(
        @Arg('input', () => UpdateMJTestSuiteInput) input: UpdateMJTestSuiteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Suites', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestSuite_)
    async DeleteMJTestSuite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Suites', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Test Types
//****************************************************************************
@ObjectType({ description: `Defines test type drivers that can be dynamically instantiated via MJGlobal.Instance.ClassFactory.CreateInstance(BaseTestDriver, DriverClass). Each test type represents a different category of testing (e.g., Agent Evals, Workflow Tests, Code Generation Tests).` })
export class MJTestType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name for the test type (e.g., "Agent Eval", "Workflow Test", "Code Generation Test")`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this test type validates and how it works`}) 
    Description?: string;
        
    @Field({description: `Class name for the driver implementation (e.g., "AgentEvalDriver"). Used with ClassFactory to instantiate the appropriate BaseTestDriver subclass.`}) 
    @MaxLength(510)
    DriverClass: string;
        
    @Field({description: `Status of the test type: Pending (under development), Active (available for use), Disabled (no longer available)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON schema defining the variables available for tests of this type. Contains schemaVersion and array of variable definitions with name, displayName, description, dataType, valueSource, possibleValues, defaultValue, and required fields.`}) 
    VariablesSchema?: string;
        
    @Field(() => [MJTestRubric_])
    MJ_TestRubrics_TypeIDArray: MJTestRubric_[]; // Link to MJ_TestRubrics
    
    @Field(() => [MJTest_])
    MJ_Tests_TypeIDArray: MJTest_[]; // Link to MJ_Tests
    
}

//****************************************************************************
// INPUT TYPE for MJ: Test Types
//****************************************************************************
@InputType()
export class CreateMJTestTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    VariablesSchema: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Test Types
//****************************************************************************
@InputType()
export class UpdateMJTestTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    VariablesSchema?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Test Types
//****************************************************************************
@ObjectType()
export class RunMJTestTypeViewResult {
    @Field(() => [MJTestType_])
    Results: MJTestType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTestType_)
export class MJTestTypeResolver extends ResolverBase {
    @Query(() => RunMJTestTypeViewResult)
    async RunMJTestTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestTypeViewResult)
    async RunMJTestTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestTypeViewResult)
    async RunMJTestTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Test Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTestType_, { nullable: true })
    async MJTestType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTestType_ | null> {
        this.CheckUserReadPermissions('MJ: Test Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Test Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRubric_])
    async MJ_TestRubrics_TypeIDArray(@Root() mjtesttype_: MJTestType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Rubrics', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRubrics] WHERE [TypeID]='${mjtesttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Rubrics', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Rubrics', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTest_])
    async MJ_Tests_TypeIDArray(@Root() mjtesttype_: MJTestType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTests] WHERE [TypeID]='${mjtesttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTestType_)
    async CreateMJTestType(
        @Arg('input', () => CreateMJTestTypeInput) input: CreateMJTestTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Test Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTestType_)
    async UpdateMJTestType(
        @Arg('input', () => UpdateMJTestTypeInput) input: UpdateMJTestTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Test Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTestType_)
    async DeleteMJTestType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Test Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Tests
//****************************************************************************
@ObjectType({ description: `Individual test definitions. Each test has a specific type (via TypeID) which determines how it executes. Tests store their inputs, expected outcomes, and configuration as JSON, allowing flexibility for different test types while maintaining a common schema.` })
export class MJTest_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign Key - The type of test (e.g., Agent Eval, Workflow Test). Determines which driver class handles execution.`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field({description: `Name of the test (e.g., "Pie Chart with Drilldown", "Memory Recall Accuracy")`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of what this test validates and why it matters`}) 
    Description?: string;
        
    @Field({description: `Status of the test: Pending (being configured), Active (ready to run), Disabled (archived/not in use)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `JSON object defining the inputs/parameters for the test. Structure varies by test type (e.g., for Agent Eval: {prompt, context, conversationHistory})`}) 
    InputDefinition?: string;
        
    @Field({nullable: true, description: `JSON object defining what success looks like. Structure varies by test type (e.g., for Agent Eval: {toolCalls, outputFormat, semanticGoals, dataAssertions})`}) 
    ExpectedOutcomes?: string;
        
    @Field({nullable: true, description: `JSON object for test-specific configuration (e.g., oracles to use, rubrics, retry policies, timeout settings)`}) 
    Configuration?: string;
        
    @Field({nullable: true, description: `JSON array of tags for categorization and filtering (e.g., ["smoke", "agent-quality", "performance"])`}) 
    Tags?: string;
        
    @Field(() => Int, {nullable: true, description: `Priority for execution ordering. Lower numbers run first. Useful for dependencies or critical path tests.`}) 
    Priority?: number;
        
    @Field(() => Int, {nullable: true, description: `Estimated execution time in seconds. Used for scheduling and timeout calculations.`}) 
    EstimatedDurationSeconds?: number;
        
    @Field(() => Float, {nullable: true, description: `Estimated cost in USD for running this test (e.g., LLM token costs, compute resources). Used for budgeting and optimization.`}) 
    EstimatedCostUSD?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Number of times to repeat this test execution. NULL or 1 = single execution. Values > 1 will create multiple test runs for statistical analysis.`}) 
    RepeatCount?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum execution time in milliseconds for this test. If NULL, uses default (300000ms = 5 minutes). Can be overridden by Configuration JSON maxExecutionTime field for backward compatibility.`}) 
    MaxExecutionTimeMS?: number;
        
    @Field({nullable: true, description: `JSON configuration for which test type variables are exposed by this test, along with test-level defaults, locks, and value restrictions. References variables defined in the parent TestType.VariablesSchema.`}) 
    Variables?: string;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field(() => [MJTestRun_])
    MJ_TestRuns_TestIDArray: MJTestRun_[]; // Link to MJ_TestRuns
    
    @Field(() => [MJTestSuiteTest_])
    MJ_TestSuiteTests_TestIDArray: MJTestSuiteTest_[]; // Link to MJ_TestSuiteTests
    
}

//****************************************************************************
// INPUT TYPE for MJ: Tests
//****************************************************************************
@InputType()
export class CreateMJTestInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InputDefinition: string | null;

    @Field({ nullable: true })
    ExpectedOutcomes: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    Tags: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => Int, { nullable: true })
    EstimatedDurationSeconds: number | null;

    @Field(() => Float, { nullable: true })
    EstimatedCostUSD: number | null;

    @Field(() => Int, { nullable: true })
    RepeatCount: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS: number | null;

    @Field({ nullable: true })
    Variables: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Tests
//****************************************************************************
@InputType()
export class UpdateMJTestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InputDefinition?: string | null;

    @Field({ nullable: true })
    ExpectedOutcomes?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    Tags?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => Int, { nullable: true })
    EstimatedDurationSeconds?: number | null;

    @Field(() => Float, { nullable: true })
    EstimatedCostUSD?: number | null;

    @Field(() => Int, { nullable: true })
    RepeatCount?: number | null;

    @Field(() => Int, { nullable: true })
    MaxExecutionTimeMS?: number | null;

    @Field({ nullable: true })
    Variables?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Tests
//****************************************************************************
@ObjectType()
export class RunMJTestViewResult {
    @Field(() => [MJTest_])
    Results: MJTest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTest_)
export class MJTestResolver extends ResolverBase {
    @Query(() => RunMJTestViewResult)
    async RunMJTestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestViewResult)
    async RunMJTestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTestViewResult)
    async RunMJTestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Tests';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTest_, { nullable: true })
    async MJTest(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTest_ | null> {
        this.CheckUserReadPermissions('MJ: Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTests] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Tests', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTestRun_])
    async MJ_TestRuns_TestIDArray(@Root() mjtest_: MJTest_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRuns] WHERE [TestID]='${mjtest_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteTest_])
    async MJ_TestSuiteTests_TestIDArray(@Root() mjtest_: MJTest_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Tests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuiteTests] WHERE [TestID]='${mjtest_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Tests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Tests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTest_)
    async CreateMJTest(
        @Arg('input', () => CreateMJTestInput) input: CreateMJTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Tests', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTest_)
    async UpdateMJTest(
        @Arg('input', () => UpdateMJTestInput) input: UpdateMJTestInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Tests', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTest_)
    async DeleteMJTest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Tests', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Notification Preferences
//****************************************************************************
@ObjectType({ description: `Per-user preferences for each notification type (delivery method overrides)` })
export class MJUserNotificationPreference_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    NotificationTypeID: string;
        
    @Field(() => Boolean, {nullable: true, description: `User preference for in-app notifications (NULL = use default)`}) 
    InAppEnabled?: boolean;
        
    @Field(() => Boolean, {nullable: true, description: `User preference for email notifications (NULL = use default)`}) 
    EmailEnabled?: boolean;
        
    @Field(() => Boolean, {nullable: true, description: `User preference for SMS notifications (NULL = use default)`}) 
    SMSEnabled?: boolean;
        
    @Field(() => Boolean, {nullable: true}) 
    Enabled?: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(200)
    NotificationType: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Notification Preferences
//****************************************************************************
@InputType()
export class CreateMJUserNotificationPreferenceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    NotificationTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    InAppEnabled: boolean | null;

    @Field(() => Boolean, { nullable: true })
    EmailEnabled: boolean | null;

    @Field(() => Boolean, { nullable: true })
    SMSEnabled: boolean | null;

    @Field(() => Boolean, { nullable: true })
    Enabled?: boolean | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Notification Preferences
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationPreferenceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    NotificationTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    InAppEnabled?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    EmailEnabled?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    SMSEnabled?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    Enabled?: boolean | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Notification Preferences
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationPreferenceViewResult {
    @Field(() => [MJUserNotificationPreference_])
    Results: MJUserNotificationPreference_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotificationPreference_)
export class MJUserNotificationPreferenceResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationPreferenceViewResult)
    async RunMJUserNotificationPreferenceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationPreferenceViewResult)
    async RunMJUserNotificationPreferenceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationPreferenceViewResult)
    async RunMJUserNotificationPreferenceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Notification Preferences';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotificationPreference_, { nullable: true })
    async MJUserNotificationPreference(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotificationPreference_ | null> {
        this.CheckUserReadPermissions('MJ: User Notification Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotificationPreferences] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Notification Preferences', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserNotificationPreference_)
    async CreateMJUserNotificationPreference(
        @Arg('input', () => CreateMJUserNotificationPreferenceInput) input: CreateMJUserNotificationPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Notification Preferences', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotificationPreference_)
    async UpdateMJUserNotificationPreference(
        @Arg('input', () => UpdateMJUserNotificationPreferenceInput) input: UpdateMJUserNotificationPreferenceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Notification Preferences', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotificationPreference_)
    async DeleteMJUserNotificationPreference(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Notification Preferences', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Notification Types
//****************************************************************************
@ObjectType({ description: `Defines categories of notifications with delivery configuration and template associations` })
export class MJUserNotificationType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Unique name for the notification type (e.g., 'Agent Completion')`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    Description?: string;
        
    @Field(() => Boolean, {description: `Whether in-app notifications are enabled by default for this type`}) 
    DefaultInApp: boolean;
        
    @Field(() => Boolean, {description: `Whether email notifications are enabled by default for this type`}) 
    DefaultEmail: boolean;
        
    @Field(() => Boolean, {description: `Whether SMS notifications are enabled by default for this type`}) 
    DefaultSMS: boolean;
        
    @Field(() => Boolean, {nullable: true, description: `Whether users can override the default delivery method`}) 
    AllowUserPreference?: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EmailTemplateID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SMSTemplateID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Color?: string;
        
    @Field(() => Int, {nullable: true}) 
    AutoExpireDays?: number;
        
    @Field(() => Int, {nullable: true}) 
    Priority?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EmailTemplate?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SMSTemplate?: string;
        
    @Field(() => [MJUserNotification_])
    UserNotifications_NotificationTypeIDArray: MJUserNotification_[]; // Link to UserNotifications
    
    @Field(() => [MJUserNotificationPreference_])
    MJ_UserNotificationPreferences_NotificationTypeIDArray: MJUserNotificationPreference_[]; // Link to MJ_UserNotificationPreferences
    
}

//****************************************************************************
// INPUT TYPE for MJ: User Notification Types
//****************************************************************************
@InputType()
export class CreateMJUserNotificationTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInApp?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultSMS?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserPreference?: boolean | null;

    @Field({ nullable: true })
    EmailTemplateID: string | null;

    @Field({ nullable: true })
    SMSTemplateID: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    Color: string | null;

    @Field(() => Int, { nullable: true })
    AutoExpireDays: number | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Notification Types
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInApp?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultEmail?: boolean;

    @Field(() => Boolean, { nullable: true })
    DefaultSMS?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserPreference?: boolean | null;

    @Field({ nullable: true })
    EmailTemplateID?: string | null;

    @Field({ nullable: true })
    SMSTemplateID?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    Color?: string | null;

    @Field(() => Int, { nullable: true })
    AutoExpireDays?: number | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Notification Types
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationTypeViewResult {
    @Field(() => [MJUserNotificationType_])
    Results: MJUserNotificationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotificationType_)
export class MJUserNotificationTypeResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationTypeViewResult)
    async RunMJUserNotificationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationTypeViewResult)
    async RunMJUserNotificationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationTypeViewResult)
    async RunMJUserNotificationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Notification Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotificationType_, { nullable: true })
    async MJUserNotificationType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotificationType_ | null> {
        this.CheckUserReadPermissions('MJ: User Notification Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotificationTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Notification Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserNotification_])
    async UserNotifications_NotificationTypeIDArray(@Root() mjusernotificationtype_: MJUserNotificationType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [NotificationTypeID]='${mjusernotificationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Notifications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationPreference_])
    async MJ_UserNotificationPreferences_NotificationTypeIDArray(@Root() mjusernotificationtype_: MJUserNotificationType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotificationPreferences] WHERE [NotificationTypeID]='${mjusernotificationtype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserNotificationType_)
    async CreateMJUserNotificationType(
        @Arg('input', () => CreateMJUserNotificationTypeInput) input: CreateMJUserNotificationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Notification Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotificationType_)
    async UpdateMJUserNotificationType(
        @Arg('input', () => UpdateMJUserNotificationTypeInput) input: UpdateMJUserNotificationTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Notification Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotificationType_)
    async DeleteMJUserNotificationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Notification Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: User Settings
//****************************************************************************
@ObjectType({ description: `Generic key-value store for per-user settings. Allows any application or feature to persist user preferences.` })
export class MJUserSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The user this setting belongs to.`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `The setting key/name. Use namespaced keys like "DataExplorer.ViewMode" or "Dashboard.AI.CollapsedSections" to avoid collisions.`}) 
    @MaxLength(510)
    Setting: string;
        
    @Field({nullable: true, description: `The setting value. Can be simple text, numbers, booleans, or JSON for complex configuration objects.`}) 
    Value?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: User Settings
//****************************************************************************
@InputType()
export class CreateMJUserSettingInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Setting?: string;

    @Field({ nullable: true })
    Value: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: User Settings
//****************************************************************************
@InputType()
export class UpdateMJUserSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Setting?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: User Settings
//****************************************************************************
@ObjectType()
export class RunMJUserSettingViewResult {
    @Field(() => [MJUserSetting_])
    Results: MJUserSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserSetting_)
export class MJUserSettingResolver extends ResolverBase {
    @Query(() => RunMJUserSettingViewResult)
    async RunMJUserSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserSettingViewResult)
    async RunMJUserSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserSettingViewResult)
    async RunMJUserSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: User Settings';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserSetting_, { nullable: true })
    async MJUserSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserSetting_ | null> {
        this.CheckUserReadPermissions('MJ: User Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: User Settings', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserSetting_)
    async CreateMJUserSetting(
        @Arg('input', () => CreateMJUserSettingInput) input: CreateMJUserSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: User Settings', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserSetting_)
    async UpdateMJUserSetting(
        @Arg('input', () => UpdateMJUserSettingInput) input: UpdateMJUserSettingInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: User Settings', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserSetting_)
    async DeleteMJUserSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: User Settings', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Label Items
//****************************************************************************
@ObjectType({ description: `Links a Version Label to the specific RecordChange snapshot for each record captured by that label. Denormalizes EntityID and RecordID for efficient querying.` })
export class MJVersionLabelItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The version label this item belongs to`}) 
    @MaxLength(16)
    VersionLabelID: string;
        
    @Field({description: `The specific RecordChange entry representing the record state at label creation time`}) 
    @MaxLength(16)
    RecordChangeID: string;
        
    @Field({description: `Denormalized entity reference for query performance`}) 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `Denormalized record primary key for query performance`}) 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(400)
    VersionLabel: string;
        
    @Field() 
    RecordChange: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Version Label Items
//****************************************************************************
@InputType()
export class CreateMJVersionLabelItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    RecordChangeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Label Items
//****************************************************************************
@InputType()
export class UpdateMJVersionLabelItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    RecordChangeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Label Items
//****************************************************************************
@ObjectType()
export class RunMJVersionLabelItemViewResult {
    @Field(() => [MJVersionLabelItem_])
    Results: MJVersionLabelItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionLabelItem_)
export class MJVersionLabelItemResolver extends ResolverBase {
    @Query(() => RunMJVersionLabelItemViewResult)
    async RunMJVersionLabelItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelItemViewResult)
    async RunMJVersionLabelItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelItemViewResult)
    async RunMJVersionLabelItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Label Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionLabelItem_, { nullable: true })
    async MJVersionLabelItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionLabelItem_ | null> {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Label Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJVersionLabelItem_)
    async CreateMJVersionLabelItem(
        @Arg('input', () => CreateMJVersionLabelItemInput) input: CreateMJVersionLabelItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Label Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionLabelItem_)
    async UpdateMJVersionLabelItem(
        @Arg('input', () => UpdateMJVersionLabelItemInput) input: UpdateMJVersionLabelItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Label Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionLabelItem_)
    async DeleteMJVersionLabelItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Label Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Label Restores
//****************************************************************************
@ObjectType({ description: `Audit trail for restore operations performed against version labels. Tracks progress, success/failure counts, and links to the safety-net pre-restore label.` })
export class MJVersionLabelRestore_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The version label being restored to`}) 
    @MaxLength(16)
    VersionLabelID: string;
        
    @Field({description: `Current status of the restore operation`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `When the restore operation began`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `When the restore operation completed or failed`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `The user who initiated the restore`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Int, {description: `Total number of records to restore`}) 
    TotalItems: number;
        
    @Field(() => Int, {description: `Number of records successfully restored so far`}) 
    CompletedItems: number;
        
    @Field(() => Int, {description: `Number of records that failed to restore`}) 
    FailedItems: number;
        
    @Field({nullable: true, description: `Detailed error information for failed restore items`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Reference to the automatically created safety-net label that captured state before the restore began`}) 
    @MaxLength(16)
    PreRestoreLabelID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(400)
    VersionLabel: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    PreRestoreLabel?: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Version Label Restores
//****************************************************************************
@InputType()
export class CreateMJVersionLabelRestoreInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    TotalItems?: number;

    @Field(() => Int, { nullable: true })
    CompletedItems?: number;

    @Field(() => Int, { nullable: true })
    FailedItems?: number;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    PreRestoreLabelID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Label Restores
//****************************************************************************
@InputType()
export class UpdateMJVersionLabelRestoreInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    VersionLabelID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    TotalItems?: number;

    @Field(() => Int, { nullable: true })
    CompletedItems?: number;

    @Field(() => Int, { nullable: true })
    FailedItems?: number;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    PreRestoreLabelID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Label Restores
//****************************************************************************
@ObjectType()
export class RunMJVersionLabelRestoreViewResult {
    @Field(() => [MJVersionLabelRestore_])
    Results: MJVersionLabelRestore_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionLabelRestore_)
export class MJVersionLabelRestoreResolver extends ResolverBase {
    @Query(() => RunMJVersionLabelRestoreViewResult)
    async RunMJVersionLabelRestoreViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelRestoreViewResult)
    async RunMJVersionLabelRestoreViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelRestoreViewResult)
    async RunMJVersionLabelRestoreDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Label Restores';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionLabelRestore_, { nullable: true })
    async MJVersionLabelRestore(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionLabelRestore_ | null> {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelRestores] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Label Restores', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJVersionLabelRestore_)
    async CreateMJVersionLabelRestore(
        @Arg('input', () => CreateMJVersionLabelRestoreInput) input: CreateMJVersionLabelRestoreInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Label Restores', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionLabelRestore_)
    async UpdateMJVersionLabelRestore(
        @Arg('input', () => UpdateMJVersionLabelRestoreInput) input: UpdateMJVersionLabelRestoreInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Label Restores', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionLabelRestore_)
    async DeleteMJVersionLabelRestore(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Label Restores', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Version Labels
//****************************************************************************
@ObjectType({ description: `A named point-in-time bookmark into the RecordChange history, used for versioning, diffing, and restoration.` })
export class MJVersionLabel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Human-readable label name, e.g. Release 2.5, Pre-Refactor Snapshot`}) 
    @MaxLength(400)
    Name: string;
        
    @Field({nullable: true, description: `Optional longer description of what this label represents`}) 
    Description?: string;
        
    @Field({description: `Breadth of the label: Record (one record and its dependency graph, the primary use case), Entity (one entity type), or System (all entities). Parent grouping labels may use any scope as a logical container.`}) 
    @MaxLength(100)
    Scope: string;
        
    @Field({nullable: true, description: `When Scope is Entity or Record, identifies the target entity. NULL for System scope.`}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `When Scope is Record, identifies the specific record. NULL for System and Entity scopes.`}) 
    @MaxLength(1500)
    RecordID?: string;
        
    @Field({nullable: true, description: `Self-referencing parent for grouping related labels. When a user labels multiple records of the same entity, a parent label is created as the container and each individual record label references it via ParentID.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Lifecycle state: Active (current), Archived (historical reference only), Restored (this label was used in a restore operation)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({description: `The user who created this version label`}) 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field({nullable: true, description: `Optional reference to an external system identifier such as a git SHA, release tag, or deployment ID`}) 
    @MaxLength(400)
    ExternalSystemID?: string;
        
    @Field(() => Int, {description: `Total number of VersionLabelItem rows created for this label. Populated after label creation completes.`}) 
    ItemCount: number;
        
    @Field(() => Int, {description: `Time in milliseconds taken to create this label and all its items. Used for estimation of future label creation operations.`}) 
    CreationDurationMS: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJVersionLabelRestore_])
    MJ_VersionLabelRestores_PreRestoreLabelIDArray: MJVersionLabelRestore_[]; // Link to MJ_VersionLabelRestores
    
    @Field(() => [MJVersionLabelItem_])
    MJ_VersionLabelItems_VersionLabelIDArray: MJVersionLabelItem_[]; // Link to MJ_VersionLabelItems
    
    @Field(() => [MJVersionLabelRestore_])
    MJ_VersionLabelRestores_VersionLabelIDArray: MJVersionLabelRestore_[]; // Link to MJ_VersionLabelRestores
    
    @Field(() => [MJVersionLabel_])
    MJ_VersionLabels_ParentIDArray: MJVersionLabel_[]; // Link to MJ_VersionLabels
    
}

//****************************************************************************
// INPUT TYPE for MJ: Version Labels
//****************************************************************************
@InputType()
export class CreateMJVersionLabelInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ExternalSystemID: string | null;

    @Field(() => Int, { nullable: true })
    ItemCount?: number;

    @Field(() => Int, { nullable: true })
    CreationDurationMS?: number;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Version Labels
//****************************************************************************
@InputType()
export class UpdateMJVersionLabelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Scope?: string;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Int, { nullable: true })
    ItemCount?: number;

    @Field(() => Int, { nullable: true })
    CreationDurationMS?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Version Labels
//****************************************************************************
@ObjectType()
export class RunMJVersionLabelViewResult {
    @Field(() => [MJVersionLabel_])
    Results: MJVersionLabel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionLabel_)
export class MJVersionLabelResolver extends ResolverBase {
    @Query(() => RunMJVersionLabelViewResult)
    async RunMJVersionLabelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelViewResult)
    async RunMJVersionLabelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionLabelViewResult)
    async RunMJVersionLabelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Version Labels';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionLabel_, { nullable: true })
    async MJVersionLabel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionLabel_ | null> {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('MJ: Version Labels', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJVersionLabelRestore_])
    async MJ_VersionLabelRestores_PreRestoreLabelIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelRestores] WHERE [PreRestoreLabelID]='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Restores', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelItem_])
    async MJ_VersionLabelItems_VersionLabelIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelItems] WHERE [VersionLabelID]='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelRestore_])
    async MJ_VersionLabelRestores_VersionLabelIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelRestores] WHERE [VersionLabelID]='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Restores', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabel_])
    async MJ_VersionLabels_ParentIDArray(@Root() mjversionlabel_: MJVersionLabel_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabels] WHERE [ParentID]='${mjversionlabel_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Labels', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJVersionLabel_)
    async CreateMJVersionLabel(
        @Arg('input', () => CreateMJVersionLabelInput) input: CreateMJVersionLabelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('MJ: Version Labels', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionLabel_)
    async UpdateMJVersionLabel(
        @Arg('input', () => UpdateMJVersionLabelInput) input: UpdateMJVersionLabelInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('MJ: Version Labels', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionLabel_)
    async DeleteMJVersionLabel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Version Labels', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Delivery Types
//****************************************************************************
@ObjectType({ description: `Defines methods for delivering generated outputs such as email, file storage, API endpoints, or messaging platforms.` })
export class MJOutputDeliveryType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    Reports_OutputDeliveryTypeIDArray: MJReport_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Output Delivery Types
//****************************************************************************
@InputType()
export class CreateMJOutputDeliveryTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Output Delivery Types
//****************************************************************************
@InputType()
export class UpdateMJOutputDeliveryTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Output Delivery Types
//****************************************************************************
@ObjectType()
export class RunMJOutputDeliveryTypeViewResult {
    @Field(() => [MJOutputDeliveryType_])
    Results: MJOutputDeliveryType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputDeliveryType_)
export class MJOutputDeliveryTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputDeliveryTypeViewResult)
    async RunMJOutputDeliveryTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Delivery Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputDeliveryType_, { nullable: true })
    async MJOutputDeliveryType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputDeliveryType_ | null> {
        this.CheckUserReadPermissions('Output Delivery Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputDeliveryTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Delivery Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Output Delivery Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputDeliveryTypeIDArray(@Root() mjoutputdeliverytype_: MJOutputDeliveryType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputDeliveryTypeID]='${mjoutputdeliverytype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOutputDeliveryType_)
    async CreateMJOutputDeliveryType(
        @Arg('input', () => CreateMJOutputDeliveryTypeInput) input: CreateMJOutputDeliveryTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Output Delivery Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOutputDeliveryType_)
    async UpdateMJOutputDeliveryType(
        @Arg('input', () => UpdateMJOutputDeliveryTypeInput) input: UpdateMJOutputDeliveryTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Output Delivery Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOutputDeliveryType_)
    async DeleteMJOutputDeliveryType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Output Delivery Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Format Types
//****************************************************************************
@ObjectType({ description: `Specifies available output formats for generated content including PDF, Excel, CSV, JSON, and custom formats.` })
export class MJOutputFormatType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Configuration or template for how data should be formatted in this output type.`}) 
    DisplayFormat?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    Reports_OutputFormatTypeIDArray: MJReport_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Output Format Types
//****************************************************************************
@InputType()
export class CreateMJOutputFormatTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DisplayFormat: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Output Format Types
//****************************************************************************
@InputType()
export class UpdateMJOutputFormatTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DisplayFormat?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Output Format Types
//****************************************************************************
@ObjectType()
export class RunMJOutputFormatTypeViewResult {
    @Field(() => [MJOutputFormatType_])
    Results: MJOutputFormatType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputFormatType_)
export class MJOutputFormatTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputFormatTypeViewResult)
    async RunMJOutputFormatTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Format Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputFormatType_, { nullable: true })
    async MJOutputFormatType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputFormatType_ | null> {
        this.CheckUserReadPermissions('Output Format Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputFormatTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Format Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Output Format Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputFormatTypeIDArray(@Root() mjoutputformattype_: MJOutputFormatType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputFormatTypeID]='${mjoutputformattype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOutputFormatType_)
    async CreateMJOutputFormatType(
        @Arg('input', () => CreateMJOutputFormatTypeInput) input: CreateMJOutputFormatTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Output Format Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOutputFormatType_)
    async UpdateMJOutputFormatType(
        @Arg('input', () => UpdateMJOutputFormatTypeInput) input: UpdateMJOutputFormatTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Output Format Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOutputFormatType_)
    async DeleteMJOutputFormatType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Output Format Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Trigger Types
//****************************************************************************
@ObjectType({ description: `Defines events that can trigger output generation such as schedules, data changes, or manual requests.` })
export class MJOutputTriggerType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJReport_])
    Reports_OutputTriggerTypeIDArray: MJReport_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Output Trigger Types
//****************************************************************************
@InputType()
export class CreateMJOutputTriggerTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Output Trigger Types
//****************************************************************************
@InputType()
export class UpdateMJOutputTriggerTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Output Trigger Types
//****************************************************************************
@ObjectType()
export class RunMJOutputTriggerTypeViewResult {
    @Field(() => [MJOutputTriggerType_])
    Results: MJOutputTriggerType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJOutputTriggerType_)
export class MJOutputTriggerTypeResolver extends ResolverBase {
    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJOutputTriggerTypeViewResult)
    async RunMJOutputTriggerTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Trigger Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJOutputTriggerType_, { nullable: true })
    async MJOutputTriggerType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJOutputTriggerType_ | null> {
        this.CheckUserReadPermissions('Output Trigger Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputTriggerTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Output Trigger Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Output Trigger Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputTriggerTypeIDArray(@Root() mjoutputtriggertype_: MJOutputTriggerType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputTriggerTypeID]='${mjoutputtriggertype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJOutputTriggerType_)
    async CreateMJOutputTriggerType(
        @Arg('input', () => CreateMJOutputTriggerTypeInput) input: CreateMJOutputTriggerTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Output Trigger Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJOutputTriggerType_)
    async UpdateMJOutputTriggerType(
        @Arg('input', () => UpdateMJOutputTriggerTypeInput) input: UpdateMJOutputTriggerTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Output Trigger Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJOutputTriggerType_)
    async DeleteMJOutputTriggerType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Output Trigger Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queries
//****************************************************************************
@ObjectType({ description: `Catalog of stored queries. This is useful for any arbitrary query that is known to be performant and correct and can be reused. Queries can be viewed/run by a user, used programatically via RunQuery, and also used by AI systems for improved reliability instead of dynamically generated SQL. Queries can also improve security since they store the SQL instead of using dynamic SQL.` })
export class MJQuery_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `The natural language question this query answers, used for AI query selection.`}) 
    UserQuestion?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `The actual SQL query text to execute, may include parameters.`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Technical documentation of the query logic, performance considerations, and parameter usage.`}) 
    TechnicalDescription?: string;
        
    @Field({nullable: true, description: `The original SQL before any optimization or modification, kept for reference.`}) 
    OriginalSQL?: string;
        
    @Field({nullable: true, description: `User feedback on query accuracy, performance, or suggested improvements.`}) 
    Feedback?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Value indicating the quality of the query, higher values mean a better quality`}) 
    QualityRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Higher numbers indicate more execution overhead/time required. Useful for planning which queries to use in various scenarios.`}) 
    ExecutionCostRank?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {nullable: true, description: `Automatically set to true when the SQL column contains Nunjucks template markers (e.g., {{ paramName }}). This flag is maintained by the QueryEntityServer for performance optimization and discovery purposes. It allows quick filtering of parameterized queries and enables the UI to show parameter inputs only when needed. The system will automatically update this flag when the SQL content changes.`}) 
    UsesTemplate?: boolean;
        
    @Field(() => Boolean, {description: `When true, all executions of this query will be logged to the Audit Log system for tracking and compliance`}) 
    AuditQueryRuns: boolean;
        
    @Field(() => Boolean, {description: `When true, enables query result caching. Caching behavior depends on CacheValidationSQL: (1) If CacheValidationSQL is NULL, uses simple server-side TTL caching based on CacheTTLMinutes - results are cached on the server and expire after the TTL period. (2) If CacheValidationSQL is set, enables smart client-side caching with freshness validation - client sends cache fingerprint (maxUpdatedAt + rowCount) to server, server validates using CacheValidationSQL and returns 'current' (use cached) or 'stale' (with fresh data). Smart caching provides real-time accuracy while minimizing data transfer.`}) 
    CacheEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Time-to-live in minutes for cached query results. NULL uses default TTL.`}) 
    CacheTTLMinutes?: number;
        
    @Field(() => Int, {nullable: true, description: `Maximum number of cached result sets for this query. NULL uses default size limit.`}) 
    CacheMaxSize?: number;
        
    @Field({nullable: true, description: `Optional JSON-serialized embedding vector for the query, used for similarity search and query analysis`}) 
    EmbeddingVector?: string;
        
    @Field({nullable: true, description: `The AI Model used to generate the embedding vector for this query. Required for vector similarity comparisons.`}) 
    @MaxLength(16)
    EmbeddingModelID?: string;
        
    @Field({nullable: true, description: `SQL query used to validate cache freshness for smart caching. When set (and CacheEnabled=true), enables smart cache validation instead of simple TTL expiration. This query MUST return exactly two columns: MaxUpdatedAt (datetime/datetimeoffset) and TotalRows (int). The query has access to the same Nunjucks parameters as the main query SQL. When NULL, caching uses TTL-only behavior based on CacheTTLMinutes. Example: SELECT MAX(__mj_UpdatedAt) AS MaxUpdatedAt, COUNT(*) AS TotalRows FROM Orders WHERE Status = '{{ status }}'`}) 
    CacheValidationSQL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmbeddingModel?: string;
        
    @Field(() => [MJQueryField_])
    QueryFields_QueryIDArray: MJQueryField_[]; // Link to QueryFields
    
    @Field(() => [MJQueryPermission_])
    QueryPermissions_QueryIDArray: MJQueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [MJDataContextItem_])
    DataContextItems_QueryIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [MJQueryParameter_])
    MJ_QueryParameters_QueryIDArray: MJQueryParameter_[]; // Link to MJ_QueryParameters
    
    @Field(() => [MJQueryEntity_])
    QueryEntities_QueryIDArray: MJQueryEntity_[]; // Link to QueryEntities
    
}

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class CreateMJQueryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserQuestion: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    TechnicalDescription: string | null;

    @Field({ nullable: true })
    OriginalSQL: string | null;

    @Field({ nullable: true })
    Feedback: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank: number | null;

    @Field(() => Boolean, { nullable: true })
    UsesTemplate?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    AuditQueryRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLMinutes: number | null;

    @Field(() => Int, { nullable: true })
    CacheMaxSize: number | null;

    @Field({ nullable: true })
    EmbeddingVector: string | null;

    @Field({ nullable: true })
    EmbeddingModelID: string | null;

    @Field({ nullable: true })
    CacheValidationSQL: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class UpdateMJQueryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserQuestion?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    TechnicalDescription?: string | null;

    @Field({ nullable: true })
    OriginalSQL?: string | null;

    @Field({ nullable: true })
    Feedback?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    UsesTemplate?: boolean | null;

    @Field(() => Boolean, { nullable: true })
    AuditQueryRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    CacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    CacheTTLMinutes?: number | null;

    @Field(() => Int, { nullable: true })
    CacheMaxSize?: number | null;

    @Field({ nullable: true })
    EmbeddingVector?: string | null;

    @Field({ nullable: true })
    EmbeddingModelID?: string | null;

    @Field({ nullable: true })
    CacheValidationSQL?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queries
//****************************************************************************
@ObjectType()
export class RunMJQueryViewResult {
    @Field(() => [MJQuery_])
    Results: MJQuery_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQuery_)
export class MJQueryResolver extends ResolverBase {
    @Query(() => RunMJQueryViewResult)
    async RunMJQueryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryViewResult)
    async RunMJQueryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryViewResult)
    async RunMJQueryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queries';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQuery_, { nullable: true })
    async MJQuery(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQuery_ | null> {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Queries', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueryField_])
    async QueryFields_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Fields', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryPermission_])
    async QueryPermissions_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryParameter_])
    async MJ_QueryParameters_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Query Parameters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryParameters] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Query Parameters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Query Parameters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryEntity_])
    async QueryEntities_QueryIDArray(@Root() mjquery_: MJQuery_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [QueryID]='${mjquery_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQuery_)
    async CreateMJQuery(
        @Arg('input', () => CreateMJQueryInput) input: CreateMJQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queries', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQuery_)
    async UpdateMJQuery(
        @Arg('input', () => UpdateMJQueryInput) input: UpdateMJQueryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queries', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQuery_)
    async DeleteMJQuery(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queries', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Categories
//****************************************************************************
@ObjectType({ description: `Organizes saved queries into categories for discovery and management, supporting folder-like organization of queries.` })
export class MJQueryCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Default cache setting for queries in this category`}) 
    DefaultCacheEnabled: boolean;
        
    @Field(() => Int, {nullable: true, description: `Default TTL in minutes for cached results of queries in this category`}) 
    DefaultCacheTTLMinutes?: number;
        
    @Field(() => Int, {nullable: true, description: `Default maximum cache size for queries in this category`}) 
    DefaultCacheMaxSize?: number;
        
    @Field(() => Boolean, {description: `When true, queries without cache config will inherit from this category`}) 
    CacheInheritanceEnabled: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJQueryCategory_])
    QueryCategories_ParentIDArray: MJQueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [MJQuery_])
    Queries_CategoryIDArray: MJQuery_[]; // Link to Queries
    
}

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class CreateMJQueryCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    DefaultCacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    DefaultCacheTTLMinutes: number | null;

    @Field(() => Int, { nullable: true })
    DefaultCacheMaxSize: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheInheritanceEnabled?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class UpdateMJQueryCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Boolean, { nullable: true })
    DefaultCacheEnabled?: boolean;

    @Field(() => Int, { nullable: true })
    DefaultCacheTTLMinutes?: number | null;

    @Field(() => Int, { nullable: true })
    DefaultCacheMaxSize?: number | null;

    @Field(() => Boolean, { nullable: true })
    CacheInheritanceEnabled?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Categories
//****************************************************************************
@ObjectType()
export class RunMJQueryCategoryViewResult {
    @Field(() => [MJQueryCategory_])
    Results: MJQueryCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryCategory_)
export class MJQueryCategoryResolver extends ResolverBase {
    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryCategoryViewResult)
    async RunMJQueryCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryCategory_, { nullable: true })
    async MJQueryCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryCategory_ | null> {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Query Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueryCategory_])
    async QueryCategories_ParentIDArray(@Root() mjquerycategory_: MJQueryCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ParentID]='${mjquerycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQuery_])
    async Queries_CategoryIDArray(@Root() mjquerycategory_: MJQueryCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queries', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [CategoryID]='${mjquerycategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queries', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Queries', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQueryCategory_)
    async CreateMJQueryCategory(
        @Arg('input', () => CreateMJQueryCategoryInput) input: CreateMJQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryCategory_)
    async UpdateMJQueryCategory(
        @Arg('input', () => UpdateMJQueryCategoryInput) input: UpdateMJQueryCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryCategory_)
    async DeleteMJQueryCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Entities
//****************************************************************************
@ObjectType({ description: `Tracks which entities are involved in a given query. The Queries table stores SQL and descriptions for stored queries that can be executed and serve as examples for AI.` })
export class MJQueryEntity_ {
    @Field({description: `Unique identifier for the QueryEntity record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the ID of the query in the Queries table.`}) 
    @MaxLength(16)
    QueryID: string;
        
    @Field({description: `References the ID of the entity in the Entities table.`}) 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates how this entity-query relationship was identified. "AI" means the QueryEntityServer used LLM analysis to parse the SQL/template and identify which MemberJunction entities are referenced (by analyzing table names, joins, and query structure). "Manual" means a user explicitly marked this entity as being used by the query. AI detection helps maintain accurate metadata automatically as queries evolve.`}) 
    @MaxLength(100)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was that this entity is actually used in the query. Only populated when DetectionMethod="AI". Considers factors like: direct table references vs indirect joins, clear entity names vs ambiguous aliases, and context from the query purpose. Lower scores might indicate the entity is only peripherally involved or the detection was uncertain.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class CreateMJQueryEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class UpdateMJQueryEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Entities
//****************************************************************************
@ObjectType()
export class RunMJQueryEntityViewResult {
    @Field(() => [MJQueryEntity_])
    Results: MJQueryEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryEntity_)
export class MJQueryEntityResolver extends ResolverBase {
    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryEntityViewResult)
    async RunMJQueryEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryEntity_, { nullable: true })
    async MJQueryEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryEntity_ | null> {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Query Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryEntity_)
    async CreateMJQueryEntity(
        @Arg('input', () => CreateMJQueryEntityInput) input: CreateMJQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryEntity_)
    async UpdateMJQueryEntity(
        @Arg('input', () => UpdateMJQueryEntityInput) input: UpdateMJQueryEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryEntity_)
    async DeleteMJQueryEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Fields
//****************************************************************************
@ObjectType({ description: `Stores field-level metadata for queries including display names, data types, and formatting rules for result presentation.` })
export class MJQueryField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Int, {description: `Display order of this field in query results.`}) 
    Sequence: number;
        
    @Field({description: `The base type, not including parameters, in SQL. For example this field would be nvarchar or decimal, and wouldn't include type parameters. The SQLFullType field provides that information.`}) 
    @MaxLength(100)
    SQLBaseType: string;
        
    @Field({description: `The full SQL type for the field, for example datetime or nvarchar(10) etc.`}) 
    @MaxLength(200)
    SQLFullType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SourceEntityID?: string;
        
    @Field({nullable: true, description: `The original field name from the SQL query if different from the display name.`}) 
    @MaxLength(510)
    SourceFieldName?: string;
        
    @Field(() => Boolean, {description: `Indicates if this field is calculated from other fields rather than directly from the database.`}) 
    IsComputed: boolean;
        
    @Field({nullable: true, description: `Explanation of how this computed field is calculated.`}) 
    ComputationDescription?: string;
        
    @Field(() => Boolean, {description: `Whether this field represents an aggregate or summary value.`}) 
    IsSummary: boolean;
        
    @Field({nullable: true, description: `Description of what this summary field represents and how it's aggregated.`}) 
    SummaryDescription?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates how this field was identified in the query output. "AI" means the QueryEntityServer used LLM analysis to parse the SELECT clause and determine field names, types, and their source entities/columns. This includes handling aliased columns, computed expressions, aggregations, and CASE statements. "Manual" means a user explicitly defined this output field. AI detection ensures the field list stays synchronized with query changes.`}) 
    @MaxLength(100)
    DetectionMethod: string;
        
    @Field(() => Float, {nullable: true, description: `Confidence score (0.00-1.00) indicating how certain the AI was about this field detection. Only populated when DetectionMethod="AI". Factors include: clarity of the SELECT clause, complexity of any expressions or transformations, confidence in type inference, and ability to trace back to source entity/column. Complex computed fields or ambiguous aliases result in lower scores. This helps identify fields that may need manual verification.`}) 
    AutoDetectConfidenceScore?: number;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class CreateMJQueryFieldInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID: string | null;

    @Field({ nullable: true })
    SourceFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class UpdateMJQueryFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID?: string | null;

    @Field({ nullable: true })
    SourceFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription?: string | null;

    @Field({ nullable: true })
    DetectionMethod?: string;

    @Field(() => Float, { nullable: true })
    AutoDetectConfidenceScore?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Fields
//****************************************************************************
@ObjectType()
export class RunMJQueryFieldViewResult {
    @Field(() => [MJQueryField_])
    Results: MJQueryField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryField_)
export class MJQueryFieldResolver extends ResolverBase {
    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryFieldViewResult)
    async RunMJQueryFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Fields';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryField_, { nullable: true })
    async MJQueryField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryField_ | null> {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Query Fields', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryField_)
    async CreateMJQueryField(
        @Arg('input', () => CreateMJQueryFieldInput) input: CreateMJQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Fields', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryField_)
    async UpdateMJQueryField(
        @Arg('input', () => UpdateMJQueryFieldInput) input: UpdateMJQueryFieldInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Fields', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryField_)
    async DeleteMJQueryField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Fields', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Permissions
//****************************************************************************
@ObjectType({ description: `Controls access to queries by defining which users and roles can run specific queries.` })
export class MJQueryPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class CreateMJQueryPermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class UpdateMJQueryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Permissions
//****************************************************************************
@ObjectType()
export class RunMJQueryPermissionViewResult {
    @Field(() => [MJQueryPermission_])
    Results: MJQueryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueryPermission_)
export class MJQueryPermissionResolver extends ResolverBase {
    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueryPermissionViewResult)
    async RunMJQueryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueryPermission_, { nullable: true })
    async MJQueryPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueryPermission_ | null> {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Query Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueryPermission_)
    async CreateMJQueryPermission(
        @Arg('input', () => CreateMJQueryPermissionInput) input: CreateMJQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Query Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueryPermission_)
    async UpdateMJQueryPermission(
        @Arg('input', () => UpdateMJQueryPermissionInput) input: UpdateMJQueryPermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Query Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueryPermission_)
    async DeleteMJQueryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Tasks
//****************************************************************************
@ObjectType({ description: `Manages asynchronous tasks in processing queues, tracking status, priority, and execution details for background operations.` })
export class MJQueueTask_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueueID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({nullable: true, description: `JSON payload containing the data needed to process this task.`}) 
    Data?: string;
        
    @Field({nullable: true, description: `JSON configuration options for how this task should be processed.`}) 
    Options?: string;
        
    @Field({nullable: true, description: `Result data from task execution, typically in JSON format.`}) 
    Output?: string;
        
    @Field({nullable: true, description: `Error details if the task failed during processing.`}) 
    ErrorMessage?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Queue: string;
        
}

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class CreateMJQueueTaskInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field({ nullable: true })
    Options: string | null;

    @Field({ nullable: true })
    Output: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class UpdateMJQueueTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field({ nullable: true })
    Options?: string | null;

    @Field({ nullable: true })
    Output?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queue Tasks
//****************************************************************************
@ObjectType()
export class RunMJQueueTaskViewResult {
    @Field(() => [MJQueueTask_])
    Results: MJQueueTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueueTask_)
export class MJQueueTaskResolver extends ResolverBase {
    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTaskViewResult)
    async RunMJQueueTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Tasks';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueueTask_, { nullable: true })
    async MJQueueTask(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueueTask_ | null> {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Queue Tasks', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJQueueTask_)
    async CreateMJQueueTask(
        @Arg('input', () => CreateMJQueueTaskInput) input: CreateMJQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queue Tasks', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueueTask_)
    async UpdateMJQueueTask(
        @Arg('input', () => UpdateMJQueueTaskInput) input: UpdateMJQueueTaskInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queue Tasks', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueueTask_)
    async DeleteMJQueueTask(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queue Tasks', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Types
//****************************************************************************
@ObjectType({ description: `Defines different types of processing queues with specific behaviors, priorities, and processing rules for task management.` })
export class MJQueueType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Field DriverClass for entity Queue Types.`}) 
    @MaxLength(200)
    DriverClass: string;
        
    @Field({nullable: true, description: `Field DriverImportPath for entity Queue Types.`}) 
    @MaxLength(400)
    DriverImportPath?: string;
        
    @Field(() => Boolean, {description: `Field IsActive for entity Queue Types.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJQueue_])
    Queues_QueueTypeIDArray: MJQueue_[]; // Link to Queues
    
}

//****************************************************************************
// INPUT TYPE for Queue Types
//****************************************************************************
@InputType()
export class CreateMJQueueTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Queue Types
//****************************************************************************
@InputType()
export class UpdateMJQueueTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queue Types
//****************************************************************************
@ObjectType()
export class RunMJQueueTypeViewResult {
    @Field(() => [MJQueueType_])
    Results: MJQueueType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueueType_)
export class MJQueueTypeResolver extends ResolverBase {
    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueTypeViewResult)
    async RunMJQueueTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueueType_, { nullable: true })
    async MJQueueType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueueType_ | null> {
        this.CheckUserReadPermissions('Queue Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Queue Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueue_])
    async Queues_QueueTypeIDArray(@Root() mjqueuetype_: MJQueueType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [QueueTypeID]='${mjqueuetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Queues', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQueueType_)
    async CreateMJQueueType(
        @Arg('input', () => CreateMJQueueTypeInput) input: CreateMJQueueTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queue Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueueType_)
    async UpdateMJQueueType(
        @Arg('input', () => UpdateMJQueueTypeInput) input: UpdateMJQueueTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queue Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueueType_)
    async DeleteMJQueueType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queue Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queues
//****************************************************************************
@ObjectType({ description: `Queues can be used to async execute long running tasks` })
export class MJQueue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    QueueTypeID: string;
        
    @Field(() => Boolean, {description: `Field IsActive for entity Queues.`}) 
    IsActive: boolean;
        
    @Field(() => Int, {nullable: true, description: `Field ProcessPID for entity Queues.`}) 
    ProcessPID?: number;
        
    @Field({nullable: true, description: `Field ProcessPlatform for entity Queues.`}) 
    @MaxLength(60)
    ProcessPlatform?: string;
        
    @Field({nullable: true, description: `Field ProcessVersion for entity Queues.`}) 
    @MaxLength(30)
    ProcessVersion?: string;
        
    @Field({nullable: true, description: `Field ProcessCwd for entity Queues.`}) 
    @MaxLength(200)
    ProcessCwd?: string;
        
    @Field({nullable: true, description: `Field ProcessIPAddress for entity Queues.`}) 
    @MaxLength(100)
    ProcessIPAddress?: string;
        
    @Field({nullable: true, description: `Field ProcessMacAddress for entity Queues.`}) 
    @MaxLength(100)
    ProcessMacAddress?: string;
        
    @Field({nullable: true, description: `Field ProcessOSName for entity Queues.`}) 
    @MaxLength(50)
    ProcessOSName?: string;
        
    @Field({nullable: true, description: `Field ProcessOSVersion for entity Queues.`}) 
    @MaxLength(20)
    ProcessOSVersion?: string;
        
    @Field({nullable: true, description: `Field ProcessHostName for entity Queues.`}) 
    @MaxLength(100)
    ProcessHostName?: string;
        
    @Field({nullable: true, description: `Field ProcessUserID for entity Queues.`}) 
    @MaxLength(50)
    ProcessUserID?: string;
        
    @Field({nullable: true, description: `Field ProcessUserName for entity Queues.`}) 
    @MaxLength(100)
    ProcessUserName?: string;
        
    @Field({description: `Field LastHeartbeat for entity Queues.`}) 
    @MaxLength(10)
    LastHeartbeat: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    QueueType: string;
        
    @Field(() => [MJQueueTask_])
    QueueTasks_QueueIDArray: MJQueueTask_[]; // Link to QueueTasks
    
}

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class CreateMJQueueInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID: number | null;

    @Field({ nullable: true })
    ProcessPlatform: string | null;

    @Field({ nullable: true })
    ProcessVersion: string | null;

    @Field({ nullable: true })
    ProcessCwd: string | null;

    @Field({ nullable: true })
    ProcessIPAddress: string | null;

    @Field({ nullable: true })
    ProcessMacAddress: string | null;

    @Field({ nullable: true })
    ProcessOSName: string | null;

    @Field({ nullable: true })
    ProcessOSVersion: string | null;

    @Field({ nullable: true })
    ProcessHostName: string | null;

    @Field({ nullable: true })
    ProcessUserID: string | null;

    @Field({ nullable: true })
    ProcessUserName: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class UpdateMJQueueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID?: number | null;

    @Field({ nullable: true })
    ProcessPlatform?: string | null;

    @Field({ nullable: true })
    ProcessVersion?: string | null;

    @Field({ nullable: true })
    ProcessCwd?: string | null;

    @Field({ nullable: true })
    ProcessIPAddress?: string | null;

    @Field({ nullable: true })
    ProcessMacAddress?: string | null;

    @Field({ nullable: true })
    ProcessOSName?: string | null;

    @Field({ nullable: true })
    ProcessOSVersion?: string | null;

    @Field({ nullable: true })
    ProcessHostName?: string | null;

    @Field({ nullable: true })
    ProcessUserID?: string | null;

    @Field({ nullable: true })
    ProcessUserName?: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queues
//****************************************************************************
@ObjectType()
export class RunMJQueueViewResult {
    @Field(() => [MJQueue_])
    Results: MJQueue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJQueue_)
export class MJQueueResolver extends ResolverBase {
    @Query(() => RunMJQueueViewResult)
    async RunMJQueueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueViewResult)
    async RunMJQueueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJQueueViewResult)
    async RunMJQueueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queues';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJQueue_, { nullable: true })
    async MJQueue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJQueue_ | null> {
        this.CheckUserReadPermissions('Queues', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queues', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Queues', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJQueueTask_])
    async QueueTasks_QueueIDArray(@Root() mjqueue_: MJQueue_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [QueueID]='${mjqueue_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Queue Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJQueue_)
    async CreateMJQueue(
        @Arg('input', () => CreateMJQueueInput) input: CreateMJQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Queues', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJQueue_)
    async UpdateMJQueue(
        @Arg('input', () => UpdateMJQueueInput) input: UpdateMJQueueInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Queues', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJQueue_)
    async DeleteMJQueue(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queues', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Items
//****************************************************************************
@ObjectType({ description: `Table to store individual recommendation items that are the right side of the recommendation which we track in the DestinationEntityID/DestinationEntityRecordID` })
export class MJRecommendationItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationID: string;
        
    @Field() 
    @MaxLength(16)
    DestinationEntityID: string;
        
    @Field({description: `The record ID of the destination entity`}) 
    @MaxLength(900)
    DestinationEntityRecordID: string;
        
    @Field(() => Float, {nullable: true, description: `A value between 0 and 1 indicating the probability of the match, higher numbers indicating a more certain match/recommendation.`}) 
    MatchProbability?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    Recommendation: string;
        
    @Field() 
    @MaxLength(510)
    DestinationEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class CreateMJRecommendationItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class UpdateMJRecommendationItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Items
//****************************************************************************
@ObjectType()
export class RunMJRecommendationItemViewResult {
    @Field(() => [MJRecommendationItem_])
    Results: MJRecommendationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationItem_)
export class MJRecommendationItemResolver extends ResolverBase {
    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationItemViewResult)
    async RunMJRecommendationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationItem_, { nullable: true })
    async MJRecommendationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationItem_ | null> {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Recommendation Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJRecommendationItem_)
    async CreateMJRecommendationItem(
        @Arg('input', () => CreateMJRecommendationItemInput) input: CreateMJRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationItem_)
    async UpdateMJRecommendationItem(
        @Arg('input', () => UpdateMJRecommendationItemInput) input: UpdateMJRecommendationItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationItem_)
    async DeleteMJRecommendationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Providers
//****************************************************************************
@ObjectType({ description: `Recommendation providers details` })
export class MJRecommendationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJRecommendationRun_])
    RecommendationRuns_RecommendationProviderIDArray: MJRecommendationRun_[]; // Link to RecommendationRuns
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class CreateMJRecommendationProviderInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class UpdateMJRecommendationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Providers
//****************************************************************************
@ObjectType()
export class RunMJRecommendationProviderViewResult {
    @Field(() => [MJRecommendationProvider_])
    Results: MJRecommendationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationProvider_)
export class MJRecommendationProviderResolver extends ResolverBase {
    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationProviderViewResult)
    async RunMJRecommendationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Providers';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationProvider_, { nullable: true })
    async MJRecommendationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationProvider_ | null> {
        this.CheckUserReadPermissions('Recommendation Providers', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Providers', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Recommendation Providers', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecommendationRun_])
    async RecommendationRuns_RecommendationProviderIDArray(@Root() mjrecommendationprovider_: MJRecommendationProvider_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RecommendationProviderID]='${mjrecommendationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecommendationProvider_)
    async CreateMJRecommendationProvider(
        @Arg('input', () => CreateMJRecommendationProviderInput) input: CreateMJRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Providers', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationProvider_)
    async UpdateMJRecommendationProvider(
        @Arg('input', () => UpdateMJRecommendationProviderInput) input: UpdateMJRecommendationProviderInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Providers', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationProvider_)
    async DeleteMJRecommendationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Providers', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Runs
//****************************************************************************
@ObjectType({ description: `Recommendation runs log each time a provider is requested to provide recommendations` })
export class MJRecommendationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationProviderID: string;
        
    @Field({description: `The start date of the recommendation run`}) 
    @MaxLength(10)
    StartDate: Date;
        
    @Field({nullable: true, description: `The end date of the recommendation run`}) 
    @MaxLength(10)
    EndDate?: Date;
        
    @Field({description: `The status of the recommendation run`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    RecommendationProvider: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJRecommendation_])
    Recommendations_RecommendationRunIDArray: MJRecommendation_[]; // Link to Recommendations
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class CreateMJRecommendationRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class UpdateMJRecommendationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Runs
//****************************************************************************
@ObjectType()
export class RunMJRecommendationRunViewResult {
    @Field(() => [MJRecommendationRun_])
    Results: MJRecommendationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendationRun_)
export class MJRecommendationRunResolver extends ResolverBase {
    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationRunViewResult)
    async RunMJRecommendationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendationRun_, { nullable: true })
    async MJRecommendationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendationRun_ | null> {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Recommendation Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecommendation_])
    async Recommendations_RecommendationRunIDArray(@Root() mjrecommendationrun_: MJRecommendationRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [RecommendationRunID]='${mjrecommendationrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Recommendations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecommendationRun_)
    async CreateMJRecommendationRun(
        @Arg('input', () => CreateMJRecommendationRunInput) input: CreateMJRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendation Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendationRun_)
    async UpdateMJRecommendationRun(
        @Arg('input', () => UpdateMJRecommendationRunInput) input: UpdateMJRecommendationRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendation Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendationRun_)
    async DeleteMJRecommendationRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendations
//****************************************************************************
@ObjectType({ description: `Recommendation headers that store the left side of the recommendation which we track in the SourceEntityID/SourceEntityRecordID` })
export class MJRecommendation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationRunID: string;
        
    @Field() 
    @MaxLength(16)
    SourceEntityID: string;
        
    @Field({description: `The record ID of the source entity`}) 
    SourceEntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    RecommendationRun: string;
        
    @Field() 
    @MaxLength(510)
    SourceEntity: string;
        
    @Field(() => [MJRecommendationItem_])
    RecommendationItems_RecommendationIDArray: MJRecommendationItem_[]; // Link to RecommendationItems
    
}

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class CreateMJRecommendationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class UpdateMJRecommendationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendations
//****************************************************************************
@ObjectType()
export class RunMJRecommendationViewResult {
    @Field(() => [MJRecommendation_])
    Results: MJRecommendation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecommendation_)
export class MJRecommendationResolver extends ResolverBase {
    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecommendationViewResult)
    async RunMJRecommendationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecommendation_, { nullable: true })
    async MJRecommendation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecommendation_ | null> {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Recommendations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecommendationItem_])
    async RecommendationItems_RecommendationIDArray(@Root() mjrecommendation_: MJRecommendation_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [RecommendationID]='${mjrecommendation_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Recommendation Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecommendation_)
    async CreateMJRecommendation(
        @Arg('input', () => CreateMJRecommendationInput) input: CreateMJRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Recommendations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecommendation_)
    async UpdateMJRecommendation(
        @Arg('input', () => UpdateMJRecommendationInput) input: UpdateMJRecommendationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Recommendations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecommendation_)
    async DeleteMJRecommendation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Change Replay Runs
//****************************************************************************
@ObjectType({ description: `Table to track the runs of replaying external record changes` })
export class MJRecordChangeReplayRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Timestamp when the replay run started`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the replay run ended`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Status of the replay run (Pending, In Progress, Complete, Error)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJRecordChange_])
    RecordChanges_ReplayRunIDArray: MJRecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class CreateMJRecordChangeReplayRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class UpdateMJRecordChangeReplayRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Change Replay Runs
//****************************************************************************
@ObjectType()
export class RunMJRecordChangeReplayRunViewResult {
    @Field(() => [MJRecordChangeReplayRun_])
    Results: MJRecordChangeReplayRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordChangeReplayRun_)
export class MJRecordChangeReplayRunResolver extends ResolverBase {
    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeReplayRunViewResult)
    async RunMJRecordChangeReplayRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Change Replay Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordChangeReplayRun_, { nullable: true })
    async MJRecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordChangeReplayRun_ | null> {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Record Change Replay Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_ReplayRunIDArray(@Root() mjrecordchangereplayrun_: MJRecordChangeReplayRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ReplayRunID]='${mjrecordchangereplayrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecordChangeReplayRun_)
    async CreateMJRecordChangeReplayRun(
        @Arg('input', () => CreateMJRecordChangeReplayRunInput) input: CreateMJRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Change Replay Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordChangeReplayRun_)
    async UpdateMJRecordChangeReplayRun(
        @Arg('input', () => UpdateMJRecordChangeReplayRunInput) input: UpdateMJRecordChangeReplayRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Change Replay Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordChangeReplayRun_)
    async DeleteMJRecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Change Replay Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Changes
//****************************************************************************
@ObjectType({ description: `For entities that have TrackRecordChanges=1, Record Changes will store the history of all changes made within the system. For integrations you can directly add values here if you have inbound signals indicating records were changed in a source system. This entity only automatically captures Record Changes if they were made within the system.` })
export class MJRecordChange_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `Field RecordID for entity Record Changes.`}) 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Create, Update, or Delete`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `Internal or External`}) 
    @MaxLength(40)
    Source: string;
        
    @Field({description: `The date/time that the change occured.`}) 
    @MaxLength(10)
    ChangedAt: Date;
        
    @Field({description: `JSON structure that describes what was changed in a structured format.`}) 
    ChangesJSON: string;
        
    @Field({description: `A generated, human-readable description of what was changed.`}) 
    ChangesDescription: string;
        
    @Field({description: `A complete snapshot of the record AFTER the change was applied in a JSON format that can be parsed.`}) 
    FullRecordJSON: string;
        
    @Field({description: `For internal record changes generated within MJ, the status is immediately Complete. For external changes that are detected, the workflow starts off as Pending, then In Progress and finally either Complete or Error`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true, description: `Field ErrorLog for entity Record Changes.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReplayRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    IntegrationID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({description: `Field CreatedAt for entity Record Changes.`}) 
    @MaxLength(10)
    CreatedAt: Date;
        
    @Field({description: `Field UpdatedAt for entity Record Changes.`}) 
    @MaxLength(10)
    UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ReplayRun?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Integration?: string;
        
    @Field(() => [MJVersionLabelItem_])
    MJ_VersionLabelItems_RecordChangeIDArray: MJVersionLabelItem_[]; // Link to MJ_VersionLabelItems
    
}

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class CreateMJRecordChangeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ReplayRunID: string | null;

    @Field({ nullable: true })
    IntegrationID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class UpdateMJRecordChangeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ReplayRunID?: string | null;

    @Field({ nullable: true })
    IntegrationID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Changes
//****************************************************************************
@ObjectType()
export class RunMJRecordChangeViewResult {
    @Field(() => [MJRecordChange_])
    Results: MJRecordChange_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordChange_)
export class MJRecordChangeResolver extends ResolverBase {
    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordChangeViewResult)
    async RunMJRecordChangeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Changes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordChange_, { nullable: true })
    async MJRecordChange(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordChange_ | null> {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Record Changes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJVersionLabelItem_])
    async MJ_VersionLabelItems_RecordChangeIDArray(@Root() mjrecordchange_: MJRecordChange_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelItems] WHERE [RecordChangeID]='${mjrecordchange_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecordChange_)
    async CreateMJRecordChange(
        @Arg('input', () => CreateMJRecordChangeInput) input: CreateMJRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Changes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordChange_)
    async UpdateMJRecordChange(
        @Arg('input', () => UpdateMJRecordChangeInput) input: UpdateMJRecordChangeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Changes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordChange_)
    async DeleteMJRecordChange(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Changes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Deletion Logs
//****************************************************************************
@ObjectType({ description: `Tracks records deleted during merge operations, maintaining an audit trail of data consolidation activities.` })
export class MJRecordMergeDeletionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecordMergeLogID: string;
        
    @Field({description: `Field DeletedRecordID for entity Record Merge Deletion Logs.`}) 
    @MaxLength(1500)
    DeletedRecordID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `Field ProcessingLog for entity Record Merge Deletion Logs.`}) 
    ProcessingLog?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(900)
    RecordMergeLog: string;
        
}

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class CreateMJRecordMergeDeletionLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class UpdateMJRecordMergeDeletionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class RunMJRecordMergeDeletionLogViewResult {
    @Field(() => [MJRecordMergeDeletionLog_])
    Results: MJRecordMergeDeletionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordMergeDeletionLog_)
export class MJRecordMergeDeletionLogResolver extends ResolverBase {
    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeDeletionLogViewResult)
    async RunMJRecordMergeDeletionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Deletion Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordMergeDeletionLog_, { nullable: true })
    async MJRecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordMergeDeletionLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Record Merge Deletion Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJRecordMergeDeletionLog_)
    async CreateMJRecordMergeDeletionLog(
        @Arg('input', () => CreateMJRecordMergeDeletionLogInput) input: CreateMJRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Merge Deletion Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordMergeDeletionLog_)
    async UpdateMJRecordMergeDeletionLog(
        @Arg('input', () => UpdateMJRecordMergeDeletionLogInput) input: UpdateMJRecordMergeDeletionLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Merge Deletion Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordMergeDeletionLog_)
    async DeleteMJRecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Merge Deletion Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Logs
//****************************************************************************
@ObjectType({ description: `Records the history of record merge operations including source records, target records, and merge rules applied.` })
export class MJRecordMergeLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the record that survived the merge and contains the consolidated data.`}) 
    @MaxLength(900)
    SurvivingRecordID: string;
        
    @Field() 
    @MaxLength(16)
    InitiatedByUserID: string;
        
    @Field({description: `Field ApprovalStatus for entity Record Merge Logs.`}) 
    @MaxLength(20)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field({description: `Field ProcessingStatus for entity Record Merge Logs.`}) 
    @MaxLength(20)
    ProcessingStatus: string;
        
    @Field({description: `Field ProcessingStartedAt for entity Record Merge Logs.`}) 
    @MaxLength(10)
    ProcessingStartedAt: Date;
        
    @Field({nullable: true, description: `Field ProcessingEndedAt for entity Record Merge Logs.`}) 
    @MaxLength(10)
    ProcessingEndedAt?: Date;
        
    @Field({nullable: true, description: `Detailed log of the merge process including field mappings and decisions.`}) 
    ProcessingLog?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    InitiatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [MJRecordMergeDeletionLog_])
    RecordMergeDeletionLogs_RecordMergeLogIDArray: MJRecordMergeDeletionLog_[]; // Link to RecordMergeDeletionLogs
    
    @Field(() => [MJDuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_RecordMergeLogIDArray: MJDuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class CreateMJRecordMergeLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt: Date | null;

    @Field({ nullable: true })
    ProcessingLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class UpdateMJRecordMergeLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt?: Date | null;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Logs
//****************************************************************************
@ObjectType()
export class RunMJRecordMergeLogViewResult {
    @Field(() => [MJRecordMergeLog_])
    Results: MJRecordMergeLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRecordMergeLog_)
export class MJRecordMergeLogResolver extends ResolverBase {
    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRecordMergeLogViewResult)
    async RunMJRecordMergeLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRecordMergeLog_, { nullable: true })
    async MJRecordMergeLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRecordMergeLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Record Merge Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJRecordMergeDeletionLog_])
    async RecordMergeDeletionLogs_RecordMergeLogIDArray(@Root() mjrecordmergelog_: MJRecordMergeLog_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [RecordMergeLogID]='${mjrecordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Merge Deletion Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_RecordMergeLogIDArray(@Root() mjrecordmergelog_: MJRecordMergeLog_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [RecordMergeLogID]='${mjrecordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRecordMergeLog_)
    async CreateMJRecordMergeLog(
        @Arg('input', () => CreateMJRecordMergeLogInput) input: CreateMJRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Record Merge Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRecordMergeLog_)
    async UpdateMJRecordMergeLog(
        @Arg('input', () => UpdateMJRecordMergeLogInput) input: UpdateMJRecordMergeLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Record Merge Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRecordMergeLog_)
    async DeleteMJRecordMergeLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Record Merge Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Categories
//****************************************************************************
@ObjectType({ description: `Organizes reports into logical groupings for navigation, access control, and discovery within the reporting system.` })
export class MJReportCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJReportCategory_])
    ReportCategories_ParentIDArray: MJReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [MJReport_])
    Reports_CategoryIDArray: MJReport_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class CreateMJReportCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class UpdateMJReportCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Categories
//****************************************************************************
@ObjectType()
export class RunMJReportCategoryViewResult {
    @Field(() => [MJReportCategory_])
    Results: MJReportCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportCategory_)
export class MJReportCategoryResolver extends ResolverBase {
    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportCategoryViewResult)
    async RunMJReportCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportCategory_, { nullable: true })
    async MJReportCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportCategory_ | null> {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Report Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReportCategory_])
    async ReportCategories_ParentIDArray(@Root() mjreportcategory_: MJReportCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ParentID]='${mjreportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Report Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_CategoryIDArray(@Root() mjreportcategory_: MJReportCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [CategoryID]='${mjreportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJReportCategory_)
    async CreateMJReportCategory(
        @Arg('input', () => CreateMJReportCategoryInput) input: CreateMJReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Report Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportCategory_)
    async UpdateMJReportCategory(
        @Arg('input', () => UpdateMJReportCategoryInput) input: UpdateMJReportCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Report Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportCategory_)
    async DeleteMJReportCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Snapshots
//****************************************************************************
@ObjectType({ description: `Stores point-in-time captures of report outputs, preserving historical data and enabling comparison over time.` })
export class MJReportSnapshot_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field({description: `Field ResultSet for entity Report Snapshots.`}) 
    ResultSet: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class CreateMJReportSnapshotInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class UpdateMJReportSnapshotInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Snapshots
//****************************************************************************
@ObjectType()
export class RunMJReportSnapshotViewResult {
    @Field(() => [MJReportSnapshot_])
    Results: MJReportSnapshot_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReportSnapshot_)
export class MJReportSnapshotResolver extends ResolverBase {
    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportSnapshotViewResult)
    async RunMJReportSnapshotDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Snapshots';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReportSnapshot_, { nullable: true })
    async MJReportSnapshot(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReportSnapshot_ | null> {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Report Snapshots', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJReportSnapshot_)
    async CreateMJReportSnapshot(
        @Arg('input', () => CreateMJReportSnapshotInput) input: CreateMJReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Report Snapshots', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReportSnapshot_)
    async UpdateMJReportSnapshot(
        @Arg('input', () => UpdateMJReportSnapshotInput) input: UpdateMJReportSnapshotInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Report Snapshots', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReportSnapshot_)
    async DeleteMJReportSnapshot(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Snapshots', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Reports
//****************************************************************************
@ObjectType({ description: `Defines report configurations including data sources, layouts, filters, and scheduling for automated report generation.` })
export class MJReport_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Field SharingScope for entity Reports.`}) 
    @MaxLength(40)
    SharingScope: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field({nullable: true, description: `Field Configuration for entity Reports.`}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputTriggerTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputFormatTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputDeliveryTypeID?: string;
        
    @Field({nullable: true, description: `For scheduled reports, the frequency of generation (Daily, Weekly, Monthly, etc.).`}) 
    @MaxLength(100)
    OutputFrequency?: string;
        
    @Field({nullable: true, description: `Email address(es) to send the report to when using email delivery.`}) 
    @MaxLength(510)
    OutputTargetEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputWorkflowID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Thumbnail image for the report that can be displayed in gallery views. Can contain either a URL to an image file or a Base64-encoded image string.`}) 
    Thumbnail?: string;
        
    @Field() 
    @MaxLength(16)
    EnvironmentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    ConversationDetail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputTriggerType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputFormatType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputDeliveryType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    OutputWorkflow?: string;
        
    @Field() 
    @MaxLength(510)
    Environment: string;
        
    @Field(() => [MJReportSnapshot_])
    ReportSnapshots_ReportIDArray: MJReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [MJReportVersion_])
    MJ_ReportVersions_ReportIDArray: MJReportVersion_[]; // Link to MJ_ReportVersions
    
    @Field(() => [MJReportUserState_])
    MJ_ReportUserStates_ReportIDArray: MJReportUserState_[]; // Link to MJ_ReportUserStates
    
}

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class CreateMJReportInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID: string | null;

    @Field({ nullable: true })
    OutputFrequency: string | null;

    @Field({ nullable: true })
    OutputTargetEmail: string | null;

    @Field({ nullable: true })
    OutputWorkflowID: string | null;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class UpdateMJReportInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID?: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID?: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID?: string | null;

    @Field({ nullable: true })
    OutputFrequency?: string | null;

    @Field({ nullable: true })
    OutputTargetEmail?: string | null;

    @Field({ nullable: true })
    OutputWorkflowID?: string | null;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    EnvironmentID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Reports
//****************************************************************************
@ObjectType()
export class RunMJReportViewResult {
    @Field(() => [MJReport_])
    Results: MJReport_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJReport_)
export class MJReportResolver extends ResolverBase {
    @Query(() => RunMJReportViewResult)
    async RunMJReportViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportViewResult)
    async RunMJReportViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJReportViewResult)
    async RunMJReportDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Reports';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJReport_, { nullable: true })
    async MJReport(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJReport_ | null> {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Reports', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReportSnapshot_])
    async ReportSnapshots_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ReportID]='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Report Snapshots', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportVersion_])
    async MJ_ReportVersions_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ReportID]='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportUserState_])
    async MJ_ReportUserStates_ReportIDArray(@Root() mjreport_: MJReport_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ReportID]='${mjreport_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJReport_)
    async CreateMJReport(
        @Arg('input', () => CreateMJReportInput) input: CreateMJReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Reports', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJReport_)
    async UpdateMJReport(
        @Arg('input', () => UpdateMJReportInput) input: UpdateMJReportInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Reports', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJReport_)
    async DeleteMJReport(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Reports', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Links
//****************************************************************************
@ObjectType({ description: `Table to track user links to shared resources such as views, dashboards, etc.` })
export class MJResourceLink_ {
    @Field({description: `Unique identifier for each resource link`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to the user linking the resource`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Foreign key to the resource type (view, dashboard, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being linked`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({nullable: true, description: `Optional folder where the user organizes the linked resource`}) 
    @MaxLength(510)
    FolderID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class CreateMJResourceLinkInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class UpdateMJResourceLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Links
//****************************************************************************
@ObjectType()
export class RunMJResourceLinkViewResult {
    @Field(() => [MJResourceLink_])
    Results: MJResourceLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourceLink_)
export class MJResourceLinkResolver extends ResolverBase {
    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceLinkViewResult)
    async RunMJResourceLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Links';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourceLink_, { nullable: true })
    async MJResourceLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourceLink_ | null> {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Resource Links', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJResourceLink_)
    async CreateMJResourceLink(
        @Arg('input', () => CreateMJResourceLinkInput) input: CreateMJResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Links', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourceLink_)
    async UpdateMJResourceLink(
        @Arg('input', () => UpdateMJResourceLinkInput) input: UpdateMJResourceLinkInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Links', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourceLink_)
    async DeleteMJResourceLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Links', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Permissions
//****************************************************************************
@ObjectType({ description: `Table for managing sharing of resources to users or roles with time constraints and permission levels` })
export class MJResourcePermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the type of resource being shared (View, Dashboard, Report, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being shared`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({description: `The level of sharing either Role or User`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Optional: Date when sharing starts`}) 
    @MaxLength(10)
    StartSharingAt?: Date;
        
    @Field({nullable: true, description: `Optional: Date when sharing ends`}) 
    @MaxLength(10)
    EndSharingAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RoleID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Permission level defining the type of access (View, Edit, Owner)`}) 
    @MaxLength(40)
    PermissionLevel?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the resource permission request. Possible values are Requested, Approved, Rejected, or Revoked.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class CreateMJResourcePermissionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt: Date | null;

    @Field({ nullable: true })
    EndSharingAt: Date | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    PermissionLevel: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class UpdateMJResourcePermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt?: Date | null;

    @Field({ nullable: true })
    EndSharingAt?: Date | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    PermissionLevel?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Permissions
//****************************************************************************
@ObjectType()
export class RunMJResourcePermissionViewResult {
    @Field(() => [MJResourcePermission_])
    Results: MJResourcePermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourcePermission_)
export class MJResourcePermissionResolver extends ResolverBase {
    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourcePermissionViewResult)
    async RunMJResourcePermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Permissions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourcePermission_, { nullable: true })
    async MJResourcePermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourcePermission_ | null> {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Resource Permissions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJResourcePermission_)
    async CreateMJResourcePermission(
        @Arg('input', () => CreateMJResourcePermissionInput) input: CreateMJResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Permissions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourcePermission_)
    async UpdateMJResourcePermission(
        @Arg('input', () => UpdateMJResourcePermissionInput) input: UpdateMJResourcePermissionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Permissions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourcePermission_)
    async DeleteMJResourcePermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Permissions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Types
//****************************************************************************
@ObjectType({ description: `Tracks types of system resources such as records, dashboards, and reports.` })
export class MJResourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `Field DisplayName for entity Resource Types.`}) 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Icon identifier for displaying this resource type in the UI.`}) 
    @MaxLength(200)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Nullable foreign key to the ID column in Entities entity, representing the category entity. ASSUMPTION: If provided, the assumption is there is a self-referencing/recursive foreign key establishing a hierarchy within the Category Entity, commonly called ParentID, but it can be named anything.`}) 
    @MaxLength(16)
    CategoryEntityID?: string;
        
    @Field({nullable: true, description: `The Angular component class name to instantiate for this resource type. NULL for Custom resource type (uses NavItem DriverClass instead).`}) 
    @MaxLength(510)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CategoryEntity?: string;
        
    @Field(() => [MJWorkspaceItem_])
    WorkspaceItems_ResourceTypeIDArray: MJWorkspaceItem_[]; // Link to WorkspaceItems
    
    @Field(() => [MJUserNotification_])
    UserNotifications_ResourceTypeIDArray: MJUserNotification_[]; // Link to UserNotifications
    
    @Field(() => [MJResourceLink_])
    ResourceLinks_ResourceTypeIDArray: MJResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [MJResourcePermission_])
    ResourcePermissions_ResourceTypeIDArray: MJResourcePermission_[]; // Link to ResourcePermissions
    
}

//****************************************************************************
// INPUT TYPE for Resource Types
//****************************************************************************
@InputType()
export class CreateMJResourceTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    CategoryEntityID: string | null;

    @Field({ nullable: true })
    DriverClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Resource Types
//****************************************************************************
@InputType()
export class UpdateMJResourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    CategoryEntityID?: string | null;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Types
//****************************************************************************
@ObjectType()
export class RunMJResourceTypeViewResult {
    @Field(() => [MJResourceType_])
    Results: MJResourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJResourceType_)
export class MJResourceTypeResolver extends ResolverBase {
    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJResourceTypeViewResult)
    async RunMJResourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJResourceType_, { nullable: true })
    async MJResourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJResourceType_ | null> {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Resource Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJWorkspaceItem_])
    async WorkspaceItems_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Workspace Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotification_])
    async UserNotifications_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Notifications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourceLink_])
    async ResourceLinks_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Resource Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async ResourcePermissions_ResourceTypeIDArray(@Root() mjresourcetype_: MJResourceType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ResourceTypeID]='${mjresourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJResourceType_)
    async CreateMJResourceType(
        @Arg('input', () => CreateMJResourceTypeInput) input: CreateMJResourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Resource Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJResourceType_)
    async UpdateMJResourceType(
        @Arg('input', () => UpdateMJResourceTypeInput) input: UpdateMJResourceTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Resource Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJResourceType_)
    async DeleteMJResourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Roles
//****************************************************************************
@ObjectType({ description: `Roles are used for security administration and can have zero to many Users as members` })
export class MJRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Role with full permissions to manage AI agents and all related entities. This role is required for AgentSpecSync operations to function correctly, allowing create, read, update, and delete operations on agents, prompts, actions, relationships, steps, and paths.`}) 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of the role`}) 
    Description?: string;
        
    @Field({nullable: true, description: `The unique ID of the role in the directory being used for authentication, for example an ID in Azure.`}) 
    @MaxLength(500)
    DirectoryID?: string;
        
    @Field({nullable: true, description: `The name of the role in the database, this is used for auto-generating permission statements by CodeGen`}) 
    @MaxLength(500)
    SQLName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEmployeeRole_])
    EmployeeRoles_RoleIDArray: MJEmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [MJEntityPermission_])
    EntityPermissions_RoleNameArray: MJEntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [MJUserRole_])
    UserRoles_RoleNameArray: MJUserRole_[]; // Link to UserRoles
    
    @Field(() => [MJAuthorizationRole_])
    AuthorizationRoles_RoleNameArray: MJAuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [MJQueryPermission_])
    QueryPermissions_RoleNameArray: MJQueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [MJResourcePermission_])
    ResourcePermissions_RoleIDArray: MJResourcePermission_[]; // Link to ResourcePermissions
    
    @Field(() => [MJMCPServerConnectionPermission_])
    MJ_MCPServerConnectionPermissions_RoleIDArray: MJMCPServerConnectionPermission_[]; // Link to MJ_MCPServerConnectionPermissions
    
    @Field(() => [MJAIAgentPermission_])
    MJ_AIAgentPermissions_RoleIDArray: MJAIAgentPermission_[]; // Link to MJ_AIAgentPermissions
    
}

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class CreateMJRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DirectoryID: string | null;

    @Field({ nullable: true })
    SQLName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class UpdateMJRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DirectoryID?: string | null;

    @Field({ nullable: true })
    SQLName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Roles
//****************************************************************************
@ObjectType()
export class RunMJRoleViewResult {
    @Field(() => [MJRole_])
    Results: MJRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRole_)
export class MJRoleResolver extends ResolverBase {
    @Query(() => RunMJRoleViewResult)
    async RunMJRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRoleViewResult)
    async RunMJRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRoleViewResult)
    async RunMJRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRole_, { nullable: true })
    async MJRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRole_ | null> {
        this.CheckUserReadPermissions('Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJRole_])
    async AllRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles]` + this.getRowLevelSecurityWhereClause(provider, 'Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployeeRole_])
    async EmployeeRoles_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [RoleID]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employee Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityPermission_])
    async EntityPermissions_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRole_])
    async UserRoles_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuthorizationRole_])
    async AuthorizationRoles_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Authorization Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryPermission_])
    async QueryPermissions_RoleNameArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [RoleName]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async ResourcePermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [RoleID]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnectionPermission_])
    async MJ_MCPServerConnectionPermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionPermissions] WHERE [RoleID]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPermission_])
    async MJ_AIAgentPermissions_RoleIDArray(@Root() mjrole_: MJRole_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPermissions] WHERE [RoleID]='${mjrole_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRole_)
    async CreateMJRole(
        @Arg('input', () => CreateMJRoleInput) input: CreateMJRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRole_)
    async UpdateMJRole(
        @Arg('input', () => UpdateMJRoleInput) input: UpdateMJRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRole_)
    async DeleteMJRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Row Level Security Filters
//****************************************************************************
@ObjectType({ description: `Defines data access rules that filter records based on user context, implementing fine-grained security at the row level.` })
export class MJRowLevelSecurityFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `SQL WHERE clause template that filters records based on user context variables.`}) 
    FilterText?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJEntityPermission_])
    EntityPermissions_ReadRLSFilterIDArray: MJEntityPermission_[]; // Link to EntityPermissions
    
}

//****************************************************************************
// INPUT TYPE for Row Level Security Filters
//****************************************************************************
@InputType()
export class CreateMJRowLevelSecurityFilterInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    FilterText: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Row Level Security Filters
//****************************************************************************
@InputType()
export class UpdateMJRowLevelSecurityFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    FilterText?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Row Level Security Filters
//****************************************************************************
@ObjectType()
export class RunMJRowLevelSecurityFilterViewResult {
    @Field(() => [MJRowLevelSecurityFilter_])
    Results: MJRowLevelSecurityFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJRowLevelSecurityFilter_)
export class MJRowLevelSecurityFilterResolver extends ResolverBase {
    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJRowLevelSecurityFilterViewResult)
    async RunMJRowLevelSecurityFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Row Level Security Filters';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJRowLevelSecurityFilter_, { nullable: true })
    async MJRowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJRowLevelSecurityFilter_ | null> {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Row Level Security Filters', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Row Level Security Filters', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJRowLevelSecurityFilter_])
    async AllRowLevelSecurityFilters(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters]` + this.getRowLevelSecurityWhereClause(provider, 'Row Level Security Filters', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Row Level Security Filters', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityPermission_])
    async EntityPermissions_ReadRLSFilterIDArray(@Root() mjrowlevelsecurityfilter_: MJRowLevelSecurityFilter_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ReadRLSFilterID]='${mjrowlevelsecurityfilter_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJRowLevelSecurityFilter_)
    async CreateMJRowLevelSecurityFilter(
        @Arg('input', () => CreateMJRowLevelSecurityFilterInput) input: CreateMJRowLevelSecurityFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Row Level Security Filters', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJRowLevelSecurityFilter_)
    async UpdateMJRowLevelSecurityFilter(
        @Arg('input', () => UpdateMJRowLevelSecurityFilterInput) input: UpdateMJRowLevelSecurityFilterInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Row Level Security Filters', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJRowLevelSecurityFilter_)
    async DeleteMJRowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Row Level Security Filters', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Scheduled Action Params
//****************************************************************************
@ObjectType({ description: `Stores parameter values for scheduled action executions, configuring inputs for automated action runs.` })
export class MJScheduledActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ScheduledActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field({description: `Field ValueType for entity Scheduled Action Params.`}) 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true, description: `Field Value for entity Scheduled Action Params.`}) 
    Value?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ScheduledAction: string;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class CreateMJScheduledActionParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class UpdateMJScheduledActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Action Params
//****************************************************************************
@ObjectType()
export class RunMJScheduledActionParamViewResult {
    @Field(() => [MJScheduledActionParam_])
    Results: MJScheduledActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledActionParam_)
export class MJScheduledActionParamResolver extends ResolverBase {
    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionParamViewResult)
    async RunMJScheduledActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Action Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledActionParam_, { nullable: true })
    async MJScheduledActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledActionParam_ | null> {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Scheduled Action Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJScheduledActionParam_)
    async CreateMJScheduledActionParam(
        @Arg('input', () => CreateMJScheduledActionParamInput) input: CreateMJScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Scheduled Action Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledActionParam_)
    async UpdateMJScheduledActionParam(
        @Arg('input', () => UpdateMJScheduledActionParamInput) input: UpdateMJScheduledActionParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Scheduled Action Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledActionParam_)
    async DeleteMJScheduledActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Action Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Scheduled Actions
//****************************************************************************
@ObjectType({ description: `Track scheduled actions and their details` })
export class MJScheduledAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Type of the scheduled action (Daily, Weekly, Monthly, Yearly, Custom)`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Cron expression defining the schedule, automatically maintained by the system unless Type is Custom, in which case the user directly sets this`}) 
    @MaxLength(200)
    CronExpression?: string;
        
    @Field({description: `Timezone for the scheduled action, if not specified defaults to UTC/Z`}) 
    @MaxLength(200)
    Timezone: string;
        
    @Field({description: `Status of the scheduled action (Pending, Active, Disabled, Expired)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Interval in days for the scheduled action`}) 
    IntervalDays?: number;
        
    @Field({nullable: true, description: `Day of the week for the scheduled action`}) 
    @MaxLength(40)
    DayOfWeek?: string;
        
    @Field(() => Int, {nullable: true, description: `Day of the month for the scheduled action`}) 
    DayOfMonth?: number;
        
    @Field({nullable: true, description: `Month for the scheduled action`}) 
    @MaxLength(40)
    Month?: string;
        
    @Field({nullable: true, description: `Field CustomCronExpression for entity Scheduled Actions.`}) 
    @MaxLength(510)
    CustomCronExpression?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [MJScheduledActionParam_])
    ScheduledActionParams_ScheduledActionIDArray: MJScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class CreateMJScheduledActionInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays: number | null;

    @Field({ nullable: true })
    DayOfWeek: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth: number | null;

    @Field({ nullable: true })
    Month: string | null;

    @Field({ nullable: true })
    CustomCronExpression: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class UpdateMJScheduledActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression?: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays?: number | null;

    @Field({ nullable: true })
    DayOfWeek?: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth?: number | null;

    @Field({ nullable: true })
    Month?: string | null;

    @Field({ nullable: true })
    CustomCronExpression?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Actions
//****************************************************************************
@ObjectType()
export class RunMJScheduledActionViewResult {
    @Field(() => [MJScheduledAction_])
    Results: MJScheduledAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJScheduledAction_)
export class MJScheduledActionResolver extends ResolverBase {
    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJScheduledActionViewResult)
    async RunMJScheduledActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Actions';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJScheduledAction_, { nullable: true })
    async MJScheduledAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJScheduledAction_ | null> {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Scheduled Actions', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJScheduledActionParam_])
    async ScheduledActionParams_ScheduledActionIDArray(@Root() mjscheduledaction_: MJScheduledAction_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ScheduledActionID]='${mjscheduledaction_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJScheduledAction_)
    async CreateMJScheduledAction(
        @Arg('input', () => CreateMJScheduledActionInput) input: CreateMJScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Scheduled Actions', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJScheduledAction_)
    async UpdateMJScheduledAction(
        @Arg('input', () => UpdateMJScheduledActionInput) input: UpdateMJScheduledActionInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Scheduled Actions', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJScheduledAction_)
    async DeleteMJScheduledAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Actions', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Schema Info
//****************************************************************************
@ObjectType({ description: `Tracks the schemas in the system and the ID ranges that are valid for entities within each schema.` })
export class MJSchemaInfo_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `The database schema this information applies to.`}) 
    @MaxLength(100)
    SchemaName: string;
        
    @Field(() => Int, {description: `Field EntityIDMin for entity Schema Info.`}) 
    EntityIDMin: number;
        
    @Field(() => Int, {description: `Field EntityIDMax for entity Schema Info.`}) 
    EntityIDMax: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Optional prefix to prepend to entity names generated for this schema. For example, setting this to "Committees: " would result in entity names like "Committees: Individuals". Can be overridden by mj.config.cjs NameRulesBySchema settings.`}) 
    @MaxLength(50)
    EntityNamePrefix?: string;
        
    @Field({nullable: true, description: `Optional suffix to append to entity names generated for this schema. Can be overridden by mj.config.cjs NameRulesBySchema settings.`}) 
    @MaxLength(50)
    EntityNameSuffix?: string;
        
}

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class CreateMJSchemaInfoInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityNamePrefix: string | null;

    @Field({ nullable: true })
    EntityNameSuffix: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class UpdateMJSchemaInfoInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityNamePrefix?: string | null;

    @Field({ nullable: true })
    EntityNameSuffix?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Schema Info
//****************************************************************************
@ObjectType()
export class RunMJSchemaInfoViewResult {
    @Field(() => [MJSchemaInfo_])
    Results: MJSchemaInfo_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSchemaInfo_)
export class MJSchemaInfoResolver extends ResolverBase {
    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSchemaInfoViewResult)
    async RunMJSchemaInfoDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Schema Info';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSchemaInfo_, { nullable: true })
    async MJSchemaInfo(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSchemaInfo_ | null> {
        this.CheckUserReadPermissions('Schema Info', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSchemaInfos] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Schema Info', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Schema Info', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJSchemaInfo_)
    async CreateMJSchemaInfo(
        @Arg('input', () => CreateMJSchemaInfoInput) input: CreateMJSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Schema Info', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJSchemaInfo_)
    async UpdateMJSchemaInfo(
        @Arg('input', () => UpdateMJSchemaInfoInput) input: UpdateMJSchemaInfoInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Schema Info', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJSchemaInfo_)
    async DeleteMJSchemaInfo(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Schema Info', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Skills
//****************************************************************************
@ObjectType({ description: `A hierarchical list of possible skills that are linked to Employees and can also be linked to any other entity` })
export class MJSkill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJEmployeeSkill_])
    EmployeeSkills_SkillIDArray: MJEmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [MJSkill_])
    Skills_ParentIDArray: MJSkill_[]; // Link to Skills
    
}

//****************************************************************************
// INPUT TYPE for Skills
//****************************************************************************
@InputType()
export class CreateMJSkillInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Skills
//****************************************************************************
@InputType()
export class UpdateMJSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Skills
//****************************************************************************
@ObjectType()
export class RunMJSkillViewResult {
    @Field(() => [MJSkill_])
    Results: MJSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJSkill_)
export class MJSkillResolver extends ResolverBase {
    @Query(() => RunMJSkillViewResult)
    async RunMJSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSkillViewResult)
    async RunMJSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJSkillViewResult)
    async RunMJSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Skills';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJSkill_, { nullable: true })
    async MJSkill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJSkill_ | null> {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Skills', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJSkill_])
    async AllSkills(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills]` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEmployeeSkill_])
    async EmployeeSkills_SkillIDArray(@Root() mjskill_: MJSkill_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [SkillID]='${mjskill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Employee Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJSkill_])
    async Skills_ParentIDArray(@Root() mjskill_: MJSkill_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ParentID]='${mjskill_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Skills', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Skills', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJSkill_)
    async CreateMJSkill(
        @Arg('input', () => CreateMJSkillInput) input: CreateMJSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Skills', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJSkill_)
    async UpdateMJSkill(
        @Arg('input', () => UpdateMJSkillInput) input: UpdateMJSkillInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Skills', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJSkill_)
    async DeleteMJSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Skills', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Tagged Items
//****************************************************************************
@ObjectType({ description: `Tracks the links between any record in any entity with Tags` })
export class MJTaggedItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TagID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `Field RecordID for entity Tagged Items.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Tag: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Tagged Items
//****************************************************************************
@InputType()
export class CreateMJTaggedItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TagID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Tagged Items
//****************************************************************************
@InputType()
export class UpdateMJTaggedItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TagID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Tagged Items
//****************************************************************************
@ObjectType()
export class RunMJTaggedItemViewResult {
    @Field(() => [MJTaggedItem_])
    Results: MJTaggedItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTaggedItem_)
export class MJTaggedItemResolver extends ResolverBase {
    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTaggedItemViewResult)
    async RunMJTaggedItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tagged Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTaggedItem_, { nullable: true })
    async MJTaggedItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTaggedItem_ | null> {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Tagged Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTaggedItem_)
    async CreateMJTaggedItem(
        @Arg('input', () => CreateMJTaggedItemInput) input: CreateMJTaggedItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Tagged Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTaggedItem_)
    async UpdateMJTaggedItem(
        @Arg('input', () => UpdateMJTaggedItemInput) input: UpdateMJTaggedItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Tagged Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTaggedItem_)
    async DeleteMJTaggedItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Tagged Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Tags
//****************************************************************************
@ObjectType({ description: `Tags are used to arbitrarily associate any record in any entity with addtional information.` })
export class MJTag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Field DisplayName for entity Tags.`}) 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJTag_])
    Tags_ParentIDArray: MJTag_[]; // Link to Tags
    
    @Field(() => [MJTaggedItem_])
    TaggedItems_TagIDArray: MJTaggedItem_[]; // Link to TaggedItems
    
}

//****************************************************************************
// INPUT TYPE for Tags
//****************************************************************************
@InputType()
export class CreateMJTagInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Tags
//****************************************************************************
@InputType()
export class UpdateMJTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    DisplayName?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Tags
//****************************************************************************
@ObjectType()
export class RunMJTagViewResult {
    @Field(() => [MJTag_])
    Results: MJTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTag_)
export class MJTagResolver extends ResolverBase {
    @Query(() => RunMJTagViewResult)
    async RunMJTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTagViewResult)
    async RunMJTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTagViewResult)
    async RunMJTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tags';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTag_, { nullable: true })
    async MJTag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTag_ | null> {
        this.CheckUserReadPermissions('Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Tags', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTag_])
    async Tags_ParentIDArray(@Root() mjtag_: MJTag_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tags', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ParentID]='${mjtag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tags', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Tags', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTaggedItem_])
    async TaggedItems_TagIDArray(@Root() mjtag_: MJTag_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [TagID]='${mjtag_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Tagged Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTag_)
    async CreateMJTag(
        @Arg('input', () => CreateMJTagInput) input: CreateMJTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Tags', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTag_)
    async UpdateMJTag(
        @Arg('input', () => UpdateMJTagInput) input: UpdateMJTagInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Tags', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTag_)
    async DeleteMJTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Tags', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Categories
//****************************************************************************
@ObjectType({ description: `Template categories for organizing templates` })
export class MJTemplateCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template category`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template category`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJTemplate_])
    Templates_CategoryIDArray: MJTemplate_[]; // Link to Templates
    
    @Field(() => [MJTemplateCategory_])
    TemplateCategories_ParentIDArray: MJTemplateCategory_[]; // Link to TemplateCategories
    
}

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class CreateMJTemplateCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class UpdateMJTemplateCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Categories
//****************************************************************************
@ObjectType()
export class RunMJTemplateCategoryViewResult {
    @Field(() => [MJTemplateCategory_])
    Results: MJTemplateCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateCategory_)
export class MJTemplateCategoryResolver extends ResolverBase {
    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateCategoryViewResult)
    async RunMJTemplateCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateCategory_, { nullable: true })
    async MJTemplateCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateCategory_ | null> {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Template Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplate_])
    async Templates_CategoryIDArray(@Root() mjtemplatecategory_: MJTemplateCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [CategoryID]='${mjtemplatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Templates', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateCategory_])
    async TemplateCategories_ParentIDArray(@Root() mjtemplatecategory_: MJTemplateCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ParentID]='${mjtemplatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplateCategory_)
    async CreateMJTemplateCategory(
        @Arg('input', () => CreateMJTemplateCategoryInput) input: CreateMJTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateCategory_)
    async UpdateMJTemplateCategory(
        @Arg('input', () => UpdateMJTemplateCategoryInput) input: UpdateMJTemplateCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateCategory_)
    async DeleteMJTemplateCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Content Types
//****************************************************************************
@ObjectType({ description: `Template content types for categorizing content within templates` })
export class MJTemplateContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template content type`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template content type`}) 
    Description?: string;
        
    @Field({description: `Refers to the primary language or codetype of the templates of this type, HTML, JSON, JavaScript, etc`}) 
    @MaxLength(50)
    CodeType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJTemplateContent_])
    TemplateContents_TypeIDArray: MJTemplateContent_[]; // Link to TemplateContents
    
}

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class CreateMJTemplateContentTypeInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class UpdateMJTemplateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Content Types
//****************************************************************************
@ObjectType()
export class RunMJTemplateContentTypeViewResult {
    @Field(() => [MJTemplateContentType_])
    Results: MJTemplateContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateContentType_)
export class MJTemplateContentTypeResolver extends ResolverBase {
    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentTypeViewResult)
    async RunMJTemplateContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Content Types';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateContentType_, { nullable: true })
    async MJTemplateContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateContentType_ | null> {
        this.CheckUserReadPermissions('Template Content Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Template Content Types', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplateContent_])
    async TemplateContents_TypeIDArray(@Root() mjtemplatecontenttype_: MJTemplateContentType_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TypeID]='${mjtemplatecontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Contents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplateContentType_)
    async CreateMJTemplateContentType(
        @Arg('input', () => CreateMJTemplateContentTypeInput) input: CreateMJTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Content Types', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateContentType_)
    async UpdateMJTemplateContentType(
        @Arg('input', () => UpdateMJTemplateContentTypeInput) input: UpdateMJTemplateContentTypeInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Content Types', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateContentType_)
    async DeleteMJTemplateContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Content Types', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Contents
//****************************************************************************
@ObjectType({ description: `Template content for different versions of a template for purposes like HTML/Text/etc` })
export class MJTemplateContent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field({nullable: true, description: `The actual text content for the template`}) 
    TemplateText?: string;
        
    @Field(() => Int, {description: `Priority of the content version, higher priority versions will be used ahead of lower priority versions for a given Type`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Indicates whether the content is active or not. Use this to disable a particular Template Content item without having to remove it`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field(() => [MJTemplateParam_])
    TemplateParams_TemplateContentIDArray: MJTemplateParam_[]; // Link to TemplateParams
    
}

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class CreateMJTemplateContentInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class UpdateMJTemplateContentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Contents
//****************************************************************************
@ObjectType()
export class RunMJTemplateContentViewResult {
    @Field(() => [MJTemplateContent_])
    Results: MJTemplateContent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateContent_)
export class MJTemplateContentResolver extends ResolverBase {
    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateContentViewResult)
    async RunMJTemplateContentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Contents';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateContent_, { nullable: true })
    async MJTemplateContent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateContent_ | null> {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Template Contents', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplateParam_])
    async TemplateParams_TemplateContentIDArray(@Root() mjtemplatecontent_: MJTemplateContent_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [TemplateContentID]='${mjtemplatecontent_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplateContent_)
    async CreateMJTemplateContent(
        @Arg('input', () => CreateMJTemplateContentInput) input: CreateMJTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Contents', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateContent_)
    async UpdateMJTemplateContent(
        @Arg('input', () => UpdateMJTemplateContentInput) input: UpdateMJTemplateContentInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Contents', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateContent_)
    async DeleteMJTemplateContent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Contents', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Params
//****************************************************************************
@ObjectType({ description: `Parameters allowed for use inside the template` })
export class MJTemplateParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({description: `Name of the parameter`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the parameter`}) 
    Description?: string;
        
    @Field({description: `Type of the parameter - Record is an individual record within the entity specified by EntityID. Entity means an entire Entity or an entity filtered by the LinkedParameterName/Field attributes and/or ExtraFilter. Object is any valid JSON object. Array and Scalar have their common meanings.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Default value of the parameter`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `Whether this parameter must be provided when using the template.`}) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Only used when Type=Entity, this is used to link an Entity parameter with another parameter so that the rows in the Entity parameter can be filtered automatically based on the FKEY relationship between the Record and this Entity parameter. For example, if the Entity-based parameter is for an entity like Activities and there is another parameter of type Record for an entity like Contacts, in that situation the Activities Parameter would point to the Contacts parameter as the LinkedParameterName because we would filter down the Activities in each template render to only those linked to the Contact.`}) 
    @MaxLength(510)
    LinkedParameterName?: string;
        
    @Field({nullable: true, description: `If the LinkedParameterName is specified, this is an optional setting to specify the field within the LinkedParameter that will be used for filtering. This is only needed if there is more than one foreign key relationship between the Entity parameter and the Linked parameter, or if there is no defined foreign key in the database between the two entities.`}) 
    @MaxLength(1000)
    LinkedParameterField?: string;
        
    @Field({nullable: true, description: `Only used when Type = Entity, used to specify an optional filter to reduce the set of rows that are returned for each of the templates being rendered.`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `Record ID, used only when Type is Record and a specific hardcoded record ID is desired, this is an uncommon use case, helpful for pulling in static types and metadata in some cases.`}) 
    @MaxLength(4000)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `This field is used only when the Type of the TemplateParam table is "Entity". It is an optional field used to specify the sorting order for the related entity data that is used in the template for the Entity specified.`}) 
    OrderBy?: string;
        
    @Field({nullable: true, description: `Optional reference to a specific template content. When NULL, this parameter applies to all content items within the template. When set, this parameter applies only to the specified template content.`}) 
    @MaxLength(16)
    TemplateContentID?: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    TemplateContent?: string;
        
}

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class CreateMJTemplateParamInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName: string | null;

    @Field({ nullable: true })
    LinkedParameterField: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;

    @Field({ nullable: true })
    TemplateContentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class UpdateMJTemplateParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName?: string | null;

    @Field({ nullable: true })
    LinkedParameterField?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field({ nullable: true })
    TemplateContentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Params
//****************************************************************************
@ObjectType()
export class RunMJTemplateParamViewResult {
    @Field(() => [MJTemplateParam_])
    Results: MJTemplateParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplateParam_)
export class MJTemplateParamResolver extends ResolverBase {
    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateParamViewResult)
    async RunMJTemplateParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Params';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplateParam_, { nullable: true })
    async MJTemplateParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplateParam_ | null> {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Template Params', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJTemplateParam_)
    async CreateMJTemplateParam(
        @Arg('input', () => CreateMJTemplateParamInput) input: CreateMJTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Template Params', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplateParam_)
    async UpdateMJTemplateParam(
        @Arg('input', () => UpdateMJTemplateParamInput) input: UpdateMJTemplateParamInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Template Params', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplateParam_)
    async DeleteMJTemplateParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Params', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Templates
//****************************************************************************
@ObjectType({ description: `Templates are used for dynamic expansion of a static template with data from a given context. Templates can be used to create documents, messages and anything else that requires dynamic document creation merging together static text, data and lightweight logic` })
export class MJTemplate_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `This prompt will be used by the AI to generate template content as requested by the user.`}) 
    UserPrompt?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use until the specified date. Requires IsActive to be set to 1`}) 
    @MaxLength(10)
    ActiveAt?: Date;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use after the specified date. If IsActive=0, this has no effect.`}) 
    @MaxLength(10)
    DisabledAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 0, the template will be disabled regardless of the values in ActiveAt/DisabledAt. `}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJTemplateParam_])
    TemplateParams_TemplateIDArray: MJTemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [MJTemplateContent_])
    TemplateContents_TemplateIDArray: MJTemplateContent_[]; // Link to TemplateContents
    
    @Field(() => [MJUserNotificationType_])
    MJ_UserNotificationTypes_SMSTemplateIDArray: MJUserNotificationType_[]; // Link to MJ_UserNotificationTypes
    
    @Field(() => [MJAIPrompt_])
    AIPrompts_TemplateIDArray: MJAIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [MJUserNotificationType_])
    MJ_UserNotificationTypes_EmailTemplateIDArray: MJUserNotificationType_[]; // Link to MJ_UserNotificationTypes
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_TemplateIDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class CreateMJTemplateInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt: Date | null;

    @Field({ nullable: true })
    DisabledAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class UpdateMJTemplateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt?: Date | null;

    @Field({ nullable: true })
    DisabledAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Templates
//****************************************************************************
@ObjectType()
export class RunMJTemplateViewResult {
    @Field(() => [MJTemplate_])
    Results: MJTemplate_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJTemplate_)
export class MJTemplateResolver extends ResolverBase {
    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJTemplateViewResult)
    async RunMJTemplateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Templates';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJTemplate_, { nullable: true })
    async MJTemplate(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJTemplate_ | null> {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Templates', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJTemplateParam_])
    async TemplateParams_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Params', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateContent_])
    async TemplateContents_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Contents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationType_])
    async MJ_UserNotificationTypes_SMSTemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotificationTypes] WHERE [SMSTemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIPrompt_])
    async AIPrompts_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Prompts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationType_])
    async MJ_UserNotificationTypes_EmailTemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Types', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotificationTypes] WHERE [EmailTemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Types', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Types', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_TemplateIDArray(@Root() mjtemplate_: MJTemplate_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TemplateID]='${mjtemplate_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJTemplate_)
    async CreateMJTemplate(
        @Arg('input', () => CreateMJTemplateInput) input: CreateMJTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Templates', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJTemplate_)
    async UpdateMJTemplate(
        @Arg('input', () => UpdateMJTemplateInput) input: UpdateMJTemplateInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Templates', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJTemplate_)
    async DeleteMJTemplate(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Templates', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Application Entities
//****************************************************************************
@ObjectType({ description: `Links users to specific entities within applications, managing entity-level personalization.` })
export class MJUserApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of this entity for the user within the application.`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class CreateMJUserApplicationEntityInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class UpdateMJUserApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Application Entities
//****************************************************************************
@ObjectType()
export class RunMJUserApplicationEntityViewResult {
    @Field(() => [MJUserApplicationEntity_])
    Results: MJUserApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserApplicationEntity_)
export class MJUserApplicationEntityResolver extends ResolverBase {
    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationEntityViewResult)
    async RunMJUserApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Application Entities';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserApplicationEntity_, { nullable: true })
    async MJUserApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserApplicationEntity_ | null> {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Application Entities', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserApplicationEntity_)
    async CreateMJUserApplicationEntity(
        @Arg('input', () => CreateMJUserApplicationEntityInput) input: CreateMJUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Application Entities', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserApplicationEntity_)
    async UpdateMJUserApplicationEntity(
        @Arg('input', () => UpdateMJUserApplicationEntityInput) input: UpdateMJUserApplicationEntityInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Application Entities', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserApplicationEntity_)
    async DeleteMJUserApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Application Entities', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Applications
//****************************************************************************
@ObjectType({ description: `Tracks which applications users have configured to display.` })
export class MJUserApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field(() => Int, {description: `Display order of this application in the user's navigation.`}) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `Whether this application is currently visible to the user.`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field(() => [MJUserApplicationEntity_])
    UserApplicationEntities_UserApplicationIDArray: MJUserApplicationEntity_[]; // Link to UserApplicationEntities
    
}

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class CreateMJUserApplicationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class UpdateMJUserApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Applications
//****************************************************************************
@ObjectType()
export class RunMJUserApplicationViewResult {
    @Field(() => [MJUserApplication_])
    Results: MJUserApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserApplication_)
export class MJUserApplicationResolver extends ResolverBase {
    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserApplicationViewResult)
    async RunMJUserApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Applications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserApplication_, { nullable: true })
    async MJUserApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserApplication_ | null> {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Applications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserApplicationEntity_])
    async UserApplicationEntities_UserApplicationIDArray(@Root() mjuserapplication_: MJUserApplication_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [UserApplicationID]='${mjuserapplication_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Application Entities', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserApplication_)
    async CreateMJUserApplication(
        @Arg('input', () => CreateMJUserApplicationInput) input: CreateMJUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Applications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserApplication_)
    async UpdateMJUserApplication(
        @Arg('input', () => UpdateMJUserApplicationInput) input: UpdateMJUserApplicationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Applications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserApplication_)
    async DeleteMJUserApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Applications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Favorites
//****************************************************************************
@ObjectType({ description: `Records that each user can mark as a favorite for easy access` })
export class MJUserFavorite_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the favorited record.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
}

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class CreateMJUserFavoriteInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class UpdateMJUserFavoriteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Favorites
//****************************************************************************
@ObjectType()
export class RunMJUserFavoriteViewResult {
    @Field(() => [MJUserFavorite_])
    Results: MJUserFavorite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserFavorite_)
export class MJUserFavoriteResolverBase extends ResolverBase {
    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserFavoriteViewResult)
    async RunMJUserFavoriteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Favorites';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserFavorite_, { nullable: true })
    async MJUserFavorite(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserFavorite_ | null> {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Favorites', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserFavorite_)
    async CreateMJUserFavorite(
        @Arg('input', () => CreateMJUserFavoriteInput) input: CreateMJUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Favorites', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserFavorite_)
    async UpdateMJUserFavorite(
        @Arg('input', () => UpdateMJUserFavoriteInput) input: UpdateMJUserFavoriteInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Favorites', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserFavorite_)
    async DeleteMJUserFavorite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Favorites', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Notifications
//****************************************************************************
@ObjectType({ description: `Manages notifications sent to users including alerts, messages, and system updates with read status and priority.` })
export class MJUserNotification_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Brief title or subject of the notification.`}) 
    @MaxLength(510)
    Title?: string;
        
    @Field({nullable: true, description: `Full notification message content.`}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ResourceTypeID?: string;
        
    @Field({nullable: true, description: `Field ResourceConfiguration for entity User Notifications.`}) 
    ResourceConfiguration?: string;
        
    @Field(() => Boolean, {description: `Field Unread for entity User Notifications.`}) 
    Unread: boolean;
        
    @Field({nullable: true, description: `Timestamp when the user read this notification.`}) 
    @MaxLength(10)
    ReadAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `ID of the specific record this notification is about.`}) 
    @MaxLength(16)
    ResourceRecordID?: string;
        
    @Field({nullable: true, description: `Optional reference to notification type for categorization and delivery preferences`}) 
    @MaxLength(16)
    NotificationTypeID?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResourceType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    NotificationType?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class CreateMJUserNotificationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    ResourceTypeID: string | null;

    @Field({ nullable: true })
    ResourceConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt: Date | null;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field({ nullable: true })
    NotificationTypeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class UpdateMJUserNotificationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    ResourceTypeID?: string | null;

    @Field({ nullable: true })
    ResourceConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt?: Date | null;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field({ nullable: true })
    NotificationTypeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Notifications
//****************************************************************************
@ObjectType()
export class RunMJUserNotificationViewResult {
    @Field(() => [MJUserNotification_])
    Results: MJUserNotification_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserNotification_)
export class MJUserNotificationResolver extends ResolverBase {
    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserNotificationViewResult)
    async RunMJUserNotificationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Notifications';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserNotification_, { nullable: true })
    async MJUserNotification(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserNotification_ | null> {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Notifications', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserNotification_)
    async CreateMJUserNotification(
        @Arg('input', () => CreateMJUserNotificationInput) input: CreateMJUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Notifications', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserNotification_)
    async UpdateMJUserNotification(
        @Arg('input', () => UpdateMJUserNotificationInput) input: UpdateMJUserNotificationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Notifications', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserNotification_)
    async DeleteMJUserNotification(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Notifications', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Record Logs
//****************************************************************************
@ObjectType({ description: `Tracks user interactions with specific records, maintaining an audit trail of views or other operations. Changes are managed separately in the Record Changes entity.` })
export class MJUserRecordLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The ID of the accessed record.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field({description: `Field EarliestAt for entity User Record Logs.`}) 
    @MaxLength(10)
    EarliestAt: Date;
        
    @Field({description: `Field LatestAt for entity User Record Logs.`}) 
    @MaxLength(10)
    LatestAt: Date;
        
    @Field(() => Int, {description: `Field TotalCount for entity User Record Logs.`}) 
    TotalCount: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    UserSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UserSupervisorEmail?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Record Logs
//****************************************************************************
@InputType()
export class CreateMJUserRecordLogInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;
}
    

//****************************************************************************
// INPUT TYPE for User Record Logs
//****************************************************************************
@InputType()
export class UpdateMJUserRecordLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Record Logs
//****************************************************************************
@ObjectType()
export class RunMJUserRecordLogViewResult {
    @Field(() => [MJUserRecordLog_])
    Results: MJUserRecordLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserRecordLog_)
export class MJUserRecordLogResolver extends ResolverBase {
    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRecordLogViewResult)
    async RunMJUserRecordLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Record Logs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserRecordLog_, { nullable: true })
    async MJUserRecordLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserRecordLog_ | null> {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Record Logs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserRecordLog_)
    async CreateMJUserRecordLog(
        @Arg('input', () => CreateMJUserRecordLogInput) input: CreateMJUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Record Logs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserRecordLog_)
    async UpdateMJUserRecordLog(
        @Arg('input', () => UpdateMJUserRecordLogInput) input: UpdateMJUserRecordLogInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Record Logs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserRecordLog_)
    async DeleteMJUserRecordLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Record Logs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Roles
//****************************************************************************
@ObjectType({ description: `Associates users with roles in the system, managing role-based access control and permission inheritance.` })
export class MJUserRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for User Roles
//****************************************************************************
@InputType()
export class CreateMJUserRoleInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User Roles
//****************************************************************************
@InputType()
export class UpdateMJUserRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Roles
//****************************************************************************
@ObjectType()
export class RunMJUserRoleViewResult {
    @Field(() => [MJUserRole_])
    Results: MJUserRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserRole_)
export class MJUserRoleResolver extends ResolverBase {
    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserRoleViewResult)
    async RunMJUserRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Roles';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserRole_, { nullable: true })
    async MJUserRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserRole_ | null> {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Roles', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJUserRole_])
    async AllUserRoles(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles]` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserRole_)
    async CreateMJUserRole(
        @Arg('input', () => CreateMJUserRoleInput) input: CreateMJUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Roles', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserRole_)
    async UpdateMJUserRole(
        @Arg('input', () => UpdateMJUserRoleInput) input: UpdateMJUserRoleInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Roles', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserRole_)
    async DeleteMJUserRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Roles', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Categories
//****************************************************************************
@ObjectType({ description: `Organizes user-created views into categories for personal organization and sharing within teams.` })
export class MJUserViewCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RootParentID?: string;
        
    @Field(() => [MJUserViewCategory_])
    UserViewCategories_ParentIDArray: MJUserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [MJUserView_])
    UserViews_CategoryIDArray: MJUserView_[]; // Link to UserViews
    
}

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class CreateMJUserViewCategoryInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class UpdateMJUserViewCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Categories
//****************************************************************************
@ObjectType()
export class RunMJUserViewCategoryViewResult {
    @Field(() => [MJUserViewCategory_])
    Results: MJUserViewCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewCategory_)
export class MJUserViewCategoryResolver extends ResolverBase {
    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewCategoryViewResult)
    async RunMJUserViewCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Categories';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewCategory_, { nullable: true })
    async MJUserViewCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewCategory_ | null> {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User View Categories', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserViewCategory_])
    async UserViewCategories_ParentIDArray(@Root() mjuserviewcategory_: MJUserViewCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ParentID]='${mjuserviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User View Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async UserViews_CategoryIDArray(@Root() mjuserviewcategory_: MJUserViewCategory_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [CategoryID]='${mjuserviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserViewCategory_)
    async CreateMJUserViewCategory(
        @Arg('input', () => CreateMJUserViewCategoryInput) input: CreateMJUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Categories', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewCategory_)
    async UpdateMJUserViewCategory(
        @Arg('input', () => UpdateMJUserViewCategoryInput) input: UpdateMJUserViewCategoryInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Categories', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewCategory_)
    async DeleteMJUserViewCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Categories', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Run Details
//****************************************************************************
@ObjectType({ description: `Tracks the set of records that were included in each run of a given user view.` })
export class MJUserViewRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewRunID: string;
        
    @Field({description: `Field RecordID for entity User View Run Details.`}) 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class CreateMJUserViewRunDetailInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class UpdateMJUserViewRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Run Details
//****************************************************************************
@ObjectType()
export class RunMJUserViewRunDetailViewResult {
    @Field(() => [MJUserViewRunDetail_])
    Results: MJUserViewRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewRunDetail_)
export class MJUserViewRunDetailResolver extends ResolverBase {
    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunDetailViewResult)
    async RunMJUserViewRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Run Details';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewRunDetail_, { nullable: true })
    async MJUserViewRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewRunDetail_ | null> {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User View Run Details', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJUserViewRunDetail_)
    async CreateMJUserViewRunDetail(
        @Arg('input', () => CreateMJUserViewRunDetailInput) input: CreateMJUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Run Details', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewRunDetail_)
    async UpdateMJUserViewRunDetail(
        @Arg('input', () => UpdateMJUserViewRunDetailInput) input: UpdateMJUserViewRunDetailInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Run Details', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewRunDetail_)
    async DeleteMJUserViewRunDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Run Details', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Runs
//****************************************************************************
@ObjectType({ description: `User Views can be logged when run to capture the date and user that ran the view as well as the output results.` })
export class MJUserViewRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field({description: `Timestamp when the view was executed.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    UserView: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [MJUserViewRunDetail_])
    UserViewRunDetails_UserViewRunIDArray: MJUserViewRunDetail_[]; // Link to UserViewRunDetails
    
}

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class CreateMJUserViewRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class UpdateMJUserViewRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Runs
//****************************************************************************
@ObjectType()
export class RunMJUserViewRunViewResult {
    @Field(() => [MJUserViewRun_])
    Results: MJUserViewRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserViewRun_)
export class MJUserViewRunResolver extends ResolverBase {
    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewRunViewResult)
    async RunMJUserViewRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserViewRun_, { nullable: true })
    async MJUserViewRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserViewRun_ | null> {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User View Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserViewRunDetail_])
    async UserViewRunDetails_UserViewRunIDArray(@Root() mjuserviewrun_: MJUserViewRun_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [UserViewRunID]='${mjuserviewrun_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User View Run Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserViewRun_)
    async CreateMJUserViewRun(
        @Arg('input', () => CreateMJUserViewRunInput) input: CreateMJUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User View Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserViewRun_)
    async UpdateMJUserViewRun(
        @Arg('input', () => UpdateMJUserViewRunInput) input: UpdateMJUserViewRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User View Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserViewRun_)
    async DeleteMJUserViewRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Views
//****************************************************************************
@ObjectType({ description: `Views are sets of records within a given entity defined by filtering rules. Views can be used programatically to retrieve dynamic sets of data and in user interfaces like MJ Explorer for end-user consumption.` })
export class MJUserView_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field(() => Boolean, {description: `Whether this view is shared with other users.`}) 
    IsShared: boolean;
        
    @Field(() => Boolean, {description: `Whether this is the user's default view for the entity.`}) 
    IsDefault: boolean;
        
    @Field({nullable: true, description: `JSON storing complete grid configuration including columns, widths, and formatting.`}) 
    GridState?: string;
        
    @Field({nullable: true, description: `JSON storing the view's filter configuration.`}) 
    FilterState?: string;
        
    @Field(() => Boolean, {description: `Indicates if custom filters beyond standard options are applied.`}) 
    CustomFilterState: boolean;
        
    @Field(() => Boolean, {description: `Whether AI-powered smart filtering is enabled for this view.`}) 
    SmartFilterEnabled: boolean;
        
    @Field({nullable: true, description: `Natural language prompt for AI-powered filtering.`}) 
    SmartFilterPrompt?: string;
        
    @Field({nullable: true, description: `Generated WHERE clause from smart filter processing.`}) 
    SmartFilterWhereClause?: string;
        
    @Field({nullable: true, description: `AI-generated explanation of what the smart filter does.`}) 
    SmartFilterExplanation?: string;
        
    @Field({nullable: true, description: `Direct SQL WHERE clause for the view filter.`}) 
    WhereClause?: string;
        
    @Field(() => Boolean, {description: `Indicates if a custom WHERE clause is used instead of standard filters.`}) 
    CustomWhereClause: boolean;
        
    @Field({nullable: true, description: `JSON storing the view's sort configuration.`}) 
    SortState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Thumbnail image for the user view that can be displayed in gallery views. Can contain either a URL to an image file or a Base64-encoded image string.`}) 
    Thumbnail?: string;
        
    @Field({nullable: true, description: `JSON configuration for card display mode in Data Explorer. Stores card layout settings including title field, subtitle, display fields, thumbnails, and layout density. When null, defaults are derived from entity metadata. See CardState interface in packages/Angular/Generic/entity-viewer/src/lib/types.ts for the current schema definition.`}) 
    CardState?: string;
        
    @Field({nullable: true, description: `JSON configuration for display mode settings. Stores default display mode (grid/cards/timeline/chart), available modes for sharing, and mode-specific configurations like timeline date field and segmentation. See ViewDisplayState interface in packages/Angular/Generic/entity-viewer/src/lib/types.ts for schema.`}) 
    DisplayState?: string;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field() 
    @MaxLength(30)
    UserType: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field(() => [MJEntityRelationship_])
    EntityRelationships_DisplayUserViewGUIDArray: MJEntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [MJUserViewRun_])
    UserViewRuns_UserViewIDArray: MJUserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [MJDataContextItem_])
    DataContextItems_ViewIDArray: MJDataContextItem_[]; // Link to DataContextItems
    
}

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class CreateMJUserViewInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState: string | null;

    @Field({ nullable: true })
    FilterState: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation: string | null;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState: string | null;

    @Field({ nullable: true })
    Thumbnail: string | null;

    @Field({ nullable: true })
    CardState: string | null;

    @Field({ nullable: true })
    DisplayState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class UpdateMJUserViewInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState?: string | null;

    @Field({ nullable: true })
    FilterState?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt?: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause?: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation?: string | null;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState?: string | null;

    @Field({ nullable: true })
    Thumbnail?: string | null;

    @Field({ nullable: true })
    CardState?: string | null;

    @Field({ nullable: true })
    DisplayState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Views
//****************************************************************************
@ObjectType()
export class RunMJUserViewViewResult {
    @Field(() => [MJUserView_])
    Results: MJUserView_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUserView_)
export class MJUserViewResolverBase extends ResolverBase {
    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewViewResult)
    async RunMJUserViewDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Views';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUserView_, { nullable: true })
    async MJUserView(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUserView_ | null> {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('User Views', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJUserView_])
    async AllUserViews(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews]` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityRelationship_])
    async EntityRelationships_DisplayUserViewGUIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayUserViewGUID]='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Relationships', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewRun_])
    async UserViewRuns_UserViewIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [UserViewID]='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User View Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContextItem_])
    async DataContextItems_ViewIDArray(@Root() mjuserview_: MJUserView_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ViewID]='${mjuserview_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Data Context Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUserView_)
    async CreateMJUserView(
        @Arg('input', () => CreateMJUserViewInput) input: CreateMJUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('User Views', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUserView_)
    async UpdateMJUserView(
        @Arg('input', () => UpdateMJUserViewInput) input: UpdateMJUserViewInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('User Views', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUserView_)
    async DeleteMJUserView(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Views', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Users
//****************************************************************************
@ObjectType({ description: `A list of all users who have or had access to the system` })
export class MJUser_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `User's first name or given name.`}) 
    @MaxLength(100)
    FirstName?: string;
        
    @Field({nullable: true, description: `User's last name or surname.`}) 
    @MaxLength(100)
    LastName?: string;
        
    @Field({nullable: true, description: `User's professional title or salutation.`}) 
    @MaxLength(100)
    Title?: string;
        
    @Field({description: `Unique email address for the user. This field must be unique across all users in the system.`}) 
    @MaxLength(200)
    Email: string;
        
    @Field({description: `User account type (User, Guest, System, API).`}) 
    @MaxLength(30)
    Type: string;
        
    @Field(() => Boolean, {description: `Whether this user account is currently active and can log in.`}) 
    IsActive: boolean;
        
    @Field({description: `Type of record this user is linked to (None, Employee, Contact, etc.).`}) 
    @MaxLength(20)
    LinkedRecordType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true, description: `ID of the specific record this user is linked to.`}) 
    @MaxLength(900)
    LinkedEntityRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EmployeeID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `User avatar image. Can be a Base64 encoded data URI (e.g., "data:image/png;base64,...") or a URL to an image file. Preferred over UserImageIconClass when present. Recommended for small thumbnail images only to maintain performance.`}) 
    UserImageURL?: string;
        
    @Field({nullable: true, description: `Font Awesome icon class for user avatar (e.g., "fa-solid fa-user-astronaut"). Used as fallback when UserImageURL is not provided. Example classes: "fa-solid fa-user", "fa-regular fa-circle-user", "fa-solid fa-user-tie".`}) 
    @MaxLength(200)
    UserImageIconClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeFirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmployeeTitle?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeSupervisorEmail?: string;
        
    @Field(() => [MJUserApplication_])
    UserApplications_UserIDArray: MJUserApplication_[]; // Link to UserApplications
    
    @Field(() => [MJUserRole_])
    UserRoles_UserIDArray: MJUserRole_[]; // Link to UserRoles
    
    @Field(() => [MJWorkspace_])
    Workspaces_UserIDArray: MJWorkspace_[]; // Link to Workspaces
    
    @Field(() => [MJReport_])
    Reports_UserIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJReportSnapshot_])
    ReportSnapshots_UserIDArray: MJReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [MJRecordChange_])
    RecordChanges_UserIDArray: MJRecordChange_[]; // Link to RecordChanges
    
    @Field(() => [MJDashboard_])
    Dashboards_UserIDArray: MJDashboard_[]; // Link to Dashboards
    
    @Field(() => [MJUserViewRun_])
    UserViewRuns_RunByUserIDArray: MJUserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [MJAuditLog_])
    AuditLogs_UserIDArray: MJAuditLog_[]; // Link to AuditLogs
    
    @Field(() => [MJList_])
    Lists_UserIDArray: MJList_[]; // Link to Lists
    
    @Field(() => [MJUserFavorite_])
    UserFavorites_UserIDArray: MJUserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [MJUserRecordLog_])
    UserRecordLogs_UserIDArray: MJUserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [MJUserView_])
    UserViews_UserIDArray: MJUserView_[]; // Link to UserViews
    
    @Field(() => [MJCompanyIntegrationRun_])
    CompanyIntegrationRuns_RunByUserIDArray: MJCompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [MJUserNotification_])
    UserNotifications_UserIDArray: MJUserNotification_[]; // Link to UserNotifications
    
    @Field(() => [MJConversation_])
    Conversations_UserIDArray: MJConversation_[]; // Link to Conversations
    
    @Field(() => [MJRecordMergeLog_])
    RecordMergeLogs_InitiatedByUserIDArray: MJRecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [MJDataContext_])
    DataContexts_UserIDArray: MJDataContext_[]; // Link to DataContexts
    
    @Field(() => [MJReportCategory_])
    ReportCategories_UserIDArray: MJReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [MJUserViewCategory_])
    UserViewCategories_UserIDArray: MJUserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [MJDashboardCategory_])
    DashboardCategories_UserIDArray: MJDashboardCategory_[]; // Link to DashboardCategories
    
    @Field(() => [MJQueryCategory_])
    QueryCategories_UserIDArray: MJQueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [MJDuplicateRun_])
    DuplicateRuns_StartedByUserIDArray: MJDuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [MJActionExecutionLog_])
    ActionExecutionLogs_UserIDArray: MJActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [MJAction_])
    Actions_CodeApprovedByUserIDArray: MJAction_[]; // Link to Actions
    
    @Field(() => [MJCommunicationRun_])
    CommunicationRuns_UserIDArray: MJCommunicationRun_[]; // Link to CommunicationRuns
    
    @Field(() => [MJTemplate_])
    Templates_UserIDArray: MJTemplate_[]; // Link to Templates
    
    @Field(() => [MJTemplateCategory_])
    TemplateCategories_UserIDArray: MJTemplateCategory_[]; // Link to TemplateCategories
    
    @Field(() => [MJRecommendationRun_])
    RecommendationRuns_RunByUserIDArray: MJRecommendationRun_[]; // Link to RecommendationRuns
    
    @Field(() => [MJRecordChangeReplayRun_])
    RecordChangeReplayRuns_UserIDArray: MJRecordChangeReplayRun_[]; // Link to RecordChangeReplayRuns
    
    @Field(() => [MJListCategory_])
    ListCategories_UserIDArray: MJListCategory_[]; // Link to ListCategories
    
    @Field(() => [MJScheduledAction_])
    ScheduledActions_CreatedByUserIDArray: MJScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [MJResourceLink_])
    ResourceLinks_UserIDArray: MJResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [MJAIAgentRequest_])
    AIAgentRequests_ResponseByUserIDArray: MJAIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [MJAIAgentNote_])
    AIAgentNotes_UserIDArray: MJAIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [MJReportUserState_])
    MJ_ReportUserStates_UserIDArray: MJReportUserState_[]; // Link to MJ_ReportUserStates
    
    @Field(() => [MJDashboardUserPreference_])
    MJ_DashboardUserPreferences_UserIDArray: MJDashboardUserPreference_[]; // Link to MJ_DashboardUserPreferences
    
    @Field(() => [MJDashboardUserState_])
    MJ_DashboardUserStates_UserIDArray: MJDashboardUserState_[]; // Link to MJ_DashboardUserStates
    
    @Field(() => [MJArtifactVersion_])
    MJ_ArtifactVersions_UserIDArray: MJArtifactVersion_[]; // Link to MJ_ArtifactVersions
    
    @Field(() => [MJPublicLink_])
    MJ_PublicLinks_UserIDArray: MJPublicLink_[]; // Link to MJ_PublicLinks
    
    @Field(() => [MJScheduledJobRun_])
    MJ_ScheduledJobRuns_ExecutedByUserIDArray: MJScheduledJobRun_[]; // Link to MJ_ScheduledJobRuns
    
    @Field(() => [MJScheduledJob_])
    MJ_ScheduledJobs_NotifyUserIDArray: MJScheduledJob_[]; // Link to MJ_ScheduledJobs
    
    @Field(() => [MJArtifactPermission_])
    MJ_ArtifactPermissions_UserIDArray: MJArtifactPermission_[]; // Link to MJ_ArtifactPermissions
    
    @Field(() => [MJArtifactUse_])
    MJ_ArtifactUses_UserIDArray: MJArtifactUse_[]; // Link to MJ_ArtifactUses
    
    @Field(() => [MJConversationDetailRating_])
    MJ_ConversationDetailRatings_UserIDArray: MJConversationDetailRating_[]; // Link to MJ_ConversationDetailRatings
    
    @Field(() => [MJTestRunFeedback_])
    MJ_TestRunFeedbacks_ReviewerUserIDArray: MJTestRunFeedback_[]; // Link to MJ_TestRunFeedbacks
    
    @Field(() => [MJTestSuiteRun_])
    MJ_TestSuiteRuns_RunByUserIDArray: MJTestSuiteRun_[]; // Link to MJ_TestSuiteRuns
    
    @Field(() => [MJUserSetting_])
    MJ_UserSettings_UserIDArray: MJUserSetting_[]; // Link to MJ_UserSettings
    
    @Field(() => [MJListShare_])
    MJ_ListShares_UserIDArray: MJListShare_[]; // Link to MJ_ListShares
    
    @Field(() => [MJListInvitation_])
    MJ_ListInvitations_CreatedByUserIDArray: MJListInvitation_[]; // Link to MJ_ListInvitations
    
    @Field(() => [MJDashboardCategoryLink_])
    MJ_DashboardCategoryLinks_UserIDArray: MJDashboardCategoryLink_[]; // Link to MJ_DashboardCategoryLinks
    
    @Field(() => [MJDashboardCategoryPermission_])
    MJ_DashboardCategoryPermissions_UserIDArray: MJDashboardCategoryPermission_[]; // Link to MJ_DashboardCategoryPermissions
    
    @Field(() => [MJDashboardPermission_])
    MJ_DashboardPermissions_SharedByUserIDArray: MJDashboardPermission_[]; // Link to MJ_DashboardPermissions
    
    @Field(() => [MJAPIKey_])
    MJ_APIKeys_UserIDArray: MJAPIKey_[]; // Link to MJ_APIKeys
    
    @Field(() => [MJUserNotificationPreference_])
    MJ_UserNotificationPreferences_UserIDArray: MJUserNotificationPreference_[]; // Link to MJ_UserNotificationPreferences
    
    @Field(() => [MJMCPToolExecutionLog_])
    MJ_MCPToolExecutionLogs_UserIDArray: MJMCPToolExecutionLog_[]; // Link to MJ_MCPToolExecutionLogs
    
    @Field(() => [MJVersionLabelRestore_])
    MJ_VersionLabelRestores_UserIDArray: MJVersionLabelRestore_[]; // Link to MJ_VersionLabelRestores
    
    @Field(() => [MJOAuthAuthorizationState_])
    MJ_OAuthAuthorizationStates_UserIDArray: MJOAuthAuthorizationState_[]; // Link to MJ_OAuthAuthorizationStates
    
    @Field(() => [MJResourcePermission_])
    ResourcePermissions_UserIDArray: MJResourcePermission_[]; // Link to ResourcePermissions
    
    @Field(() => [MJAIAgentRequest_])
    AIAgentRequests_RequestForUserIDArray: MJAIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [MJConversationDetail_])
    ConversationDetails_UserIDArray: MJConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [MJAccessControlRule_])
    MJ_AccessControlRules_GrantedByUserIDArray: MJAccessControlRule_[]; // Link to MJ_AccessControlRules
    
    @Field(() => [MJArtifact_])
    MJ_Artifacts_UserIDArray: MJArtifact_[]; // Link to MJ_Artifacts
    
    @Field(() => [MJScheduledJob_])
    MJ_ScheduledJobs_OwnerUserIDArray: MJScheduledJob_[]; // Link to MJ_ScheduledJobs
    
    @Field(() => [MJCollectionPermission_])
    MJ_CollectionPermissions_SharedByUserIDArray: MJCollectionPermission_[]; // Link to MJ_CollectionPermissions
    
    @Field(() => [MJArtifactPermission_])
    MJ_ArtifactPermissions_SharedByUserIDArray: MJArtifactPermission_[]; // Link to MJ_ArtifactPermissions
    
    @Field(() => [MJTestRun_])
    MJ_TestRuns_RunByUserIDArray: MJTestRun_[]; // Link to MJ_TestRuns
    
    @Field(() => [MJDashboardPermission_])
    MJ_DashboardPermissions_UserIDArray: MJDashboardPermission_[]; // Link to MJ_DashboardPermissions
    
    @Field(() => [MJDashboardCategoryPermission_])
    MJ_DashboardCategoryPermissions_SharedByUserIDArray: MJDashboardCategoryPermission_[]; // Link to MJ_DashboardCategoryPermissions
    
    @Field(() => [MJAPIKey_])
    MJ_APIKeys_CreatedByUserIDArray: MJAPIKey_[]; // Link to MJ_APIKeys
    
    @Field(() => [MJMCPServerConnectionPermission_])
    MJ_MCPServerConnectionPermissions_UserIDArray: MJMCPServerConnectionPermission_[]; // Link to MJ_MCPServerConnectionPermissions
    
    @Field(() => [MJVersionLabel_])
    MJ_VersionLabels_CreatedByUserIDArray: MJVersionLabel_[]; // Link to MJ_VersionLabels
    
    @Field(() => [MJAIAgentRun_])
    MJ_AIAgentRuns_UserIDArray: MJAIAgentRun_[]; // Link to MJ_AIAgentRuns
    
    @Field(() => [MJAIAgentPermission_])
    MJ_AIAgentPermissions_UserIDArray: MJAIAgentPermission_[]; // Link to MJ_AIAgentPermissions
    
    @Field(() => [MJCollection_])
    MJ_Collections_OwnerIDArray: MJCollection_[]; // Link to MJ_Collections
    
    @Field(() => [MJCollectionPermission_])
    MJ_CollectionPermissions_UserIDArray: MJCollectionPermission_[]; // Link to MJ_CollectionPermissions
    
    @Field(() => [MJTask_])
    MJ_Tasks_UserIDArray: MJTask_[]; // Link to MJ_Tasks
    
    @Field(() => [MJAIAgentExample_])
    MJ_AIAgentExamples_UserIDArray: MJAIAgentExample_[]; // Link to MJ_AIAgentExamples
    
    @Field(() => [MJAIAgent_])
    AIAgents_OwnerUserIDArray: MJAIAgent_[]; // Link to AIAgents
    
}

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class CreateMJUserInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName: string | null;

    @Field({ nullable: true })
    LastName: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID: string | null;

    @Field({ nullable: true })
    EmployeeID: string | null;

    @Field({ nullable: true })
    UserImageURL: string | null;

    @Field({ nullable: true })
    UserImageIconClass: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class UpdateMJUserInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName?: string | null;

    @Field({ nullable: true })
    LastName?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID?: string | null;

    @Field({ nullable: true })
    EmployeeID?: string | null;

    @Field({ nullable: true })
    UserImageURL?: string | null;

    @Field({ nullable: true })
    UserImageIconClass?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Users
//****************************************************************************
@ObjectType()
export class RunMJUserViewResult {
    @Field(() => [MJUser_])
    Results: MJUser_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJUser_)
export class MJUserResolverBase extends ResolverBase {
    @Query(() => RunMJUserViewResult)
    async RunMJUserViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewResult)
    async RunMJUserViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJUserViewResult)
    async RunMJUserDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Users';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJUser_, { nullable: true })
    async MJUser(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJUser_ | null> {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Users', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Query(() => [MJUser_])
    async AllUsers(@Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers]` + this.getRowLevelSecurityWhereClause(provider, 'Users', userPayload, EntityPermissionType.Read, ' WHERE');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Users', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJUserApplication_])
    async UserApplications_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Applications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRole_])
    async UserRoles_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Roles', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJWorkspace_])
    async Workspaces_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Workspaces', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReport_])
    async Reports_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportSnapshot_])
    async ReportSnapshots_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Report Snapshots', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChange_])
    async RecordChanges_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Changes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboard_])
    async Dashboards_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dashboards', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewRun_])
    async UserViewRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User View Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAuditLog_])
    async AuditLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Audit Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJList_])
    async Lists_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Lists', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Lists', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserFavorite_])
    async UserFavorites_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Favorites', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserRecordLog_])
    async UserRecordLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Record Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserView_])
    async UserViews_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Views', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Views', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCompanyIntegrationRun_])
    async CompanyIntegrationRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotification_])
    async UserNotifications_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User Notifications', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversation_])
    async Conversations_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordMergeLog_])
    async RecordMergeLogs_InitiatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [InitiatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDataContext_])
    async DataContexts_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Data Contexts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportCategory_])
    async ReportCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Report Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserViewCategory_])
    async UserViewCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('User View Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategory_])
    async DashboardCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJQueryCategory_])
    async QueryCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Query Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDuplicateRun_])
    async DuplicateRuns_StartedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [StartedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJActionExecutionLog_])
    async ActionExecutionLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAction_])
    async Actions_CodeApprovedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CodeApprovedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCommunicationRun_])
    async CommunicationRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Communication Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplate_])
    async Templates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Templates', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Templates', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTemplateCategory_])
    async TemplateCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Template Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecommendationRun_])
    async RecommendationRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJRecordChangeReplayRun_])
    async RecordChangeReplayRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Record Change Replay Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListCategory_])
    async ListCategories_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('List Categories', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledAction_])
    async ScheduledActions_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [CreatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourceLink_])
    async ResourceLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Resource Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async AIAgentRequests_ResponseByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ResponseByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentNote_])
    async AIAgentNotes_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJReportUserState_])
    async MJ_ReportUserStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserPreference_])
    async MJ_DashboardUserPreferences_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserPreferences] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardUserState_])
    async MJ_DashboardUserStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard User States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardUserStates] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard User States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard User States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactVersion_])
    async MJ_ArtifactVersions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Versions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactVersions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Versions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJPublicLink_])
    async MJ_PublicLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Public Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwPublicLinks] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Public Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Public Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledJobRun_])
    async MJ_ScheduledJobRuns_ExecutedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Job Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobRuns] WHERE [ExecutedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Job Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Job Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledJob_])
    async MJ_ScheduledJobs_NotifyUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobs] WHERE [NotifyUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactPermission_])
    async MJ_ArtifactPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactPermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactUse_])
    async MJ_ArtifactUses_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Uses', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactUses] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Uses', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Uses', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetailRating_])
    async MJ_ConversationDetailRatings_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Detail Ratings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetailRatings] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Conversation Detail Ratings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Detail Ratings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRunFeedback_])
    async MJ_TestRunFeedbacks_ReviewerUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Run Feedbacks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRunFeedbacks] WHERE [ReviewerUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Run Feedbacks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Run Feedbacks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestSuiteRun_])
    async MJ_TestSuiteRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Suite Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestSuiteRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Suite Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Suite Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserSetting_])
    async MJ_UserSettings_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Settings', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserSettings] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Settings', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Settings', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListShare_])
    async MJ_ListShares_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Shares', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListShares] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Shares', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Shares', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJListInvitation_])
    async MJ_ListInvitations_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: List Invitations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListInvitations] WHERE [CreatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: List Invitations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: List Invitations', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryLink_])
    async MJ_DashboardCategoryLinks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Links', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryLinks] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Links', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Links', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryPermission_])
    async MJ_DashboardCategoryPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryPermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardPermission_])
    async MJ_DashboardPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardPermissions] WHERE [SharedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKey_])
    async MJ_APIKeys_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeys] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJUserNotificationPreference_])
    async MJ_UserNotificationPreferences_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: User Notification Preferences', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotificationPreferences] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: User Notification Preferences', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: User Notification Preferences', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPToolExecutionLog_])
    async MJ_MCPToolExecutionLogs_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Tool Execution Logs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPToolExecutionLogs] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Tool Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Tool Execution Logs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabelRestore_])
    async MJ_VersionLabelRestores_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Label Restores', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabelRestores] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Label Restores', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Label Restores', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJOAuthAuthorizationState_])
    async MJ_OAuthAuthorizationStates_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: O Auth Authorization States', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOAuthAuthorizationStates] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: O Auth Authorization States', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: O Auth Authorization States', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJResourcePermission_])
    async ResourcePermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Resource Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRequest_])
    async AIAgentRequests_RequestForUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [RequestForUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJConversationDetail_])
    async ConversationDetails_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Conversation Details', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAccessControlRule_])
    async MJ_AccessControlRules_GrantedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Access Control Rules', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAccessControlRules] WHERE [GrantedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Access Control Rules', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Access Control Rules', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifact_])
    async MJ_Artifacts_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifacts', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifacts] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifacts', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJScheduledJob_])
    async MJ_ScheduledJobs_OwnerUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Scheduled Jobs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledJobs] WHERE [OwnerUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Scheduled Jobs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Scheduled Jobs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionPermission_])
    async MJ_CollectionPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionPermissions] WHERE [SharedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJArtifactPermission_])
    async MJ_ArtifactPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Artifact Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactPermissions] WHERE [SharedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Artifact Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTestRun_])
    async MJ_TestRuns_RunByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Test Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTestRuns] WHERE [RunByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Test Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Test Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardPermission_])
    async MJ_DashboardPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardPermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJDashboardCategoryPermission_])
    async MJ_DashboardCategoryPermissions_SharedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Dashboard Category Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategoryPermissions] WHERE [SharedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Dashboard Category Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Dashboard Category Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAPIKey_])
    async MJ_APIKeys_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: API Keys', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAPIKeys] WHERE [CreatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: API Keys', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: API Keys', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJMCPServerConnectionPermission_])
    async MJ_MCPServerConnectionPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: MCP Server Connection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwMCPServerConnectionPermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: MCP Server Connection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: MCP Server Connection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJVersionLabel_])
    async MJ_VersionLabels_CreatedByUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Version Labels', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionLabels] WHERE [CreatedByUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Version Labels', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Version Labels', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentRun_])
    async MJ_AIAgentRuns_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRuns] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentPermission_])
    async MJ_AIAgentPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentPermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollection_])
    async MJ_Collections_OwnerIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collections', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollections] WHERE [OwnerID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collections', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collections', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJCollectionPermission_])
    async MJ_CollectionPermissions_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Collection Permissions', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCollectionPermissions] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Collection Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Collection Permissions', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJTask_])
    async MJ_Tasks_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Tasks', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTasks] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: Tasks', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgentExample_])
    async MJ_AIAgentExamples_UserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: AI Agent Examples', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentExamples] WHERE [UserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'MJ: AI Agent Examples', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('MJ: AI Agent Examples', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJAIAgent_])
    async AIAgents_OwnerUserIDArray(@Root() mjuser_: MJUser_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [OwnerUserID]='${mjuser_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('AI Agents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJUser_)
    async CreateMJUser(
        @Arg('input', () => CreateMJUserInput) input: CreateMJUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Users', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJUser_)
    async UpdateMJUser(
        @Arg('input', () => UpdateMJUserInput) input: UpdateMJUserInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Users', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJUser_)
    async DeleteMJUser(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Users', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Databases
//****************************************************************************
@ObjectType({ description: `Configures connections to vector database systems for AI embeddings, similarity search, and semantic operations.` })
export class MJVectorDatabase_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Field DefaultURL for entity Vector Databases.`}) 
    @MaxLength(510)
    DefaultURL?: string;
        
    @Field({nullable: true, description: `Field ClassKey for entity Vector Databases.`}) 
    @MaxLength(200)
    ClassKey?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJVectorIndex_])
    VectorIndexes_VectorDatabaseIDArray: MJVectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [MJEntityDocument_])
    EntityDocuments_IDArray: MJEntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class CreateMJVectorDatabaseInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultURL: string | null;

    @Field({ nullable: true })
    ClassKey: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class UpdateMJVectorDatabaseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultURL?: string | null;

    @Field({ nullable: true })
    ClassKey?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Databases
//****************************************************************************
@ObjectType()
export class RunMJVectorDatabaseViewResult {
    @Field(() => [MJVectorDatabase_])
    Results: MJVectorDatabase_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVectorDatabase_)
export class MJVectorDatabaseResolver extends ResolverBase {
    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorDatabaseViewResult)
    async RunMJVectorDatabaseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Databases';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVectorDatabase_, { nullable: true })
    async MJVectorDatabase(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVectorDatabase_ | null> {
        this.CheckUserReadPermissions('Vector Databases', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorDatabases] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Databases', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Vector Databases', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJVectorIndex_])
    async VectorIndexes_VectorDatabaseIDArray(@Root() mjvectordatabase_: MJVectorDatabase_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [VectorDatabaseID]='${mjvectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Vector Indexes', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJEntityDocument_])
    async EntityDocuments_IDArray(@Root() mjvectordatabase_: MJVectorDatabase_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${mjvectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJVectorDatabase_)
    async CreateMJVectorDatabase(
        @Arg('input', () => CreateMJVectorDatabaseInput) input: CreateMJVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Vector Databases', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVectorDatabase_)
    async UpdateMJVectorDatabase(
        @Arg('input', () => UpdateMJVectorDatabaseInput) input: UpdateMJVectorDatabaseInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Vector Databases', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVectorDatabase_)
    async DeleteMJVectorDatabase(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Databases', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Indexes
//****************************************************************************
@ObjectType({ description: `Defines vector indexes within a given Vector Database.` })
export class MJVectorIndex_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(16)
    EmbeddingModelID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(100)
    EmbeddingModel: string;
        
    @Field(() => [MJEntityRecordDocument_])
    EntityRecordDocuments_VectorIndexIDArray: MJEntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class CreateMJVectorIndexInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class UpdateMJVectorIndexInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Indexes
//****************************************************************************
@ObjectType()
export class RunMJVectorIndexViewResult {
    @Field(() => [MJVectorIndex_])
    Results: MJVectorIndex_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVectorIndex_)
export class MJVectorIndexResolver extends ResolverBase {
    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVectorIndexViewResult)
    async RunMJVectorIndexDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Indexes';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVectorIndex_, { nullable: true })
    async MJVectorIndex(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVectorIndex_ | null> {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Vector Indexes', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJEntityRecordDocument_])
    async EntityRecordDocuments_VectorIndexIDArray(@Root() mjvectorindex_: MJVectorIndex_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [VectorIndexID]='${mjvectorindex_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJVectorIndex_)
    async CreateMJVectorIndex(
        @Arg('input', () => CreateMJVectorIndexInput) input: CreateMJVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Vector Indexes', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVectorIndex_)
    async UpdateMJVectorIndex(
        @Arg('input', () => UpdateMJVectorIndexInput) input: UpdateMJVectorIndexInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Vector Indexes', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVectorIndex_)
    async DeleteMJVectorIndex(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Indexes', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Version Installations
//****************************************************************************
@ObjectType({ description: `Records installation history of system versions, tracking deployments, rollbacks, and version-specific configurations.` })
export class MJVersionInstallation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int, {description: `Major version number installed.`}) 
    MajorVersion: number;
        
    @Field(() => Int, {description: `Minor version number installed.`}) 
    MinorVersion: number;
        
    @Field(() => Int, {description: `Patch version number installed.`}) 
    PatchVersion: number;
        
    @Field({nullable: true, description: `What type of installation was applied`}) 
    @MaxLength(40)
    Type?: string;
        
    @Field({description: `Timestamp when this version was installed.`}) 
    @MaxLength(10)
    InstalledAt: Date;
        
    @Field({description: `Pending, Complete, Failed`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Any logging that was saved from the installation process`}) 
    InstallLog?: string;
        
    @Field({nullable: true, description: `Optional, comments the administrator wants to save for each installed version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(604)
    CompleteVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class CreateMJVersionInstallationInput {
    @Field({ nullable: true })
    ID?: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class UpdateMJVersionInstallationInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Version Installations
//****************************************************************************
@ObjectType()
export class RunMJVersionInstallationViewResult {
    @Field(() => [MJVersionInstallation_])
    Results: MJVersionInstallation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJVersionInstallation_)
export class MJVersionInstallationResolver extends ResolverBase {
    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJVersionInstallationViewResult)
    async RunMJVersionInstallationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Version Installations';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJVersionInstallation_, { nullable: true })
    async MJVersionInstallation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJVersionInstallation_ | null> {
        this.CheckUserReadPermissions('Version Installations', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionInstallations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Version Installations', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Version Installations', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJVersionInstallation_)
    async CreateMJVersionInstallation(
        @Arg('input', () => CreateMJVersionInstallationInput) input: CreateMJVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Version Installations', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJVersionInstallation_)
    async UpdateMJVersionInstallation(
        @Arg('input', () => UpdateMJVersionInstallationInput) input: UpdateMJVersionInstallationInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Version Installations', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJVersionInstallation_)
    async DeleteMJVersionInstallation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Version Installations', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Engines
//****************************************************************************
@ObjectType({ description: `Registers available workflow execution engines with their capabilities, configuration, and supported workflow types.` })
export class MJWorkflowEngine_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Import path for the workflow engine driver.`}) 
    @MaxLength(1000)
    DriverPath: string;
        
    @Field({description: `Class name implementing the workflow engine interface.`}) 
    @MaxLength(200)
    DriverClass: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [MJWorkflow_])
    Workflows_WorkflowEngineNameArray: MJWorkflow_[]; // Link to Workflows
    
}

//****************************************************************************
// INPUT TYPE for Workflow Engines
//****************************************************************************
@InputType()
export class CreateMJWorkflowEngineInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;
}
    

//****************************************************************************
// INPUT TYPE for Workflow Engines
//****************************************************************************
@InputType()
export class UpdateMJWorkflowEngineInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Engines
//****************************************************************************
@ObjectType()
export class RunMJWorkflowEngineViewResult {
    @Field(() => [MJWorkflowEngine_])
    Results: MJWorkflowEngine_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflowEngine_)
export class MJWorkflowEngineResolver extends ResolverBase {
    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowEngineViewResult)
    async RunMJWorkflowEngineDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Engines';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflowEngine_, { nullable: true })
    async MJWorkflowEngine(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflowEngine_ | null> {
        this.CheckUserReadPermissions('Workflow Engines', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowEngines] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Engines', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Workflow Engines', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJWorkflow_])
    async Workflows_WorkflowEngineNameArray(@Root() mjworkflowengine_: MJWorkflowEngine_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [WorkflowEngineName]='${mjworkflowengine_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Workflows', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJWorkflowEngine_)
    async CreateMJWorkflowEngine(
        @Arg('input', () => CreateMJWorkflowEngineInput) input: CreateMJWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workflow Engines', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkflowEngine_)
    async UpdateMJWorkflowEngine(
        @Arg('input', () => UpdateMJWorkflowEngineInput) input: UpdateMJWorkflowEngineInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflow Engines', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflowEngine_)
    async DeleteMJWorkflowEngine(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflow Engines', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Runs
//****************************************************************************
@ObjectType({ description: `Tracks execution instances of workflows including status, timing, context data, and detailed step-by-step results.` })
export class MJWorkflowRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowID: string;
        
    @Field({description: `Field ExternalSystemRecordID for entity Workflow Runs.`}) 
    @MaxLength(1000)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true, description: `JSON-formatted detailed results from the workflow execution, including outputs from each step and any error information.`}) 
    Results?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Workflow: string;
        
    @Field() 
    @MaxLength(200)
    WorkflowEngineName: string;
        
}

//****************************************************************************
// INPUT TYPE for Workflow Runs
//****************************************************************************
@InputType()
export class CreateMJWorkflowRunInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workflow Runs
//****************************************************************************
@InputType()
export class UpdateMJWorkflowRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Runs
//****************************************************************************
@ObjectType()
export class RunMJWorkflowRunViewResult {
    @Field(() => [MJWorkflowRun_])
    Results: MJWorkflowRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflowRun_)
export class MJWorkflowRunResolver extends ResolverBase {
    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowRunViewResult)
    async RunMJWorkflowRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Runs';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflowRun_, { nullable: true })
    async MJWorkflowRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflowRun_ | null> {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Workflow Runs', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJWorkflowRun_)
    async CreateMJWorkflowRun(
        @Arg('input', () => CreateMJWorkflowRunInput) input: CreateMJWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workflow Runs', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkflowRun_)
    async UpdateMJWorkflowRun(
        @Arg('input', () => UpdateMJWorkflowRunInput) input: UpdateMJWorkflowRunInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflow Runs', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflowRun_)
    async DeleteMJWorkflowRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflow Runs', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflows
//****************************************************************************
@ObjectType({ description: `Defines automated workflows with steps, conditions, and actions for orchestrating complex business processes.` })
export class MJWorkflow_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowEngineID: string;
        
    @Field({description: `The unique identifier of this workflow in an external system, used for synchronization with external workflow engines.`}) 
    @MaxLength(200)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `If set to 1, the workflow will be run automatically on the interval specified by the AutoRunIntervalType and AutoRunInterval fields`}) 
    AutoRunEnabled: boolean;
        
    @Field({nullable: true, description: `Minutes, Hours, Days, Weeks, Months, Years`}) 
    @MaxLength(40)
    AutoRunIntervalUnits?: string;
        
    @Field(() => Int, {nullable: true, description: `The interval, denominated in the units specified in the AutoRunIntervalUnits column, between auto runs of this workflow.`}) 
    AutoRunInterval?: number;
        
    @Field({nullable: true, description: `If specified, this subclass key, via the ClassFactory, will be instantiated, to execute this workflow. If not specified the WorkflowBase class will be used by default.`}) 
    @MaxLength(400)
    SubclassName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true}) 
    AutoRunIntervalMinutes?: number;
        
    @Field(() => [MJReport_])
    Reports_OutputWorkflowIDArray: MJReport_[]; // Link to Reports
    
    @Field(() => [MJWorkflowRun_])
    WorkflowRuns_WorkflowNameArray: MJWorkflowRun_[]; // Link to WorkflowRuns
    
}

//****************************************************************************
// INPUT TYPE for Workflows
//****************************************************************************
@InputType()
export class CreateMJWorkflowInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval: number | null;

    @Field({ nullable: true })
    SubclassName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workflows
//****************************************************************************
@InputType()
export class UpdateMJWorkflowInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval?: number | null;

    @Field({ nullable: true })
    SubclassName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflows
//****************************************************************************
@ObjectType()
export class RunMJWorkflowViewResult {
    @Field(() => [MJWorkflow_])
    Results: MJWorkflow_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkflow_)
export class MJWorkflowResolver extends ResolverBase {
    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkflowViewResult)
    async RunMJWorkflowDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflows';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkflow_, { nullable: true })
    async MJWorkflow(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkflow_ | null> {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Workflows', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJReport_])
    async Reports_OutputWorkflowIDArray(@Root() mjworkflow_: MJWorkflow_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputWorkflowID]='${mjworkflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Reports', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Reports', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @FieldResolver(() => [MJWorkflowRun_])
    async WorkflowRuns_WorkflowNameArray(@Root() mjworkflow_: MJWorkflow_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [WorkflowName]='${mjworkflow_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Workflow Runs', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJWorkflow_)
    async CreateMJWorkflow(
        @Arg('input', () => CreateMJWorkflowInput) input: CreateMJWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workflows', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkflow_)
    async UpdateMJWorkflow(
        @Arg('input', () => UpdateMJWorkflowInput) input: UpdateMJWorkflowInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workflows', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkflow_)
    async DeleteMJWorkflow(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflows', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspace Items
//****************************************************************************
@ObjectType({ description: `Tracks the resources that are active within a given worksapce` })
export class MJWorkspaceItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkspaceID: string;
        
    @Field() 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({nullable: true, description: `The ID of the resource (such as a view, dashboard, or other entity record) that is included in this workspace.`}) 
    @MaxLength(4000)
    ResourceRecordID?: string;
        
    @Field(() => Int, {description: `The display order of this item within the workspace, used for arranging resources in the user interface.`}) 
    Sequence: number;
        
    @Field({nullable: true, description: `JSON configuration data specific to this workspace item, storing custom settings and state information.`}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Workspace: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class CreateMJWorkspaceItemInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class UpdateMJWorkspaceItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspace Items
//****************************************************************************
@ObjectType()
export class RunMJWorkspaceItemViewResult {
    @Field(() => [MJWorkspaceItem_])
    Results: MJWorkspaceItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkspaceItem_)
export class MJWorkspaceItemResolver extends ResolverBase {
    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceItemViewResult)
    async RunMJWorkspaceItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspace Items';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkspaceItem_, { nullable: true })
    async MJWorkspaceItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkspaceItem_ | null> {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Workspace Items', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @Mutation(() => MJWorkspaceItem_)
    async CreateMJWorkspaceItem(
        @Arg('input', () => CreateMJWorkspaceItemInput) input: CreateMJWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workspace Items', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkspaceItem_)
    async UpdateMJWorkspaceItem(
        @Arg('input', () => UpdateMJWorkspaceItemInput) input: UpdateMJWorkspaceItemInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workspace Items', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkspaceItem_)
    async DeleteMJWorkspaceItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspace Items', key, options, provider, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspaces
//****************************************************************************
@ObjectType({ description: `A user can have one or more workspaces` })
export class MJWorkspace_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `JSON blob containing all workspace state: tabs, layout configuration, theme preferences, and active tab. Replaces WorkspaceItem table.`}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [MJWorkspaceItem_])
    WorkspaceItems_WorkSpaceIDArray: MJWorkspaceItem_[]; // Link to WorkspaceItems
    
}

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class CreateMJWorkspaceInput {
    @Field({ nullable: true })
    ID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class UpdateMJWorkspaceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspaces
//****************************************************************************
@ObjectType()
export class RunMJWorkspaceViewResult {
    @Field(() => [MJWorkspace_])
    Results: MJWorkspace_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(MJWorkspace_)
export class MJWorkspaceResolver extends ResolverBase {
    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, provider, userPayload, pubSub);
    }

    @Query(() => RunMJWorkspaceViewResult)
    async RunMJWorkspaceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspaces';
        return super.RunDynamicViewGeneric(input, provider, userPayload, pubSub);
    }
    @Query(() => MJWorkspace_, { nullable: true })
    async MJWorkspace(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<MJWorkspace_ | null> {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.MapFieldNamesToCodeNames('Workspaces', rows && rows.length > 0 ? rows[0] : {}, this.GetUserFromPayload(userPayload));
        return result;
    }
    
    @FieldResolver(() => [MJWorkspaceItem_])
    async WorkspaceItems_WorkSpaceIDArray(@Root() mjworkspace_: MJWorkspace_, @Ctx() { dataSources, userPayload, providers }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const provider = GetReadOnlyProvider(providers, { allowFallbackToReadWrite: true });
        const connPool = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [WorkSpaceID]='${mjworkspace_.ID}' ` + this.getRowLevelSecurityWhereClause(provider, 'Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const rows = await SQLServerDataProvider.ExecuteSQLWithPool(connPool, sSQL, undefined, this.GetUserFromPayload(userPayload));
        const result = await this.ArrayMapFieldNamesToCodeNames('Workspace Items', rows, this.GetUserFromPayload(userPayload));
        return result;
    }
        
    @Mutation(() => MJWorkspace_)
    async CreateMJWorkspace(
        @Arg('input', () => CreateMJWorkspaceInput) input: CreateMJWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.CreateRecord('Workspaces', input, provider, userPayload, pubSub)
    }
        
    @Mutation(() => MJWorkspace_)
    async UpdateMJWorkspace(
        @Arg('input', () => UpdateMJWorkspaceInput) input: UpdateMJWorkspaceInput,
        @Ctx() { providers, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const provider = GetReadWriteProvider(providers);
        return this.UpdateRecord('Workspaces', input, provider, userPayload, pubSub);
    }
    
    @Mutation(() => MJWorkspace_)
    async DeleteMJWorkspace(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { providers, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const provider = GetReadWriteProvider(providers);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspaces', key, options, provider, userPayload, pubSub);
    }
    
}