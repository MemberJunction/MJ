/********************************************************************************
* ALL ENTITIES - TypeGraphQL Type Class Definition - AUTO GENERATED FILE
* Generated Entities and Resolvers for Server
*
*   >>> DO NOT MODIFY THIS FILE!!!!!!!!!!!!
*   >>> YOUR CHANGES WILL BE OVERWRITTEN
*   >>> THE NEXT TIME THIS FILE IS GENERATED
*
**********************************************************************************/
import { Arg, Ctx, Int, Query, Resolver, Field, Float, ObjectType, FieldResolver, Root, InputType, Mutation,
            PubSub, PubSubEngine, ResolverBase, RunViewByIDInput, RunViewByNameInput, RunDynamicViewInput,
            AppContext, KeyValuePairInput, DeleteOptionsInput, GraphQLTimestamp as Timestamp,
            GetReadOnlyDataSource, GetReadWriteDataSource } from '@memberjunction/server';
import { Metadata, EntityPermissionType, CompositeKey } from '@memberjunction/core'

import { MaxLength } from 'class-validator';
import { DataSource } from 'typeorm';
import { mj_core_schema } from '../config.js';



import { ScheduledActionEntity, ScheduledActionParamEntity, ExplorerNavigationItemEntity, GeneratedCodeCategoryEntity, AIAgentModelEntity, AIAgentNoteTypeEntity, AIAgentEntity, AIAgentNoteEntity, AIAgentActionEntity, AIPromptEntity, AIResultCacheEntity, AIPromptCategoryEntity, AIPromptTypeEntity, CompanyEntity, EmployeeEntity, UserFavoriteEntity, EmployeeCompanyIntegrationEntity, EmployeeRoleEntity, EmployeeSkillEntity, RoleEntity, SkillEntity, IntegrationURLFormatEntity, IntegrationEntity, CompanyIntegrationEntity, EntityFieldEntity, EntityEntity, UserEntity, EntityRelationshipEntity, UserRecordLogEntity, UserViewEntity, CompanyIntegrationRunEntity, CompanyIntegrationRunDetailEntity, ErrorLogEntity, ApplicationEntity, ApplicationEntityEntity, EntityPermissionEntity, UserApplicationEntityEntity, UserApplicationEntity, CompanyIntegrationRunAPILogEntity, ListEntity, ListDetailEntity, UserViewRunEntity, UserViewRunDetailEntity, WorkflowRunEntity, WorkflowEntity, WorkflowEngineEntity, RecordChangeEntity, UserRoleEntity, RowLevelSecurityFilterEntity, AuditLogEntity, AuthorizationEntity, AuthorizationRoleEntity, AuditLogTypeEntity, EntityFieldValueEntity, AIModelEntity, AIActionEntity, AIModelActionEntity, EntityAIActionEntity, AIModelTypeEntity, QueueTypeEntity, QueueEntity, QueueTaskEntity, DashboardEntity, OutputTriggerTypeEntity, OutputFormatTypeEntity, OutputDeliveryTypeEntity, ReportEntity, ReportSnapshotEntity, ResourceTypeEntity, TagEntity, TaggedItemEntity, WorkspaceEntity, WorkspaceItemEntity, DatasetEntity, DatasetItemEntity, ConversationDetailEntity, ConversationEntity, UserNotificationEntity, SchemaInfoEntity, CompanyIntegrationRecordMapEntity, RecordMergeLogEntity, RecordMergeDeletionLogEntity, QueryFieldEntity, QueryCategoryEntity, QueryEntity, QueryPermissionEntity, VectorIndexEntity, EntityDocumentTypeEntity, EntityDocumentRunEntity, VectorDatabaseEntity, EntityRecordDocumentEntity, EntityDocumentEntity, DataContextItemEntity, DataContextEntity, UserViewCategoryEntity, DashboardCategoryEntity, ReportCategoryEntity, FileStorageProviderEntity, FileEntity, FileCategoryEntity, FileEntityRecordLinkEntity, VersionInstallationEntity, DuplicateRunDetailMatchEntity, EntityDocumentSettingEntity, EntitySettingEntity, DuplicateRunEntity, DuplicateRunDetailEntity, ApplicationSettingEntity, ActionCategoryEntity, EntityActionEntity, EntityActionInvocationEntity, ActionAuthorizationEntity, EntityActionInvocationTypeEntity, ActionEntity, EntityActionFilterEntity, ActionFilterEntity, ActionContextTypeEntity, ActionResultCodeEntity, ActionContextEntity, ActionExecutionLogEntity, ActionParamEntity, ActionLibraryEntity, LibraryEntity, ListCategoryEntity, CommunicationProviderEntity, CommunicationRunEntity, CommunicationProviderMessageTypeEntity, CommunicationLogEntity, CommunicationBaseMessageTypeEntity, TemplateEntity, TemplateCategoryEntity, TemplateContentEntity, TemplateParamEntity, TemplateContentTypeEntity, RecommendationEntity, RecommendationProviderEntity, RecommendationRunEntity, RecommendationItemEntity, EntityCommunicationMessageTypeEntity, EntityCommunicationFieldEntity, RecordChangeReplayRunEntity, LibraryItemEntity, EntityRelationshipDisplayComponentEntity, EntityActionParamEntity, ResourcePermissionEntity, ResourceLinkEntity, ConversationArtifactVersionEntity, AIAgentRequestEntity, ReportUserStateEntity, QueryEntityEntity, ArtifactTypeEntity, ConversationArtifactEntity, ContentProcessRunEntity, ContentSourceEntity, ContentSourceParamEntity, ContentSourceTypeEntity, ContentSourceTypeParamEntity, ContentTypeEntity, ContentTypeAttributeEntity, ContentFileTypeEntity, ContentItemEntity, ContentItemAttributeEntity, ContentItemTagEntity, GeneratedCodeEntity, ConversationArtifactPermissionEntity, AIAgentLearningCycleEntity, ReportVersionEntity } from '@memberjunction/core-entities';
    

//****************************************************************************
// ENTITY CLASS for Scheduled Actions
//****************************************************************************
@ObjectType({ description: `Track scheduled actions and their details` })
export class ScheduledAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    CreatedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Type of the scheduled action (Daily, Weekly, Monthly, Yearly, Custom)`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Cron expression defining the schedule, automatically maintained by the system unless Type is Custom, in which case the user directly sets this`}) 
    @MaxLength(200)
    CronExpression?: string;
        
    @Field({description: `Timezone for the scheduled action, if not specified defaults to UTC/Z`}) 
    @MaxLength(200)
    Timezone: string;
        
    @Field({description: `Status of the scheduled action (Pending, Active, Disabled, Expired)`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Interval in days for the scheduled action`}) 
    IntervalDays?: number;
        
    @Field({nullable: true, description: `Day of the week for the scheduled action`}) 
    @MaxLength(40)
    DayOfWeek?: string;
        
    @Field(() => Int, {nullable: true, description: `Day of the month for the scheduled action`}) 
    DayOfMonth?: number;
        
    @Field({nullable: true, description: `Month for the scheduled action`}) 
    @MaxLength(40)
    Month?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CustomCronExpression?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    CreatedByUser: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [ScheduledActionParam_])
    ScheduledActionParams_ScheduledActionIDArray: ScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class CreateScheduledActionInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays: number | null;

    @Field({ nullable: true })
    DayOfWeek: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth: number | null;

    @Field({ nullable: true })
    Month: string | null;

    @Field({ nullable: true })
    CustomCronExpression: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Actions
//****************************************************************************
@InputType()
export class UpdateScheduledActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CreatedByUserID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    CronExpression?: string | null;

    @Field({ nullable: true })
    Timezone?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    IntervalDays?: number | null;

    @Field({ nullable: true })
    DayOfWeek?: string | null;

    @Field(() => Int, { nullable: true })
    DayOfMonth?: number | null;

    @Field({ nullable: true })
    Month?: string | null;

    @Field({ nullable: true })
    CustomCronExpression?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Actions
//****************************************************************************
@ObjectType()
export class RunScheduledActionViewResult {
    @Field(() => [ScheduledAction_])
    Results: ScheduledAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ScheduledAction_)
export class ScheduledActionResolver extends ResolverBase {
    @Query(() => RunScheduledActionViewResult)
    async RunScheduledActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionViewResult)
    async RunScheduledActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionViewResult)
    async RunScheduledActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ScheduledAction_, { nullable: true })
    async ScheduledAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ScheduledAction_ | null> {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Scheduled Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ScheduledActionParam_])
    async ScheduledActionParams_ScheduledActionIDArray(@Root() scheduledaction_: ScheduledAction_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ScheduledActionID]='${scheduledaction_.ID}' ` + this.getRowLevelSecurityWhereClause('Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ScheduledAction_)
    async CreateScheduledAction(
        @Arg('input', () => CreateScheduledActionInput) input: CreateScheduledActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Scheduled Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ScheduledAction_)
    async UpdateScheduledAction(
        @Arg('input', () => UpdateScheduledActionInput) input: UpdateScheduledActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Scheduled Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ScheduledAction_)
    async DeleteScheduledAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Scheduled Action Params
//****************************************************************************
@ObjectType()
export class ScheduledActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ScheduledActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field() 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true}) 
    Value?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ScheduledAction: string;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class CreateScheduledActionParamInput {
    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Scheduled Action Params
//****************************************************************************
@InputType()
export class UpdateScheduledActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ScheduledActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Scheduled Action Params
//****************************************************************************
@ObjectType()
export class RunScheduledActionParamViewResult {
    @Field(() => [ScheduledActionParam_])
    Results: ScheduledActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ScheduledActionParam_)
export class ScheduledActionParamResolver extends ResolverBase {
    @Query(() => RunScheduledActionParamViewResult)
    async RunScheduledActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionParamViewResult)
    async RunScheduledActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunScheduledActionParamViewResult)
    async RunScheduledActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Scheduled Action Params';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ScheduledActionParam_, { nullable: true })
    async ScheduledActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ScheduledActionParam_ | null> {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Scheduled Action Params', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ScheduledActionParam_)
    async CreateScheduledActionParam(
        @Arg('input', () => CreateScheduledActionParamInput) input: CreateScheduledActionParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Scheduled Action Params', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ScheduledActionParam_)
    async UpdateScheduledActionParam(
        @Arg('input', () => UpdateScheduledActionParamInput) input: UpdateScheduledActionParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Scheduled Action Params', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ScheduledActionParam_)
    async DeleteScheduledActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Scheduled Action Params', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Explorer Navigation Items
//****************************************************************************
@ObjectType({ description: `Table to store navigation items for MemberJunction Explorer` })
export class ExplorerNavigationItem_ {
    @Field({description: `Unique identifier for each navigation item`}) 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int, {description: `Sequence number for the navigation item, must be unique and greater than 0`}) 
    Sequence: number;
        
    @Field({description: `Unique name of the navigation item displayed to the user`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({description: `The route for the navigation item relative to the app main URL, using Angular syntax like "entity/:entityName"`}) 
    @MaxLength(510)
    Route: string;
        
    @Field(() => Boolean, {description: `Indicates if the navigation item is active; allows turning off items in the UI without deleting them from the metadata`}) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `Controls if the navigation item is shown on the Home screen for MJ Explorer`}) 
    ShowInHomeScreen: boolean;
        
    @Field(() => Boolean, {description: `Controls if the item is shown in the left navigation drawer in the MJ Explorer app or not.`}) 
    ShowInNavigationDrawer: boolean;
        
    @Field({nullable: true, description: `Optional, CSS class for an icon to be displayed with the navigation item`}) 
    @MaxLength(200)
    IconCSSClass?: string;
        
    @Field({nullable: true, description: `Description of the navigation item, shown to the user on hover or in larger displays`}) 
    Description?: string;
        
    @Field({nullable: true, description: `Administrator comments, not shown to the end user in MJ Explorer app`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class CreateExplorerNavigationItemInput {
    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Explorer Navigation Items
//****************************************************************************
@InputType()
export class UpdateExplorerNavigationItemInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Route?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInHomeScreen?: boolean;

    @Field(() => Boolean, { nullable: true })
    ShowInNavigationDrawer?: boolean;

    @Field({ nullable: true })
    IconCSSClass?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Explorer Navigation Items
//****************************************************************************
@ObjectType()
export class RunExplorerNavigationItemViewResult {
    @Field(() => [ExplorerNavigationItem_])
    Results: ExplorerNavigationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ExplorerNavigationItem_)
export class ExplorerNavigationItemResolver extends ResolverBase {
    @Query(() => RunExplorerNavigationItemViewResult)
    async RunExplorerNavigationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunExplorerNavigationItemViewResult)
    async RunExplorerNavigationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunExplorerNavigationItemViewResult)
    async RunExplorerNavigationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Explorer Navigation Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ExplorerNavigationItem_, { nullable: true })
    async ExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ExplorerNavigationItem_ | null> {
        this.CheckUserReadPermissions('Explorer Navigation Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwExplorerNavigationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Explorer Navigation Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Explorer Navigation Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ExplorerNavigationItem_)
    async CreateExplorerNavigationItem(
        @Arg('input', () => CreateExplorerNavigationItemInput) input: CreateExplorerNavigationItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Explorer Navigation Items', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ExplorerNavigationItem_)
    async UpdateExplorerNavigationItem(
        @Arg('input', () => UpdateExplorerNavigationItemInput) input: UpdateExplorerNavigationItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Explorer Navigation Items', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ExplorerNavigationItem_)
    async DeleteExplorerNavigationItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Explorer Navigation Items', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Code Categories
//****************************************************************************
@ObjectType()
export class GeneratedCodeCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Parent category ID, allowing for hierarchical categorization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [GeneratedCodeCategory_])
    GeneratedCodeCategories_ParentIDArray: GeneratedCodeCategory_[]; // Link to GeneratedCodeCategories
    
    @Field(() => [GeneratedCode_])
    GeneratedCodes_CategoryIDArray: GeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class CreateGeneratedCodeCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Generated Code Categories
//****************************************************************************
@InputType()
export class UpdateGeneratedCodeCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Code Categories
//****************************************************************************
@ObjectType()
export class RunGeneratedCodeCategoryViewResult {
    @Field(() => [GeneratedCodeCategory_])
    Results: GeneratedCodeCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(GeneratedCodeCategory_)
export class GeneratedCodeCategoryResolver extends ResolverBase {
    @Query(() => RunGeneratedCodeCategoryViewResult)
    async RunGeneratedCodeCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeCategoryViewResult)
    async RunGeneratedCodeCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeCategoryViewResult)
    async RunGeneratedCodeCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Code Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => GeneratedCodeCategory_, { nullable: true })
    async GeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<GeneratedCodeCategory_ | null> {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Generated Code Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [GeneratedCodeCategory_])
    async GeneratedCodeCategories_ParentIDArray(@Root() generatedcodecategory_: GeneratedCodeCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Code Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodeCategories] WHERE [ParentID]='${generatedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Generated Code Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Code Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [GeneratedCode_])
    async GeneratedCodes_CategoryIDArray(@Root() generatedcodecategory_: GeneratedCodeCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [CategoryID]='${generatedcodecategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => GeneratedCodeCategory_)
    async CreateGeneratedCodeCategory(
        @Arg('input', () => CreateGeneratedCodeCategoryInput) input: CreateGeneratedCodeCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Generated Code Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => GeneratedCodeCategory_)
    async UpdateGeneratedCodeCategory(
        @Arg('input', () => UpdateGeneratedCodeCategoryInput) input: UpdateGeneratedCodeCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Generated Code Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => GeneratedCodeCategory_)
    async DeleteGeneratedCodeCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Code Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Models
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and AI models.` })
export class AIAgentModel_ {
    @Field({description: `The unique identifier for each AI agent-model mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `The unique identifier of the associated AI model.`}) 
    @MaxLength(16)
    ModelID?: string;
        
    @Field(() => Boolean, {nullable: true}) 
    Active?: boolean;
        
    @Field(() => Int, {nullable: true, description: `The priority level of the AI model for the agent, where higher values indicate higher priority.`}) 
    Priority?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Model?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class CreateAIAgentModelInput {
    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    Active: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority: number | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Models
//****************************************************************************
@InputType()
export class UpdateAIAgentModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean | null;

    @Field(() => Int, { nullable: true })
    Priority?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Models
//****************************************************************************
@ObjectType()
export class RunAIAgentModelViewResult {
    @Field(() => [AIAgentModel_])
    Results: AIAgentModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentModel_)
export class AIAgentModelResolver extends ResolverBase {
    @Query(() => RunAIAgentModelViewResult)
    async RunAIAgentModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentModelViewResult)
    async RunAIAgentModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentModelViewResult)
    async RunAIAgentModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Models';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgentModel_, { nullable: true })
    async AIAgentModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentModel_ | null> {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agent Models', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AIAgentModel_)
    async CreateAIAgentModel(
        @Arg('input', () => CreateAIAgentModelInput) input: CreateAIAgentModelInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agent Models', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentModel_)
    async UpdateAIAgentModel(
        @Arg('input', () => UpdateAIAgentModelInput) input: UpdateAIAgentModelInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agent Models', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentModel_)
    async DeleteAIAgentModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Models', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Note Types
//****************************************************************************
@ObjectType()
export class AIAgentNoteType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIAgentNote_])
    AIAgentNotes_AgentNoteTypeIDArray: AIAgentNote_[]; // Link to AIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class CreateAIAgentNoteTypeInput {
    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Note Types
//****************************************************************************
@InputType()
export class UpdateAIAgentNoteTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Note Types
//****************************************************************************
@ObjectType()
export class RunAIAgentNoteTypeViewResult {
    @Field(() => [AIAgentNoteType_])
    Results: AIAgentNoteType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentNoteType_)
export class AIAgentNoteTypeResolver extends ResolverBase {
    @Query(() => RunAIAgentNoteTypeViewResult)
    async RunAIAgentNoteTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteTypeViewResult)
    async RunAIAgentNoteTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteTypeViewResult)
    async RunAIAgentNoteTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Note Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgentNoteType_, { nullable: true })
    async AIAgentNoteType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentNoteType_ | null> {
        this.CheckUserReadPermissions('AI Agent Note Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNoteTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Note Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agent Note Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [AIAgentNote_])
    async AIAgentNotes_AgentNoteTypeIDArray(@Root() aiagentnotetype_: AIAgentNoteType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentNoteTypeID]='${aiagentnotetype_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIAgentNoteType_)
    async CreateAIAgentNoteType(
        @Arg('input', () => CreateAIAgentNoteTypeInput) input: CreateAIAgentNoteTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agent Note Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentNoteType_)
    async UpdateAIAgentNoteType(
        @Arg('input', () => UpdateAIAgentNoteTypeInput) input: UpdateAIAgentNoteTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agent Note Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentNoteType_)
    async DeleteAIAgentNoteType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Note Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agents
//****************************************************************************
@ObjectType({ description: `Table to store information about AI agents.` })
export class AIAgent_ {
    @Field({description: `The unique identifier for each AI agent. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `The name of the AI agent.`}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true, description: `A detailed description of the AI agent.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LogoURL?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIAgentRequest_])
    AIAgentRequests_AgentIDArray: AIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [AIAgentLearningCycle_])
    AIAgentLearningCycles_AgentIDArray: AIAgentLearningCycle_[]; // Link to AIAgentLearningCycles
    
    @Field(() => [AIAgentModel_])
    AIAgentModels_AgentIDArray: AIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [AIAgentAction_])
    AIAgentActions_AgentIDArray: AIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [AIAgentNote_])
    AIAgentNotes_AgentIDArray: AIAgentNote_[]; // Link to AIAgentNotes
    
}

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class CreateAIAgentInput {
    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agents
//****************************************************************************
@InputType()
export class UpdateAIAgentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agents
//****************************************************************************
@ObjectType()
export class RunAIAgentViewResult {
    @Field(() => [AIAgent_])
    Results: AIAgent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgent_)
export class AIAgentResolver extends ResolverBase {
    @Query(() => RunAIAgentViewResult)
    async RunAIAgentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentViewResult)
    async RunAIAgentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentViewResult)
    async RunAIAgentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agents';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgent_, { nullable: true })
    async AIAgent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgent_ | null> {
        this.CheckUserReadPermissions('AI Agents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agents', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [AIAgentRequest_])
    async AIAgentRequests_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentLearningCycle_])
    async AIAgentLearningCycles_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Learning Cycles', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentModel_])
    async AIAgentModels_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Models', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentAction_])
    async AIAgentActions_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentNote_])
    async AIAgentNotes_AgentIDArray(@Root() aiagent_: AIAgent_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [AgentID]='${aiagent_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIAgent_)
    async CreateAIAgent(
        @Arg('input', () => CreateAIAgentInput) input: CreateAIAgentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agents', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgent_)
    async UpdateAIAgent(
        @Arg('input', () => UpdateAIAgentInput) input: UpdateAIAgentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agents', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgent_)
    async DeleteAIAgent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agents', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Notes
//****************************************************************************
@ObjectType()
export class AIAgentNote_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AgentNoteTypeID?: string;
        
    @Field({nullable: true}) 
    Note?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Indicates the type of note, either User-specific or Global.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Foreign key referencing the ID column in the User table, indicating the user associated with the note. Used when Type=User`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AgentNoteType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class CreateAIAgentNoteInput {
    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID: string | null;

    @Field({ nullable: true })
    Note: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Notes
//****************************************************************************
@InputType()
export class UpdateAIAgentNoteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    AgentNoteTypeID?: string | null;

    @Field({ nullable: true })
    Note?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Notes
//****************************************************************************
@ObjectType()
export class RunAIAgentNoteViewResult {
    @Field(() => [AIAgentNote_])
    Results: AIAgentNote_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentNote_)
export class AIAgentNoteResolver extends ResolverBase {
    @Query(() => RunAIAgentNoteViewResult)
    async RunAIAgentNoteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteViewResult)
    async RunAIAgentNoteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentNoteViewResult)
    async RunAIAgentNoteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Notes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgentNote_, { nullable: true })
    async AIAgentNote(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentNote_ | null> {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agent Notes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AIAgentNote_)
    async CreateAIAgentNote(
        @Arg('input', () => CreateAIAgentNoteInput) input: CreateAIAgentNoteInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agent Notes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentNote_)
    async UpdateAIAgentNote(
        @Arg('input', () => UpdateAIAgentNoteInput) input: UpdateAIAgentNoteInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agent Notes', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentNote_)
    async DeleteAIAgentNote(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Notes', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Actions
//****************************************************************************
@ObjectType({ description: `Table to store the relationship between AI agents and actions.` })
export class AIAgentAction_ {
    @Field({description: `The unique identifier for each AI agent-action mapping. Serves as the primary key.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated AI agent from the AIAgent table.`}) 
    @MaxLength(16)
    AgentID?: string;
        
    @Field({nullable: true, description: `References the unique identifier of the associated action from the Action table.`}) 
    @MaxLength(16)
    ActionID?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(850)
    Action?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class CreateAIAgentActionInput {
    @Field({ nullable: true })
    AgentID: string | null;

    @Field({ nullable: true })
    ActionID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Actions
//****************************************************************************
@InputType()
export class UpdateAIAgentActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string | null;

    @Field({ nullable: true })
    ActionID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Actions
//****************************************************************************
@ObjectType()
export class RunAIAgentActionViewResult {
    @Field(() => [AIAgentAction_])
    Results: AIAgentAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentAction_)
export class AIAgentActionResolver extends ResolverBase {
    @Query(() => RunAIAgentActionViewResult)
    async RunAIAgentActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentActionViewResult)
    async RunAIAgentActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentActionViewResult)
    async RunAIAgentActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgentAction_, { nullable: true })
    async AIAgentAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentAction_ | null> {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agent Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AIAgentAction_)
    async CreateAIAgentAction(
        @Arg('input', () => CreateAIAgentActionInput) input: CreateAIAgentActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agent Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentAction_)
    async UpdateAIAgentAction(
        @Arg('input', () => UpdateAIAgentActionInput) input: UpdateAIAgentActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agent Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentAction_)
    async DeleteAIAgentAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompts
//****************************************************************************
@ObjectType({ description: `Stores AI prompts, including references to categories, types, and templates.` })
export class AIPrompt_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Reference to the template used for the prompt.`}) 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({nullable: true, description: `Reference to the category the prompt belongs to.`}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({description: `Reference to the type of the prompt.`}) 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates whether the results of the prompt should be cached.`}) 
    CacheResults: boolean;
        
    @Field(() => Float, {description: `Number of hours the cache is valid for; can be fractional or 0 if the cache never expires.`}) 
    CacheExpiration: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Specifies the expected response format for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(40)
    ResponseFormat: string;
        
    @Field({nullable: true, description: `A JSON-formatted string containing model-specific response format instructions. This will be parsed and provided as a JSON object to the model.`}) 
    ModelSpecificResponseFormat?: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
    @Field(() => [AIResultCache_])
    AIResultCache_AIPromptIDArray: AIResultCache_[]; // Link to AIResultCache
    
}

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class CreateAIPromptInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    CacheResults?: boolean;

    @Field(() => Float, { nullable: true })
    CacheExpiration?: number;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompts
//****************************************************************************
@InputType()
export class UpdateAIPromptInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    CacheResults?: boolean;

    @Field(() => Float, { nullable: true })
    CacheExpiration?: number;

    @Field({ nullable: true })
    ResponseFormat?: string;

    @Field({ nullable: true })
    ModelSpecificResponseFormat?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompts
//****************************************************************************
@ObjectType()
export class RunAIPromptViewResult {
    @Field(() => [AIPrompt_])
    Results: AIPrompt_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPrompt_)
export class AIPromptResolver extends ResolverBase {
    @Query(() => RunAIPromptViewResult)
    async RunAIPromptViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIPromptViewResult)
    async RunAIPromptViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIPromptViewResult)
    async RunAIPromptDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompts';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIPrompt_, { nullable: true })
    async AIPrompt(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPrompt_ | null> {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Prompts', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_AIPromptIDArray(@Root() aiprompt_: AIPrompt_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIPromptID]='${aiprompt_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIPrompt_)
    async CreateAIPrompt(
        @Arg('input', () => CreateAIPromptInput) input: CreateAIPromptInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Prompts', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIPrompt_)
    async UpdateAIPrompt(
        @Arg('input', () => UpdateAIPromptInput) input: UpdateAIPromptInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Prompts', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIPrompt_)
    async DeleteAIPrompt(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompts', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Result Cache
//****************************************************************************
@ObjectType({ description: `Stores cached results of AI prompts, including multiple runs for history and tracking purposes.` })
export class AIResultCache_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the AI prompt this result corresponds to.`}) 
    @MaxLength(16)
    AIPromptID: string;
        
    @Field({description: `Reference to the AI model that generated this result.`}) 
    @MaxLength(16)
    AIModelID: string;
        
    @Field({description: `Timestamp of when this result was generated.`}) 
    @MaxLength(10)
    RunAt: Date;
        
    @Field({description: `The prompt text used to generate this result.`}) 
    PromptText: string;
        
    @Field({nullable: true, description: `The text of the result generated by the AI model.`}) 
    ResultText?: string;
        
    @Field({description: `The status of this result, indicating whether it is currently active or expired.`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true, description: `Timestamp of when this result was marked as expired.`}) 
    @MaxLength(10)
    ExpiredOn?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    AIPrompt: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class CreateAIResultCacheInput {
    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Result Cache
//****************************************************************************
@InputType()
export class UpdateAIResultCacheInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIPromptID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    PromptText?: string;

    @Field({ nullable: true })
    ResultText?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ExpiredOn?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Result Cache
//****************************************************************************
@ObjectType()
export class RunAIResultCacheViewResult {
    @Field(() => [AIResultCache_])
    Results: AIResultCache_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIResultCache_)
export class AIResultCacheResolver extends ResolverBase {
    @Query(() => RunAIResultCacheViewResult)
    async RunAIResultCacheViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIResultCacheViewResult)
    async RunAIResultCacheViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIResultCacheViewResult)
    async RunAIResultCacheDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Result Cache';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIResultCache_, { nullable: true })
    async AIResultCache(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIResultCache_ | null> {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Result Cache', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AIResultCache_)
    async CreateAIResultCache(
        @Arg('input', () => CreateAIResultCacheInput) input: CreateAIResultCacheInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Result Cache', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIResultCache_)
    async UpdateAIResultCache(
        @Arg('input', () => UpdateAIResultCacheInput) input: UpdateAIResultCacheInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Result Cache', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIResultCache_)
    async DeleteAIResultCache(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Result Cache', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Categories
//****************************************************************************
@ObjectType({ description: `Categories for organizing AI prompts in a hierarchical structure.` })
export class AIPromptCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Parent category ID for hierarchical organization.`}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [AIPrompt_])
    AIPrompts_CategoryIDArray: AIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [AIPromptCategory_])
    AIPromptCategories_ParentIDArray: AIPromptCategory_[]; // Link to AIPromptCategories
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class CreateAIPromptCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Categories
//****************************************************************************
@InputType()
export class UpdateAIPromptCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Categories
//****************************************************************************
@ObjectType()
export class RunAIPromptCategoryViewResult {
    @Field(() => [AIPromptCategory_])
    Results: AIPromptCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPromptCategory_)
export class AIPromptCategoryResolver extends ResolverBase {
    @Query(() => RunAIPromptCategoryViewResult)
    async RunAIPromptCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIPromptCategoryViewResult)
    async RunAIPromptCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIPromptCategoryViewResult)
    async RunAIPromptCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIPromptCategory_, { nullable: true })
    async AIPromptCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPromptCategory_ | null> {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Prompt Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_CategoryIDArray(@Root() aipromptcategory_: AIPromptCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [CategoryID]='${aipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIPromptCategory_])
    async AIPromptCategories_ParentIDArray(@Root() aipromptcategory_: AIPromptCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompt Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptCategories] WHERE [ParentID]='${aipromptcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompt Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompt Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIPromptCategory_)
    async CreateAIPromptCategory(
        @Arg('input', () => CreateAIPromptCategoryInput) input: CreateAIPromptCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Prompt Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIPromptCategory_)
    async UpdateAIPromptCategory(
        @Arg('input', () => UpdateAIPromptCategoryInput) input: UpdateAIPromptCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Prompt Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIPromptCategory_)
    async DeleteAIPromptCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Prompt Types
//****************************************************************************
@ObjectType({ description: `Types of AI prompts such as Chat, Text-to-Image, Text-to-Video, etc.` })
export class AIPromptType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIPrompt_])
    AIPrompts_TypeIDArray: AIPrompt_[]; // Link to AIPrompts
    
}

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class CreateAIPromptTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Prompt Types
//****************************************************************************
@InputType()
export class UpdateAIPromptTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Prompt Types
//****************************************************************************
@ObjectType()
export class RunAIPromptTypeViewResult {
    @Field(() => [AIPromptType_])
    Results: AIPromptType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIPromptType_)
export class AIPromptTypeResolver extends ResolverBase {
    @Query(() => RunAIPromptTypeViewResult)
    async RunAIPromptTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIPromptTypeViewResult)
    async RunAIPromptTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIPromptTypeViewResult)
    async RunAIPromptTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Prompt Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIPromptType_, { nullable: true })
    async AIPromptType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIPromptType_ | null> {
        this.CheckUserReadPermissions('AI Prompt Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPromptTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompt Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Prompt Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_TypeIDArray(@Root() aiprompttype_: AIPromptType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TypeID]='${aiprompttype_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIPromptType_)
    async CreateAIPromptType(
        @Arg('input', () => CreateAIPromptTypeInput) input: CreateAIPromptTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Prompt Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIPromptType_)
    async UpdateAIPromptType(
        @Arg('input', () => UpdateAIPromptTypeInput) input: UpdateAIPromptTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Prompt Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIPromptType_)
    async DeleteAIPromptType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Prompt Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Companies
//****************************************************************************
@ObjectType({ description: `A list of organizational units within your business. These can be subsidiaries or divisions or other units. Companies are used to organizae employee records and also for separating integrations if you have multiple integrations of the same type of system.` })
export class Company_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field() 
    @MaxLength(400)
    Description: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Website?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    LogoURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Domain?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Workflow_])
    Workflows_CompanyNameArray: Workflow_[]; // Link to Workflows
    
    @Field(() => [CompanyIntegration_])
    CompanyIntegrations_CompanyNameArray: CompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [Employee_])
    Employees_CompanyIDArray: Employee_[]; // Link to Employees
    
}

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class CreateCompanyInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website: string | null;

    @Field({ nullable: true })
    LogoURL: string | null;

    @Field({ nullable: true })
    Domain: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Companies
//****************************************************************************
@InputType()
export class UpdateCompanyInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string;

    @Field({ nullable: true })
    Website?: string | null;

    @Field({ nullable: true })
    LogoURL?: string | null;

    @Field({ nullable: true })
    Domain?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Companies
//****************************************************************************
@ObjectType()
export class RunCompanyViewResult {
    @Field(() => [Company_])
    Results: Company_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Company_)
export class CompanyResolver extends ResolverBase {
    @Query(() => RunCompanyViewResult)
    async RunCompanyViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyViewResult)
    async RunCompanyViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyViewResult)
    async RunCompanyDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Companies';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Company_, { nullable: true })
    async Company(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Company_ | null> {
        this.CheckUserReadPermissions('Companies', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Companies', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Companies', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Company_])
    async AllCompanies(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Companies', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanies]` + this.getRowLevelSecurityWhereClause('Companies', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Companies', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [Workflow_])
    async Workflows_CompanyNameArray(@Root() company_: Company_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [CompanyName]='${company_.ID}' ` + this.getRowLevelSecurityWhereClause('Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Workflows', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegration_])
    async CompanyIntegrations_CompanyNameArray(@Root() company_: Company_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [CompanyName]='${company_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integrations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Employee_])
    async Employees_CompanyIDArray(@Root() company_: Company_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [CompanyID]='${company_.ID}' ` + this.getRowLevelSecurityWhereClause('Employees', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Company_)
    async CreateCompany(
        @Arg('input', () => CreateCompanyInput) input: CreateCompanyInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Companies', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Company_)
    async UpdateCompany(
        @Arg('input', () => UpdateCompanyInput) input: UpdateCompanyInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Companies', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Company_)
    async DeleteCompany(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Companies', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employees
//****************************************************************************
@ObjectType({ description: `A list of employees across all units of your organization` })
export class Employee_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    BCMID: string;
        
    @Field() 
    @MaxLength(60)
    FirstName: string;
        
    @Field() 
    @MaxLength(100)
    LastName: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SupervisorID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Title?: string;
        
    @Field() 
    @MaxLength(200)
    Email: string;
        
    @Field({nullable: true}) 
    @MaxLength(40)
    Phone?: string;
        
    @Field(() => Boolean) 
    Active: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    Supervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(60)
    SupervisorFirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    SupervisorLastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    SupervisorEmail?: string;
        
    @Field(() => [User_])
    Users_EmployeeIDArray: User_[]; // Link to Users
    
    @Field(() => [EmployeeSkill_])
    EmployeeSkills_EmployeeIDArray: EmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [EmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_EmployeeIDArray: EmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
    @Field(() => [Employee_])
    Employees_SupervisorIDArray: Employee_[]; // Link to Employees
    
    @Field(() => [EmployeeRole_])
    EmployeeRoles_EmployeeIDArray: EmployeeRole_[]; // Link to EmployeeRoles
    
}

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class CreateEmployeeInput {
    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Employees
//****************************************************************************
@InputType()
export class UpdateEmployeeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FirstName?: string;

    @Field({ nullable: true })
    LastName?: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    SupervisorID?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Phone?: string | null;

    @Field(() => Boolean, { nullable: true })
    Active?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employees
//****************************************************************************
@ObjectType()
export class RunEmployeeViewResult {
    @Field(() => [Employee_])
    Results: Employee_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Employee_)
export class EmployeeResolver extends ResolverBase {
    @Query(() => RunEmployeeViewResult)
    async RunEmployeeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeViewResult)
    async RunEmployeeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeViewResult)
    async RunEmployeeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employees';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Employee_, { nullable: true })
    async Employee(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Employee_ | null> {
        this.CheckUserReadPermissions('Employees', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Employees', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Employees', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Employee_])
    async AllEmployees(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees]` + this.getRowLevelSecurityWhereClause('Employees', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [User_])
    async Users_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause('Users', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Users', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EmployeeSkill_])
    async EmployeeSkills_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause('Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Skills', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause('Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Employee_])
    async Employees_SupervisorIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employees', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployees] WHERE [SupervisorID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause('Employees', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employees', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EmployeeRole_])
    async EmployeeRoles_EmployeeIDArray(@Root() employee_: Employee_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [EmployeeID]='${employee_.ID}' ` + this.getRowLevelSecurityWhereClause('Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Roles', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Employee_)
    async CreateEmployee(
        @Arg('input', () => CreateEmployeeInput) input: CreateEmployeeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Employees', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Employee_)
    async UpdateEmployee(
        @Arg('input', () => UpdateEmployeeInput) input: UpdateEmployeeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Employees', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Employee_)
    async DeleteEmployee(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employees', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Favorites
//****************************************************************************
@ObjectType({ description: `Records that each user can mark as a favorite for easy access` })
export class UserFavorite_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
}

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class CreateUserFavoriteInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User Favorites
//****************************************************************************
@InputType()
export class UpdateUserFavoriteInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Favorites
//****************************************************************************
@ObjectType()
export class RunUserFavoriteViewResult {
    @Field(() => [UserFavorite_])
    Results: UserFavorite_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserFavorite_)
export class UserFavoriteResolverBase extends ResolverBase {
    @Query(() => RunUserFavoriteViewResult)
    async RunUserFavoriteViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserFavoriteViewResult)
    async RunUserFavoriteViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserFavoriteViewResult)
    async RunUserFavoriteDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Favorites';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserFavorite_, { nullable: true })
    async UserFavorite(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserFavorite_ | null> {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Favorites', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => UserFavorite_)
    async CreateUserFavorite(
        @Arg('input', () => CreateUserFavoriteInput) input: CreateUserFavoriteInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User Favorites', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserFavorite_)
    async UpdateUserFavorite(
        @Arg('input', () => UpdateUserFavoriteInput) input: UpdateUserFavoriteInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User Favorites', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => UserFavorite_)
    async DeleteUserFavorite(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Favorites', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Company Integrations
//****************************************************************************
@ObjectType()
export class EmployeeCompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Employee Company Integrations
//****************************************************************************
@InputType()
export class UpdateEmployeeCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Company Integrations
//****************************************************************************
@ObjectType()
export class RunEmployeeCompanyIntegrationViewResult {
    @Field(() => [EmployeeCompanyIntegration_])
    Results: EmployeeCompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EmployeeCompanyIntegration_)
export class EmployeeCompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunEmployeeCompanyIntegrationViewResult)
    async RunEmployeeCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeCompanyIntegrationViewResult)
    async RunEmployeeCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeCompanyIntegrationViewResult)
    async RunEmployeeCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Company Integrations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EmployeeCompanyIntegration_, { nullable: true })
    async EmployeeCompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EmployeeCompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Employee Company Integrations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EmployeeCompanyIntegration_)
    async UpdateEmployeeCompanyIntegration(
        @Arg('input', () => UpdateEmployeeCompanyIntegrationInput) input: UpdateEmployeeCompanyIntegrationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Employee Company Integrations', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Roles
//****************************************************************************
@ObjectType()
export class EmployeeRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Roles
//****************************************************************************
@InputType()
export class UpdateEmployeeRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Roles
//****************************************************************************
@ObjectType()
export class RunEmployeeRoleViewResult {
    @Field(() => [EmployeeRole_])
    Results: EmployeeRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EmployeeRole_)
export class EmployeeRoleResolver extends ResolverBase {
    @Query(() => RunEmployeeRoleViewResult)
    async RunEmployeeRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeRoleViewResult)
    async RunEmployeeRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeRoleViewResult)
    async RunEmployeeRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Roles';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EmployeeRole_, { nullable: true })
    async EmployeeRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EmployeeRole_ | null> {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Employee Roles', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EmployeeRole_)
    async UpdateEmployeeRole(
        @Arg('input', () => UpdateEmployeeRoleInput) input: UpdateEmployeeRoleInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Employee Roles', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EmployeeRole_)
    async DeleteEmployeeRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Roles', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Employee Skills
//****************************************************************************
@ObjectType()
export class EmployeeSkill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EmployeeID: string;
        
    @Field() 
    @MaxLength(16)
    SkillID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Skill: string;
        
}

//****************************************************************************
// INPUT TYPE for Employee Skills
//****************************************************************************
@InputType()
export class UpdateEmployeeSkillInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EmployeeID?: string;

    @Field({ nullable: true })
    SkillID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Employee Skills
//****************************************************************************
@ObjectType()
export class RunEmployeeSkillViewResult {
    @Field(() => [EmployeeSkill_])
    Results: EmployeeSkill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EmployeeSkill_)
export class EmployeeSkillResolver extends ResolverBase {
    @Query(() => RunEmployeeSkillViewResult)
    async RunEmployeeSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeSkillViewResult)
    async RunEmployeeSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEmployeeSkillViewResult)
    async RunEmployeeSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Employee Skills';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EmployeeSkill_, { nullable: true })
    async EmployeeSkill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EmployeeSkill_ | null> {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Employee Skills', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EmployeeSkill_)
    async UpdateEmployeeSkill(
        @Arg('input', () => UpdateEmployeeSkillInput) input: UpdateEmployeeSkillInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Employee Skills', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EmployeeSkill_)
    async DeleteEmployeeSkill(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Employee Skills', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Roles
//****************************************************************************
@ObjectType({ description: `Roles are used for security administration and can have zero to many Users as members` })
export class Role_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true, description: `Description of the role`}) 
    Description?: string;
        
    @Field({nullable: true, description: `The unique ID of the role in the directory being used for authentication, for example an ID in Azure.`}) 
    @MaxLength(500)
    DirectoryID?: string;
        
    @Field({nullable: true, description: `The name of the role in the database, this is used for auto-generating permission statements by CodeGen`}) 
    @MaxLength(500)
    SQLName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [UserRole_])
    UserRoles_RoleNameArray: UserRole_[]; // Link to UserRoles
    
    @Field(() => [AuthorizationRole_])
    AuthorizationRoles_RoleNameArray: AuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [EntityPermission_])
    EntityPermissions_RoleNameArray: EntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [QueryPermission_])
    QueryPermissions_RoleNameArray: QueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [EmployeeRole_])
    EmployeeRoles_RoleIDArray: EmployeeRole_[]; // Link to EmployeeRoles
    
    @Field(() => [ResourcePermission_])
    ResourcePermissions_RoleIDArray: ResourcePermission_[]; // Link to ResourcePermissions
    
}

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class CreateRoleInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DirectoryID: string | null;

    @Field({ nullable: true })
    SQLName: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Roles
//****************************************************************************
@InputType()
export class UpdateRoleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DirectoryID?: string | null;

    @Field({ nullable: true })
    SQLName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Roles
//****************************************************************************
@ObjectType()
export class RunRoleViewResult {
    @Field(() => [Role_])
    Results: Role_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Role_)
export class RoleResolver extends ResolverBase {
    @Query(() => RunRoleViewResult)
    async RunRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRoleViewResult)
    async RunRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRoleViewResult)
    async RunRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Roles';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Role_, { nullable: true })
    async Role(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Role_ | null> {
        this.CheckUserReadPermissions('Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Roles', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Role_])
    async AllRoles(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRoles]` + this.getRowLevelSecurityWhereClause('Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Roles', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [UserRole_])
    async UserRoles_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause('User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AuthorizationRole_])
    async AuthorizationRoles_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause('Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityPermission_])
    async EntityPermissions_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [QueryPermission_])
    async QueryPermissions_RoleNameArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [RoleName]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EmployeeRole_])
    async EmployeeRoles_RoleIDArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeRoles] WHERE [RoleID]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause('Employee Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Roles', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ResourcePermission_])
    async ResourcePermissions_RoleIDArray(@Root() role_: Role_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [RoleID]='${role_.ID}' ` + this.getRowLevelSecurityWhereClause('Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Role_)
    async CreateRole(
        @Arg('input', () => CreateRoleInput) input: CreateRoleInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Roles', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Role_)
    async UpdateRole(
        @Arg('input', () => UpdateRoleInput) input: UpdateRoleInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Roles', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Role_)
    async DeleteRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Roles', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Skills
//****************************************************************************
@ObjectType({ description: `A hierarchical list of possible skills that are linked to Employees and can also be linked to any other entity` })
export class Skill_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field(() => [EmployeeSkill_])
    EmployeeSkills_SkillIDArray: EmployeeSkill_[]; // Link to EmployeeSkills
    
    @Field(() => [Skill_])
    Skills_ParentIDArray: Skill_[]; // Link to Skills
    
}
//****************************************************************************
// RESOLVER for Skills
//****************************************************************************
@ObjectType()
export class RunSkillViewResult {
    @Field(() => [Skill_])
    Results: Skill_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Skill_)
export class SkillResolver extends ResolverBase {
    @Query(() => RunSkillViewResult)
    async RunSkillViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunSkillViewResult)
    async RunSkillViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunSkillViewResult)
    async RunSkillDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Skills';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Skill_, { nullable: true })
    async Skill(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Skill_ | null> {
        this.CheckUserReadPermissions('Skills', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Skills', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Skills', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Skill_])
    async AllSkills(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills]` + this.getRowLevelSecurityWhereClause('Skills', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Skills', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [EmployeeSkill_])
    async EmployeeSkills_SkillIDArray(@Root() skill_: Skill_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Skills', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeSkills] WHERE [SkillID]='${skill_.ID}' ` + this.getRowLevelSecurityWhereClause('Employee Skills', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Skills', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Skill_])
    async Skills_ParentIDArray(@Root() skill_: Skill_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Skills', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSkills] WHERE [ParentID]='${skill_.ID}' ` + this.getRowLevelSecurityWhereClause('Skills', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Skills', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Integration URL Formats
//****************************************************************************
@ObjectType({ description: `Used to generate web links for end users to easily access resources in a source system. URL Formats support templating to inject various field values at run-time to take a user directly to a resource in a source system.` })
export class IntegrationURLFormat_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({description: `The URL Format for the given integration including the ability to include markup with fields from the integration`}) 
    @MaxLength(1000)
    URLFormat: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    FullURLFormat?: string;
        
}

//****************************************************************************
// INPUT TYPE for Integration URL Formats
//****************************************************************************
@InputType()
export class UpdateIntegrationURLFormatInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    URLFormat?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integration URL Formats
//****************************************************************************
@ObjectType()
export class RunIntegrationURLFormatViewResult {
    @Field(() => [IntegrationURLFormat_])
    Results: IntegrationURLFormat_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(IntegrationURLFormat_)
export class IntegrationURLFormatResolver extends ResolverBase {
    @Query(() => RunIntegrationURLFormatViewResult)
    async RunIntegrationURLFormatViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunIntegrationURLFormatViewResult)
    async RunIntegrationURLFormatViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunIntegrationURLFormatViewResult)
    async RunIntegrationURLFormatDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integration URL Formats';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => IntegrationURLFormat_, { nullable: true })
    async IntegrationURLFormat(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<IntegrationURLFormat_ | null> {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Integration URL Formats', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [IntegrationURLFormat_])
    async AllIntegrationURLFormats(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats]` + this.getRowLevelSecurityWhereClause('Integration URL Formats', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => IntegrationURLFormat_)
    async UpdateIntegrationURLFormat(
        @Arg('input', () => UpdateIntegrationURLFormatInput) input: UpdateIntegrationURLFormatInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Integration URL Formats', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => IntegrationURLFormat_)
    async DeleteIntegrationURLFormat(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integration URL Formats', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Integrations
//****************************************************************************
@ObjectType({ description: `Catalog of all integrations that have been configured in the system.` })
export class Integration_ {
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    NavigationBaseURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ImportPath?: string;
        
    @Field(() => Int) 
    BatchMaxRequestCount: number;
        
    @Field(() => Int) 
    BatchRequestWaitTime: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => [IntegrationURLFormat_])
    IntegrationURLFormats_IntegrationIDArray: IntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [CompanyIntegration_])
    CompanyIntegrations_IntegrationNameArray: CompanyIntegration_[]; // Link to CompanyIntegrations
    
    @Field(() => [RecordChange_])
    RecordChanges_IntegrationIDArray: RecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Integrations
//****************************************************************************
@InputType()
export class UpdateIntegrationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    NavigationBaseURL?: string | null;

    @Field({ nullable: true })
    ClassName?: string | null;

    @Field({ nullable: true })
    ImportPath?: string | null;

    @Field(() => Int, { nullable: true })
    BatchMaxRequestCount?: number;

    @Field(() => Int, { nullable: true })
    BatchRequestWaitTime?: number;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Integrations
//****************************************************************************
@ObjectType()
export class RunIntegrationViewResult {
    @Field(() => [Integration_])
    Results: Integration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Integration_)
export class IntegrationResolver extends ResolverBase {
    @Query(() => RunIntegrationViewResult)
    async RunIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunIntegrationViewResult)
    async RunIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunIntegrationViewResult)
    async RunIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Integrations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Integration_, { nullable: true })
    async Integration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Integration_ | null> {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Integrations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Integration_])
    async AllIntegrations(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrations]` + this.getRowLevelSecurityWhereClause('Integrations', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Integrations', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [IntegrationURLFormat_])
    async IntegrationURLFormats_IntegrationIDArray(@Root() integration_: Integration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [IntegrationID]='${integration_.ID}' ` + this.getRowLevelSecurityWhereClause('Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegration_])
    async CompanyIntegrations_IntegrationNameArray(@Root() integration_: Integration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [IntegrationName]='${integration_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integrations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_IntegrationIDArray(@Root() integration_: Integration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [IntegrationID]='${integration_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Integration_)
    async UpdateIntegration(
        @Arg('input', () => UpdateIntegrationInput) input: UpdateIntegrationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Integrations', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Integration_)
    async DeleteIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Integrations', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integrations
//****************************************************************************
@ObjectType({ description: `Links individual company records to specific integrations` })
export class CompanyIntegration_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyID: string;
        
    @Field() 
    @MaxLength(16)
    IntegrationID: string;
        
    @Field(() => Boolean, {nullable: true}) 
    IsActive?: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    AccessToken?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RefreshToken?: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    TokenExpirationDate?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    APIKey?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExternalSystemID?: string;
        
    @Field(() => Boolean) 
    IsExternalSystemReadOnly: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ClientID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ClientSecret?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CustomAttribute1?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverImportPath?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LastRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRunEndedAt?: Date;
        
    @Field(() => [CompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_CompanyIntegrationIDArray: CompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
    @Field(() => [List_])
    Lists_CompanyIntegrationIDArray: List_[]; // Link to Lists
    
    @Field(() => [CompanyIntegrationRun_])
    CompanyIntegrationRuns_CompanyIntegrationIDArray: CompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [EmployeeCompanyIntegration_])
    EmployeeCompanyIntegrations_CompanyIntegrationIDArray: EmployeeCompanyIntegration_[]; // Link to EmployeeCompanyIntegrations
    
}

//****************************************************************************
// INPUT TYPE for Company Integrations
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyID?: string;

    @Field({ nullable: true })
    IntegrationID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean | null;

    @Field({ nullable: true })
    AccessToken?: string | null;

    @Field({ nullable: true })
    RefreshToken?: string | null;

    @Field({ nullable: true })
    TokenExpirationDate?: Date | null;

    @Field({ nullable: true })
    APIKey?: string | null;

    @Field({ nullable: true })
    ExternalSystemID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsExternalSystemReadOnly?: boolean;

    @Field({ nullable: true })
    ClientID?: string | null;

    @Field({ nullable: true })
    ClientSecret?: string | null;

    @Field({ nullable: true })
    CustomAttribute1?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integrations
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationViewResult {
    @Field(() => [CompanyIntegration_])
    Results: CompanyIntegration_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegration_)
export class CompanyIntegrationResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationViewResult)
    async RunCompanyIntegrationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationViewResult)
    async RunCompanyIntegrationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationViewResult)
    async RunCompanyIntegrationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integrations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CompanyIntegration_, { nullable: true })
    async CompanyIntegration(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegration_ | null> {
        this.CheckUserReadPermissions('Company Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Company Integrations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [CompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause('Lists', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRun_])
    async CompanyIntegrationRuns_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EmployeeCompanyIntegration_])
    async EmployeeCompanyIntegrations_CompanyIntegrationIDArray(@Root() companyintegration_: CompanyIntegration_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Employee Company Integrations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEmployeeCompanyIntegrations] WHERE [CompanyIntegrationID]='${companyintegration_.ID}' ` + this.getRowLevelSecurityWhereClause('Employee Company Integrations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Employee Company Integrations', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CompanyIntegration_)
    async UpdateCompanyIntegration(
        @Arg('input', () => UpdateCompanyIntegrationInput) input: UpdateCompanyIntegrationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Company Integrations', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => CompanyIntegration_)
    async DeleteCompanyIntegration(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Company Integrations', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Fields
//****************************************************************************
@ObjectType({ description: `List of all fields within each entity with metadata about each field` })
export class EntityField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Display order of the field within the entity`}) 
    Sequence: number;
        
    @Field({description: `Name of the field within the database table`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `A user friendly alternative to the field name`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({nullable: true, description: `Descriptive text explaining the purpose of the field`}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the column within the underlying view (first choice) or table (second choice), the Description column in the entity field definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity field definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field is part of the primary key for the entity (auto maintained by CodeGen)`}) 
    IsPrimaryKey: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the field must have unique values within the entity.`}) 
    IsUnique: boolean;
        
    @Field({nullable: true, description: `Used for generating custom tabs in the generated forms, only utilized if GeneratedFormSection=Category`}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({description: `SQL Data type (auto maintained by CodeGen)`}) 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Int, {nullable: true, description: `SQL data length (auto maintained by CodeGen)`}) 
    Length?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL precision (auto maintained by CodeGen)`}) 
    Precision?: number;
        
    @Field(() => Int, {nullable: true, description: `SQL scale (auto maintained by CodeGen)`}) 
    Scale?: number;
        
    @Field(() => Boolean, {description: `Does the column allow null or not (auto maintained by CodeGen)`}) 
    AllowsNull: boolean;
        
    @Field({nullable: true, description: `If a default value is defined for the field it is stored here (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    DefaultValue?: string;
        
    @Field(() => Boolean, {description: `If this field automatically increments within the table, this field is set to 1 (auto maintained by CodeGen)`}) 
    AutoIncrement: boolean;
        
    @Field({description: `Possible Values of None, List, ListOrUserEntry - the last option meaning that the list of possible values are options, but a user can enter anything else desired too.`}) 
    @MaxLength(40)
    ValueListType: string;
        
    @Field({nullable: true, description: `Defines extended behaviors for a field such as for Email, Web URLs, Code, etc.`}) 
    @MaxLength(100)
    ExtendedType?: string;
        
    @Field({nullable: true, description: `The type of code associated with this field. Only used when the ExtendedType field is set to "Code"`}) 
    @MaxLength(100)
    CodeType?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included by default in any new view created by a user.`}) 
    DefaultInView: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    ViewCellTemplate?: string;
        
    @Field(() => Int, {nullable: true, description: `Determines the default width for this field when included in a view`}) 
    DefaultColumnWidth?: number;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be considered updateable by the API and object model. For this field to have effect, the column type must be updateable (e.g. not part of the primary key and not auto-increment)`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, and if AllowUpdateAPI=1, the field can be edited within a view when the view is in edit mode.`}) 
    AllowUpdateInView: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be included in user search queries for both traditional and full text search`}) 
    IncludeInUserSearchAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, CodeGen will automatically generate a Full Text Catalog/Index in the database and include this field in the search index.`}) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true, description: `NULL`}) 
    @MaxLength(1000)
    UserSearchParamFormatAPI?: string;
        
    @Field(() => Boolean, {description: `If set to 1, this field will be included in the generated form by CodeGen. If set to 0, this field will be excluded from the generated form. For custom forms, this field has no effect as the layout is controlled independently.`}) 
    IncludeInGeneratedForm: boolean;
        
    @Field({description: `When set to Top, the field will be placed in a "top area" on the top of a generated form and visible regardless of which tab is displayed. When set to "category" Options: Top, Category, Details`}) 
    @MaxLength(20)
    GeneratedFormSection: string;
        
    @Field(() => Boolean, {description: `NULL`}) 
    IsVirtual: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, this column will be used as the "Name" field for the entity and will be used to display the name of the record in various places in the UI.`}) 
    IsNameField: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RelatedEntityID?: string;
        
    @Field({nullable: true, description: `Name of the field in the Related Entity that this field links to (auto maintained by CodeGen)`}) 
    @MaxLength(510)
    RelatedEntityFieldName?: string;
        
    @Field(() => Boolean, {description: `If set to 1, the "Name" field of the Related Entity will be included in this entity as a virtual field`}) 
    IncludeRelatedEntityNameFieldInBaseView: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityNameFieldMap?: string;
        
    @Field({description: `Controls the generated form in the MJ Explorer UI - defaults to a search box, other option is a drop down. Possible values are Search and Dropdown`}) 
    @MaxLength(40)
    RelatedEntityDisplayType: string;
        
    @Field({nullable: true, description: `Optional, used for "Soft Keys" to link records to different entity/record combinations on a per-record basis (for example the FileEntityRecordLink table has an EntityID/RecordID field pair. For that entity, the RecordID specifies "EntityID" for this field. This information allows MJ to detect soft keys/links for dependency detection, merging and for preventing orphaned soft-linked records during delete operations.`}) 
    @MaxLength(200)
    EntityIDFieldName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `A comma-delimited string indicating the default scope for field visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for a simple method of filtering field defaults for visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field(() => Boolean, {description: `Indicates whether the related entity information should be automatically updated from the database schema. When set to 0, relationships not part of the database schema can be manually defined at the application and AI agent level. Defaults to 1.`}) 
    AutoUpdateRelatedEntityInfo: boolean;
        
    @Field({description: `Determines whether values for the field should be included when the schema is packed. Options: Auto (include manually set or auto-derived values), None (exclude all values), All (include all distinct values from the table). Defaults to Auto.`}) 
    @MaxLength(20)
    ValuesToPackWithSchema: string;
        
    @Field({nullable: true}) 
    FieldCodeName?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    SchemaName: string;
        
    @Field() 
    @MaxLength(510)
    BaseTable: string;
        
    @Field() 
    @MaxLength(510)
    BaseView: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntitySchemaName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    RelatedEntityBaseView?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field(() => [EntityFieldValue_])
    EntityFieldValues_EntityFieldIDArray: EntityFieldValue_[]; // Link to EntityFieldValues
    
}

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class CreateEntityFieldInput {
    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType: string | null;

    @Field({ nullable: true })
    CodeType: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Fields
//****************************************************************************
@InputType()
export class UpdateEntityFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsPrimaryKey?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsUnique?: boolean;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    ValueListType?: string;

    @Field({ nullable: true })
    ExtendedType?: string | null;

    @Field({ nullable: true })
    CodeType?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultInView?: boolean;

    @Field({ nullable: true })
    ViewCellTemplate?: string | null;

    @Field(() => Int, { nullable: true })
    DefaultColumnWidth?: number | null;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateInView?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    UserSearchParamFormatAPI?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeInGeneratedForm?: boolean;

    @Field({ nullable: true })
    GeneratedFormSection?: string;

    @Field(() => Boolean, { nullable: true })
    IsNameField?: boolean;

    @Field({ nullable: true })
    RelatedEntityID?: string | null;

    @Field({ nullable: true })
    RelatedEntityFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IncludeRelatedEntityNameFieldInBaseView?: boolean;

    @Field({ nullable: true })
    RelatedEntityNameFieldMap?: string | null;

    @Field({ nullable: true })
    RelatedEntityDisplayType?: string;

    @Field({ nullable: true })
    EntityIDFieldName?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateRelatedEntityInfo?: boolean;

    @Field({ nullable: true })
    ValuesToPackWithSchema?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Fields
//****************************************************************************
@ObjectType()
export class RunEntityFieldViewResult {
    @Field(() => [EntityField_])
    Results: EntityField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityField_)
export class EntityFieldResolver extends ResolverBase {
    @Query(() => RunEntityFieldViewResult)
    async RunEntityFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldViewResult)
    async RunEntityFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldViewResult)
    async RunEntityFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Fields';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityField_, { nullable: true })
    async EntityField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityField_ | null> {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Fields', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [EntityField_])
    async AllEntityFields(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields]` + this.getRowLevelSecurityWhereClause('Entity Fields', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Fields', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [EntityFieldValue_])
    async EntityFieldValues_EntityFieldIDArray(@Root() entityfield_: EntityField_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [EntityFieldID]='${entityfield_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Field Values', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityField_)
    async CreateEntityField(
        @Arg('input', () => CreateEntityFieldInput) input: CreateEntityFieldInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Fields', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityField_)
    async UpdateEntityField(
        @Arg('input', () => UpdateEntityFieldInput) input: UpdateEntityFieldInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Fields', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityField_)
    async DeleteEntityField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Fields', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entities
//****************************************************************************
@ObjectType({ description: `Catalog of all entities across all schemas` })
export class Entity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    NameSuffix?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean, {description: `When set to 1 (default), whenever a description is modified in the underlying view (first choice) or table (second choice), the Description column in the entity definition will be automatically updated. If you never set metadata in the database directly, you can leave this alone. However, if you have metadata set in the database level for description, and you want to provide a DIFFERENT description in this entity definition, turn this bit off and then set the Description field and future CodeGen runs will NOT override the Description field here.`}) 
    AutoUpdateDescription: boolean;
        
    @Field() 
    @MaxLength(510)
    BaseTable: string;
        
    @Field() 
    @MaxLength(510)
    BaseView: string;
        
    @Field(() => Boolean, {description: `When set to 0, CodeGen no longer generates a base view for the entity.`}) 
    BaseViewGenerated: boolean;
        
    @Field() 
    @MaxLength(510)
    SchemaName: string;
        
    @Field(() => Boolean) 
    VirtualEntity: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, changes made via the MemberJunction architecture will result in tracking records being created in the RecordChange table. In addition, when turned on CodeGen will ensure that your table has two fields: __mj_CreatedAt and __mj_UpdatedAt which are special fields used in conjunction with the RecordChange table to track changes to rows in your entity.`}) 
    TrackRecordChanges: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, accessing a record by an end-user will result in an Audit Log record being created`}) 
    AuditRecordAccess: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, users running a view against this entity will result in an Audit Log record being created.`}) 
    AuditViewRuns: boolean;
        
    @Field(() => Boolean, {description: `If set to 0, the entity will not be available at all in the GraphQL API or the object model.`}) 
    IncludeInAPI: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, a GraphQL query will be enabled that allows access to all rows in the entity.`}) 
    AllowAllRowsAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if updates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowUpdateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if creates are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowCreateAPI: boolean;
        
    @Field(() => Boolean, {description: `Global flag controlling if deletes are allowed for any user, or not. If set to 1, a GraqhQL mutation and stored procedure are created. Permissions are still required to perform the action but if this flag is set to 0, no user will be able to perform the action.`}) 
    AllowDeleteAPI: boolean;
        
    @Field(() => Boolean, {description: `Set to 1 if a custom resolver has been created for the entity.`}) 
    CustomResolverAPI: boolean;
        
    @Field(() => Boolean, {description: `Enabling this bit will result in search being possible at the API and UI layers`}) 
    AllowUserSearchAPI: boolean;
        
    @Field(() => Boolean) 
    FullTextSearchEnabled: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FullTextCatalog?: string;
        
    @Field(() => Boolean) 
    FullTextCatalogGenerated: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FullTextIndex?: string;
        
    @Field(() => Boolean) 
    FullTextIndexGenerated: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FullTextSearchFunction?: string;
        
    @Field(() => Boolean) 
    FullTextSearchFunctionGenerated: boolean;
        
    @Field(() => Int, {nullable: true}) 
    UserViewMaxRows?: number;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    spCreate?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    spUpdate?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    spDelete?: string;
        
    @Field(() => Boolean) 
    spCreateGenerated: boolean;
        
    @Field(() => Boolean) 
    spUpdateGenerated: boolean;
        
    @Field(() => Boolean) 
    spDeleteGenerated: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, the deleted spDelete will pre-process deletion to related entities that have 1:M cardinality with this entity. This does not have effect if spDeleteGenerated = 0`}) 
    CascadeDeletes: boolean;
        
    @Field({description: `Hard deletes physically remove rows from the underlying BaseTable. Soft deletes do not remove rows but instead mark the row as deleted by using the special field __mj_DeletedAt which will automatically be added to the entity's basetable by the CodeGen tool.`}) 
    @MaxLength(20)
    DeleteType: string;
        
    @Field(() => Boolean, {description: `This field must be turned on in order to enable merging of records for the entity. For AllowRecordMerge to be turned on, AllowDeleteAPI must be set to 1, and DeleteType must be set to Soft`}) 
    AllowRecordMerge: boolean;
        
    @Field({nullable: true, description: `When specified, this stored procedure is used to find matching records in this particular entity. The convention is to pass in the primary key(s) columns for the given entity to the procedure and the return will be zero to many rows where there is a column for each primary key field(s) and a ProbabilityScore (numeric(1,12)) column that has a 0 to 1 value of the probability of a match.`}) 
    @MaxLength(510)
    spMatch?: string;
        
    @Field({description: `When another entity links to this entity with a foreign key, this is the default component type that will be used in the UI. CodeGen will populate the RelatedEntityDisplayType column in the Entity Fields entity with whatever is provided here whenever a new foreign key is detected by CodeGen. The selection can be overridden on a per-foreign-key basis in each row of the Entity Fields entity.`}) 
    @MaxLength(40)
    RelationshipDefaultDisplayType: string;
        
    @Field(() => Boolean) 
    UserFormGenerated: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EntityObjectSubclassName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EntityObjectSubclassImport?: string;
        
    @Field({nullable: true, description: `Used to specify a field within the entity that in turn contains the field name that will be used for record-level communication preferences. For example in a hypothetical entity called Contacts, say there is a field called PreferredComm and that field had possible values of Email1, SMS, and Phone, and those value in turn corresponded to field names in the entity. Each record in the Contacts entity could have a specific preference for which field would be used for communication. The MJ Communication Framework will use this information when available, as a priority ahead of the data in the Entity Communication Fields entity which is entity-level and not record-level.`}) 
    @MaxLength(510)
    PreferredCommunicationField?: string;
        
    @Field({nullable: true, description: `Optional, specify an icon (CSS Class) for each entity for display in the UI`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional, comma-delimited string indicating the default scope for entity visibility. Options include Users, Admins, AI, and All. Defaults to All when NULL. This is used for simple defaults for filtering entity visibility, not security enforcement.`}) 
    @MaxLength(200)
    ScopeDefault?: string;
        
    @Field({description: `Determines how entity rows should be packaged for external use. Options include None, Sample, and All. Defaults to None.`}) 
    @MaxLength(40)
    RowsToPackWithSchema: string;
        
    @Field({description: `Defines the sampling method for row packing when RowsToPackWithSchema is set to Sample. Options include random, top n, and bottom n. Defaults to random.`}) 
    @MaxLength(40)
    RowsToPackSampleMethod: string;
        
    @Field(() => Int, {description: `The number of rows to pack when RowsToPackWithSchema is set to Sample, based on the designated sampling method. Defaults to 0.`}) 
    RowsToPackSampleCount: number;
        
    @Field({nullable: true, description: `An optional ORDER BY clause for row packing when RowsToPackWithSchema is set to Sample. Allows custom ordering for selected entity data when using top n and bottom n.`}) 
    RowsToPackSampleOrder?: string;
        
    @Field({nullable: true}) 
    CodeName?: string;
        
    @Field({nullable: true}) 
    ClassName?: string;
        
    @Field({nullable: true}) 
    BaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseTable?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ParentBaseView?: string;
        
    @Field(() => [AuditLog_])
    AuditLogs_EntityIDArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [TemplateParam_])
    TemplateParams_EntityIDArray: TemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [DatasetItem_])
    DatasetItems_EntityIDArray: DatasetItem_[]; // Link to DatasetItems
    
    @Field(() => [User_])
    Users_LinkedEntityIDArray: User_[]; // Link to Users
    
    @Field(() => [CompanyIntegrationRecordMap_])
    CompanyIntegrationRecordMaps_EntityIDArray: CompanyIntegrationRecordMap_[]; // Link to CompanyIntegrationRecordMaps
    
    @Field(() => [Entity_])
    Entities_ParentIDArray: Entity_[]; // Link to Entities
    
    @Field(() => [UserViewCategory_])
    UserViewCategories_EntityIDArray: UserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [EntityAIAction_])
    EntityAIActions_EntityIDArray: EntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [EntityAction_])
    EntityActions_EntityIDArray: EntityAction_[]; // Link to EntityActions
    
    @Field(() => [Conversation_])
    Conversations_LinkedEntityIDArray: Conversation_[]; // Link to Conversations
    
    @Field(() => [DuplicateRun_])
    DuplicateRuns_EntityIDArray: DuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [TaggedItem_])
    TaggedItems_EntityIDArray: TaggedItem_[]; // Link to TaggedItems
    
    @Field(() => [RecordMergeLog_])
    RecordMergeLogs_EntityIDArray: RecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [UserApplicationEntity_])
    UserApplicationEntities_EntityIDArray: UserApplicationEntity_[]; // Link to UserApplicationEntities
    
    @Field(() => [QueryField_])
    QueryFields_SourceEntityIDArray: QueryField_[]; // Link to QueryFields
    
    @Field(() => [UserView_])
    UserViews_EntityIDArray: UserView_[]; // Link to UserViews
    
    @Field(() => [RecommendationItem_])
    RecommendationItems_DestinationEntityIDArray: RecommendationItem_[]; // Link to RecommendationItems
    
    @Field(() => [EntityPermission_])
    EntityPermissions_EntityIDArray: EntityPermission_[]; // Link to EntityPermissions
    
    @Field(() => [List_])
    Lists_EntityIDArray: List_[]; // Link to Lists
    
    @Field(() => [UserRecordLog_])
    UserRecordLogs_EntityIDArray: UserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [EntityDocument_])
    EntityDocuments_EntityIDArray: EntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [Recommendation_])
    Recommendations_SourceEntityIDArray: Recommendation_[]; // Link to Recommendations
    
    @Field(() => [FileEntityRecordLink_])
    FileEntityRecordLinks_EntityIDArray: FileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
    @Field(() => [EntitySetting_])
    EntitySettings_EntityIDArray: EntitySetting_[]; // Link to EntitySettings
    
    @Field(() => [EntityRelationship_])
    EntityRelationships_EntityIDArray: EntityRelationship_[]; // Link to EntityRelationships
    
    @Field(() => [CompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_EntityIDArray: CompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
    @Field(() => [DataContextItem_])
    DataContextItems_EntityIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [IntegrationURLFormat_])
    IntegrationURLFormats_EntityIDArray: IntegrationURLFormat_[]; // Link to IntegrationURLFormats
    
    @Field(() => [EntityField_])
    EntityFields_EntityIDArray: EntityField_[]; // Link to EntityFields
    
    @Field(() => [UserFavorite_])
    UserFavorites_EntityIDArray: UserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [EntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_EntityIDArray: EntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
    @Field(() => [EntityRecordDocument_])
    EntityRecordDocuments_EntityIDArray: EntityRecordDocument_[]; // Link to EntityRecordDocuments
    
    @Field(() => [RecordChange_])
    RecordChanges_EntityIDArray: RecordChange_[]; // Link to RecordChanges
    
    @Field(() => [ApplicationEntity_])
    ApplicationEntities_EntityIDArray: ApplicationEntity_[]; // Link to ApplicationEntities
    
    @Field(() => [ResourceType_])
    ResourceTypes_EntityIDArray: ResourceType_[]; // Link to ResourceTypes
    
    @Field(() => [QueryEntity_])
    QueryEntities_EntityIDArray: QueryEntity_[]; // Link to QueryEntities
    
    @Field(() => [GeneratedCode_])
    GeneratedCodes_LinkedEntityIDArray: GeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class CreateEntityInput {
    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate: string | null;

    @Field({ nullable: true })
    spUpdate: string | null;

    @Field({ nullable: true })
    spDelete: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field({ nullable: true })
    ScopeDefault: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entities
//****************************************************************************
@InputType()
export class UpdateEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    NameSuffix?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateDescription?: boolean;

    @Field({ nullable: true })
    BaseView?: string;

    @Field(() => Boolean, { nullable: true })
    BaseViewGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    VirtualEntity?: boolean;

    @Field(() => Boolean, { nullable: true })
    TrackRecordChanges?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditRecordAccess?: boolean;

    @Field(() => Boolean, { nullable: true })
    AuditViewRuns?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowAllRowsAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUpdateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowCreateAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowDeleteAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    CustomResolverAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    AllowUserSearchAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchEnabled?: boolean;

    @Field({ nullable: true })
    FullTextCatalog?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextCatalogGenerated?: boolean;

    @Field({ nullable: true })
    FullTextIndex?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextIndexGenerated?: boolean;

    @Field({ nullable: true })
    FullTextSearchFunction?: string | null;

    @Field(() => Boolean, { nullable: true })
    FullTextSearchFunctionGenerated?: boolean;

    @Field(() => Int, { nullable: true })
    UserViewMaxRows?: number | null;

    @Field({ nullable: true })
    spCreate?: string | null;

    @Field({ nullable: true })
    spUpdate?: string | null;

    @Field({ nullable: true })
    spDelete?: string | null;

    @Field(() => Boolean, { nullable: true })
    spCreateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spUpdateGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    spDeleteGenerated?: boolean;

    @Field(() => Boolean, { nullable: true })
    CascadeDeletes?: boolean;

    @Field({ nullable: true })
    DeleteType?: string;

    @Field(() => Boolean, { nullable: true })
    AllowRecordMerge?: boolean;

    @Field({ nullable: true })
    spMatch?: string | null;

    @Field({ nullable: true })
    RelationshipDefaultDisplayType?: string;

    @Field(() => Boolean, { nullable: true })
    UserFormGenerated?: boolean;

    @Field({ nullable: true })
    EntityObjectSubclassName?: string | null;

    @Field({ nullable: true })
    EntityObjectSubclassImport?: string | null;

    @Field({ nullable: true })
    PreferredCommunicationField?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field({ nullable: true })
    ScopeDefault?: string | null;

    @Field({ nullable: true })
    RowsToPackWithSchema?: string;

    @Field({ nullable: true })
    RowsToPackSampleMethod?: string;

    @Field(() => Int, { nullable: true })
    RowsToPackSampleCount?: number;

    @Field({ nullable: true })
    RowsToPackSampleOrder?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entities
//****************************************************************************
@ObjectType()
export class RunEntityViewResult {
    @Field(() => [Entity_])
    Results: Entity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Entity_)
export class EntityResolverBase extends ResolverBase {
    @Query(() => RunEntityViewResult)
    async RunEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityViewResult)
    async RunEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityViewResult)
    async RunEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entities';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Entity_, { nullable: true })
    async Entity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Entity_ | null> {
        this.CheckUserReadPermissions('Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entities', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Entity_])
    async AllEntities(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities]` + this.getRowLevelSecurityWhereClause('Entities', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Entities', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [TemplateParam_])
    async TemplateParams_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DatasetItem_])
    async DatasetItems_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Dataset Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [User_])
    async Users_LinkedEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [LinkedEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Users', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Users', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRecordMap_])
    async CompanyIntegrationRecordMaps_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Record Maps', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Entity_])
    async Entities_ParentIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntities] WHERE [ParentID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserViewCategory_])
    async UserViewCategories_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityAIAction_])
    async EntityAIActions_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityAction_])
    async EntityActions_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Conversation_])
    async Conversations_LinkedEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [LinkedEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DuplicateRun_])
    async DuplicateRuns_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [TaggedItem_])
    async TaggedItems_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Tagged Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecordMergeLog_])
    async RecordMergeLogs_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserApplicationEntity_])
    async UserApplicationEntities_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Application Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [QueryField_])
    async QueryFields_SourceEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [SourceEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Fields', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserView_])
    async UserViews_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('User Views', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecommendationItem_])
    async RecommendationItems_DestinationEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [DestinationEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityPermission_])
    async EntityPermissions_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Lists', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserRecordLog_])
    async UserRecordLogs_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Record Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Recommendation_])
    async Recommendations_SourceEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [SourceEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [FileEntityRecordLink_])
    async FileEntityRecordLinks_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntitySetting_])
    async EntitySettings_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Settings', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityRelationship_])
    async EntityRelationships_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [IntegrationURLFormat_])
    async IntegrationURLFormats_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Integration URL Formats', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwIntegrationURLFormats] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Integration URL Formats', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Integration URL Formats', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityField_])
    async EntityFields_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFields] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Fields', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserFavorite_])
    async UserFavorites_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Favorites', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityRecordDocument_])
    async EntityRecordDocuments_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ApplicationEntity_])
    async ApplicationEntities_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Application Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ResourceType_])
    async ResourceTypes_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Types', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [QueryEntity_])
    async QueryEntities_EntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [EntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [GeneratedCode_])
    async GeneratedCodes_LinkedEntityIDArray(@Root() entity_: Entity_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [LinkedEntityID]='${entity_.ID}' ` + this.getRowLevelSecurityWhereClause('Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Entity_)
    async CreateEntity(
        @Arg('input', () => CreateEntityInput) input: CreateEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entities', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Entity_)
    async UpdateEntity(
        @Arg('input', () => UpdateEntityInput) input: UpdateEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entities', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Entity_)
    async DeleteEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entities', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Users
//****************************************************************************
@ObjectType({ description: `A list of all users who have or had access to the system` })
export class User_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    FirstName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    LastName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Title?: string;
        
    @Field() 
    @MaxLength(200)
    Email: string;
        
    @Field() 
    @MaxLength(30)
    Type: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(20)
    LinkedRecordType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(900)
    LinkedEntityRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EmployeeID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    FirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeFirstLast?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    EmployeeTitle?: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    EmployeeSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    EmployeeSupervisorEmail?: string;
        
    @Field(() => [RecommendationRun_])
    RecommendationRuns_RunByUserIDArray: RecommendationRun_[]; // Link to RecommendationRuns
    
    @Field(() => [UserApplication_])
    UserApplications_UserIDArray: UserApplication_[]; // Link to UserApplications
    
    @Field(() => [Dashboard_])
    Dashboards_UserIDArray: Dashboard_[]; // Link to Dashboards
    
    @Field(() => [RecordChange_])
    RecordChanges_UserIDArray: RecordChange_[]; // Link to RecordChanges
    
    @Field(() => [Report_])
    Reports_UserIDArray: Report_[]; // Link to Reports
    
    @Field(() => [DashboardCategory_])
    DashboardCategories_UserIDArray: DashboardCategory_[]; // Link to DashboardCategories
    
    @Field(() => [Action_])
    Actions_CodeApprovedByUserIDArray: Action_[]; // Link to Actions
    
    @Field(() => [QueryCategory_])
    QueryCategories_UserIDArray: QueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [UserViewCategory_])
    UserViewCategories_UserIDArray: UserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [DataContext_])
    DataContexts_UserIDArray: DataContext_[]; // Link to DataContexts
    
    @Field(() => [RecordMergeLog_])
    RecordMergeLogs_InitiatedByUserIDArray: RecordMergeLog_[]; // Link to RecordMergeLogs
    
    @Field(() => [CompanyIntegrationRun_])
    CompanyIntegrationRuns_RunByUserIDArray: CompanyIntegrationRun_[]; // Link to CompanyIntegrationRuns
    
    @Field(() => [ReportCategory_])
    ReportCategories_UserIDArray: ReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [RecordChangeReplayRun_])
    RecordChangeReplayRuns_UserIDArray: RecordChangeReplayRun_[]; // Link to RecordChangeReplayRuns
    
    @Field(() => [UserRole_])
    UserRoles_UserIDArray: UserRole_[]; // Link to UserRoles
    
    @Field(() => [UserViewRun_])
    UserViewRuns_RunByUserIDArray: UserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [Workspace_])
    Workspaces_UserIDArray: Workspace_[]; // Link to Workspaces
    
    @Field(() => [Conversation_])
    Conversations_UserIDArray: Conversation_[]; // Link to Conversations
    
    @Field(() => [List_])
    Lists_UserIDArray: List_[]; // Link to Lists
    
    @Field(() => [CommunicationRun_])
    CommunicationRuns_UserIDArray: CommunicationRun_[]; // Link to CommunicationRuns
    
    @Field(() => [ActionExecutionLog_])
    ActionExecutionLogs_UserIDArray: ActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [AuditLog_])
    AuditLogs_UserIDArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [ReportSnapshot_])
    ReportSnapshots_UserIDArray: ReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [UserView_])
    UserViews_UserIDArray: UserView_[]; // Link to UserViews
    
    @Field(() => [TemplateCategory_])
    TemplateCategories_UserIDArray: TemplateCategory_[]; // Link to TemplateCategories
    
    @Field(() => [DuplicateRun_])
    DuplicateRuns_StartedByUserIDArray: DuplicateRun_[]; // Link to DuplicateRuns
    
    @Field(() => [UserRecordLog_])
    UserRecordLogs_UserIDArray: UserRecordLog_[]; // Link to UserRecordLogs
    
    @Field(() => [UserNotification_])
    UserNotifications_UserIDArray: UserNotification_[]; // Link to UserNotifications
    
    @Field(() => [Template_])
    Templates_UserIDArray: Template_[]; // Link to Templates
    
    @Field(() => [UserFavorite_])
    UserFavorites_UserIDArray: UserFavorite_[]; // Link to UserFavorites
    
    @Field(() => [ResourceLink_])
    ResourceLinks_UserIDArray: ResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [ListCategory_])
    ListCategories_UserIDArray: ListCategory_[]; // Link to ListCategories
    
    @Field(() => [ScheduledAction_])
    ScheduledActions_CreatedByUserIDArray: ScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [AIAgentRequest_])
    AIAgentRequests_ResponseByUserIDArray: AIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [ReportUserState_])
    MJ_ReportUserStates_UserIDArray: ReportUserState_[]; // Link to MJ_ReportUserStates
    
    @Field(() => [AIAgentNote_])
    AIAgentNotes_UserIDArray: AIAgentNote_[]; // Link to AIAgentNotes
    
    @Field(() => [ResourcePermission_])
    ResourcePermissions_UserIDArray: ResourcePermission_[]; // Link to ResourcePermissions
    
    @Field(() => [AIAgentRequest_])
    AIAgentRequests_RequestForUserIDArray: AIAgentRequest_[]; // Link to AIAgentRequests
    
    @Field(() => [ConversationDetail_])
    ConversationDetails_UserIDArray: ConversationDetail_[]; // Link to ConversationDetails
    
}

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class CreateUserInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName: string | null;

    @Field({ nullable: true })
    LastName: string | null;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID: string | null;

    @Field({ nullable: true })
    EmployeeID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Users
//****************************************************************************
@InputType()
export class UpdateUserInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FirstName?: string | null;

    @Field({ nullable: true })
    LastName?: string | null;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Email?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    LinkedRecordType?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedEntityRecordID?: string | null;

    @Field({ nullable: true })
    EmployeeID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Users
//****************************************************************************
@ObjectType()
export class RunUserViewResult {
    @Field(() => [User_])
    Results: User_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(User_)
export class UserResolverBase extends ResolverBase {
    @Query(() => RunUserViewResult)
    async RunUserViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewResult)
    async RunUserViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewResult)
    async RunUserDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Users';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => User_, { nullable: true })
    async User(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<User_ | null> {
        this.CheckUserReadPermissions('Users', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Users', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Users', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [User_])
    async AllUsers(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Users', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUsers]` + this.getRowLevelSecurityWhereClause('Users', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Users', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [RecommendationRun_])
    async RecommendationRuns_RunByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RunByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserApplication_])
    async UserApplications_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Applications', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Dashboard_])
    async Dashboards_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DashboardCategory_])
    async DashboardCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Action_])
    async Actions_CodeApprovedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CodeApprovedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [QueryCategory_])
    async QueryCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserViewCategory_])
    async UserViewCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DataContext_])
    async DataContexts_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Data Contexts', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecordMergeLog_])
    async RecordMergeLogs_InitiatedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [InitiatedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRun_])
    async CompanyIntegrationRuns_RunByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [RunByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ReportCategory_])
    async ReportCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Report Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [RecordChangeReplayRun_])
    async RecordChangeReplayRuns_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Change Replay Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserRole_])
    async UserRoles_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserViewRun_])
    async UserViewRuns_RunByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [RunByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User View Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Workspace_])
    async Workspaces_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Workspaces', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Conversation_])
    async Conversations_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Lists', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CommunicationRun_])
    async CommunicationRuns_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionExecutionLog_])
    async ActionExecutionLogs_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ReportSnapshot_])
    async ReportSnapshots_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Report Snapshots', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserView_])
    async UserViews_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User Views', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [TemplateCategory_])
    async TemplateCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Template Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DuplicateRun_])
    async DuplicateRuns_StartedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [StartedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserRecordLog_])
    async UserRecordLogs_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Record Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserNotification_])
    async UserNotifications_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Notifications', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Template_])
    async Templates_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Templates', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Templates', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserFavorite_])
    async UserFavorites_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Favorites', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserFavorites] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('User Favorites', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Favorites', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ResourceLink_])
    async ResourceLinks_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Links', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ListCategory_])
    async ListCategories_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('List Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ScheduledAction_])
    async ScheduledActions_CreatedByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [CreatedByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentRequest_])
    async AIAgentRequests_ResponseByUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ResponseByUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ReportUserState_])
    async MJ_ReportUserStates_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentNote_])
    async AIAgentNotes_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Notes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentNotes] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Notes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Notes', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ResourcePermission_])
    async ResourcePermissions_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentRequest_])
    async AIAgentRequests_RequestForUserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [RequestForUserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Requests', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ConversationDetail_])
    async ConversationDetails_UserIDArray(@Root() user_: User_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [UserID]='${user_.ID}' ` + this.getRowLevelSecurityWhereClause('Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => User_)
    async CreateUser(
        @Arg('input', () => CreateUserInput) input: CreateUserInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Users', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => User_)
    async UpdateUser(
        @Arg('input', () => UpdateUserInput) input: UpdateUserInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Users', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => User_)
    async DeleteUser(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Users', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationships
//****************************************************************************
@ObjectType({ description: `Metadata about relationships between entities including display preferences for the UI` })
export class EntityRelationship_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int, {description: `Used for display order in generated forms and in other places in the UI where relationships for an entity are shown`}) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    RelatedEntityID: string;
        
    @Field(() => Boolean) 
    BundleInAPI: boolean;
        
    @Field(() => Boolean) 
    IncludeInParentAllQuery: boolean;
        
    @Field() 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    EntityKeyField?: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityJoinField: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    JoinView?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    JoinEntityJoinField?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    JoinEntityInverseJoinField?: string;
        
    @Field(() => Boolean, {description: `When unchecked the relationship will NOT be displayed on the generated form`}) 
    DisplayInForm: boolean;
        
    @Field() 
    @MaxLength(100)
    DisplayLocation: string;
        
    @Field({nullable: true, description: `Optional, when specified this value overrides the related entity name for the label on the tab`}) 
    @MaxLength(510)
    DisplayName?: string;
        
    @Field({description: `When Related Entity Icon - uses the icon from the related entity, if one exists. When Custom, uses the value in the DisplayIcon field in this record, and when None, no icon is displayed`}) 
    @MaxLength(100)
    DisplayIconType: string;
        
    @Field({nullable: true, description: `If specified, the icon `}) 
    @MaxLength(510)
    DisplayIcon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayUserViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DisplayComponentID?: string;
        
    @Field({nullable: true, description: `If DisplayComponentID is specified, this field can optionally be used to track component-specific and relationship-specific configuration details that will be used by CodeGen to provide to the display component selected.`}) 
    DisplayComponentConfiguration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Indicates whether this relationship should be automatically updated by CodeGen. When set to 0, the record will not be modified by CodeGen. Defaults to 1.`}) 
    AutoUpdateFromSchema: boolean;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntity: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseTable: string;
        
    @Field() 
    @MaxLength(510)
    RelatedEntityBaseView: string;
        
    @Field({nullable: true}) 
    RelatedEntityClassName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityCodeName?: string;
        
    @Field({nullable: true}) 
    RelatedEntityBaseTableCodeName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DisplayUserViewName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class CreateEntityRelationshipInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon: string | null;

    @Field({ nullable: true })
    DisplayComponentID: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationships
//****************************************************************************
@InputType()
export class UpdateEntityRelationshipInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    RelatedEntityID?: string;

    @Field(() => Boolean, { nullable: true })
    BundleInAPI?: boolean;

    @Field(() => Boolean, { nullable: true })
    IncludeInParentAllQuery?: boolean;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    EntityKeyField?: string | null;

    @Field({ nullable: true })
    RelatedEntityJoinField?: string;

    @Field({ nullable: true })
    JoinView?: string | null;

    @Field({ nullable: true })
    JoinEntityJoinField?: string | null;

    @Field({ nullable: true })
    JoinEntityInverseJoinField?: string | null;

    @Field(() => Boolean, { nullable: true })
    DisplayInForm?: boolean;

    @Field({ nullable: true })
    DisplayLocation?: string;

    @Field({ nullable: true })
    DisplayName?: string | null;

    @Field({ nullable: true })
    DisplayIconType?: string;

    @Field({ nullable: true })
    DisplayIcon?: string | null;

    @Field({ nullable: true })
    DisplayComponentID?: string | null;

    @Field({ nullable: true })
    DisplayComponentConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    AutoUpdateFromSchema?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationships
//****************************************************************************
@ObjectType()
export class RunEntityRelationshipViewResult {
    @Field(() => [EntityRelationship_])
    Results: EntityRelationship_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityRelationship_)
export class EntityRelationshipResolver extends ResolverBase {
    @Query(() => RunEntityRelationshipViewResult)
    async RunEntityRelationshipViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipViewResult)
    async RunEntityRelationshipViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipViewResult)
    async RunEntityRelationshipDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationships';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityRelationship_, { nullable: true })
    async EntityRelationship(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityRelationship_ | null> {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Relationships', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [EntityRelationship_])
    async AllEntityRelationships(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships]` + this.getRowLevelSecurityWhereClause('Entity Relationships', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => EntityRelationship_)
    async CreateEntityRelationship(
        @Arg('input', () => CreateEntityRelationshipInput) input: CreateEntityRelationshipInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Relationships', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityRelationship_)
    async UpdateEntityRelationship(
        @Arg('input', () => UpdateEntityRelationshipInput) input: UpdateEntityRelationshipInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Relationships', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityRelationship_)
    async DeleteEntityRelationship(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Relationships', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Record Logs
//****************************************************************************
@ObjectType()
export class UserRecordLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(8)
    EarliestAt: Date;
        
    @Field() 
    @MaxLength(8)
    LatestAt: Date;
        
    @Field(() => Int) 
    TotalCount: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field({nullable: true}) 
    @MaxLength(162)
    UserSupervisor?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UserSupervisorEmail?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Record Logs
//****************************************************************************
@InputType()
export class UpdateUserRecordLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EarliestAt?: Date;

    @Field({ nullable: true })
    LatestAt?: Date;

    @Field(() => Int, { nullable: true })
    TotalCount?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Record Logs
//****************************************************************************
@ObjectType()
export class RunUserRecordLogViewResult {
    @Field(() => [UserRecordLog_])
    Results: UserRecordLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserRecordLog_)
export class UserRecordLogResolver extends ResolverBase {
    @Query(() => RunUserRecordLogViewResult)
    async RunUserRecordLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserRecordLogViewResult)
    async RunUserRecordLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserRecordLogViewResult)
    async RunUserRecordLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Record Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserRecordLog_, { nullable: true })
    async UserRecordLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserRecordLog_ | null> {
        this.CheckUserReadPermissions('User Record Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRecordLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Record Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Record Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => UserRecordLog_)
    async UpdateUserRecordLog(
        @Arg('input', () => UpdateUserRecordLogInput) input: UpdateUserRecordLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User Record Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Views
//****************************************************************************
@ObjectType({ description: `Views are sets of records within a given entity defined by filtering rules. Views can be used programatically to retrieve dynamic sets of data and in user interfaces like MJ Explorer for end-user consumption.` })
export class UserView_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field(() => Boolean) 
    IsShared: boolean;
        
    @Field(() => Boolean) 
    IsDefault: boolean;
        
    @Field({nullable: true}) 
    GridState?: string;
        
    @Field({nullable: true}) 
    FilterState?: string;
        
    @Field(() => Boolean) 
    CustomFilterState: boolean;
        
    @Field(() => Boolean) 
    SmartFilterEnabled: boolean;
        
    @Field({nullable: true}) 
    SmartFilterPrompt?: string;
        
    @Field({nullable: true}) 
    SmartFilterWhereClause?: string;
        
    @Field({nullable: true}) 
    SmartFilterExplanation?: string;
        
    @Field({nullable: true}) 
    WhereClause?: string;
        
    @Field(() => Boolean) 
    CustomWhereClause: boolean;
        
    @Field({nullable: true}) 
    SortState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    UserName: string;
        
    @Field({nullable: true}) 
    @MaxLength(202)
    UserFirstLast?: string;
        
    @Field() 
    @MaxLength(200)
    UserEmail: string;
        
    @Field() 
    @MaxLength(30)
    UserType: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseView: string;
        
    @Field(() => [DataContextItem_])
    DataContextItems_ViewIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [UserViewRun_])
    UserViewRuns_UserViewIDArray: UserViewRun_[]; // Link to UserViewRuns
    
    @Field(() => [EntityRelationship_])
    EntityRelationships_DisplayUserViewGUIDArray: EntityRelationship_[]; // Link to EntityRelationships
    
}

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class CreateUserViewInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState: string | null;

    @Field({ nullable: true })
    FilterState: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation: string | null;

    @Field({ nullable: true })
    WhereClause: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Views
//****************************************************************************
@InputType()
export class UpdateUserViewInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsShared?: boolean;

    @Field(() => Boolean, { nullable: true })
    IsDefault?: boolean;

    @Field({ nullable: true })
    GridState?: string | null;

    @Field({ nullable: true })
    FilterState?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomFilterState?: boolean;

    @Field(() => Boolean, { nullable: true })
    SmartFilterEnabled?: boolean;

    @Field({ nullable: true })
    SmartFilterPrompt?: string | null;

    @Field({ nullable: true })
    SmartFilterWhereClause?: string | null;

    @Field({ nullable: true })
    SmartFilterExplanation?: string | null;

    @Field({ nullable: true })
    WhereClause?: string | null;

    @Field(() => Boolean, { nullable: true })
    CustomWhereClause?: boolean;

    @Field({ nullable: true })
    SortState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Views
//****************************************************************************
@ObjectType()
export class RunUserViewViewResult {
    @Field(() => [UserView_])
    Results: UserView_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserView_)
export class UserViewResolverBase extends ResolverBase {
    @Query(() => RunUserViewViewResult)
    async RunUserViewViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewViewResult)
    async RunUserViewViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewViewResult)
    async RunUserViewDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Views';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserView_, { nullable: true })
    async UserView(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserView_ | null> {
        this.CheckUserReadPermissions('User Views', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Views', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Views', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [UserView_])
    async AllUserViews(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews]` + this.getRowLevelSecurityWhereClause('User Views', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_ViewIDArray(@Root() userview_: UserView_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ViewID]='${userview_.ID}' ` + this.getRowLevelSecurityWhereClause('Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserViewRun_])
    async UserViewRuns_UserViewIDArray(@Root() userview_: UserView_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [UserViewID]='${userview_.ID}' ` + this.getRowLevelSecurityWhereClause('User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User View Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityRelationship_])
    async EntityRelationships_DisplayUserViewGUIDArray(@Root() userview_: UserView_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayUserViewGUID]='${userview_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => UserView_)
    async CreateUserView(
        @Arg('input', () => CreateUserViewInput) input: CreateUserViewInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User Views', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserView_)
    async UpdateUserView(
        @Arg('input', () => UpdateUserViewInput) input: UpdateUserViewInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User Views', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => UserView_)
    async DeleteUserView(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Views', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Runs
//****************************************************************************
@ObjectType()
export class CompanyIntegrationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field(() => Int) 
    TotalRecords: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the integration run. Possible values: Pending, In Progress, Success, Failed.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Optional error log information for the integration run.`}) 
    ErrorLog?: string;
        
    @Field({nullable: true, description: `Optional configuration data in JSON format for the request that started the integration run for audit purposes.`}) 
    ConfigData?: string;
        
    @Field() 
    @MaxLength(200)
    Integration: string;
        
    @Field() 
    @MaxLength(100)
    Company: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [ErrorLog_])
    ErrorLogs_CompanyIntegrationRunIDArray: ErrorLog_[]; // Link to ErrorLogs
    
    @Field(() => [CompanyIntegrationRunDetail_])
    CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray: CompanyIntegrationRunDetail_[]; // Link to CompanyIntegrationRunDetails
    
    @Field(() => [CompanyIntegrationRunAPILog_])
    CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray: CompanyIntegrationRunAPILog_[]; // Link to CompanyIntegrationRunAPILogs
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRunInput {
    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ConfigData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Runs
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field(() => Int, { nullable: true })
    TotalRecords?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ConfigData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Runs
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRunViewResult {
    @Field(() => [CompanyIntegrationRun_])
    Results: CompanyIntegrationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRun_)
export class CompanyIntegrationRunResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRunViewResult)
    async RunCompanyIntegrationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunViewResult)
    async RunCompanyIntegrationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunViewResult)
    async RunCompanyIntegrationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRun_, { nullable: true })
    async CompanyIntegrationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRun_ | null> {
        this.CheckUserReadPermissions('Company Integration Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Company Integration Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ErrorLog_])
    async ErrorLogs_CompanyIntegrationRunIDArray(@Root() companyintegrationrun_: CompanyIntegrationRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunID]='${companyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause('Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Error Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRunDetail_])
    async CompanyIntegrationRunDetails_CompanyIntegrationRunIDArray(@Root() companyintegrationrun_: CompanyIntegrationRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [CompanyIntegrationRunID]='${companyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run Details', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CompanyIntegrationRunAPILog_])
    async CompanyIntegrationRunAPILogs_CompanyIntegrationRunIDArray(@Root() companyintegrationrun_: CompanyIntegrationRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [CompanyIntegrationRunID]='${companyintegrationrun_.ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Company Integration Run API Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CompanyIntegrationRun_)
    async CreateCompanyIntegrationRun(
        @Arg('input', () => CreateCompanyIntegrationRunInput) input: CreateCompanyIntegrationRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Company Integration Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRun_)
    async UpdateCompanyIntegrationRun(
        @Arg('input', () => UpdateCompanyIntegrationRunInput) input: UpdateCompanyIntegrationRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Company Integration Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run Details
//****************************************************************************
@ObjectType()
export class CompanyIntegrationRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(40)
    Action: string;
        
    @Field() 
    @MaxLength(8)
    ExecutedAt: Date;
        
    @Field(() => Boolean) 
    IsSuccess: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    RunStartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    RunEndedAt?: Date;
        
    @Field(() => [ErrorLog_])
    ErrorLogs_CompanyIntegrationRunDetailIDArray: ErrorLog_[]; // Link to ErrorLogs
    
}

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRunDetailInput {
    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run Details
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run Details
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRunDetailViewResult {
    @Field(() => [CompanyIntegrationRunDetail_])
    Results: CompanyIntegrationRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRunDetail_)
export class CompanyIntegrationRunDetailResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRunDetailViewResult)
    async RunCompanyIntegrationRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunDetailViewResult)
    async RunCompanyIntegrationRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunDetailViewResult)
    async RunCompanyIntegrationRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run Details';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRunDetail_, { nullable: true })
    async CompanyIntegrationRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRunDetail_ | null> {
        this.CheckUserReadPermissions('Company Integration Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Company Integration Run Details', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ErrorLog_])
    async ErrorLogs_CompanyIntegrationRunDetailIDArray(@Root() companyintegrationrundetail_: CompanyIntegrationRunDetail_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [CompanyIntegrationRunDetailID]='${companyintegrationrundetail_.ID}' ` + this.getRowLevelSecurityWhereClause('Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Error Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CompanyIntegrationRunDetail_)
    async CreateCompanyIntegrationRunDetail(
        @Arg('input', () => CreateCompanyIntegrationRunDetailInput) input: CreateCompanyIntegrationRunDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Company Integration Run Details', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRunDetail_)
    async UpdateCompanyIntegrationRunDetail(
        @Arg('input', () => UpdateCompanyIntegrationRunDetailInput) input: UpdateCompanyIntegrationRunDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Company Integration Run Details', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Error Logs
//****************************************************************************
@ObjectType()
export class ErrorLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationRunDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(40)
    Code?: string;
        
    @Field({nullable: true}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    CreatedBy?: string;
        
    @Field({nullable: true}) 
    @MaxLength(20)
    Status?: string;
        
    @Field({nullable: true}) 
    @MaxLength(40)
    Category?: string;
        
    @Field({nullable: true}) 
    Details?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class CreateErrorLogInput {
    @Field({ nullable: true })
    CompanyIntegrationRunID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field({ nullable: true })
    Category: string | null;

    @Field({ nullable: true })
    Details: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Error Logs
//****************************************************************************
@InputType()
export class UpdateErrorLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationRunDetailID?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    CreatedBy?: string | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field({ nullable: true })
    Category?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Error Logs
//****************************************************************************
@ObjectType()
export class RunErrorLogViewResult {
    @Field(() => [ErrorLog_])
    Results: ErrorLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ErrorLog_)
export class ErrorLogResolver extends ResolverBase {
    @Query(() => RunErrorLogViewResult)
    async RunErrorLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunErrorLogViewResult)
    async RunErrorLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunErrorLogViewResult)
    async RunErrorLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Error Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ErrorLog_, { nullable: true })
    async ErrorLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ErrorLog_ | null> {
        this.CheckUserReadPermissions('Error Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwErrorLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Error Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Error Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ErrorLog_)
    async CreateErrorLog(
        @Arg('input', () => CreateErrorLogInput) input: CreateErrorLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Error Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ErrorLog_)
    async UpdateErrorLog(
        @Arg('input', () => UpdateErrorLogInput) input: UpdateErrorLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Error Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Applications
//****************************************************************************
@ObjectType({ description: `Applications are used to group entities in the user interface for ease of user access` })
export class Application_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true, description: `Specify the CSS class information for the display icon for each application.`}) 
    @MaxLength(1000)
    Icon?: string;
        
    @Field(() => Boolean, {description: `If turned on, when a new user first uses the MJ Explorer app, the application records with this turned on will have this application included in their selected application list.`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ApplicationSetting_])
    ApplicationSettings_ApplicationIDArray: ApplicationSetting_[]; // Link to ApplicationSettings
    
    @Field(() => [UserApplication_])
    UserApplications_ApplicationIDArray: UserApplication_[]; // Link to UserApplications
    
    @Field(() => [ApplicationEntity_])
    ApplicationEntities_ApplicationIDArray: ApplicationEntity_[]; // Link to ApplicationEntities
    
}

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class CreateApplicationInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Icon: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Applications
//****************************************************************************
@InputType()
export class UpdateApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Icon?: string | null;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Applications
//****************************************************************************
@ObjectType()
export class RunApplicationViewResult {
    @Field(() => [Application_])
    Results: Application_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Application_)
export class ApplicationResolver extends ResolverBase {
    @Query(() => RunApplicationViewResult)
    async RunApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunApplicationViewResult)
    async RunApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunApplicationViewResult)
    async RunApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Applications';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Application_, { nullable: true })
    async Application(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Application_ | null> {
        this.CheckUserReadPermissions('Applications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Applications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Applications', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Application_])
    async AllApplications(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Applications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplications]` + this.getRowLevelSecurityWhereClause('Applications', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Applications', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [ApplicationSetting_])
    async ApplicationSettings_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause('Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Application Settings', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserApplication_])
    async UserApplications_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause('User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Applications', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ApplicationEntity_])
    async ApplicationEntities_ApplicationIDArray(@Root() application_: Application_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ApplicationID]='${application_.ID}' ` + this.getRowLevelSecurityWhereClause('Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Application Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Application_)
    async CreateApplication(
        @Arg('input', () => CreateApplicationInput) input: CreateApplicationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Applications', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Application_)
    async UpdateApplication(
        @Arg('input', () => UpdateApplicationInput) input: UpdateApplicationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Applications', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Application_)
    async DeleteApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Applications', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Entities
//****************************************************************************
@ObjectType({ description: `List of entities within each application. An application can have any number of entities and an entity can be part of any number of applications.` })
export class ApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field(() => Boolean, {description: `When set to 1, the entity will be included by default for a new user when they first access the application in question`}) 
    DefaultForNewUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(510)
    EntityBaseTable: string;
        
    @Field({nullable: true}) 
    EntityCodeName?: string;
        
    @Field({nullable: true}) 
    EntityClassName?: string;
        
    @Field({nullable: true}) 
    EntityBaseTableCodeName?: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class CreateApplicationEntityInput {
    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Application Entities
//****************************************************************************
@InputType()
export class UpdateApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    DefaultForNewUser?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Entities
//****************************************************************************
@ObjectType()
export class RunApplicationEntityViewResult {
    @Field(() => [ApplicationEntity_])
    Results: ApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ApplicationEntity_)
export class ApplicationEntityResolver extends ResolverBase {
    @Query(() => RunApplicationEntityViewResult)
    async RunApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunApplicationEntityViewResult)
    async RunApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunApplicationEntityViewResult)
    async RunApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Entities';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ApplicationEntity_, { nullable: true })
    async ApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ApplicationEntity_ | null> {
        this.CheckUserReadPermissions('Application Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Application Entities', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ApplicationEntity_)
    async CreateApplicationEntity(
        @Arg('input', () => CreateApplicationEntityInput) input: CreateApplicationEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Application Entities', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ApplicationEntity_)
    async UpdateApplicationEntity(
        @Arg('input', () => UpdateApplicationEntityInput) input: UpdateApplicationEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Application Entities', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ApplicationEntity_)
    async DeleteApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Entities', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Permissions
//****************************************************************************
@ObjectType({ description: `Security settings for each entity` })
export class EntityPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field(() => Boolean) 
    CanCreate: boolean;
        
    @Field(() => Boolean) 
    CanRead: boolean;
        
    @Field(() => Boolean) 
    CanUpdate: boolean;
        
    @Field(() => Boolean) 
    CanDelete: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReadRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CreateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UpdateRLSFilterID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DeleteRLSFilterID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    RoleName: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    RoleSQLName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CreateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ReadRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    UpdateRLSFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DeleteRLSFilter?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class CreateEntityPermissionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Permissions
//****************************************************************************
@InputType()
export class UpdateEntityPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => Boolean, { nullable: true })
    CanCreate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanRead?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanUpdate?: boolean;

    @Field(() => Boolean, { nullable: true })
    CanDelete?: boolean;

    @Field({ nullable: true })
    ReadRLSFilterID?: string | null;

    @Field({ nullable: true })
    CreateRLSFilterID?: string | null;

    @Field({ nullable: true })
    UpdateRLSFilterID?: string | null;

    @Field({ nullable: true })
    DeleteRLSFilterID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Permissions
//****************************************************************************
@ObjectType()
export class RunEntityPermissionViewResult {
    @Field(() => [EntityPermission_])
    Results: EntityPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityPermission_)
export class EntityPermissionResolver extends ResolverBase {
    @Query(() => RunEntityPermissionViewResult)
    async RunEntityPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityPermissionViewResult)
    async RunEntityPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityPermissionViewResult)
    async RunEntityPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Permissions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityPermission_, { nullable: true })
    async EntityPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityPermission_ | null> {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Permissions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [EntityPermission_])
    async AllEntityPermissions(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions]` + this.getRowLevelSecurityWhereClause('Entity Permissions', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => EntityPermission_)
    async CreateEntityPermission(
        @Arg('input', () => CreateEntityPermissionInput) input: CreateEntityPermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Permissions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityPermission_)
    async UpdateEntityPermission(
        @Arg('input', () => UpdateEntityPermissionInput) input: UpdateEntityPermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Permissions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityPermission_)
    async DeleteEntityPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Permissions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Application Entities
//****************************************************************************
@ObjectType()
export class UserApplicationEntity_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserApplicationID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class CreateUserApplicationEntityInput {
    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for User Application Entities
//****************************************************************************
@InputType()
export class UpdateUserApplicationEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserApplicationID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Application Entities
//****************************************************************************
@ObjectType()
export class RunUserApplicationEntityViewResult {
    @Field(() => [UserApplicationEntity_])
    Results: UserApplicationEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserApplicationEntity_)
export class UserApplicationEntityResolver extends ResolverBase {
    @Query(() => RunUserApplicationEntityViewResult)
    async RunUserApplicationEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationEntityViewResult)
    async RunUserApplicationEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationEntityViewResult)
    async RunUserApplicationEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Application Entities';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserApplicationEntity_, { nullable: true })
    async UserApplicationEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserApplicationEntity_ | null> {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Application Entities', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => UserApplicationEntity_)
    async CreateUserApplicationEntity(
        @Arg('input', () => CreateUserApplicationEntityInput) input: CreateUserApplicationEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User Application Entities', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserApplicationEntity_)
    async UpdateUserApplicationEntity(
        @Arg('input', () => UpdateUserApplicationEntityInput) input: UpdateUserApplicationEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User Application Entities', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => UserApplicationEntity_)
    async DeleteUserApplicationEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Application Entities', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Applications
//****************************************************************************
@ObjectType()
export class UserApplication_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
    @Field(() => [UserApplicationEntity_])
    UserApplicationEntities_UserApplicationIDArray: UserApplicationEntity_[]; // Link to UserApplicationEntities
    
}

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class CreateUserApplicationInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for User Applications
//****************************************************************************
@InputType()
export class UpdateUserApplicationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Applications
//****************************************************************************
@ObjectType()
export class RunUserApplicationViewResult {
    @Field(() => [UserApplication_])
    Results: UserApplication_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserApplication_)
export class UserApplicationResolver extends ResolverBase {
    @Query(() => RunUserApplicationViewResult)
    async RunUserApplicationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationViewResult)
    async RunUserApplicationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserApplicationViewResult)
    async RunUserApplicationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Applications';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserApplication_, { nullable: true })
    async UserApplication(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserApplication_ | null> {
        this.CheckUserReadPermissions('User Applications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Applications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Applications', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [UserApplicationEntity_])
    async UserApplicationEntities_UserApplicationIDArray(@Root() userapplication_: UserApplication_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Application Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserApplicationEntities] WHERE [UserApplicationID]='${userapplication_.ID}' ` + this.getRowLevelSecurityWhereClause('User Application Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Application Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => UserApplication_)
    async CreateUserApplication(
        @Arg('input', () => CreateUserApplicationInput) input: CreateUserApplicationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User Applications', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserApplication_)
    async UpdateUserApplication(
        @Arg('input', () => UpdateUserApplicationInput) input: UpdateUserApplicationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User Applications', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => UserApplication_)
    async DeleteUserApplication(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Applications', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class CompanyIntegrationRunAPILog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationRunID: string;
        
    @Field() 
    @MaxLength(8)
    ExecutedAt: Date;
        
    @Field(() => Boolean) 
    IsSuccess: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(24)
    RequestMethod?: string;
        
    @Field({nullable: true}) 
    URL?: string;
        
    @Field({nullable: true}) 
    Parameters?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRunAPILogInput {
    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod: string | null;

    @Field({ nullable: true })
    URL: string | null;

    @Field({ nullable: true })
    Parameters: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Run API Logs
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRunAPILogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationRunID?: string;

    @Field({ nullable: true })
    ExecutedAt?: Date;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    RequestMethod?: string | null;

    @Field({ nullable: true })
    URL?: string | null;

    @Field({ nullable: true })
    Parameters?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Run API Logs
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRunAPILogViewResult {
    @Field(() => [CompanyIntegrationRunAPILog_])
    Results: CompanyIntegrationRunAPILog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRunAPILog_)
export class CompanyIntegrationRunAPILogResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRunAPILogViewResult)
    async RunCompanyIntegrationRunAPILogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunAPILogViewResult)
    async RunCompanyIntegrationRunAPILogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRunAPILogViewResult)
    async RunCompanyIntegrationRunAPILogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Run API Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRunAPILog_, { nullable: true })
    async CompanyIntegrationRunAPILog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRunAPILog_ | null> {
        this.CheckUserReadPermissions('Company Integration Run API Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRunAPILogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Run API Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Company Integration Run API Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => CompanyIntegrationRunAPILog_)
    async CreateCompanyIntegrationRunAPILog(
        @Arg('input', () => CreateCompanyIntegrationRunAPILogInput) input: CreateCompanyIntegrationRunAPILogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Company Integration Run API Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRunAPILog_)
    async UpdateCompanyIntegrationRunAPILog(
        @Arg('input', () => UpdateCompanyIntegrationRunAPILogInput) input: UpdateCompanyIntegrationRunAPILogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Company Integration Run API Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Lists
//****************************************************************************
@ObjectType({ description: `Static lists are useful for controlling a set of data for a given entity. These can be used programatically for applications like logging and tracking long-running tasks and also by end users for tracking any particular list of records they want to directly control the set.` })
export class List_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExternalSystemRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CompanyIntegrationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field(() => [ListDetail_])
    ListDetails_ListIDArray: ListDetail_[]; // Link to ListDetails
    
    @Field(() => [DuplicateRun_])
    DuplicateRuns_SourceListIDArray: DuplicateRun_[]; // Link to DuplicateRuns
    
}

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class CreateListInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Lists
//****************************************************************************
@InputType()
export class UpdateListInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string | null;

    @Field({ nullable: true })
    CompanyIntegrationID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Lists
//****************************************************************************
@ObjectType()
export class RunListViewResult {
    @Field(() => [List_])
    Results: List_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(List_)
export class ListResolver extends ResolverBase {
    @Query(() => RunListViewResult)
    async RunListViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunListViewResult)
    async RunListViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunListViewResult)
    async RunListDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Lists';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => List_, { nullable: true })
    async List(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<List_ | null> {
        this.CheckUserReadPermissions('Lists', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Lists', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Lists', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ListDetail_])
    async ListDetails_ListIDArray(@Root() list_: List_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ListID]='${list_.ID}' ` + this.getRowLevelSecurityWhereClause('List Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('List Details', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DuplicateRun_])
    async DuplicateRuns_SourceListIDArray(@Root() list_: List_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [SourceListID]='${list_.ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => List_)
    async CreateList(
        @Arg('input', () => CreateListInput) input: CreateListInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Lists', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => List_)
    async UpdateList(
        @Arg('input', () => UpdateListInput) input: UpdateListInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Lists', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => List_)
    async DeleteList(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Lists', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Details
//****************************************************************************
@ObjectType({ description: `Tracks the records within each list.` })
export class ListDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ListID: string;
        
    @Field() 
    @MaxLength(890)
    RecordID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Tracks the status of each individual list detail row to enable processing of various types and the use of the status column for filtering list detail rows within a list that are in a particular state.`}) 
    @MaxLength(60)
    Status: string;
        
    @Field({nullable: true, description: `Optional column that allows for tracking any additional data for each ListDetail row`}) 
    AdditionalData?: string;
        
    @Field() 
    @MaxLength(200)
    List: string;
        
}

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class CreateListDetailInput {
    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData: string | null;
}
    

//****************************************************************************
// INPUT TYPE for List Details
//****************************************************************************
@InputType()
export class UpdateListDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ListID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalData?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Details
//****************************************************************************
@ObjectType()
export class RunListDetailViewResult {
    @Field(() => [ListDetail_])
    Results: ListDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ListDetail_)
export class ListDetailResolver extends ResolverBase {
    @Query(() => RunListDetailViewResult)
    async RunListDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunListDetailViewResult)
    async RunListDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunListDetailViewResult)
    async RunListDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Details';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ListDetail_, { nullable: true })
    async ListDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ListDetail_ | null> {
        this.CheckUserReadPermissions('List Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('List Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('List Details', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ListDetail_)
    async CreateListDetail(
        @Arg('input', () => CreateListDetailInput) input: CreateListDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('List Details', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ListDetail_)
    async UpdateListDetail(
        @Arg('input', () => UpdateListDetailInput) input: UpdateListDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('List Details', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ListDetail_)
    async DeleteListDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Details', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Runs
//****************************************************************************
@ObjectType({ description: `User Views can be logged when run to capture the date and user that ran the view as well as the output results.` })
export class UserViewRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field() 
    @MaxLength(8)
    RunAt: Date;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    UserView: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [UserViewRunDetail_])
    UserViewRunDetails_UserViewRunIDArray: UserViewRunDetail_[]; // Link to UserViewRunDetails
    
}

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class CreateUserViewRunInput {
    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Runs
//****************************************************************************
@InputType()
export class UpdateUserViewRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewID?: string;

    @Field({ nullable: true })
    RunAt?: Date;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Runs
//****************************************************************************
@ObjectType()
export class RunUserViewRunViewResult {
    @Field(() => [UserViewRun_])
    Results: UserViewRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserViewRun_)
export class UserViewRunResolver extends ResolverBase {
    @Query(() => RunUserViewRunViewResult)
    async RunUserViewRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunViewResult)
    async RunUserViewRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunViewResult)
    async RunUserViewRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserViewRun_, { nullable: true })
    async UserViewRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserViewRun_ | null> {
        this.CheckUserReadPermissions('User View Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User View Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User View Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [UserViewRunDetail_])
    async UserViewRunDetails_UserViewRunIDArray(@Root() userviewrun_: UserViewRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [UserViewRunID]='${userviewrun_.ID}' ` + this.getRowLevelSecurityWhereClause('User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User View Run Details', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => UserViewRun_)
    async CreateUserViewRun(
        @Arg('input', () => CreateUserViewRunInput) input: CreateUserViewRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User View Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserViewRun_)
    async UpdateUserViewRun(
        @Arg('input', () => UpdateUserViewRunInput) input: UpdateUserViewRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User View Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Run Details
//****************************************************************************
@ObjectType({ description: `Tracks the set of records that were included in each run of a given user view.` })
export class UserViewRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserViewRunID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    UserViewID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class CreateUserViewRunDetailInput {
    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Run Details
//****************************************************************************
@InputType()
export class UpdateUserViewRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserViewRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Run Details
//****************************************************************************
@ObjectType()
export class RunUserViewRunDetailViewResult {
    @Field(() => [UserViewRunDetail_])
    Results: UserViewRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserViewRunDetail_)
export class UserViewRunDetailResolver extends ResolverBase {
    @Query(() => RunUserViewRunDetailViewResult)
    async RunUserViewRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunDetailViewResult)
    async RunUserViewRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewRunDetailViewResult)
    async RunUserViewRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Run Details';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserViewRunDetail_, { nullable: true })
    async UserViewRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserViewRunDetail_ | null> {
        this.CheckUserReadPermissions('User View Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User View Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User View Run Details', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => UserViewRunDetail_)
    async CreateUserViewRunDetail(
        @Arg('input', () => CreateUserViewRunDetailInput) input: CreateUserViewRunDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User View Run Details', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserViewRunDetail_)
    async UpdateUserViewRunDetail(
        @Arg('input', () => UpdateUserViewRunDetailInput) input: UpdateUserViewRunDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User View Run Details', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Runs
//****************************************************************************
@ObjectType()
export class WorkflowRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowID: string;
        
    @Field() 
    @MaxLength(1000)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    Results?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Workflow: string;
        
    @Field() 
    @MaxLength(200)
    WorkflowEngineName: string;
        
}

//****************************************************************************
// INPUT TYPE for Workflow Runs
//****************************************************************************
@InputType()
export class UpdateWorkflowRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    WorkflowID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Results?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Runs
//****************************************************************************
@ObjectType()
export class RunWorkflowRunViewResult {
    @Field(() => [WorkflowRun_])
    Results: WorkflowRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(WorkflowRun_)
export class WorkflowRunResolver extends ResolverBase {
    @Query(() => RunWorkflowRunViewResult)
    async RunWorkflowRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkflowRunViewResult)
    async RunWorkflowRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkflowRunViewResult)
    async RunWorkflowRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => WorkflowRun_, { nullable: true })
    async WorkflowRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<WorkflowRun_ | null> {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Workflow Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => WorkflowRun_)
    async UpdateWorkflowRun(
        @Arg('input', () => UpdateWorkflowRunInput) input: UpdateWorkflowRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Workflow Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflows
//****************************************************************************
@ObjectType()
export class Workflow_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkflowEngineID: string;
        
    @Field() 
    @MaxLength(200)
    ExternalSystemRecordID: string;
        
    @Field(() => Boolean, {description: `If set to 1, the workflow will be run automatically on the interval specified by the AutoRunIntervalType and AutoRunInterval fields`}) 
    AutoRunEnabled: boolean;
        
    @Field({nullable: true, description: `Minutes, Hours, Days, Weeks, Months, Years`}) 
    @MaxLength(40)
    AutoRunIntervalUnits?: string;
        
    @Field(() => Int, {nullable: true, description: `The interval, denominated in the units specified in the AutoRunIntervalUnits column, between auto runs of this workflow.`}) 
    AutoRunInterval?: number;
        
    @Field({nullable: true, description: `If specified, this subclass key, via the ClassFactory, will be instantiated, to execute this workflow. If not specified the WorkflowBase class will be used by default.`}) 
    @MaxLength(400)
    SubclassName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true}) 
    AutoRunIntervalMinutes?: number;
        
    @Field(() => [Report_])
    Reports_OutputWorkflowIDArray: Report_[]; // Link to Reports
    
    @Field(() => [WorkflowRun_])
    WorkflowRuns_WorkflowNameArray: WorkflowRun_[]; // Link to WorkflowRuns
    
}

//****************************************************************************
// INPUT TYPE for Workflows
//****************************************************************************
@InputType()
export class UpdateWorkflowInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkflowEngineID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field(() => Boolean, { nullable: true })
    AutoRunEnabled?: boolean;

    @Field({ nullable: true })
    AutoRunIntervalUnits?: string | null;

    @Field(() => Int, { nullable: true })
    AutoRunInterval?: number | null;

    @Field({ nullable: true })
    SubclassName?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflows
//****************************************************************************
@ObjectType()
export class RunWorkflowViewResult {
    @Field(() => [Workflow_])
    Results: Workflow_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Workflow_)
export class WorkflowResolver extends ResolverBase {
    @Query(() => RunWorkflowViewResult)
    async RunWorkflowViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkflowViewResult)
    async RunWorkflowViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkflowViewResult)
    async RunWorkflowDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflows';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Workflow_, { nullable: true })
    async Workflow(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Workflow_ | null> {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Workflows', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputWorkflowIDArray(@Root() workflow_: Workflow_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputWorkflowID]='${workflow_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [WorkflowRun_])
    async WorkflowRuns_WorkflowNameArray(@Root() workflow_: Workflow_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflow Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowRuns] WHERE [WorkflowName]='${workflow_.ID}' ` + this.getRowLevelSecurityWhereClause('Workflow Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Workflow Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Workflow_)
    async UpdateWorkflow(
        @Arg('input', () => UpdateWorkflowInput) input: UpdateWorkflowInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Workflows', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workflow Engines
//****************************************************************************
@ObjectType()
export class WorkflowEngine_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(1000)
    DriverPath: string;
        
    @Field() 
    @MaxLength(200)
    DriverClass: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Workflow_])
    Workflows_WorkflowEngineNameArray: Workflow_[]; // Link to Workflows
    
}

//****************************************************************************
// INPUT TYPE for Workflow Engines
//****************************************************************************
@InputType()
export class UpdateWorkflowEngineInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DriverPath?: string;

    @Field({ nullable: true })
    DriverClass?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workflow Engines
//****************************************************************************
@ObjectType()
export class RunWorkflowEngineViewResult {
    @Field(() => [WorkflowEngine_])
    Results: WorkflowEngine_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(WorkflowEngine_)
export class WorkflowEngineResolver extends ResolverBase {
    @Query(() => RunWorkflowEngineViewResult)
    async RunWorkflowEngineViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkflowEngineViewResult)
    async RunWorkflowEngineViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkflowEngineViewResult)
    async RunWorkflowEngineDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workflow Engines';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => WorkflowEngine_, { nullable: true })
    async WorkflowEngine(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<WorkflowEngine_ | null> {
        this.CheckUserReadPermissions('Workflow Engines', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflowEngines] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Workflow Engines', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Workflow Engines', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Workflow_])
    async Workflows_WorkflowEngineNameArray(@Root() workflowengine_: WorkflowEngine_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workflows', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkflows] WHERE [WorkflowEngineName]='${workflowengine_.ID}' ` + this.getRowLevelSecurityWhereClause('Workflows', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Workflows', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => WorkflowEngine_)
    async UpdateWorkflowEngine(
        @Arg('input', () => UpdateWorkflowEngineInput) input: UpdateWorkflowEngineInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Workflow Engines', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => WorkflowEngine_)
    async DeleteWorkflowEngine(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workflow Engines', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Changes
//****************************************************************************
@ObjectType({ description: `For entities that have TrackRecordChanges=1, Record Changes will store the history of all changes made within the system. For integrations you can directly add values here if you have inbound signals indicating records were changed in a source system. This entity only automatically captures Record Changes if they were made within the system.` })
export class RecordChange_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Create, Update, or Delete`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({description: `Internal or External`}) 
    @MaxLength(40)
    Source: string;
        
    @Field({description: `The date/time that the change occured.`}) 
    @MaxLength(10)
    ChangedAt: Date;
        
    @Field({description: `JSON structure that describes what was changed in a structured format.`}) 
    ChangesJSON: string;
        
    @Field({description: `A generated, human-readable description of what was changed.`}) 
    ChangesDescription: string;
        
    @Field({description: `A complete snapshot of the record AFTER the change was applied in a JSON format that can be parsed.`}) 
    FullRecordJSON: string;
        
    @Field({description: `For internal record changes generated within MJ, the status is immediately Complete. For external changes that are detected, the workflow starts off as Pending, then In Progress and finally either Complete or Error`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    ErrorLog?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ReplayRunID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    IntegrationID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Integration?: string;
        
}

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class CreateRecordChangeInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog: string | null;

    @Field({ nullable: true })
    ReplayRunID: string | null;

    @Field({ nullable: true })
    IntegrationID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Changes
//****************************************************************************
@InputType()
export class UpdateRecordChangeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    ChangedAt?: Date;

    @Field({ nullable: true })
    ChangesJSON?: string;

    @Field({ nullable: true })
    ChangesDescription?: string;

    @Field({ nullable: true })
    FullRecordJSON?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ErrorLog?: string | null;

    @Field({ nullable: true })
    ReplayRunID?: string | null;

    @Field({ nullable: true })
    IntegrationID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Changes
//****************************************************************************
@ObjectType()
export class RunRecordChangeViewResult {
    @Field(() => [RecordChange_])
    Results: RecordChange_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordChange_)
export class RecordChangeResolver extends ResolverBase {
    @Query(() => RunRecordChangeViewResult)
    async RunRecordChangeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeViewResult)
    async RunRecordChangeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeViewResult)
    async RunRecordChangeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Changes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecordChange_, { nullable: true })
    async RecordChange(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordChange_ | null> {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Record Changes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => RecordChange_)
    async CreateRecordChange(
        @Arg('input', () => CreateRecordChangeInput) input: CreateRecordChangeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Record Changes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecordChange_)
    async UpdateRecordChange(
        @Arg('input', () => UpdateRecordChangeInput) input: UpdateRecordChangeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Record Changes', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Roles
//****************************************************************************
@ObjectType()
export class UserRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for User Roles
//****************************************************************************
@InputType()
export class CreateUserRoleInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    
//****************************************************************************
// RESOLVER for User Roles
//****************************************************************************
@ObjectType()
export class RunUserRoleViewResult {
    @Field(() => [UserRole_])
    Results: UserRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserRole_)
export class UserRoleResolver extends ResolverBase {
    @Query(() => RunUserRoleViewResult)
    async RunUserRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserRoleViewResult)
    async RunUserRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserRoleViewResult)
    async RunUserRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Roles';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserRole_, { nullable: true })
    async UserRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserRole_ | null> {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Roles', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [UserRole_])
    async AllUserRoles(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserRoles]` + this.getRowLevelSecurityWhereClause('User Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('User Roles', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => UserRole_)
    async CreateUserRole(
        @Arg('input', () => CreateUserRoleInput) input: CreateUserRoleInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User Roles', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserRole_)
    async DeleteUserRole(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Roles', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Row Level Security Filters
//****************************************************************************
@ObjectType()
export class RowLevelSecurityFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    FilterText?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityPermission_])
    EntityPermissions_ReadRLSFilterIDArray: EntityPermission_[]; // Link to EntityPermissions
    
}
//****************************************************************************
// RESOLVER for Row Level Security Filters
//****************************************************************************
@ObjectType()
export class RunRowLevelSecurityFilterViewResult {
    @Field(() => [RowLevelSecurityFilter_])
    Results: RowLevelSecurityFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RowLevelSecurityFilter_)
export class RowLevelSecurityFilterResolver extends ResolverBase {
    @Query(() => RunRowLevelSecurityFilterViewResult)
    async RunRowLevelSecurityFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRowLevelSecurityFilterViewResult)
    async RunRowLevelSecurityFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRowLevelSecurityFilterViewResult)
    async RunRowLevelSecurityFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Row Level Security Filters';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RowLevelSecurityFilter_, { nullable: true })
    async RowLevelSecurityFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RowLevelSecurityFilter_ | null> {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Row Level Security Filters', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Row Level Security Filters', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [RowLevelSecurityFilter_])
    async AllRowLevelSecurityFilters(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Row Level Security Filters', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRowLevelSecurityFilters]` + this.getRowLevelSecurityWhereClause('Row Level Security Filters', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Row Level Security Filters', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [EntityPermission_])
    async EntityPermissions_ReadRLSFilterIDArray(@Root() rowlevelsecurityfilter_: RowLevelSecurityFilter_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityPermissions] WHERE [ReadRLSFilterID]='${rowlevelsecurityfilter_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Permissions', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Audit Logs
//****************************************************************************
@ObjectType()
export class AuditLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(16)
    AuditLogTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    Details?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(100)
    AuditLogType: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class CreateAuditLogInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Details: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Audit Logs
//****************************************************************************
@InputType()
export class UpdateAuditLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AuditLogTypeID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Details?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Audit Logs
//****************************************************************************
@ObjectType()
export class RunAuditLogViewResult {
    @Field(() => [AuditLog_])
    Results: AuditLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AuditLog_)
export class AuditLogResolver extends ResolverBase {
    @Query(() => RunAuditLogViewResult)
    async RunAuditLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuditLogViewResult)
    async RunAuditLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuditLogViewResult)
    async RunAuditLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AuditLog_, { nullable: true })
    async AuditLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AuditLog_ | null> {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Audit Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AuditLog_)
    async CreateAuditLog(
        @Arg('input', () => CreateAuditLogInput) input: CreateAuditLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Audit Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AuditLog_)
    async UpdateAuditLog(
        @Arg('input', () => UpdateAuditLogInput) input: UpdateAuditLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Audit Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Authorizations
//****************************************************************************
@ObjectType()
export class Authorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field(() => Boolean, {description: `When set to 1, Audit Log records are created whenever this authorization is invoked for a user`}) 
    UseAuditLog: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field(() => [AuthorizationRole_])
    AuthorizationRoles_AuthorizationIDArray: AuthorizationRole_[]; // Link to AuthorizationRoles
    
    @Field(() => [ActionAuthorization_])
    ActionAuthorizations_AuthorizationIDArray: ActionAuthorization_[]; // Link to ActionAuthorizations
    
    @Field(() => [Authorization_])
    Authorizations_ParentIDArray: Authorization_[]; // Link to Authorizations
    
    @Field(() => [AuditLog_])
    AuditLogs_AuthorizationNameArray: AuditLog_[]; // Link to AuditLogs
    
    @Field(() => [AuditLogType_])
    AuditLogTypes_AuthorizationNameArray: AuditLogType_[]; // Link to AuditLogTypes
    
}
//****************************************************************************
// RESOLVER for Authorizations
//****************************************************************************
@ObjectType()
export class RunAuthorizationViewResult {
    @Field(() => [Authorization_])
    Results: Authorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Authorization_)
export class AuthorizationResolver extends ResolverBase {
    @Query(() => RunAuthorizationViewResult)
    async RunAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationViewResult)
    async RunAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationViewResult)
    async RunAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorizations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Authorization_, { nullable: true })
    async Authorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Authorization_ | null> {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Authorizations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [Authorization_])
    async AllAuthorizations(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations]` + this.getRowLevelSecurityWhereClause('Authorizations', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Authorizations', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [AuthorizationRole_])
    async AuthorizationRoles_AuthorizationIDArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [AuthorizationID]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause('Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionAuthorization_])
    async ActionAuthorizations_AuthorizationIDArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [AuthorizationID]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Authorizations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Authorization_])
    async Authorizations_ParentIDArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorizations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizations] WHERE [ParentID]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause('Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Authorizations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_AuthorizationNameArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuthorizationName]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause('Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AuditLogType_])
    async AuditLogTypes_AuthorizationNameArray(@Root() authorization_: Authorization_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [AuthorizationName]='${authorization_.ID}' ` + this.getRowLevelSecurityWhereClause('Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Authorization Roles
//****************************************************************************
@ObjectType()
export class AuthorizationRole_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(20)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}
//****************************************************************************
// RESOLVER for Authorization Roles
//****************************************************************************
@ObjectType()
export class RunAuthorizationRoleViewResult {
    @Field(() => [AuthorizationRole_])
    Results: AuthorizationRole_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AuthorizationRole_)
export class AuthorizationRoleResolver extends ResolverBase {
    @Query(() => RunAuthorizationRoleViewResult)
    async RunAuthorizationRoleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationRoleViewResult)
    async RunAuthorizationRoleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuthorizationRoleViewResult)
    async RunAuthorizationRoleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Authorization Roles';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AuthorizationRole_, { nullable: true })
    async AuthorizationRole(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AuthorizationRole_ | null> {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Authorization Roles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Authorization Roles', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [AuthorizationRole_])
    async AllAuthorizationRoles(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Authorization Roles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuthorizationRoles]` + this.getRowLevelSecurityWhereClause('Authorization Roles', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Authorization Roles', await dataSource.query(sSQL));
        return result;
    }
    
}

//****************************************************************************
// ENTITY CLASS for Audit Log Types
//****************************************************************************
@ObjectType()
export class AuditLogType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    AuthorizationID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Authorization?: string;
        
    @Field(() => [AuditLogType_])
    AuditLogTypes_ParentIDArray: AuditLogType_[]; // Link to AuditLogTypes
    
    @Field(() => [AuditLog_])
    AuditLogs_AuditLogTypeNameArray: AuditLog_[]; // Link to AuditLogs
    
}
//****************************************************************************
// RESOLVER for Audit Log Types
//****************************************************************************
@ObjectType()
export class RunAuditLogTypeViewResult {
    @Field(() => [AuditLogType_])
    Results: AuditLogType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AuditLogType_)
export class AuditLogTypeResolver extends ResolverBase {
    @Query(() => RunAuditLogTypeViewResult)
    async RunAuditLogTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuditLogTypeViewResult)
    async RunAuditLogTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAuditLogTypeViewResult)
    async RunAuditLogTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Audit Log Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AuditLogType_, { nullable: true })
    async AuditLogType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AuditLogType_ | null> {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Audit Log Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [AuditLogType_])
    async AllAuditLogTypes(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes]` + this.getRowLevelSecurityWhereClause('Audit Log Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [AuditLogType_])
    async AuditLogTypes_ParentIDArray(@Root() auditlogtype_: AuditLogType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Log Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogTypes] WHERE [ParentID]='${auditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause('Audit Log Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Log Types', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AuditLog_])
    async AuditLogs_AuditLogTypeNameArray(@Root() auditlogtype_: AuditLogType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Audit Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAuditLogs] WHERE [AuditLogTypeName]='${auditlogtype_.ID}' ` + this.getRowLevelSecurityWhereClause('Audit Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Audit Logs', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Entity Field Values
//****************************************************************************
@ObjectType()
export class EntityFieldValue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityFieldID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(510)
    Value: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Code?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    EntityField: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Field Values
//****************************************************************************
@InputType()
export class UpdateEntityFieldValueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityFieldID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Field Values
//****************************************************************************
@ObjectType()
export class RunEntityFieldValueViewResult {
    @Field(() => [EntityFieldValue_])
    Results: EntityFieldValue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityFieldValue_)
export class EntityFieldValueResolver extends ResolverBase {
    @Query(() => RunEntityFieldValueViewResult)
    async RunEntityFieldValueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldValueViewResult)
    async RunEntityFieldValueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityFieldValueViewResult)
    async RunEntityFieldValueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Field Values';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityFieldValue_, { nullable: true })
    async EntityFieldValue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityFieldValue_ | null> {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Field Values', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Field Values', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [EntityFieldValue_])
    async AllEntityFieldValues(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Field Values', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityFieldValues]` + this.getRowLevelSecurityWhereClause('Entity Field Values', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Field Values', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => EntityFieldValue_)
    async UpdateEntityFieldValue(
        @Arg('input', () => UpdateEntityFieldValueInput) input: UpdateEntityFieldValueInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Field Values', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Models
//****************************************************************************
@ObjectType({ description: `Catalog of all AI Models configured in the system` })
export class AIModel_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Vendor?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelTypeID: string;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the power of the AI model. Default is 0 and should be non-negative.`}) 
    PowerRank?: number;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    DriverClass?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DriverImportPath?: string;
        
    @Field({nullable: true, description: `The name of the model to use with API calls which might differ from the Name, if APIName is not provided, Name will be used for API calls`}) 
    @MaxLength(200)
    APIName?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the speed of the AI model. Default is 0 and should be non-negative.`}) 
    SpeedRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Optional column that ranks the cost of the AI model. Default is 0 and should be non-negative.`}) 
    CostRank?: number;
        
    @Field({nullable: true, description: `This column stores unstructured text notes that provide insights into what the model is particularly good at and areas where it may not perform as well. These notes can be used by a human or an AI to determine if the model is a good fit for various purposes.`}) 
    ModelSelectionInsights?: string;
        
    @Field(() => Int, {nullable: true, description: `Stores the maximum number of tokens that fit in the context window for the model.`}) 
    InputTokenLimit?: number;
        
    @Field({description: `A comma-delimited string indicating the supported response formats for the AI model. Options include Any, Text, Markdown, JSON, and ModelSpecific. Defaults to Any if not specified.`}) 
    @MaxLength(200)
    SupportedResponseFormats: string;
        
    @Field() 
    @MaxLength(100)
    AIModelType: string;
        
    @Field(() => [AIAction_])
    AIActions_DefaultModelIDArray: AIAction_[]; // Link to AIActions
    
    @Field(() => [EntityDocument_])
    EntityDocuments_AIModelIDArray: EntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [AIModelAction_])
    AIModelActions_AIModelIDArray: AIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [VectorIndex_])
    VectorIndexes_EmbeddingModelIDArray: VectorIndex_[]; // Link to VectorIndexes
    
    @Field(() => [ContentType_])
    ContentTypes_AIModelIDArray: ContentType_[]; // Link to ContentTypes
    
    @Field(() => [AIResultCache_])
    AIResultCache_AIModelIDArray: AIResultCache_[]; // Link to AIResultCache
    
    @Field(() => [EntityAIAction_])
    EntityAIActions_AIModelIDArray: EntityAIAction_[]; // Link to EntityAIActions
    
    @Field(() => [AIAgentModel_])
    AIAgentModels_ModelIDArray: AIAgentModel_[]; // Link to AIAgentModels
    
    @Field(() => [GeneratedCode_])
    GeneratedCodes_GeneratedByModelIDArray: GeneratedCode_[]; // Link to GeneratedCodes
    
}

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class CreateAIModelInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Vendor: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    DriverClass: string | null;

    @Field({ nullable: true })
    DriverImportPath: string | null;

    @Field({ nullable: true })
    APIName: string | null;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;
}
    

//****************************************************************************
// INPUT TYPE for AI Models
//****************************************************************************
@InputType()
export class UpdateAIModelInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Vendor?: string | null;

    @Field({ nullable: true })
    AIModelTypeID?: string;

    @Field(() => Int, { nullable: true })
    PowerRank?: number | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field({ nullable: true })
    DriverClass?: string | null;

    @Field({ nullable: true })
    DriverImportPath?: string | null;

    @Field({ nullable: true })
    APIName?: string | null;

    @Field(() => Int, { nullable: true })
    SpeedRank?: number | null;

    @Field(() => Int, { nullable: true })
    CostRank?: number | null;

    @Field({ nullable: true })
    ModelSelectionInsights?: string | null;

    @Field(() => Int, { nullable: true })
    InputTokenLimit?: number | null;

    @Field({ nullable: true })
    SupportedResponseFormats?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Models
//****************************************************************************
@ObjectType()
export class RunAIModelViewResult {
    @Field(() => [AIModel_])
    Results: AIModel_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModel_)
export class AIModelResolver extends ResolverBase {
    @Query(() => RunAIModelViewResult)
    async RunAIModelViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIModelViewResult)
    async RunAIModelViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIModelViewResult)
    async RunAIModelDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Models';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIModel_, { nullable: true })
    async AIModel(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModel_ | null> {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Models', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [AIModel_])
    async AllAIModels(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels]` + this.getRowLevelSecurityWhereClause('AI Models', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Models', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [AIAction_])
    async AIActions_DefaultModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [DefaultModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIModelAction_])
    async AIModelActions_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [VectorIndex_])
    async VectorIndexes_EmbeddingModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [EmbeddingModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Vector Indexes', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentType_])
    async ContentTypes_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Types', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIResultCache_])
    async AIResultCache_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Result Cache', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIResultCaches] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Result Cache', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Result Cache', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityAIAction_])
    async EntityAIActions_AIModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentModel_])
    async AIAgentModels_ModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Models', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentModels] WHERE [ModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Models', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Models', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [GeneratedCode_])
    async GeneratedCodes_GeneratedByModelIDArray(@Root() aimodel_: AIModel_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [GeneratedByModelID]='${aimodel_.ID}' ` + this.getRowLevelSecurityWhereClause('Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Generated Codes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIModel_)
    async CreateAIModel(
        @Arg('input', () => CreateAIModelInput) input: CreateAIModelInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Models', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIModel_)
    async UpdateAIModel(
        @Arg('input', () => UpdateAIModelInput) input: UpdateAIModelInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Models', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIModel_)
    async DeleteAIModel(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Models', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Actions
//****************************************************************************
@ObjectType({ description: `List of all actions that are possible across all AI Models` })
export class AIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    DefaultPrompt?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DefaultModelID?: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    DefaultModel?: string;
        
    @Field(() => [AIModelAction_])
    AIModelActions_AIActionIDArray: AIModelAction_[]; // Link to AIModelActions
    
    @Field(() => [EntityAIAction_])
    EntityAIActions_AIActionIDArray: EntityAIAction_[]; // Link to EntityAIActions
    
}

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class CreateAIActionInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultPrompt: string | null;

    @Field({ nullable: true })
    DefaultModelID: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Actions
//****************************************************************************
@InputType()
export class UpdateAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultPrompt?: string | null;

    @Field({ nullable: true })
    DefaultModelID?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Actions
//****************************************************************************
@ObjectType()
export class RunAIActionViewResult {
    @Field(() => [AIAction_])
    Results: AIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAction_)
export class AIActionResolver extends ResolverBase {
    @Query(() => RunAIActionViewResult)
    async RunAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIActionViewResult)
    async RunAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIActionViewResult)
    async RunAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAction_, { nullable: true })
    async AIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAction_ | null> {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [AIAction_])
    async AllAIActions(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIActions]` + this.getRowLevelSecurityWhereClause('AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Actions', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [AIModelAction_])
    async AIModelActions_AIActionIDArray(@Root() aiaction_: AIAction_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [AIActionID]='${aiaction_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityAIAction_])
    async EntityAIActions_AIActionIDArray(@Root() aiaction_: AIAction_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [AIActionID]='${aiaction_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIAction_)
    async CreateAIAction(
        @Arg('input', () => CreateAIActionInput) input: CreateAIActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAction_)
    async UpdateAIAction(
        @Arg('input', () => UpdateAIActionInput) input: UpdateAIActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAction_)
    async DeleteAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Actions
//****************************************************************************
@ObjectType({ description: `Tracks the actions supported by each AI Model` })
export class AIModelAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class CreateAIModelActionInput {
    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Actions
//****************************************************************************
@InputType()
export class UpdateAIModelActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Actions
//****************************************************************************
@ObjectType()
export class RunAIModelActionViewResult {
    @Field(() => [AIModelAction_])
    Results: AIModelAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelAction_)
export class AIModelActionResolver extends ResolverBase {
    @Query(() => RunAIModelActionViewResult)
    async RunAIModelActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIModelActionViewResult)
    async RunAIModelActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIModelActionViewResult)
    async RunAIModelActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIModelAction_, { nullable: true })
    async AIModelAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelAction_ | null> {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Model Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Model Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [AIModelAction_])
    async AllAIModelActions(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelActions]` + this.getRowLevelSecurityWhereClause('AI Model Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Actions', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => AIModelAction_)
    async CreateAIModelAction(
        @Arg('input', () => CreateAIModelActionInput) input: CreateAIModelActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Model Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelAction_)
    async UpdateAIModelAction(
        @Arg('input', () => UpdateAIModelActionInput) input: UpdateAIModelActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Model Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelAction_)
    async DeleteAIModelAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity AI Actions
//****************************************************************************
@ObjectType({ description: `Tracks the AI actions that should be invoked based on changes to records within a given entity.` })
export class EntityAIAction_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field() 
    @MaxLength(16)
    AIActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Prompt?: string;
        
    @Field() 
    @MaxLength(30)
    TriggerEvent: string;
        
    @Field() 
    UserMessage: string;
        
    @Field() 
    @MaxLength(20)
    OutputType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OutputField?: string;
        
    @Field(() => Boolean) 
    SkipIfOutputFieldNotEmpty: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputEntityID?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field() 
    @MaxLength(100)
    AIAction: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class CreateEntityAIActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity AI Actions
//****************************************************************************
@InputType()
export class UpdateEntityAIActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field({ nullable: true })
    AIActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string | null;

    @Field({ nullable: true })
    TriggerEvent?: string;

    @Field({ nullable: true })
    UserMessage?: string;

    @Field({ nullable: true })
    OutputType?: string;

    @Field({ nullable: true })
    OutputField?: string | null;

    @Field(() => Boolean, { nullable: true })
    SkipIfOutputFieldNotEmpty?: boolean;

    @Field({ nullable: true })
    OutputEntityID?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity AI Actions
//****************************************************************************
@ObjectType()
export class RunEntityAIActionViewResult {
    @Field(() => [EntityAIAction_])
    Results: EntityAIAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityAIAction_)
export class EntityAIActionResolver extends ResolverBase {
    @Query(() => RunEntityAIActionViewResult)
    async RunEntityAIActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityAIActionViewResult)
    async RunEntityAIActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityAIActionViewResult)
    async RunEntityAIActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity AI Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityAIAction_, { nullable: true })
    async EntityAIAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityAIAction_ | null> {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity AI Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity AI Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [EntityAIAction_])
    async AllEntityAIActions(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity AI Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityAIActions]` + this.getRowLevelSecurityWhereClause('Entity AI Actions', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity AI Actions', await dataSource.query(sSQL));
        return result;
    }
    
    @Mutation(() => EntityAIAction_)
    async CreateEntityAIAction(
        @Arg('input', () => CreateEntityAIActionInput) input: CreateEntityAIActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity AI Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityAIAction_)
    async UpdateEntityAIAction(
        @Arg('input', () => UpdateEntityAIActionInput) input: UpdateEntityAIActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity AI Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityAIAction_)
    async DeleteEntityAIAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity AI Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Model Types
//****************************************************************************
@ObjectType({ description: `Types of AI Models` })
export class AIModelType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [AIModel_])
    AIModels_AIModelTypeIDArray: AIModel_[]; // Link to AIModels
    
}

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class CreateAIModelTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Model Types
//****************************************************************************
@InputType()
export class UpdateAIModelTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Model Types
//****************************************************************************
@ObjectType()
export class RunAIModelTypeViewResult {
    @Field(() => [AIModelType_])
    Results: AIModelType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIModelType_)
export class AIModelTypeResolver extends ResolverBase {
    @Query(() => RunAIModelTypeViewResult)
    async RunAIModelTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIModelTypeViewResult)
    async RunAIModelTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIModelTypeViewResult)
    async RunAIModelTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Model Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIModelType_, { nullable: true })
    async AIModelType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIModelType_ | null> {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Model Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Model Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Query(() => [AIModelType_])
    async AllAIModelTypes(@Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Model Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModelTypes]` + this.getRowLevelSecurityWhereClause('AI Model Types', userPayload, EntityPermissionType.Read, ' WHERE');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Model Types', await dataSource.query(sSQL));
        return result;
    }
    
    @FieldResolver(() => [AIModel_])
    async AIModels_AIModelTypeIDArray(@Root() aimodeltype_: AIModelType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Models', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIModels] WHERE [AIModelTypeID]='${aimodeltype_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Models', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Models', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => AIModelType_)
    async CreateAIModelType(
        @Arg('input', () => CreateAIModelTypeInput) input: CreateAIModelTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Model Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIModelType_)
    async UpdateAIModelType(
        @Arg('input', () => UpdateAIModelTypeInput) input: UpdateAIModelTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Model Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIModelType_)
    async DeleteAIModelType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Model Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Types
//****************************************************************************
@ObjectType()
export class QueueType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(200)
    DriverClass: string;
        
    @Field({nullable: true}) 
    @MaxLength(400)
    DriverImportPath?: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Queue_])
    Queues_QueueTypeIDArray: Queue_[]; // Link to Queues
    
}
//****************************************************************************
// RESOLVER for Queue Types
//****************************************************************************
@ObjectType()
export class RunQueueTypeViewResult {
    @Field(() => [QueueType_])
    Results: QueueType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueueType_)
export class QueueTypeResolver extends ResolverBase {
    @Query(() => RunQueueTypeViewResult)
    async RunQueueTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueueTypeViewResult)
    async RunQueueTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueueTypeViewResult)
    async RunQueueTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => QueueType_, { nullable: true })
    async QueueType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueueType_ | null> {
        this.CheckUserReadPermissions('Queue Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Queue Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Queue Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Queue_])
    async Queues_QueueTypeIDArray(@Root() queuetype_: QueueType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queues', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [QueueTypeID]='${queuetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Queues', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Queues', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Queues
//****************************************************************************
@ObjectType({ description: `Queues can be used to async execute long running tasks` })
export class Queue_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    QueueTypeID: string;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field(() => Int, {nullable: true}) 
    ProcessPID?: number;
        
    @Field({nullable: true}) 
    @MaxLength(60)
    ProcessPlatform?: string;
        
    @Field({nullable: true}) 
    @MaxLength(30)
    ProcessVersion?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ProcessCwd?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessIPAddress?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessMacAddress?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    ProcessOSName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(20)
    ProcessOSVersion?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessHostName?: string;
        
    @Field({nullable: true}) 
    @MaxLength(50)
    ProcessUserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ProcessUserName?: string;
        
    @Field() 
    @MaxLength(8)
    LastHeartbeat: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    QueueType: string;
        
    @Field(() => [QueueTask_])
    QueueTasks_QueueIDArray: QueueTask_[]; // Link to QueueTasks
    
}

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class CreateQueueInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID: number | null;

    @Field({ nullable: true })
    ProcessPlatform: string | null;

    @Field({ nullable: true })
    ProcessVersion: string | null;

    @Field({ nullable: true })
    ProcessCwd: string | null;

    @Field({ nullable: true })
    ProcessIPAddress: string | null;

    @Field({ nullable: true })
    ProcessMacAddress: string | null;

    @Field({ nullable: true })
    ProcessOSName: string | null;

    @Field({ nullable: true })
    ProcessOSVersion: string | null;

    @Field({ nullable: true })
    ProcessHostName: string | null;

    @Field({ nullable: true })
    ProcessUserID: string | null;

    @Field({ nullable: true })
    ProcessUserName: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Queues
//****************************************************************************
@InputType()
export class UpdateQueueInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    QueueTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => Int, { nullable: true })
    ProcessPID?: number | null;

    @Field({ nullable: true })
    ProcessPlatform?: string | null;

    @Field({ nullable: true })
    ProcessVersion?: string | null;

    @Field({ nullable: true })
    ProcessCwd?: string | null;

    @Field({ nullable: true })
    ProcessIPAddress?: string | null;

    @Field({ nullable: true })
    ProcessMacAddress?: string | null;

    @Field({ nullable: true })
    ProcessOSName?: string | null;

    @Field({ nullable: true })
    ProcessOSVersion?: string | null;

    @Field({ nullable: true })
    ProcessHostName?: string | null;

    @Field({ nullable: true })
    ProcessUserID?: string | null;

    @Field({ nullable: true })
    ProcessUserName?: string | null;

    @Field({ nullable: true })
    LastHeartbeat?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queues
//****************************************************************************
@ObjectType()
export class RunQueueViewResult {
    @Field(() => [Queue_])
    Results: Queue_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Queue_)
export class QueueResolver extends ResolverBase {
    @Query(() => RunQueueViewResult)
    async RunQueueViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueueViewResult)
    async RunQueueViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueueViewResult)
    async RunQueueDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queues';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Queue_, { nullable: true })
    async Queue(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Queue_ | null> {
        this.CheckUserReadPermissions('Queues', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueues] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Queues', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Queues', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [QueueTask_])
    async QueueTasks_QueueIDArray(@Root() queue_: Queue_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [QueueID]='${queue_.ID}' ` + this.getRowLevelSecurityWhereClause('Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Queue Tasks', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Queue_)
    async CreateQueue(
        @Arg('input', () => CreateQueueInput) input: CreateQueueInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Queues', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Queue_)
    async UpdateQueue(
        @Arg('input', () => UpdateQueueInput) input: UpdateQueueInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Queues', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queue Tasks
//****************************************************************************
@ObjectType()
export class QueueTask_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueueID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Data?: string;
        
    @Field({nullable: true}) 
    Options?: string;
        
    @Field({nullable: true}) 
    Output?: string;
        
    @Field({nullable: true}) 
    ErrorMessage?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    Queue: string;
        
}

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class CreateQueueTaskInput {
    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Data: string | null;

    @Field({ nullable: true })
    Options: string | null;

    @Field({ nullable: true })
    Output: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Queue Tasks
//****************************************************************************
@InputType()
export class UpdateQueueTaskInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueueID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Data?: string | null;

    @Field({ nullable: true })
    Options?: string | null;

    @Field({ nullable: true })
    Output?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queue Tasks
//****************************************************************************
@ObjectType()
export class RunQueueTaskViewResult {
    @Field(() => [QueueTask_])
    Results: QueueTask_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueueTask_)
export class QueueTaskResolver extends ResolverBase {
    @Query(() => RunQueueTaskViewResult)
    async RunQueueTaskViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueueTaskViewResult)
    async RunQueueTaskViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueueTaskViewResult)
    async RunQueueTaskDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queue Tasks';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => QueueTask_, { nullable: true })
    async QueueTask(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueueTask_ | null> {
        this.CheckUserReadPermissions('Queue Tasks', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueueTasks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Queue Tasks', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Queue Tasks', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => QueueTask_)
    async CreateQueueTask(
        @Arg('input', () => CreateQueueTaskInput) input: CreateQueueTaskInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Queue Tasks', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => QueueTask_)
    async UpdateQueueTask(
        @Arg('input', () => UpdateQueueTaskInput) input: UpdateQueueTaskInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Queue Tasks', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboards
//****************************************************************************
@ObjectType({ description: `Dashboards are used to group resources into a single display pane for an end-user` })
export class Dashboard_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    UIConfigDetails: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
}

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class CreateDashboardInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboards
//****************************************************************************
@InputType()
export class UpdateDashboardInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UIConfigDetails?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboards
//****************************************************************************
@ObjectType()
export class RunDashboardViewResult {
    @Field(() => [Dashboard_])
    Results: Dashboard_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Dashboard_)
export class DashboardResolver extends ResolverBase {
    @Query(() => RunDashboardViewResult)
    async RunDashboardViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDashboardViewResult)
    async RunDashboardViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDashboardViewResult)
    async RunDashboardDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboards';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Dashboard_, { nullable: true })
    async Dashboard(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Dashboard_ | null> {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Dashboards', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => Dashboard_)
    async CreateDashboard(
        @Arg('input', () => CreateDashboardInput) input: CreateDashboardInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Dashboards', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Dashboard_)
    async UpdateDashboard(
        @Arg('input', () => UpdateDashboardInput) input: UpdateDashboardInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Dashboards', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Dashboard_)
    async DeleteDashboard(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboards', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Output Trigger Types
//****************************************************************************
@ObjectType()
export class OutputTriggerType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Report_])
    Reports_OutputTriggerTypeIDArray: Report_[]; // Link to Reports
    
}
//****************************************************************************
// RESOLVER for Output Trigger Types
//****************************************************************************
@ObjectType()
export class RunOutputTriggerTypeViewResult {
    @Field(() => [OutputTriggerType_])
    Results: OutputTriggerType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(OutputTriggerType_)
export class OutputTriggerTypeResolver extends ResolverBase {
    @Query(() => RunOutputTriggerTypeViewResult)
    async RunOutputTriggerTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunOutputTriggerTypeViewResult)
    async RunOutputTriggerTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunOutputTriggerTypeViewResult)
    async RunOutputTriggerTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Trigger Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => OutputTriggerType_, { nullable: true })
    async OutputTriggerType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<OutputTriggerType_ | null> {
        this.CheckUserReadPermissions('Output Trigger Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputTriggerTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Output Trigger Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Output Trigger Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputTriggerTypeIDArray(@Root() outputtriggertype_: OutputTriggerType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputTriggerTypeID]='${outputtriggertype_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Output Format Types
//****************************************************************************
@ObjectType()
export class OutputFormatType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    DisplayFormat?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Report_])
    Reports_OutputFormatTypeIDArray: Report_[]; // Link to Reports
    
}
//****************************************************************************
// RESOLVER for Output Format Types
//****************************************************************************
@ObjectType()
export class RunOutputFormatTypeViewResult {
    @Field(() => [OutputFormatType_])
    Results: OutputFormatType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(OutputFormatType_)
export class OutputFormatTypeResolver extends ResolverBase {
    @Query(() => RunOutputFormatTypeViewResult)
    async RunOutputFormatTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunOutputFormatTypeViewResult)
    async RunOutputFormatTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunOutputFormatTypeViewResult)
    async RunOutputFormatTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Format Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => OutputFormatType_, { nullable: true })
    async OutputFormatType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<OutputFormatType_ | null> {
        this.CheckUserReadPermissions('Output Format Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputFormatTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Output Format Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Output Format Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputFormatTypeIDArray(@Root() outputformattype_: OutputFormatType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputFormatTypeID]='${outputformattype_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Output Delivery Types
//****************************************************************************
@ObjectType()
export class OutputDeliveryType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [Report_])
    Reports_OutputDeliveryTypeIDArray: Report_[]; // Link to Reports
    
}
//****************************************************************************
// RESOLVER for Output Delivery Types
//****************************************************************************
@ObjectType()
export class RunOutputDeliveryTypeViewResult {
    @Field(() => [OutputDeliveryType_])
    Results: OutputDeliveryType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(OutputDeliveryType_)
export class OutputDeliveryTypeResolver extends ResolverBase {
    @Query(() => RunOutputDeliveryTypeViewResult)
    async RunOutputDeliveryTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunOutputDeliveryTypeViewResult)
    async RunOutputDeliveryTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunOutputDeliveryTypeViewResult)
    async RunOutputDeliveryTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Output Delivery Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => OutputDeliveryType_, { nullable: true })
    async OutputDeliveryType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<OutputDeliveryType_ | null> {
        this.CheckUserReadPermissions('Output Delivery Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwOutputDeliveryTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Output Delivery Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Output Delivery Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_OutputDeliveryTypeIDArray(@Root() outputdeliverytype_: OutputDeliveryType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [OutputDeliveryTypeID]='${outputdeliverytype_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Reports
//****************************************************************************
@ObjectType()
export class Report_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(40)
    SharingScope: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ConversationDetailID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field({nullable: true}) 
    Configuration?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputTriggerTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputFormatTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputDeliveryTypeID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    OutputFrequency?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputTargetEmail?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    OutputWorkflowID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputTriggerType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputFormatType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    OutputDeliveryType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    OutputWorkflow?: string;
        
    @Field(() => [ReportSnapshot_])
    ReportSnapshots_ReportIDArray: ReportSnapshot_[]; // Link to ReportSnapshots
    
    @Field(() => [ReportVersion_])
    MJ_ReportVersions_ReportIDArray: ReportVersion_[]; // Link to MJ_ReportVersions
    
    @Field(() => [ReportUserState_])
    MJ_ReportUserStates_ReportIDArray: ReportUserState_[]; // Link to MJ_ReportUserStates
    
}

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class CreateReportInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID: string | null;

    @Field({ nullable: true })
    ConversationDetailID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID: string | null;

    @Field({ nullable: true })
    OutputFrequency: string | null;

    @Field({ nullable: true })
    OutputTargetEmail: string | null;

    @Field({ nullable: true })
    OutputWorkflowID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Reports
//****************************************************************************
@InputType()
export class UpdateReportInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    ConversationID?: string | null;

    @Field({ nullable: true })
    ConversationDetailID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field({ nullable: true })
    OutputTriggerTypeID?: string | null;

    @Field({ nullable: true })
    OutputFormatTypeID?: string | null;

    @Field({ nullable: true })
    OutputDeliveryTypeID?: string | null;

    @Field({ nullable: true })
    OutputFrequency?: string | null;

    @Field({ nullable: true })
    OutputTargetEmail?: string | null;

    @Field({ nullable: true })
    OutputWorkflowID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Reports
//****************************************************************************
@ObjectType()
export class RunReportViewResult {
    @Field(() => [Report_])
    Results: Report_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Report_)
export class ReportResolver extends ResolverBase {
    @Query(() => RunReportViewResult)
    async RunReportViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportViewResult)
    async RunReportViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportViewResult)
    async RunReportDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Reports';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Report_, { nullable: true })
    async Report(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Report_ | null> {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ReportSnapshot_])
    async ReportSnapshots_ReportIDArray(@Root() report_: Report_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ReportID]='${report_.ID}' ` + this.getRowLevelSecurityWhereClause('Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Report Snapshots', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ReportVersion_])
    async MJ_ReportVersions_ReportIDArray(@Root() report_: Report_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ReportID]='${report_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report Versions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ReportUserState_])
    async MJ_ReportUserStates_ReportIDArray(@Root() report_: Report_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ReportID]='${report_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Report User States', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Report_)
    async CreateReport(
        @Arg('input', () => CreateReportInput) input: CreateReportInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Reports', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Report_)
    async UpdateReport(
        @Arg('input', () => UpdateReportInput) input: UpdateReportInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Reports', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Report_)
    async DeleteReport(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Reports', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Snapshots
//****************************************************************************
@ObjectType()
export class ReportSnapshot_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field() 
    ResultSet: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class CreateReportSnapshotInput {
    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Snapshots
//****************************************************************************
@InputType()
export class UpdateReportSnapshotInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    ResultSet?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Snapshots
//****************************************************************************
@ObjectType()
export class RunReportSnapshotViewResult {
    @Field(() => [ReportSnapshot_])
    Results: ReportSnapshot_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportSnapshot_)
export class ReportSnapshotResolver extends ResolverBase {
    @Query(() => RunReportSnapshotViewResult)
    async RunReportSnapshotViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportSnapshotViewResult)
    async RunReportSnapshotViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportSnapshotViewResult)
    async RunReportSnapshotDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Snapshots';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ReportSnapshot_, { nullable: true })
    async ReportSnapshot(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportSnapshot_ | null> {
        this.CheckUserReadPermissions('Report Snapshots', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportSnapshots] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Report Snapshots', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Report Snapshots', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ReportSnapshot_)
    async CreateReportSnapshot(
        @Arg('input', () => CreateReportSnapshotInput) input: CreateReportSnapshotInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Report Snapshots', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ReportSnapshot_)
    async UpdateReportSnapshot(
        @Arg('input', () => UpdateReportSnapshotInput) input: UpdateReportSnapshotInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Report Snapshots', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ReportSnapshot_)
    async DeleteReportSnapshot(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Snapshots', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Types
//****************************************************************************
@ObjectType()
export class ResourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Icon?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Nullable foreign key to the ID column in Entities entity, representing the category entity. ASSUMPTION: If provided, the assumption is there is a self-referencing/recursive foreign key establishing a hierarchy within the Category Entity, commonly called ParentID, but it can be named anything.`}) 
    @MaxLength(16)
    CategoryEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    CategoryEntity?: string;
        
    @Field(() => [WorkspaceItem_])
    WorkspaceItems_ResourceTypeIDArray: WorkspaceItem_[]; // Link to WorkspaceItems
    
    @Field(() => [UserNotification_])
    UserNotifications_ResourceTypeIDArray: UserNotification_[]; // Link to UserNotifications
    
    @Field(() => [ResourceLink_])
    ResourceLinks_ResourceTypeIDArray: ResourceLink_[]; // Link to ResourceLinks
    
    @Field(() => [ResourcePermission_])
    ResourcePermissions_ResourceTypeIDArray: ResourcePermission_[]; // Link to ResourcePermissions
    
}
//****************************************************************************
// RESOLVER for Resource Types
//****************************************************************************
@ObjectType()
export class RunResourceTypeViewResult {
    @Field(() => [ResourceType_])
    Results: ResourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ResourceType_)
export class ResourceTypeResolver extends ResolverBase {
    @Query(() => RunResourceTypeViewResult)
    async RunResourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunResourceTypeViewResult)
    async RunResourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunResourceTypeViewResult)
    async RunResourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ResourceType_, { nullable: true })
    async ResourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ResourceType_ | null> {
        this.CheckUserReadPermissions('Resource Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Resource Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Resource Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [WorkspaceItem_])
    async WorkspaceItems_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Workspace Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserNotification_])
    async UserNotifications_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause('User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Notifications', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ResourceLink_])
    async ResourceLinks_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Links', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ResourcePermission_])
    async ResourcePermissions_ResourceTypeIDArray(@Root() resourcetype_: ResourceType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ResourceTypeID]='${resourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Resource Permissions', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Tags
//****************************************************************************
@ObjectType({ description: `Tags are used to arbitrarily associate any record in any entity with addtional information.` })
export class Tag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(510)
    DisplayName: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [Tag_])
    Tags_ParentIDArray: Tag_[]; // Link to Tags
    
    @Field(() => [TaggedItem_])
    TaggedItems_TagIDArray: TaggedItem_[]; // Link to TaggedItems
    
}
//****************************************************************************
// RESOLVER for Tags
//****************************************************************************
@ObjectType()
export class RunTagViewResult {
    @Field(() => [Tag_])
    Results: Tag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Tag_)
export class TagResolver extends ResolverBase {
    @Query(() => RunTagViewResult)
    async RunTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTagViewResult)
    async RunTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTagViewResult)
    async RunTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tags';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Tag_, { nullable: true })
    async Tag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Tag_ | null> {
        this.CheckUserReadPermissions('Tags', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Tags', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Tags', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Tag_])
    async Tags_ParentIDArray(@Root() tag_: Tag_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tags', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTags] WHERE [ParentID]='${tag_.ID}' ` + this.getRowLevelSecurityWhereClause('Tags', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Tags', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [TaggedItem_])
    async TaggedItems_TagIDArray(@Root() tag_: Tag_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [TagID]='${tag_.ID}' ` + this.getRowLevelSecurityWhereClause('Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Tagged Items', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Tagged Items
//****************************************************************************
@ObjectType({ description: `Tracks the links between any record in any entity with Tags` })
export class TaggedItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TagID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Tag: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}
//****************************************************************************
// RESOLVER for Tagged Items
//****************************************************************************
@ObjectType()
export class RunTaggedItemViewResult {
    @Field(() => [TaggedItem_])
    Results: TaggedItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TaggedItem_)
export class TaggedItemResolver extends ResolverBase {
    @Query(() => RunTaggedItemViewResult)
    async RunTaggedItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTaggedItemViewResult)
    async RunTaggedItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTaggedItemViewResult)
    async RunTaggedItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Tagged Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => TaggedItem_, { nullable: true })
    async TaggedItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TaggedItem_ | null> {
        this.CheckUserReadPermissions('Tagged Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTaggedItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Tagged Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Tagged Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspaces
//****************************************************************************
@ObjectType({ description: `A user can have one or more workspaces` })
export class Workspace_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [WorkspaceItem_])
    WorkspaceItems_WorkSpaceIDArray: WorkspaceItem_[]; // Link to WorkspaceItems
    
}

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class CreateWorkspaceInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Workspaces
//****************************************************************************
@InputType()
export class UpdateWorkspaceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspaces
//****************************************************************************
@ObjectType()
export class RunWorkspaceViewResult {
    @Field(() => [Workspace_])
    Results: Workspace_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Workspace_)
export class WorkspaceResolver extends ResolverBase {
    @Query(() => RunWorkspaceViewResult)
    async RunWorkspaceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceViewResult)
    async RunWorkspaceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceViewResult)
    async RunWorkspaceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspaces';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Workspace_, { nullable: true })
    async Workspace(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Workspace_ | null> {
        this.CheckUserReadPermissions('Workspaces', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaces] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Workspaces', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Workspaces', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [WorkspaceItem_])
    async WorkspaceItems_WorkSpaceIDArray(@Root() workspace_: Workspace_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [WorkSpaceID]='${workspace_.ID}' ` + this.getRowLevelSecurityWhereClause('Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Workspace Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Workspace_)
    async CreateWorkspace(
        @Arg('input', () => CreateWorkspaceInput) input: CreateWorkspaceInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Workspaces', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Workspace_)
    async UpdateWorkspace(
        @Arg('input', () => UpdateWorkspaceInput) input: UpdateWorkspaceInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Workspaces', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Workspace_)
    async DeleteWorkspace(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspaces', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Workspace Items
//****************************************************************************
@ObjectType({ description: `Tracks the resources that are active within a given worksapce` })
export class WorkspaceItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    WorkspaceID: string;
        
    @Field() 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(4000)
    ResourceRecordID?: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field({nullable: true}) 
    Configuration?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Workspace: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class CreateWorkspaceItemInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Workspace Items
//****************************************************************************
@InputType()
export class UpdateWorkspaceItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    WorkspaceID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Workspace Items
//****************************************************************************
@ObjectType()
export class RunWorkspaceItemViewResult {
    @Field(() => [WorkspaceItem_])
    Results: WorkspaceItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(WorkspaceItem_)
export class WorkspaceItemResolver extends ResolverBase {
    @Query(() => RunWorkspaceItemViewResult)
    async RunWorkspaceItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceItemViewResult)
    async RunWorkspaceItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunWorkspaceItemViewResult)
    async RunWorkspaceItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Workspace Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => WorkspaceItem_, { nullable: true })
    async WorkspaceItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<WorkspaceItem_ | null> {
        this.CheckUserReadPermissions('Workspace Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwWorkspaceItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Workspace Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Workspace Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => WorkspaceItem_)
    async CreateWorkspaceItem(
        @Arg('input', () => CreateWorkspaceItemInput) input: CreateWorkspaceItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Workspace Items', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => WorkspaceItem_)
    async UpdateWorkspaceItem(
        @Arg('input', () => UpdateWorkspaceItemInput) input: UpdateWorkspaceItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Workspace Items', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => WorkspaceItem_)
    async DeleteWorkspaceItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Workspace Items', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Datasets
//****************************************************************************
@ObjectType({ description: `Cacheable sets of data that can span one or more items` })
export class Dataset_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [DatasetItem_])
    DatasetItems_DatasetNameArray: DatasetItem_[]; // Link to DatasetItems
    
}
//****************************************************************************
// RESOLVER for Datasets
//****************************************************************************
@ObjectType()
export class RunDatasetViewResult {
    @Field(() => [Dataset_])
    Results: Dataset_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Dataset_)
export class DatasetResolver extends ResolverBase {
    @Query(() => RunDatasetViewResult)
    async RunDatasetViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDatasetViewResult)
    async RunDatasetViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDatasetViewResult)
    async RunDatasetDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Datasets';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Dataset_, { nullable: true })
    async Dataset(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Dataset_ | null> {
        this.CheckUserReadPermissions('Datasets', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasets] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Datasets', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Datasets', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [DatasetItem_])
    async DatasetItems_DatasetNameArray(@Root() dataset_: Dataset_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [DatasetName]='${dataset_.ID}' ` + this.getRowLevelSecurityWhereClause('Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Dataset Items', await dataSource.query(sSQL));
        return result;
    }
        
}

//****************************************************************************
// ENTITY CLASS for Dataset Items
//****************************************************************************
@ObjectType({ description: `A single item in a Dataset and can be sourced from multiple methods.` })
export class DatasetItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Code: string;
        
    @Field() 
    @MaxLength(16)
    DatasetID: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field({nullable: true}) 
    WhereClause?: string;
        
    @Field() 
    @MaxLength(200)
    DateFieldToCheck: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `Optional column to store a comma-delimited list of columns for the DatasetItem`}) 
    Columns?: string;
        
    @Field() 
    @MaxLength(200)
    Dataset: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}
//****************************************************************************
// RESOLVER for Dataset Items
//****************************************************************************
@ObjectType()
export class RunDatasetItemViewResult {
    @Field(() => [DatasetItem_])
    Results: DatasetItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DatasetItem_)
export class DatasetItemResolver extends ResolverBase {
    @Query(() => RunDatasetItemViewResult)
    async RunDatasetItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDatasetItemViewResult)
    async RunDatasetItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDatasetItemViewResult)
    async RunDatasetItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dataset Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DatasetItem_, { nullable: true })
    async DatasetItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DatasetItem_ | null> {
        this.CheckUserReadPermissions('Dataset Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDatasetItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Dataset Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Dataset Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversation Details
//****************************************************************************
@ObjectType()
export class ConversationDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ExternalID?: string;
        
    @Field() 
    @MaxLength(40)
    Role: string;
        
    @Field() 
    Message: string;
        
    @Field({nullable: true}) 
    Error?: string;
        
    @Field(() => Boolean) 
    HiddenToUser: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Int, {nullable: true, description: `This column is used to capture user feedback as a rating scale. The scale ranges from 1 to 10, where 1 might represent thumbs down, and 10 might represent thumbs up or the highest rating in a star-based scale.`}) 
    UserRating?: number;
        
    @Field({nullable: true, description: `This column is used to store user text feedback about a given AI response, describing what they liked or disliked.`}) 
    UserFeedback?: string;
        
    @Field({nullable: true, description: `This column stores human or AI-generated reflections on how to improve future responses based on the user feedback and the AI output generated for prior messages in the conversation.`}) 
    ReflectionInsights?: string;
        
    @Field({nullable: true, description: `This column optionally stores a summary of the entire conversation leading up to this particular conversation detail record. It is used in long-running conversations to optimize performance by summarizing earlier parts.`}) 
    SummaryOfEarlierConversation?: string;
        
    @Field({nullable: true, description: `This field, when populated, overrides the UserID at the Conversation level to specify a different user created the message.`}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
    @Field(() => [Report_])
    Reports_ConversationDetailIDArray: Report_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class CreateConversationDetailInput {
    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating: number | null;

    @Field({ nullable: true })
    UserFeedback: string | null;

    @Field({ nullable: true })
    ReflectionInsights: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation: string | null;

    @Field({ nullable: true })
    UserID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Conversation Details
//****************************************************************************
@InputType()
export class UpdateConversationDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Role?: string;

    @Field({ nullable: true })
    Message?: string;

    @Field({ nullable: true })
    Error?: string | null;

    @Field(() => Boolean, { nullable: true })
    HiddenToUser?: boolean;

    @Field(() => Int, { nullable: true })
    UserRating?: number | null;

    @Field({ nullable: true })
    UserFeedback?: string | null;

    @Field({ nullable: true })
    ReflectionInsights?: string | null;

    @Field({ nullable: true })
    SummaryOfEarlierConversation?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversation Details
//****************************************************************************
@ObjectType()
export class RunConversationDetailViewResult {
    @Field(() => [ConversationDetail_])
    Results: ConversationDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationDetail_)
export class ConversationDetailResolver extends ResolverBase {
    @Query(() => RunConversationDetailViewResult)
    async RunConversationDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationDetailViewResult)
    async RunConversationDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationDetailViewResult)
    async RunConversationDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversation Details';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ConversationDetail_, { nullable: true })
    async ConversationDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationDetail_ | null> {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Conversation Details', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_ConversationDetailIDArray(@Root() conversationdetail_: ConversationDetail_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationDetailID]='${conversationdetail_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ConversationDetail_)
    async CreateConversationDetail(
        @Arg('input', () => CreateConversationDetailInput) input: CreateConversationDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Conversation Details', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationDetail_)
    async UpdateConversationDetail(
        @Arg('input', () => UpdateConversationDetailInput) input: UpdateConversationDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Conversation Details', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationDetail_)
    async DeleteConversationDetail(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversation Details', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Conversations
//****************************************************************************
@ObjectType()
export class Conversation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    ExternalID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(100)
    Type: string;
        
    @Field(() => Boolean) 
    IsArchived: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    LinkedRecordID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    DataContextID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DataContext?: string;
        
    @Field(() => [ConversationDetail_])
    ConversationDetails_ConversationIDArray: ConversationDetail_[]; // Link to ConversationDetails
    
    @Field(() => [Report_])
    Reports_ConversationIDArray: Report_[]; // Link to Reports
    
    @Field(() => [ConversationArtifact_])
    MJ_ConversationArtifacts_ConversationIDArray: ConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
}

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class CreateConversationInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID: string | null;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordID: string | null;

    @Field({ nullable: true })
    DataContextID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Conversations
//****************************************************************************
@InputType()
export class UpdateConversationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ExternalID?: string | null;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    IsArchived?: boolean;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordID?: string | null;

    @Field({ nullable: true })
    DataContextID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Conversations
//****************************************************************************
@ObjectType()
export class RunConversationViewResult {
    @Field(() => [Conversation_])
    Results: Conversation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Conversation_)
export class ConversationResolver extends ResolverBase {
    @Query(() => RunConversationViewResult)
    async RunConversationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationViewResult)
    async RunConversationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationViewResult)
    async RunConversationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Conversations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Conversation_, { nullable: true })
    async Conversation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Conversation_ | null> {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Conversations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ConversationDetail_])
    async ConversationDetails_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversation Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationDetails] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause('Conversation Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Conversation Details', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ConversationArtifact_])
    async MJ_ConversationArtifacts_ConversationIDArray(@Root() conversation_: Conversation_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ConversationID]='${conversation_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Conversation_)
    async CreateConversation(
        @Arg('input', () => CreateConversationInput) input: CreateConversationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Conversations', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Conversation_)
    async UpdateConversation(
        @Arg('input', () => UpdateConversationInput) input: UpdateConversationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Conversations', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Conversation_)
    async DeleteConversation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Conversations', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User Notifications
//****************************************************************************
@ObjectType()
export class UserNotification_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Title?: string;
        
    @Field({nullable: true}) 
    Message?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ResourceTypeID?: string;
        
    @Field({nullable: true}) 
    ResourceConfiguration?: string;
        
    @Field(() => Boolean) 
    Unread: boolean;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    ReadAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ResourceRecordID?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResourceType?: string;
        
}

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class CreateUserNotificationInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title: string | null;

    @Field({ nullable: true })
    Message: string | null;

    @Field({ nullable: true })
    ResourceTypeID: string | null;

    @Field({ nullable: true })
    ResourceConfiguration: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt: Date | null;

    @Field({ nullable: true })
    ResourceRecordID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for User Notifications
//****************************************************************************
@InputType()
export class UpdateUserNotificationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Title?: string | null;

    @Field({ nullable: true })
    Message?: string | null;

    @Field({ nullable: true })
    ResourceTypeID?: string | null;

    @Field({ nullable: true })
    ResourceConfiguration?: string | null;

    @Field(() => Boolean, { nullable: true })
    Unread?: boolean;

    @Field({ nullable: true })
    ReadAt?: Date | null;

    @Field({ nullable: true })
    ResourceRecordID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User Notifications
//****************************************************************************
@ObjectType()
export class RunUserNotificationViewResult {
    @Field(() => [UserNotification_])
    Results: UserNotification_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserNotification_)
export class UserNotificationResolver extends ResolverBase {
    @Query(() => RunUserNotificationViewResult)
    async RunUserNotificationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserNotificationViewResult)
    async RunUserNotificationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserNotificationViewResult)
    async RunUserNotificationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User Notifications';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserNotification_, { nullable: true })
    async UserNotification(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserNotification_ | null> {
        this.CheckUserReadPermissions('User Notifications', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserNotifications] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User Notifications', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User Notifications', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => UserNotification_)
    async CreateUserNotification(
        @Arg('input', () => CreateUserNotificationInput) input: CreateUserNotificationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User Notifications', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserNotification_)
    async UpdateUserNotification(
        @Arg('input', () => UpdateUserNotificationInput) input: UpdateUserNotificationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User Notifications', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => UserNotification_)
    async DeleteUserNotification(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User Notifications', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Schema Info
//****************************************************************************
@ObjectType({ description: `Tracks the schemas in the system and the ID ranges that are valid for entities within each schema.` })
export class SchemaInfo_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    SchemaName: string;
        
    @Field(() => Int) 
    EntityIDMin: number;
        
    @Field(() => Int) 
    EntityIDMax: number;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class CreateSchemaInfoInput {
    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Schema Info
//****************************************************************************
@InputType()
export class UpdateSchemaInfoInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SchemaName?: string;

    @Field(() => Int, { nullable: true })
    EntityIDMin?: number;

    @Field(() => Int, { nullable: true })
    EntityIDMax?: number;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Schema Info
//****************************************************************************
@ObjectType()
export class RunSchemaInfoViewResult {
    @Field(() => [SchemaInfo_])
    Results: SchemaInfo_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(SchemaInfo_)
export class SchemaInfoResolver extends ResolverBase {
    @Query(() => RunSchemaInfoViewResult)
    async RunSchemaInfoViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunSchemaInfoViewResult)
    async RunSchemaInfoViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunSchemaInfoViewResult)
    async RunSchemaInfoDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Schema Info';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => SchemaInfo_, { nullable: true })
    async SchemaInfo(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<SchemaInfo_ | null> {
        this.CheckUserReadPermissions('Schema Info', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwSchemaInfos] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Schema Info', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Schema Info', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => SchemaInfo_)
    async CreateSchemaInfo(
        @Arg('input', () => CreateSchemaInfoInput) input: CreateSchemaInfoInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Schema Info', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => SchemaInfo_)
    async UpdateSchemaInfo(
        @Arg('input', () => UpdateSchemaInfoInput) input: UpdateSchemaInfoInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Schema Info', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class CompanyIntegrationRecordMap_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CompanyIntegrationID: string;
        
    @Field() 
    @MaxLength(1500)
    ExternalSystemRecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(1500)
    EntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class CreateCompanyIntegrationRecordMapInput {
    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Company Integration Record Maps
//****************************************************************************
@InputType()
export class UpdateCompanyIntegrationRecordMapInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CompanyIntegrationID?: string;

    @Field({ nullable: true })
    ExternalSystemRecordID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    EntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Company Integration Record Maps
//****************************************************************************
@ObjectType()
export class RunCompanyIntegrationRecordMapViewResult {
    @Field(() => [CompanyIntegrationRecordMap_])
    Results: CompanyIntegrationRecordMap_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CompanyIntegrationRecordMap_)
export class CompanyIntegrationRecordMapResolver extends ResolverBase {
    @Query(() => RunCompanyIntegrationRecordMapViewResult)
    async RunCompanyIntegrationRecordMapViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRecordMapViewResult)
    async RunCompanyIntegrationRecordMapViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCompanyIntegrationRecordMapViewResult)
    async RunCompanyIntegrationRecordMapDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Company Integration Record Maps';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CompanyIntegrationRecordMap_, { nullable: true })
    async CompanyIntegrationRecordMap(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CompanyIntegrationRecordMap_ | null> {
        this.CheckUserReadPermissions('Company Integration Record Maps', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCompanyIntegrationRecordMaps] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Company Integration Record Maps', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Company Integration Record Maps', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => CompanyIntegrationRecordMap_)
    async CreateCompanyIntegrationRecordMap(
        @Arg('input', () => CreateCompanyIntegrationRecordMapInput) input: CreateCompanyIntegrationRecordMapInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Company Integration Record Maps', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CompanyIntegrationRecordMap_)
    async UpdateCompanyIntegrationRecordMap(
        @Arg('input', () => UpdateCompanyIntegrationRecordMapInput) input: UpdateCompanyIntegrationRecordMapInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Company Integration Record Maps', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Logs
//****************************************************************************
@ObjectType()
export class RecordMergeLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    SurvivingRecordID: string;
        
    @Field() 
    @MaxLength(16)
    InitiatedByUserID: string;
        
    @Field() 
    @MaxLength(20)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field() 
    @MaxLength(20)
    ProcessingStatus: string;
        
    @Field() 
    @MaxLength(8)
    ProcessingStartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    ProcessingEndedAt?: Date;
        
    @Field({nullable: true}) 
    ProcessingLog?: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    InitiatedByUser: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [RecordMergeDeletionLog_])
    RecordMergeDeletionLogs_RecordMergeLogIDArray: RecordMergeDeletionLog_[]; // Link to RecordMergeDeletionLogs
    
    @Field(() => [DuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_RecordMergeLogIDArray: DuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class CreateRecordMergeLogInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt: Date | null;

    @Field({ nullable: true })
    ProcessingLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Logs
//****************************************************************************
@InputType()
export class UpdateRecordMergeLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    SurvivingRecordID?: string;

    @Field({ nullable: true })
    InitiatedByUserID?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingStartedAt?: Date;

    @Field({ nullable: true })
    ProcessingEndedAt?: Date | null;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Logs
//****************************************************************************
@ObjectType()
export class RunRecordMergeLogViewResult {
    @Field(() => [RecordMergeLog_])
    Results: RecordMergeLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordMergeLog_)
export class RecordMergeLogResolver extends ResolverBase {
    @Query(() => RunRecordMergeLogViewResult)
    async RunRecordMergeLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeLogViewResult)
    async RunRecordMergeLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeLogViewResult)
    async RunRecordMergeLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecordMergeLog_, { nullable: true })
    async RecordMergeLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordMergeLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Record Merge Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Record Merge Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [RecordMergeDeletionLog_])
    async RecordMergeDeletionLogs_RecordMergeLogIDArray(@Root() recordmergelog_: RecordMergeLog_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [RecordMergeLogID]='${recordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Merge Deletion Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_RecordMergeLogIDArray(@Root() recordmergelog_: RecordMergeLog_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [RecordMergeLogID]='${recordmergelog_.ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => RecordMergeLog_)
    async CreateRecordMergeLog(
        @Arg('input', () => CreateRecordMergeLogInput) input: CreateRecordMergeLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Record Merge Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecordMergeLog_)
    async UpdateRecordMergeLog(
        @Arg('input', () => UpdateRecordMergeLogInput) input: UpdateRecordMergeLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Record Merge Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class RecordMergeDeletionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecordMergeLogID: string;
        
    @Field() 
    @MaxLength(1500)
    DeletedRecordID: string;
        
    @Field() 
    @MaxLength(20)
    Status: string;
        
    @Field({nullable: true}) 
    ProcessingLog?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class CreateRecordMergeDeletionLogInput {
    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Record Merge Deletion Logs
//****************************************************************************
@InputType()
export class UpdateRecordMergeDeletionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string;

    @Field({ nullable: true })
    DeletedRecordID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    ProcessingLog?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Merge Deletion Logs
//****************************************************************************
@ObjectType()
export class RunRecordMergeDeletionLogViewResult {
    @Field(() => [RecordMergeDeletionLog_])
    Results: RecordMergeDeletionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordMergeDeletionLog_)
export class RecordMergeDeletionLogResolver extends ResolverBase {
    @Query(() => RunRecordMergeDeletionLogViewResult)
    async RunRecordMergeDeletionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeDeletionLogViewResult)
    async RunRecordMergeDeletionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordMergeDeletionLogViewResult)
    async RunRecordMergeDeletionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Merge Deletion Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecordMergeDeletionLog_, { nullable: true })
    async RecordMergeDeletionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordMergeDeletionLog_ | null> {
        this.CheckUserReadPermissions('Record Merge Deletion Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordMergeDeletionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Record Merge Deletion Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Record Merge Deletion Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => RecordMergeDeletionLog_)
    async CreateRecordMergeDeletionLog(
        @Arg('input', () => CreateRecordMergeDeletionLogInput) input: CreateRecordMergeDeletionLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Record Merge Deletion Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecordMergeDeletionLog_)
    async UpdateRecordMergeDeletionLog(
        @Arg('input', () => UpdateRecordMergeDeletionLogInput) input: UpdateRecordMergeDeletionLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Record Merge Deletion Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Fields
//****************************************************************************
@ObjectType()
export class QueryField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Int) 
    Sequence: number;
        
    @Field({description: `The base type, not including parameters, in SQL. For example this field would be nvarchar or decimal, and wouldn't include type parameters. The SQLFullType field provides that information.`}) 
    @MaxLength(100)
    SQLBaseType: string;
        
    @Field({description: `The full SQL type for the field, for example datetime or nvarchar(10) etc.`}) 
    @MaxLength(200)
    SQLFullType: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    SourceEntityID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceFieldName?: string;
        
    @Field(() => Boolean) 
    IsComputed: boolean;
        
    @Field({nullable: true}) 
    ComputationDescription?: string;
        
    @Field(() => Boolean) 
    IsSummary: boolean;
        
    @Field({nullable: true}) 
    SummaryDescription?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    SourceEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class CreateQueryFieldInput {
    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID: string | null;

    @Field({ nullable: true })
    SourceFieldName: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Query Fields
//****************************************************************************
@InputType()
export class UpdateQueryFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    SQLBaseType?: string;

    @Field({ nullable: true })
    SQLFullType?: string;

    @Field({ nullable: true })
    SourceEntityID?: string | null;

    @Field({ nullable: true })
    SourceFieldName?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsComputed?: boolean;

    @Field({ nullable: true })
    ComputationDescription?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsSummary?: boolean;

    @Field({ nullable: true })
    SummaryDescription?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Fields
//****************************************************************************
@ObjectType()
export class RunQueryFieldViewResult {
    @Field(() => [QueryField_])
    Results: QueryField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryField_)
export class QueryFieldResolver extends ResolverBase {
    @Query(() => RunQueryFieldViewResult)
    async RunQueryFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryFieldViewResult)
    async RunQueryFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryFieldViewResult)
    async RunQueryFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Fields';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => QueryField_, { nullable: true })
    async QueryField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryField_ | null> {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Query Fields', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => QueryField_)
    async CreateQueryField(
        @Arg('input', () => CreateQueryFieldInput) input: CreateQueryFieldInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Query Fields', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => QueryField_)
    async UpdateQueryField(
        @Arg('input', () => UpdateQueryFieldInput) input: UpdateQueryFieldInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Query Fields', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => QueryField_)
    async DeleteQueryField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Fields', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Categories
//****************************************************************************
@ObjectType()
export class QueryCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [QueryCategory_])
    QueryCategories_ParentIDArray: QueryCategory_[]; // Link to QueryCategories
    
    @Field(() => [Query_])
    Queries_CategoryIDArray: Query_[]; // Link to Queries
    
}

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class CreateQueryCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Categories
//****************************************************************************
@InputType()
export class UpdateQueryCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Categories
//****************************************************************************
@ObjectType()
export class RunQueryCategoryViewResult {
    @Field(() => [QueryCategory_])
    Results: QueryCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryCategory_)
export class QueryCategoryResolver extends ResolverBase {
    @Query(() => RunQueryCategoryViewResult)
    async RunQueryCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryCategoryViewResult)
    async RunQueryCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryCategoryViewResult)
    async RunQueryCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => QueryCategory_, { nullable: true })
    async QueryCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryCategory_ | null> {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Query Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [QueryCategory_])
    async QueryCategories_ParentIDArray(@Root() querycategory_: QueryCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryCategories] WHERE [ParentID]='${querycategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Query_])
    async Queries_CategoryIDArray(@Root() querycategory_: QueryCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Queries', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [CategoryID]='${querycategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Queries', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Queries', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => QueryCategory_)
    async CreateQueryCategory(
        @Arg('input', () => CreateQueryCategoryInput) input: CreateQueryCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Query Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => QueryCategory_)
    async UpdateQueryCategory(
        @Arg('input', () => UpdateQueryCategoryInput) input: UpdateQueryCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Query Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => QueryCategory_)
    async DeleteQueryCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Queries
//****************************************************************************
@ObjectType({ description: `Catalog of stored queries. This is useful for any arbitrary query that is known to be performant and correct and can be reused. Queries can be viewed/run by a user, used programatically via RunQuery, and also used by AI systems for improved reliability instead of dynamically generated SQL. Queries can also improve security since they store the SQL instead of using dynamic SQL.` })
export class Query_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true}) 
    UserQuestion?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    SQL?: string;
        
    @Field({nullable: true}) 
    TechnicalDescription?: string;
        
    @Field({nullable: true}) 
    OriginalSQL?: string;
        
    @Field({nullable: true}) 
    Feedback?: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field(() => Int, {nullable: true, description: `Value indicating the quality of the query, higher values mean a better quality`}) 
    QualityRank?: number;
        
    @Field(() => Int, {nullable: true, description: `Higher numbers indicate more execution overhead/time required. Useful for planning which queries to use in various scenarios.`}) 
    ExecutionCostRank?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Category?: string;
        
    @Field(() => [QueryField_])
    QueryFields_QueryIDArray: QueryField_[]; // Link to QueryFields
    
    @Field(() => [DataContextItem_])
    DataContextItems_QueryIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [QueryPermission_])
    QueryPermissions_QueryIDArray: QueryPermission_[]; // Link to QueryPermissions
    
    @Field(() => [QueryEntity_])
    QueryEntities_QueryIDArray: QueryEntity_[]; // Link to QueryEntities
    
}

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class CreateQueryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserQuestion: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    TechnicalDescription: string | null;

    @Field({ nullable: true })
    OriginalSQL: string | null;

    @Field({ nullable: true })
    Feedback: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Queries
//****************************************************************************
@InputType()
export class UpdateQueryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserQuestion?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    TechnicalDescription?: string | null;

    @Field({ nullable: true })
    OriginalSQL?: string | null;

    @Field({ nullable: true })
    Feedback?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Int, { nullable: true })
    QualityRank?: number | null;

    @Field(() => Int, { nullable: true })
    ExecutionCostRank?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Queries
//****************************************************************************
@ObjectType()
export class RunQueryViewResult {
    @Field(() => [Query_])
    Results: Query_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Query_)
export class QueryResolver extends ResolverBase {
    @Query(() => RunQueryViewResult)
    async RunQueryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryViewResult)
    async RunQueryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryViewResult)
    async RunQueryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Queries';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Query_, { nullable: true })
    async Query(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Query_ | null> {
        this.CheckUserReadPermissions('Queries', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Queries', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Queries', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [QueryField_])
    async QueryFields_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryFields] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Fields', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause('Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [QueryPermission_])
    async QueryPermissions_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [QueryEntity_])
    async QueryEntities_QueryIDArray(@Root() query_: Query_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [QueryID]='${query_.ID}' ` + this.getRowLevelSecurityWhereClause('Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Query Entities', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Query_)
    async CreateQuery(
        @Arg('input', () => CreateQueryInput) input: CreateQueryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Queries', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Query_)
    async UpdateQuery(
        @Arg('input', () => UpdateQueryInput) input: UpdateQueryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Queries', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Query_)
    async DeleteQuery(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Queries', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Permissions
//****************************************************************************
@ObjectType()
export class QueryPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    QueryID: string;
        
    @Field() 
    @MaxLength(16)
    RoleID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(100)
    Role: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class CreateQueryPermissionInput {
    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Permissions
//****************************************************************************
@InputType()
export class UpdateQueryPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    RoleID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Permissions
//****************************************************************************
@ObjectType()
export class RunQueryPermissionViewResult {
    @Field(() => [QueryPermission_])
    Results: QueryPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryPermission_)
export class QueryPermissionResolver extends ResolverBase {
    @Query(() => RunQueryPermissionViewResult)
    async RunQueryPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryPermissionViewResult)
    async RunQueryPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryPermissionViewResult)
    async RunQueryPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Permissions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => QueryPermission_, { nullable: true })
    async QueryPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryPermission_ | null> {
        this.CheckUserReadPermissions('Query Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Query Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Query Permissions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => QueryPermission_)
    async CreateQueryPermission(
        @Arg('input', () => CreateQueryPermissionInput) input: CreateQueryPermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Query Permissions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => QueryPermission_)
    async UpdateQueryPermission(
        @Arg('input', () => UpdateQueryPermissionInput) input: UpdateQueryPermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Query Permissions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => QueryPermission_)
    async DeleteQueryPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Permissions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Indexes
//****************************************************************************
@ObjectType()
export class VectorIndex_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(16)
    EmbeddingModelID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(100)
    EmbeddingModel: string;
        
    @Field(() => [EntityRecordDocument_])
    EntityRecordDocuments_VectorIndexIDArray: EntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class CreateVectorIndexInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Vector Indexes
//****************************************************************************
@InputType()
export class UpdateVectorIndexInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    EmbeddingModelID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Indexes
//****************************************************************************
@ObjectType()
export class RunVectorIndexViewResult {
    @Field(() => [VectorIndex_])
    Results: VectorIndex_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(VectorIndex_)
export class VectorIndexResolver extends ResolverBase {
    @Query(() => RunVectorIndexViewResult)
    async RunVectorIndexViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunVectorIndexViewResult)
    async RunVectorIndexViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunVectorIndexViewResult)
    async RunVectorIndexDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Indexes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => VectorIndex_, { nullable: true })
    async VectorIndex(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<VectorIndex_ | null> {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Vector Indexes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityRecordDocument_])
    async EntityRecordDocuments_VectorIndexIDArray(@Root() vectorindex_: VectorIndex_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [VectorIndexID]='${vectorindex_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => VectorIndex_)
    async CreateVectorIndex(
        @Arg('input', () => CreateVectorIndexInput) input: CreateVectorIndexInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Vector Indexes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => VectorIndex_)
    async UpdateVectorIndex(
        @Arg('input', () => UpdateVectorIndexInput) input: UpdateVectorIndexInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Vector Indexes', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => VectorIndex_)
    async DeleteVectorIndex(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Indexes', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Types
//****************************************************************************
@ObjectType()
export class EntityDocumentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityDocument_])
    EntityDocuments_TypeIDArray: EntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class CreateEntityDocumentTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Types
//****************************************************************************
@InputType()
export class UpdateEntityDocumentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Types
//****************************************************************************
@ObjectType()
export class RunEntityDocumentTypeViewResult {
    @Field(() => [EntityDocumentType_])
    Results: EntityDocumentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocumentType_)
export class EntityDocumentTypeResolver extends ResolverBase {
    @Query(() => RunEntityDocumentTypeViewResult)
    async RunEntityDocumentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentTypeViewResult)
    async RunEntityDocumentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentTypeViewResult)
    async RunEntityDocumentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityDocumentType_, { nullable: true })
    async EntityDocumentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocumentType_ | null> {
        this.CheckUserReadPermissions('Entity Document Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Document Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Document Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_TypeIDArray(@Root() entitydocumenttype_: EntityDocumentType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TypeID]='${entitydocumenttype_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityDocumentType_)
    async CreateEntityDocumentType(
        @Arg('input', () => CreateEntityDocumentTypeInput) input: CreateEntityDocumentTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Document Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocumentType_)
    async UpdateEntityDocumentType(
        @Arg('input', () => UpdateEntityDocumentTypeInput) input: UpdateEntityDocumentTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Document Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityDocumentType_)
    async DeleteEntityDocumentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Runs
//****************************************************************************
@ObjectType()
export class EntityDocumentRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Can be Pending, In Progress, Completed, or Failed`}) 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class CreateEntityDocumentRunInput {
    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Runs
//****************************************************************************
@InputType()
export class UpdateEntityDocumentRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Runs
//****************************************************************************
@ObjectType()
export class RunEntityDocumentRunViewResult {
    @Field(() => [EntityDocumentRun_])
    Results: EntityDocumentRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocumentRun_)
export class EntityDocumentRunResolver extends ResolverBase {
    @Query(() => RunEntityDocumentRunViewResult)
    async RunEntityDocumentRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentRunViewResult)
    async RunEntityDocumentRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentRunViewResult)
    async RunEntityDocumentRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityDocumentRun_, { nullable: true })
    async EntityDocumentRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocumentRun_ | null> {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Document Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityDocumentRun_)
    async CreateEntityDocumentRun(
        @Arg('input', () => CreateEntityDocumentRunInput) input: CreateEntityDocumentRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Document Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocumentRun_)
    async UpdateEntityDocumentRun(
        @Arg('input', () => UpdateEntityDocumentRunInput) input: UpdateEntityDocumentRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Document Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Vector Databases
//****************************************************************************
@ObjectType()
export class VectorDatabase_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    DefaultURL?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ClassKey?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityDocument_])
    EntityDocuments_IDArray: EntityDocument_[]; // Link to EntityDocuments
    
    @Field(() => [VectorIndex_])
    VectorIndexes_VectorDatabaseIDArray: VectorIndex_[]; // Link to VectorIndexes
    
}

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class CreateVectorDatabaseInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    DefaultURL: string | null;

    @Field({ nullable: true })
    ClassKey: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Vector Databases
//****************************************************************************
@InputType()
export class UpdateVectorDatabaseInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    DefaultURL?: string | null;

    @Field({ nullable: true })
    ClassKey?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Vector Databases
//****************************************************************************
@ObjectType()
export class RunVectorDatabaseViewResult {
    @Field(() => [VectorDatabase_])
    Results: VectorDatabase_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(VectorDatabase_)
export class VectorDatabaseResolver extends ResolverBase {
    @Query(() => RunVectorDatabaseViewResult)
    async RunVectorDatabaseViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunVectorDatabaseViewResult)
    async RunVectorDatabaseViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunVectorDatabaseViewResult)
    async RunVectorDatabaseDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Vector Databases';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => VectorDatabase_, { nullable: true })
    async VectorDatabase(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<VectorDatabase_ | null> {
        this.CheckUserReadPermissions('Vector Databases', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorDatabases] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Vector Databases', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Vector Databases', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_IDArray(@Root() vectordatabase_: VectorDatabase_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${vectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [VectorIndex_])
    async VectorIndexes_VectorDatabaseIDArray(@Root() vectordatabase_: VectorDatabase_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Vector Indexes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVectorIndexes] WHERE [VectorDatabaseID]='${vectordatabase_.ID}' ` + this.getRowLevelSecurityWhereClause('Vector Indexes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Vector Indexes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => VectorDatabase_)
    async CreateVectorDatabase(
        @Arg('input', () => CreateVectorDatabaseInput) input: CreateVectorDatabaseInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Vector Databases', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => VectorDatabase_)
    async UpdateVectorDatabase(
        @Arg('input', () => UpdateVectorDatabaseInput) input: UpdateVectorDatabaseInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Vector Databases', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => VectorDatabase_)
    async DeleteVectorDatabase(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Vector Databases', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Record Documents
//****************************************************************************
@ObjectType()
export class EntityRecordDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(900)
    RecordID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field({nullable: true}) 
    DocumentText?: string;
        
    @Field() 
    @MaxLength(16)
    VectorIndexID: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    VectorID?: string;
        
    @Field({nullable: true}) 
    VectorJSON?: string;
        
    @Field() 
    @MaxLength(8)
    EntityRecordUpdatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
    @Field() 
    @MaxLength(510)
    VectorIndex: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class CreateEntityRecordDocumentInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID: string | null;

    @Field({ nullable: true })
    VectorJSON: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Entity Record Documents
//****************************************************************************
@InputType()
export class UpdateEntityRecordDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    DocumentText?: string | null;

    @Field({ nullable: true })
    VectorIndexID?: string;

    @Field({ nullable: true })
    VectorID?: string | null;

    @Field({ nullable: true })
    VectorJSON?: string | null;

    @Field({ nullable: true })
    EntityRecordUpdatedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Record Documents
//****************************************************************************
@ObjectType()
export class RunEntityRecordDocumentViewResult {
    @Field(() => [EntityRecordDocument_])
    Results: EntityRecordDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityRecordDocument_)
export class EntityRecordDocumentResolver extends ResolverBase {
    @Query(() => RunEntityRecordDocumentViewResult)
    async RunEntityRecordDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityRecordDocumentViewResult)
    async RunEntityRecordDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityRecordDocumentViewResult)
    async RunEntityRecordDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Record Documents';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityRecordDocument_, { nullable: true })
    async EntityRecordDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityRecordDocument_ | null> {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Record Documents', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityRecordDocument_)
    async CreateEntityRecordDocument(
        @Arg('input', () => CreateEntityRecordDocumentInput) input: CreateEntityRecordDocumentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Record Documents', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityRecordDocument_)
    async UpdateEntityRecordDocument(
        @Arg('input', () => UpdateEntityRecordDocumentInput) input: UpdateEntityRecordDocumentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Record Documents', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Documents
//****************************************************************************
@ObjectType()
export class EntityDocument_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(500)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    VectorDatabaseID: string;
        
    @Field() 
    @MaxLength(30)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered a potential matching record. Value must be <= AbsoluteMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    PotentialMatchThreshold: number;
        
    @Field(() => Float, {description: `Value between 0 and 1 that determines what is considered an absolute matching record. Value must be >= PotentialMatchThreshold. This is primarily used for duplicate detection but can be used for other applications as well where matching is relevant.`}) 
    AbsoluteMatchThreshold: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    VectorDatabase: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [EntityDocumentSetting_])
    EntityDocumentSettings_EntityDocumentIDArray: EntityDocumentSetting_[]; // Link to EntityDocumentSettings
    
    @Field(() => [EntityDocumentRun_])
    EntityDocumentRuns_EntityDocumentIDArray: EntityDocumentRun_[]; // Link to EntityDocumentRuns
    
    @Field(() => [EntityRecordDocument_])
    EntityRecordDocuments_EntityDocumentIDArray: EntityRecordDocument_[]; // Link to EntityRecordDocuments
    
}

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class CreateEntityDocumentInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Documents
//****************************************************************************
@InputType()
export class UpdateEntityDocumentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    VectorDatabaseID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Float, { nullable: true })
    PotentialMatchThreshold?: number;

    @Field(() => Float, { nullable: true })
    AbsoluteMatchThreshold?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Documents
//****************************************************************************
@ObjectType()
export class RunEntityDocumentViewResult {
    @Field(() => [EntityDocument_])
    Results: EntityDocument_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocument_)
export class EntityDocumentResolver extends ResolverBase {
    @Query(() => RunEntityDocumentViewResult)
    async RunEntityDocumentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentViewResult)
    async RunEntityDocumentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentViewResult)
    async RunEntityDocumentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Documents';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityDocument_, { nullable: true })
    async EntityDocument(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocument_ | null> {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Documents', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityDocumentSetting_])
    async EntityDocumentSettings_EntityDocumentIDArray(@Root() entitydocument_: EntityDocument_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [EntityDocumentID]='${entitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Document Settings', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityDocumentRun_])
    async EntityDocumentRuns_EntityDocumentIDArray(@Root() entitydocument_: EntityDocument_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Document Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentRuns] WHERE [EntityDocumentID]='${entitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Document Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Document Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityRecordDocument_])
    async EntityRecordDocuments_EntityDocumentIDArray(@Root() entitydocument_: EntityDocument_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Record Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRecordDocuments] WHERE [EntityDocumentID]='${entitydocument_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Record Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Record Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityDocument_)
    async CreateEntityDocument(
        @Arg('input', () => CreateEntityDocumentInput) input: CreateEntityDocumentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Documents', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocument_)
    async UpdateEntityDocument(
        @Arg('input', () => UpdateEntityDocumentInput) input: UpdateEntityDocumentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Documents', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Context Items
//****************************************************************************
@ObjectType({ description: `Data Context Items store information about each item within a Data Context. Each item stores a link to a view, query, or raw sql statement and can optionally cache the JSON representing the last run of that data object as well.` })
export class DataContextItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DataContextID: string;
        
    @Field({description: `The type of the item, either "view", "query", "full_entity", "single_record", or "sql"`}) 
    @MaxLength(100)
    Type: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ViewID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    QueryID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `The Primary Key value for the record, only used when Type='single_record'`}) 
    @MaxLength(900)
    RecordID?: string;
        
    @Field({nullable: true, description: `Only used when Type=sql`}) 
    SQL?: string;
        
    @Field({nullable: true, description: `Optionally used to cache results of an item. This can be used for performance optimization, and also for having snapshots of data for historical comparisons.`}) 
    DataJSON?: string;
        
    @Field({nullable: true, description: `If DataJSON is populated, this field will show the date the the data was captured`}) 
    @MaxLength(8)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(510)
    DataContext: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    View?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Query?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class CreateDataContextItemInput {
    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID: string | null;

    @Field({ nullable: true })
    QueryID: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    SQL: string | null;

    @Field({ nullable: true })
    DataJSON: string | null;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Context Items
//****************************************************************************
@InputType()
export class UpdateDataContextItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DataContextID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ViewID?: string | null;

    @Field({ nullable: true })
    QueryID?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    SQL?: string | null;

    @Field({ nullable: true })
    DataJSON?: string | null;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Context Items
//****************************************************************************
@ObjectType()
export class RunDataContextItemViewResult {
    @Field(() => [DataContextItem_])
    Results: DataContextItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DataContextItem_)
export class DataContextItemResolver extends ResolverBase {
    @Query(() => RunDataContextItemViewResult)
    async RunDataContextItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDataContextItemViewResult)
    async RunDataContextItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDataContextItemViewResult)
    async RunDataContextItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Context Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DataContextItem_, { nullable: true })
    async DataContextItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DataContextItem_ | null> {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Data Context Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => DataContextItem_)
    async CreateDataContextItem(
        @Arg('input', () => CreateDataContextItemInput) input: CreateDataContextItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Data Context Items', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => DataContextItem_)
    async UpdateDataContextItem(
        @Arg('input', () => UpdateDataContextItemInput) input: UpdateDataContextItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Data Context Items', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => DataContextItem_)
    async DeleteDataContextItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Context Items', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Data Contexts
//****************************************************************************
@ObjectType({ description: `Data Contexts are a primitive within the MemberJunction architecture. They store information about data contexts which are groups of data including views, queries, or raw SQL statements. Data contexts can be used in conversations, reports and more.` })
export class DataContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    LastRefreshedAt?: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [Report_])
    Reports_DataContextIDArray: Report_[]; // Link to Reports
    
    @Field(() => [DataContextItem_])
    DataContextItems_DataContextIDArray: DataContextItem_[]; // Link to DataContextItems
    
    @Field(() => [Conversation_])
    Conversations_DataContextIDArray: Conversation_[]; // Link to Conversations
    
}

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class CreateDataContextInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt: Date | null;
}
    

//****************************************************************************
// INPUT TYPE for Data Contexts
//****************************************************************************
@InputType()
export class UpdateDataContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    LastRefreshedAt?: Date | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Data Contexts
//****************************************************************************
@ObjectType()
export class RunDataContextViewResult {
    @Field(() => [DataContext_])
    Results: DataContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DataContext_)
export class DataContextResolver extends ResolverBase {
    @Query(() => RunDataContextViewResult)
    async RunDataContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDataContextViewResult)
    async RunDataContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDataContextViewResult)
    async RunDataContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Data Contexts';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DataContext_, { nullable: true })
    async DataContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DataContext_ | null> {
        this.CheckUserReadPermissions('Data Contexts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Data Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Data Contexts', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Report_])
    async Reports_DataContextIDArray(@Root() datacontext_: DataContext_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [DataContextID]='${datacontext_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [DataContextItem_])
    async DataContextItems_DataContextIDArray(@Root() datacontext_: DataContext_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Data Context Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDataContextItems] WHERE [DataContextID]='${datacontext_.ID}' ` + this.getRowLevelSecurityWhereClause('Data Context Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Data Context Items', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Conversation_])
    async Conversations_DataContextIDArray(@Root() datacontext_: DataContext_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Conversations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversations] WHERE [DataContextID]='${datacontext_.ID}' ` + this.getRowLevelSecurityWhereClause('Conversations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Conversations', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => DataContext_)
    async CreateDataContext(
        @Arg('input', () => CreateDataContextInput) input: CreateDataContextInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Data Contexts', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => DataContext_)
    async UpdateDataContext(
        @Arg('input', () => UpdateDataContextInput) input: UpdateDataContextInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Data Contexts', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => DataContext_)
    async DeleteDataContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Data Contexts', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for User View Categories
//****************************************************************************
@ObjectType()
export class UserViewCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [UserViewCategory_])
    UserViewCategories_ParentIDArray: UserViewCategory_[]; // Link to UserViewCategories
    
    @Field(() => [UserView_])
    UserViews_CategoryIDArray: UserView_[]; // Link to UserViews
    
}

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class CreateUserViewCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for User View Categories
//****************************************************************************
@InputType()
export class UpdateUserViewCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for User View Categories
//****************************************************************************
@ObjectType()
export class RunUserViewCategoryViewResult {
    @Field(() => [UserViewCategory_])
    Results: UserViewCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(UserViewCategory_)
export class UserViewCategoryResolver extends ResolverBase {
    @Query(() => RunUserViewCategoryViewResult)
    async RunUserViewCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewCategoryViewResult)
    async RunUserViewCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunUserViewCategoryViewResult)
    async RunUserViewCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'User View Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => UserViewCategory_, { nullable: true })
    async UserViewCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<UserViewCategory_ | null> {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('User View Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [UserViewCategory_])
    async UserViewCategories_ParentIDArray(@Root() userviewcategory_: UserViewCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User View Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViewCategories] WHERE [ParentID]='${userviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('User View Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User View Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [UserView_])
    async UserViews_CategoryIDArray(@Root() userviewcategory_: UserViewCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('User Views', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwUserViews] WHERE [CategoryID]='${userviewcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('User Views', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('User Views', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => UserViewCategory_)
    async CreateUserViewCategory(
        @Arg('input', () => CreateUserViewCategoryInput) input: CreateUserViewCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('User View Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => UserViewCategory_)
    async UpdateUserViewCategory(
        @Arg('input', () => UpdateUserViewCategoryInput) input: UpdateUserViewCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('User View Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => UserViewCategory_)
    async DeleteUserViewCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('User View Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Dashboard Categories
//****************************************************************************
@ObjectType()
export class DashboardCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [DashboardCategory_])
    DashboardCategories_ParentIDArray: DashboardCategory_[]; // Link to DashboardCategories
    
    @Field(() => [Dashboard_])
    Dashboards_CategoryIDArray: Dashboard_[]; // Link to Dashboards
    
}

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class CreateDashboardCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Dashboard Categories
//****************************************************************************
@InputType()
export class UpdateDashboardCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Dashboard Categories
//****************************************************************************
@ObjectType()
export class RunDashboardCategoryViewResult {
    @Field(() => [DashboardCategory_])
    Results: DashboardCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DashboardCategory_)
export class DashboardCategoryResolver extends ResolverBase {
    @Query(() => RunDashboardCategoryViewResult)
    async RunDashboardCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDashboardCategoryViewResult)
    async RunDashboardCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDashboardCategoryViewResult)
    async RunDashboardCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Dashboard Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DashboardCategory_, { nullable: true })
    async DashboardCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DashboardCategory_ | null> {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Dashboard Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [DashboardCategory_])
    async DashboardCategories_ParentIDArray(@Root() dashboardcategory_: DashboardCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboard Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboardCategories] WHERE [ParentID]='${dashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Dashboard Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboard Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Dashboard_])
    async Dashboards_CategoryIDArray(@Root() dashboardcategory_: DashboardCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Dashboards', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDashboards] WHERE [CategoryID]='${dashboardcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Dashboards', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Dashboards', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => DashboardCategory_)
    async CreateDashboardCategory(
        @Arg('input', () => CreateDashboardCategoryInput) input: CreateDashboardCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Dashboard Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => DashboardCategory_)
    async UpdateDashboardCategory(
        @Arg('input', () => UpdateDashboardCategoryInput) input: UpdateDashboardCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Dashboard Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => DashboardCategory_)
    async DeleteDashboardCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Dashboard Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Report Categories
//****************************************************************************
@ObjectType()
export class ReportCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [ReportCategory_])
    ReportCategories_ParentIDArray: ReportCategory_[]; // Link to ReportCategories
    
    @Field(() => [Report_])
    Reports_CategoryIDArray: Report_[]; // Link to Reports
    
}

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class CreateReportCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Report Categories
//****************************************************************************
@InputType()
export class UpdateReportCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Report Categories
//****************************************************************************
@ObjectType()
export class RunReportCategoryViewResult {
    @Field(() => [ReportCategory_])
    Results: ReportCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportCategory_)
export class ReportCategoryResolver extends ResolverBase {
    @Query(() => RunReportCategoryViewResult)
    async RunReportCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportCategoryViewResult)
    async RunReportCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportCategoryViewResult)
    async RunReportCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Report Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ReportCategory_, { nullable: true })
    async ReportCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportCategory_ | null> {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Report Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ReportCategory_])
    async ReportCategories_ParentIDArray(@Root() reportcategory_: ReportCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Report Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportCategories] WHERE [ParentID]='${reportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Report Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Report Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Report_])
    async Reports_CategoryIDArray(@Root() reportcategory_: ReportCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Reports', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReports] WHERE [CategoryID]='${reportcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Reports', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Reports', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ReportCategory_)
    async CreateReportCategory(
        @Arg('input', () => CreateReportCategoryInput) input: CreateReportCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Report Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ReportCategory_)
    async UpdateReportCategory(
        @Arg('input', () => UpdateReportCategoryInput) input: UpdateReportCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Report Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ReportCategory_)
    async DeleteReportCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Report Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Storage Providers
//****************************************************************************
@ObjectType()
export class FileStorageProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(100)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(200)
    ServerDriverKey: string;
        
    @Field() 
    @MaxLength(200)
    ClientDriverKey: string;
        
    @Field(() => Int) 
    Priority: number;
        
    @Field(() => Boolean) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [File_])
    Files_ProviderIDArray: File_[]; // Link to Files
    
}

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class CreateFileStorageProviderInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for File Storage Providers
//****************************************************************************
@InputType()
export class UpdateFileStorageProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ServerDriverKey?: string;

    @Field({ nullable: true })
    ClientDriverKey?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Storage Providers
//****************************************************************************
@ObjectType()
export class RunFileStorageProviderViewResult {
    @Field(() => [FileStorageProvider_])
    Results: FileStorageProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(FileStorageProvider_)
export class FileStorageProviderResolver extends ResolverBase {
    @Query(() => RunFileStorageProviderViewResult)
    async RunFileStorageProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileStorageProviderViewResult)
    async RunFileStorageProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileStorageProviderViewResult)
    async RunFileStorageProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Storage Providers';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => FileStorageProvider_, { nullable: true })
    async FileStorageProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<FileStorageProvider_ | null> {
        this.CheckUserReadPermissions('File Storage Providers', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileStorageProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('File Storage Providers', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('File Storage Providers', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [File_])
    async Files_ProviderIDArray(@Root() filestorageprovider_: FileStorageProvider_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ProviderID]='${filestorageprovider_.ID}' ` + this.getRowLevelSecurityWhereClause('Files', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Files', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => FileStorageProvider_)
    async CreateFileStorageProvider(
        @Arg('input', () => CreateFileStorageProviderInput) input: CreateFileStorageProviderInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('File Storage Providers', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => FileStorageProvider_)
    async UpdateFileStorageProvider(
        @Arg('input', () => UpdateFileStorageProviderInput) input: UpdateFileStorageProviderInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('File Storage Providers', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => FileStorageProvider_)
    async DeleteFileStorageProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Storage Providers', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Files
//****************************************************************************
@ObjectType()
export class File_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(1000)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(16)
    ProviderID: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    ContentType?: string;
        
    @Field({nullable: true}) 
    @MaxLength(1000)
    ProviderKey?: string;
        
    @Field({description: `Pending, Uploading, Uploaded, Deleting, Deleted`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(100)
    Provider: string;
        
    @Field(() => [FileEntityRecordLink_])
    FileEntityRecordLinks_FileIDArray: FileEntityRecordLink_[]; // Link to FileEntityRecordLinks
    
}

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class CreateFileInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType: string | null;

    @Field({ nullable: true })
    ProviderKey: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Files
//****************************************************************************
@InputType()
export class UpdateFileInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    ProviderID?: string;

    @Field({ nullable: true })
    ContentType?: string | null;

    @Field({ nullable: true })
    ProviderKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Files
//****************************************************************************
@ObjectType()
export class RunFileViewResult {
    @Field(() => [File_])
    Results: File_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(File_)
export class FileResolver extends ResolverBase {
    @Query(() => RunFileViewResult)
    async RunFileViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileViewResult)
    async RunFileViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileViewResult)
    async RunFileDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Files';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => File_, { nullable: true })
    async File(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<File_ | null> {
        this.CheckUserReadPermissions('Files', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Files', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Files', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [FileEntityRecordLink_])
    async FileEntityRecordLinks_FileIDArray(@Root() file_: File_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [FileID]='${file_.ID}' ` + this.getRowLevelSecurityWhereClause('File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('File Entity Record Links', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => File_)
    async CreateFile(
        @Arg('input', () => CreateFileInput) input: CreateFileInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Files', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => File_)
    async UpdateFile(
        @Arg('input', () => UpdateFileInput) input: UpdateFileInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Files', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => File_)
    async DeleteFile(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Files', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Categories
//****************************************************************************
@ObjectType()
export class FileCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [File_])
    Files_CategoryIDArray: File_[]; // Link to Files
    
    @Field(() => [FileCategory_])
    FileCategories_ParentIDArray: FileCategory_[]; // Link to FileCategories
    
}

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class CreateFileCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for File Categories
//****************************************************************************
@InputType()
export class UpdateFileCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Categories
//****************************************************************************
@ObjectType()
export class RunFileCategoryViewResult {
    @Field(() => [FileCategory_])
    Results: FileCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(FileCategory_)
export class FileCategoryResolver extends ResolverBase {
    @Query(() => RunFileCategoryViewResult)
    async RunFileCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileCategoryViewResult)
    async RunFileCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileCategoryViewResult)
    async RunFileCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => FileCategory_, { nullable: true })
    async FileCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<FileCategory_ | null> {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('File Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [File_])
    async Files_CategoryIDArray(@Root() filecategory_: FileCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Files', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFiles] WHERE [CategoryID]='${filecategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Files', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Files', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [FileCategory_])
    async FileCategories_ParentIDArray(@Root() filecategory_: FileCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('File Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileCategories] WHERE [ParentID]='${filecategory_.ID}' ` + this.getRowLevelSecurityWhereClause('File Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('File Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => FileCategory_)
    async CreateFileCategory(
        @Arg('input', () => CreateFileCategoryInput) input: CreateFileCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('File Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => FileCategory_)
    async UpdateFileCategory(
        @Arg('input', () => UpdateFileCategoryInput) input: UpdateFileCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('File Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => FileCategory_)
    async DeleteFileCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for File Entity Record Links
//****************************************************************************
@ObjectType()
export class FileEntityRecordLink_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    FileID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(1500)
    RecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(1000)
    File: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class CreateFileEntityRecordLinkInput {
    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for File Entity Record Links
//****************************************************************************
@InputType()
export class UpdateFileEntityRecordLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    FileID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for File Entity Record Links
//****************************************************************************
@ObjectType()
export class RunFileEntityRecordLinkViewResult {
    @Field(() => [FileEntityRecordLink_])
    Results: FileEntityRecordLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(FileEntityRecordLink_)
export class FileEntityRecordLinkResolver extends ResolverBase {
    @Query(() => RunFileEntityRecordLinkViewResult)
    async RunFileEntityRecordLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileEntityRecordLinkViewResult)
    async RunFileEntityRecordLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunFileEntityRecordLinkViewResult)
    async RunFileEntityRecordLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'File Entity Record Links';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => FileEntityRecordLink_, { nullable: true })
    async FileEntityRecordLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<FileEntityRecordLink_ | null> {
        this.CheckUserReadPermissions('File Entity Record Links', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwFileEntityRecordLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('File Entity Record Links', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('File Entity Record Links', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => FileEntityRecordLink_)
    async CreateFileEntityRecordLink(
        @Arg('input', () => CreateFileEntityRecordLinkInput) input: CreateFileEntityRecordLinkInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('File Entity Record Links', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => FileEntityRecordLink_)
    async UpdateFileEntityRecordLink(
        @Arg('input', () => UpdateFileEntityRecordLinkInput) input: UpdateFileEntityRecordLinkInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('File Entity Record Links', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => FileEntityRecordLink_)
    async DeleteFileEntityRecordLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('File Entity Record Links', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Version Installations
//****************************************************************************
@ObjectType()
export class VersionInstallation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field(() => Int) 
    MajorVersion: number;
        
    @Field(() => Int) 
    MinorVersion: number;
        
    @Field(() => Int) 
    PatchVersion: number;
        
    @Field({nullable: true, description: `What type of installation was applied`}) 
    @MaxLength(40)
    Type?: string;
        
    @Field() 
    @MaxLength(8)
    InstalledAt: Date;
        
    @Field({description: `Pending, Complete, Failed`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Any logging that was saved from the installation process`}) 
    InstallLog?: string;
        
    @Field({nullable: true, description: `Optional, comments the administrator wants to save for each installed version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(604)
    CompleteVersion?: string;
        
}

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class CreateVersionInstallationInput {
    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Version Installations
//****************************************************************************
@InputType()
export class UpdateVersionInstallationInput {
    @Field()
    ID: string;

    @Field(() => Int, { nullable: true })
    MajorVersion?: number;

    @Field(() => Int, { nullable: true })
    MinorVersion?: number;

    @Field(() => Int, { nullable: true })
    PatchVersion?: number;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    InstalledAt?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    InstallLog?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Version Installations
//****************************************************************************
@ObjectType()
export class RunVersionInstallationViewResult {
    @Field(() => [VersionInstallation_])
    Results: VersionInstallation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(VersionInstallation_)
export class VersionInstallationResolver extends ResolverBase {
    @Query(() => RunVersionInstallationViewResult)
    async RunVersionInstallationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunVersionInstallationViewResult)
    async RunVersionInstallationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunVersionInstallationViewResult)
    async RunVersionInstallationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Version Installations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => VersionInstallation_, { nullable: true })
    async VersionInstallation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<VersionInstallation_ | null> {
        this.CheckUserReadPermissions('Version Installations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwVersionInstallations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Version Installations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Version Installations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => VersionInstallation_)
    async CreateVersionInstallation(
        @Arg('input', () => CreateVersionInstallationInput) input: CreateVersionInstallationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Version Installations', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => VersionInstallation_)
    async UpdateVersionInstallation(
        @Arg('input', () => UpdateVersionInstallationInput) input: UpdateVersionInstallationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Version Installations', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class DuplicateRunDetailMatch_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunDetailID: string;
        
    @Field({description: `Either Vector or SP`}) 
    @MaxLength(40)
    MatchSource: string;
        
    @Field() 
    @MaxLength(1000)
    MatchRecordID: string;
        
    @Field(() => Float, {description: `Value between 0 and 1 designating the computed probability of a match`}) 
    MatchProbability: number;
        
    @Field() 
    @MaxLength(8)
    MatchedAt: Date;
        
    @Field() 
    @MaxLength(40)
    Action: string;
        
    @Field() 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RecordMergeLogID?: string;
        
    @Field() 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field() 
    @MaxLength(8)
    MergedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class CreateDuplicateRunDetailMatchInput {
    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Detail Matches
//****************************************************************************
@InputType()
export class UpdateDuplicateRunDetailMatchInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunDetailID?: string;

    @Field({ nullable: true })
    MatchSource?: string;

    @Field({ nullable: true })
    MatchRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number;

    @Field({ nullable: true })
    MatchedAt?: Date;

    @Field({ nullable: true })
    Action?: string;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    RecordMergeLogID?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergedAt?: Date;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Detail Matches
//****************************************************************************
@ObjectType()
export class RunDuplicateRunDetailMatchViewResult {
    @Field(() => [DuplicateRunDetailMatch_])
    Results: DuplicateRunDetailMatch_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DuplicateRunDetailMatch_)
export class DuplicateRunDetailMatchResolver extends ResolverBase {
    @Query(() => RunDuplicateRunDetailMatchViewResult)
    async RunDuplicateRunDetailMatchViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailMatchViewResult)
    async RunDuplicateRunDetailMatchViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailMatchViewResult)
    async RunDuplicateRunDetailMatchDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Detail Matches';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DuplicateRunDetailMatch_, { nullable: true })
    async DuplicateRunDetailMatch(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DuplicateRunDetailMatch_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Duplicate Run Detail Matches', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => DuplicateRunDetailMatch_)
    async CreateDuplicateRunDetailMatch(
        @Arg('input', () => CreateDuplicateRunDetailMatchInput) input: CreateDuplicateRunDetailMatchInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Duplicate Run Detail Matches', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => DuplicateRunDetailMatch_)
    async UpdateDuplicateRunDetailMatch(
        @Arg('input', () => UpdateDuplicateRunDetailMatchInput) input: UpdateDuplicateRunDetailMatchInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Duplicate Run Detail Matches', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Document Settings
//****************************************************************************
@ObjectType()
export class EntityDocumentSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityDocumentID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(500)
    EntityDocument: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class CreateEntityDocumentSettingInput {
    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Document Settings
//****************************************************************************
@InputType()
export class UpdateEntityDocumentSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityDocumentID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Document Settings
//****************************************************************************
@ObjectType()
export class RunEntityDocumentSettingViewResult {
    @Field(() => [EntityDocumentSetting_])
    Results: EntityDocumentSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityDocumentSetting_)
export class EntityDocumentSettingResolver extends ResolverBase {
    @Query(() => RunEntityDocumentSettingViewResult)
    async RunEntityDocumentSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentSettingViewResult)
    async RunEntityDocumentSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityDocumentSettingViewResult)
    async RunEntityDocumentSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Document Settings';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityDocumentSetting_, { nullable: true })
    async EntityDocumentSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityDocumentSetting_ | null> {
        this.CheckUserReadPermissions('Entity Document Settings', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocumentSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Document Settings', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Document Settings', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityDocumentSetting_)
    async CreateEntityDocumentSetting(
        @Arg('input', () => CreateEntityDocumentSettingInput) input: CreateEntityDocumentSettingInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Document Settings', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityDocumentSetting_)
    async UpdateEntityDocumentSetting(
        @Arg('input', () => UpdateEntityDocumentSettingInput) input: UpdateEntityDocumentSettingInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Document Settings', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityDocumentSetting_)
    async DeleteEntityDocumentSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Document Settings', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Settings
//****************************************************************************
@ObjectType()
export class EntitySetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class CreateEntitySettingInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Settings
//****************************************************************************
@InputType()
export class UpdateEntitySettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Settings
//****************************************************************************
@ObjectType()
export class RunEntitySettingViewResult {
    @Field(() => [EntitySetting_])
    Results: EntitySetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntitySetting_)
export class EntitySettingResolver extends ResolverBase {
    @Query(() => RunEntitySettingViewResult)
    async RunEntitySettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntitySettingViewResult)
    async RunEntitySettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntitySettingViewResult)
    async RunEntitySettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Settings';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntitySetting_, { nullable: true })
    async EntitySetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntitySetting_ | null> {
        this.CheckUserReadPermissions('Entity Settings', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntitySettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Settings', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Settings', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntitySetting_)
    async CreateEntitySetting(
        @Arg('input', () => CreateEntitySettingInput) input: CreateEntitySettingInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Settings', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntitySetting_)
    async UpdateEntitySetting(
        @Arg('input', () => UpdateEntitySettingInput) input: UpdateEntitySettingInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Settings', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntitySetting_)
    async DeleteEntitySetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Settings', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Runs
//****************************************************************************
@ObjectType()
export class DuplicateRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    StartedByUserID: string;
        
    @Field() 
    @MaxLength(16)
    SourceListID: string;
        
    @Field() 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field() 
    @MaxLength(40)
    ApprovalStatus: string;
        
    @Field({nullable: true}) 
    ApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ApprovedByUserID?: string;
        
    @Field() 
    @MaxLength(40)
    ProcessingStatus: string;
        
    @Field({nullable: true}) 
    ProcessingErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    StartedByUser: string;
        
    @Field() 
    @MaxLength(200)
    SourceList: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ApprovedByUser?: string;
        
    @Field(() => [DuplicateRunDetail_])
    DuplicateRunDetails_DuplicateRunIDArray: DuplicateRunDetail_[]; // Link to DuplicateRunDetails
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class CreateDuplicateRunInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments: string | null;

    @Field({ nullable: true })
    ApprovedByUserID: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Runs
//****************************************************************************
@InputType()
export class UpdateDuplicateRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    StartedByUserID?: string;

    @Field({ nullable: true })
    SourceListID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    ApprovalStatus?: string;

    @Field({ nullable: true })
    ApprovalComments?: string | null;

    @Field({ nullable: true })
    ApprovedByUserID?: string | null;

    @Field({ nullable: true })
    ProcessingStatus?: string;

    @Field({ nullable: true })
    ProcessingErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Runs
//****************************************************************************
@ObjectType()
export class RunDuplicateRunViewResult {
    @Field(() => [DuplicateRun_])
    Results: DuplicateRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DuplicateRun_)
export class DuplicateRunResolver extends ResolverBase {
    @Query(() => RunDuplicateRunViewResult)
    async RunDuplicateRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunViewResult)
    async RunDuplicateRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunViewResult)
    async RunDuplicateRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DuplicateRun_, { nullable: true })
    async DuplicateRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DuplicateRun_ | null> {
        this.CheckUserReadPermissions('Duplicate Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Duplicate Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [DuplicateRunDetail_])
    async DuplicateRunDetails_DuplicateRunIDArray(@Root() duplicaterun_: DuplicateRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [DuplicateRunID]='${duplicaterun_.ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Details', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => DuplicateRun_)
    async CreateDuplicateRun(
        @Arg('input', () => CreateDuplicateRunInput) input: CreateDuplicateRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Duplicate Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => DuplicateRun_)
    async UpdateDuplicateRun(
        @Arg('input', () => UpdateDuplicateRunInput) input: UpdateDuplicateRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Duplicate Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Duplicate Run Details
//****************************************************************************
@ObjectType()
export class DuplicateRunDetail_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    DuplicateRunID: string;
        
    @Field() 
    @MaxLength(1000)
    RecordID: string;
        
    @Field() 
    @MaxLength(40)
    MatchStatus: string;
        
    @Field({nullable: true, description: `If MatchStatus=Skipped, this field can be used to store the reason why the record was skipped`}) 
    SkippedReason?: string;
        
    @Field({nullable: true, description: `If MatchStatus='Error' this field can be used to track the error from that phase of the process for logging/diagnostics.`}) 
    MatchErrorMessage?: string;
        
    @Field() 
    @MaxLength(40)
    MergeStatus: string;
        
    @Field({nullable: true}) 
    MergeErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [DuplicateRunDetailMatch_])
    DuplicateRunDetailMatches_DuplicateRunDetailIDArray: DuplicateRunDetailMatch_[]; // Link to DuplicateRunDetailMatches
    
}

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class CreateDuplicateRunDetailInput {
    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason: string | null;

    @Field({ nullable: true })
    MatchErrorMessage: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Duplicate Run Details
//****************************************************************************
@InputType()
export class UpdateDuplicateRunDetailInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    DuplicateRunID?: string;

    @Field({ nullable: true })
    RecordID?: string;

    @Field({ nullable: true })
    MatchStatus?: string;

    @Field({ nullable: true })
    SkippedReason?: string | null;

    @Field({ nullable: true })
    MatchErrorMessage?: string | null;

    @Field({ nullable: true })
    MergeStatus?: string;

    @Field({ nullable: true })
    MergeErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Duplicate Run Details
//****************************************************************************
@ObjectType()
export class RunDuplicateRunDetailViewResult {
    @Field(() => [DuplicateRunDetail_])
    Results: DuplicateRunDetail_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(DuplicateRunDetail_)
export class DuplicateRunDetailResolver extends ResolverBase {
    @Query(() => RunDuplicateRunDetailViewResult)
    async RunDuplicateRunDetailViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailViewResult)
    async RunDuplicateRunDetailViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunDuplicateRunDetailViewResult)
    async RunDuplicateRunDetailDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Duplicate Run Details';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => DuplicateRunDetail_, { nullable: true })
    async DuplicateRunDetail(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<DuplicateRunDetail_ | null> {
        this.CheckUserReadPermissions('Duplicate Run Details', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetails] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Run Details', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Duplicate Run Details', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [DuplicateRunDetailMatch_])
    async DuplicateRunDetailMatches_DuplicateRunDetailIDArray(@Root() duplicaterundetail_: DuplicateRunDetail_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Duplicate Run Detail Matches', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwDuplicateRunDetailMatches] WHERE [DuplicateRunDetailID]='${duplicaterundetail_.ID}' ` + this.getRowLevelSecurityWhereClause('Duplicate Run Detail Matches', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Duplicate Run Detail Matches', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => DuplicateRunDetail_)
    async CreateDuplicateRunDetail(
        @Arg('input', () => CreateDuplicateRunDetailInput) input: CreateDuplicateRunDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Duplicate Run Details', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => DuplicateRunDetail_)
    async UpdateDuplicateRunDetail(
        @Arg('input', () => UpdateDuplicateRunDetailInput) input: UpdateDuplicateRunDetailInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Duplicate Run Details', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Application Settings
//****************************************************************************
@ObjectType()
export class ApplicationSetting_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ApplicationID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    Application: string;
        
}

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class CreateApplicationSettingInput {
    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Application Settings
//****************************************************************************
@InputType()
export class UpdateApplicationSettingInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ApplicationID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Application Settings
//****************************************************************************
@ObjectType()
export class RunApplicationSettingViewResult {
    @Field(() => [ApplicationSetting_])
    Results: ApplicationSetting_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ApplicationSetting_)
export class ApplicationSettingResolver extends ResolverBase {
    @Query(() => RunApplicationSettingViewResult)
    async RunApplicationSettingViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunApplicationSettingViewResult)
    async RunApplicationSettingViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunApplicationSettingViewResult)
    async RunApplicationSettingDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Application Settings';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ApplicationSetting_, { nullable: true })
    async ApplicationSetting(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ApplicationSetting_ | null> {
        this.CheckUserReadPermissions('Application Settings', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwApplicationSettings] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Application Settings', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Application Settings', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ApplicationSetting_)
    async CreateApplicationSetting(
        @Arg('input', () => CreateApplicationSettingInput) input: CreateApplicationSettingInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Application Settings', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ApplicationSetting_)
    async UpdateApplicationSetting(
        @Arg('input', () => UpdateApplicationSettingInput) input: UpdateApplicationSettingInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Application Settings', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ApplicationSetting_)
    async DeleteApplicationSetting(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Application Settings', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Categories
//****************************************************************************
@ObjectType({ description: `Organizes actions into categories, including name, description, and optional parent category for hierarchy.` })
export class ActionCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the action category.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the action category.`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field({description: `Status of the action category (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field(() => [ActionCategory_])
    ActionCategories_ParentIDArray: ActionCategory_[]; // Link to ActionCategories
    
    @Field(() => [Action_])
    Actions_CategoryIDArray: Action_[]; // Link to Actions
    
}

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class CreateActionCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Categories
//****************************************************************************
@InputType()
export class UpdateActionCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Categories
//****************************************************************************
@ObjectType()
export class RunActionCategoryViewResult {
    @Field(() => [ActionCategory_])
    Results: ActionCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionCategory_)
export class ActionCategoryResolver extends ResolverBase {
    @Query(() => RunActionCategoryViewResult)
    async RunActionCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionCategoryViewResult)
    async RunActionCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionCategoryViewResult)
    async RunActionCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionCategory_, { nullable: true })
    async ActionCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionCategory_ | null> {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ActionCategory_])
    async ActionCategories_ParentIDArray(@Root() actioncategory_: ActionCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionCategories] WHERE [ParentID]='${actioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [Action_])
    async Actions_CategoryIDArray(@Root() actioncategory_: ActionCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [CategoryID]='${actioncategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ActionCategory_)
    async CreateActionCategory(
        @Arg('input', () => CreateActionCategoryInput) input: CreateActionCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionCategory_)
    async UpdateActionCategory(
        @Arg('input', () => UpdateActionCategoryInput) input: UpdateActionCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionCategory_)
    async DeleteActionCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Actions
//****************************************************************************
@ObjectType({ description: `Links entities to actions - this is the main place where you define the actions that part of, or available, for a given entity.` })
export class EntityAction_ {
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Status of the entity action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [EntityActionInvocation_])
    EntityActionInvocations_EntityActionIDArray: EntityActionInvocation_[]; // Link to EntityActionInvocations
    
    @Field(() => [EntityActionFilter_])
    EntityActionFilters_EntityActionIDArray: EntityActionFilter_[]; // Link to EntityActionFilters
    
    @Field(() => [EntityActionParam_])
    EntityActionParams_EntityActionIDArray: EntityActionParam_[]; // Link to EntityActionParams
    
}

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class CreateEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Actions
//****************************************************************************
@InputType()
export class UpdateEntityActionInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field()
    ID: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Actions
//****************************************************************************
@ObjectType()
export class RunEntityActionViewResult {
    @Field(() => [EntityAction_])
    Results: EntityAction_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityAction_)
export class EntityActionResolver extends ResolverBase {
    @Query(() => RunEntityActionViewResult)
    async RunEntityActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionViewResult)
    async RunEntityActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionViewResult)
    async RunEntityActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityAction_, { nullable: true })
    async EntityAction(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityAction_ | null> {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityActionInvocation_])
    async EntityActionInvocations_EntityActionIDArray(@Root() entityaction_: EntityAction_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [EntityActionID]='${entityaction_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityActionFilter_])
    async EntityActionFilters_EntityActionIDArray(@Root() entityaction_: EntityAction_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [EntityActionID]='${entityaction_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityActionParam_])
    async EntityActionParams_EntityActionIDArray(@Root() entityaction_: EntityAction_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [EntityActionID]='${entityaction_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Params', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityAction_)
    async CreateEntityAction(
        @Arg('input', () => CreateEntityActionInput) input: CreateEntityActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityAction_)
    async UpdateEntityAction(
        @Arg('input', () => UpdateEntityActionInput) input: UpdateEntityActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityAction_)
    async DeleteEntityAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocations
//****************************************************************************
@ObjectType({ description: `Links invocation types to entity actions – for example you might link a particular EntityAction to just “Create Record” and you might also have a second item in this table allowing the same Entity Action to be invoked from a User View or List, on demand.` })
export class EntityActionInvocation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    InvocationTypeID: string;
        
    @Field({description: `Status of the entity action invocation (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    InvocationType: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class CreateEntityActionInvocationInput {
    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocations
//****************************************************************************
@InputType()
export class UpdateEntityActionInvocationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    InvocationTypeID?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocations
//****************************************************************************
@ObjectType()
export class RunEntityActionInvocationViewResult {
    @Field(() => [EntityActionInvocation_])
    Results: EntityActionInvocation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionInvocation_)
export class EntityActionInvocationResolver extends ResolverBase {
    @Query(() => RunEntityActionInvocationViewResult)
    async RunEntityActionInvocationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationViewResult)
    async RunEntityActionInvocationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationViewResult)
    async RunEntityActionInvocationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityActionInvocation_, { nullable: true })
    async EntityActionInvocation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionInvocation_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Action Invocations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityActionInvocation_)
    async CreateEntityActionInvocation(
        @Arg('input', () => CreateEntityActionInvocationInput) input: CreateEntityActionInvocationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Action Invocations', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionInvocation_)
    async UpdateEntityActionInvocation(
        @Arg('input', () => UpdateEntityActionInvocationInput) input: UpdateEntityActionInvocationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Action Invocations', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionInvocation_)
    async DeleteEntityActionInvocation(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocations', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Authorizations
//****************************************************************************
@ObjectType({ description: `Links actions to authorizations, one or more of these must be possessed by a user in order to execute the action.` })
export class ActionAuthorization_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    AuthorizationID: string;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    Authorization: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class CreateActionAuthorizationInput {
    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Authorizations
//****************************************************************************
@InputType()
export class UpdateActionAuthorizationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    AuthorizationID?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Authorizations
//****************************************************************************
@ObjectType()
export class RunActionAuthorizationViewResult {
    @Field(() => [ActionAuthorization_])
    Results: ActionAuthorization_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionAuthorization_)
export class ActionAuthorizationResolver extends ResolverBase {
    @Query(() => RunActionAuthorizationViewResult)
    async RunActionAuthorizationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionAuthorizationViewResult)
    async RunActionAuthorizationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionAuthorizationViewResult)
    async RunActionAuthorizationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Authorizations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionAuthorization_, { nullable: true })
    async ActionAuthorization(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionAuthorization_ | null> {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Authorizations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ActionAuthorization_)
    async CreateActionAuthorization(
        @Arg('input', () => CreateActionAuthorizationInput) input: CreateActionAuthorizationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Authorizations', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionAuthorization_)
    async UpdateActionAuthorization(
        @Arg('input', () => UpdateActionAuthorizationInput) input: UpdateActionAuthorizationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Authorizations', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionAuthorization_)
    async DeleteActionAuthorization(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Authorizations', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Invocation Types
//****************************************************************************
@ObjectType({ description: `Stores the possible invocation types of an action within the context of an entity. Examples would be: Record Created/Updated/Deleted/Accessed as well as things like “View” or “List” where you could run an EntityAction against an entire set of records in a view or list – either by user click or programmatically.` })
export class EntityActionInvocationType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the invocation type such as Record Created/Updated/etc.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the invocation type.`}) 
    Description?: string;
        
    @Field(() => Int) 
    DisplaySequence: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityActionInvocation_])
    EntityActionInvocations_InvocationTypeIDArray: EntityActionInvocation_[]; // Link to EntityActionInvocations
    
}

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class CreateEntityActionInvocationTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Invocation Types
//****************************************************************************
@InputType()
export class UpdateEntityActionInvocationTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Int, { nullable: true })
    DisplaySequence?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Invocation Types
//****************************************************************************
@ObjectType()
export class RunEntityActionInvocationTypeViewResult {
    @Field(() => [EntityActionInvocationType_])
    Results: EntityActionInvocationType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionInvocationType_)
export class EntityActionInvocationTypeResolver extends ResolverBase {
    @Query(() => RunEntityActionInvocationTypeViewResult)
    async RunEntityActionInvocationTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationTypeViewResult)
    async RunEntityActionInvocationTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionInvocationTypeViewResult)
    async RunEntityActionInvocationTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Invocation Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityActionInvocationType_, { nullable: true })
    async EntityActionInvocationType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionInvocationType_ | null> {
        this.CheckUserReadPermissions('Entity Action Invocation Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocationTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Invocation Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Action Invocation Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityActionInvocation_])
    async EntityActionInvocations_InvocationTypeIDArray(@Root() entityactioninvocationtype_: EntityActionInvocationType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Invocations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionInvocations] WHERE [InvocationTypeID]='${entityactioninvocationtype_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Invocations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Invocations', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityActionInvocationType_)
    async CreateEntityActionInvocationType(
        @Arg('input', () => CreateEntityActionInvocationTypeInput) input: CreateEntityActionInvocationTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Action Invocation Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionInvocationType_)
    async UpdateEntityActionInvocationType(
        @Arg('input', () => UpdateEntityActionInvocationTypeInput) input: UpdateEntityActionInvocationTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Action Invocation Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionInvocationType_)
    async DeleteEntityActionInvocationType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Invocation Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Actions
//****************************************************************************
@ObjectType({ description: `Stores action definitions, including prompts, generated code, user comments, and status.` })
export class Action_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field() 
    @MaxLength(850)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Generated or Custom. Generated means the UserPrompt is used to prompt an AI model to automatically create the code for the Action. Custom means that a custom class has been implemented that subclasses the BaseAction class. The custom class needs to use the @RegisterClass decorator and be included in the MJAPI (or other runtime environment) to be available for execution.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true}) 
    UserPrompt?: string;
        
    @Field({nullable: true, description: `User's comments not shared with the LLM.`}) 
    UserComments?: string;
        
    @Field({nullable: true}) 
    Code?: string;
        
    @Field({nullable: true, description: `AI's explanation of the code.`}) 
    CodeComments?: string;
        
    @Field({description: `An action won't be usable until the code is approved.`}) 
    @MaxLength(40)
    CodeApprovalStatus: string;
        
    @Field({nullable: true, description: `Optional comments when an individual (or an AI) reviews and approves the code.`}) 
    CodeApprovalComments?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CodeApprovedByUserID?: string;
        
    @Field({nullable: true, description: `When the code was approved.`}) 
    @MaxLength(8)
    CodeApprovedAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 1, Code will never be generated by the AI system. This overrides all other settings including the ForceCodeGeneration bit`}) 
    CodeLocked: boolean;
        
    @Field(() => Boolean, {description: `If set to 1, the Action will generate code for the provided UserPrompt on the next Save even if the UserPrompt hasn't changed. This is useful to force regeneration when other candidates (such as a change in Action Inputs/Outputs) occurs or on demand by a user.`}) 
    ForceCodeGeneration: boolean;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain execution logs; NULL for indefinite.`}) 
    RetentionPeriod?: number;
        
    @Field({description: `Status of the action (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    CodeApprovedByUser?: string;
        
    @Field(() => [ActionParam_])
    ActionParams_ActionIDArray: ActionParam_[]; // Link to ActionParams
    
    @Field(() => [ActionLibrary_])
    ActionLibraries_ActionIDArray: ActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [ScheduledAction_])
    ScheduledActions_ActionIDArray: ScheduledAction_[]; // Link to ScheduledActions
    
    @Field(() => [ActionResultCode_])
    ActionResultCodes_ActionIDArray: ActionResultCode_[]; // Link to ActionResultCodes
    
    @Field(() => [AIAgentAction_])
    AIAgentActions_ActionIDArray: AIAgentAction_[]; // Link to AIAgentActions
    
    @Field(() => [ActionContext_])
    ActionContexts_ActionIDArray: ActionContext_[]; // Link to ActionContexts
    
    @Field(() => [EntityAction_])
    EntityActions_ActionIDArray: EntityAction_[]; // Link to EntityActions
    
    @Field(() => [ActionExecutionLog_])
    ActionExecutionLogs_ActionIDArray: ActionExecutionLog_[]; // Link to ActionExecutionLogs
    
    @Field(() => [ActionAuthorization_])
    ActionAuthorizations_ActionIDArray: ActionAuthorization_[]; // Link to ActionAuthorizations
    
}

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class CreateActionInput {
    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code: string | null;

    @Field({ nullable: true })
    CodeComments: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID: string | null;

    @Field({ nullable: true })
    CodeApprovedAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Actions
//****************************************************************************
@InputType()
export class UpdateActionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string | null;

    @Field({ nullable: true })
    CodeComments?: string | null;

    @Field({ nullable: true })
    CodeApprovalStatus?: string;

    @Field({ nullable: true })
    CodeApprovalComments?: string | null;

    @Field({ nullable: true })
    CodeApprovedByUserID?: string | null;

    @Field({ nullable: true })
    CodeApprovedAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    CodeLocked?: boolean;

    @Field(() => Boolean, { nullable: true })
    ForceCodeGeneration?: boolean;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Actions
//****************************************************************************
@ObjectType()
export class RunActionViewResult {
    @Field(() => [Action_])
    Results: Action_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Action_)
export class ActionResolver extends ResolverBase {
    @Query(() => RunActionViewResult)
    async RunActionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionViewResult)
    async RunActionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionViewResult)
    async RunActionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Actions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Action_, { nullable: true })
    async Action(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Action_ | null> {
        this.CheckUserReadPermissions('Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Actions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ActionParam_])
    async ActionParams_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Params', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionLibrary_])
    async ActionLibraries_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Libraries', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ScheduledAction_])
    async ScheduledActions_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActions] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Scheduled Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionResultCode_])
    async ActionResultCodes_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Result Codes', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIAgentAction_])
    async AIAgentActions_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Agent Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentActions] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Agent Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionContext_])
    async ActionContexts_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Contexts', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityAction_])
    async EntityActions_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Actions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActions] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Actions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Actions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionExecutionLog_])
    async ActionExecutionLogs_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Execution Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ActionAuthorization_])
    async ActionAuthorizations_ActionIDArray(@Root() action_: Action_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Authorizations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionAuthorizations] WHERE [ActionID]='${action_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Authorizations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Authorizations', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Action_)
    async CreateAction(
        @Arg('input', () => CreateActionInput) input: CreateActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Actions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Action_)
    async UpdateAction(
        @Arg('input', () => UpdateActionInput) input: UpdateActionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Actions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Action_)
    async DeleteAction(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Actions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Filters
//****************************************************************************
@ObjectType({ description: `Optional use. Maps Action Filters to specific EntityAction instances, specifying execution order and status. This allows for “pre-processing” before an Action actually is fired off, to check for various state/dirty/value conditions.` })
export class EntityActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionFilterID: string;
        
    @Field(() => Int, {description: `Order of filter execution.`}) 
    Sequence: number;
        
    @Field({description: `Status of the entity action filter (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class CreateEntityActionFilterInput {
    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Filters
//****************************************************************************
@InputType()
export class UpdateEntityActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionFilterID?: string;

    @Field(() => Int, { nullable: true })
    Sequence?: number;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Filters
//****************************************************************************
@ObjectType()
export class RunEntityActionFilterViewResult {
    @Field(() => [EntityActionFilter_])
    Results: EntityActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionFilter_)
export class EntityActionFilterResolver extends ResolverBase {
    @Query(() => RunEntityActionFilterViewResult)
    async RunEntityActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionFilterViewResult)
    async RunEntityActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionFilterViewResult)
    async RunEntityActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Filters';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityActionFilter_, { nullable: true })
    async EntityActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionFilter_ | null> {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Action Filters', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityActionFilter_)
    async CreateEntityActionFilter(
        @Arg('input', () => CreateEntityActionFilterInput) input: CreateEntityActionFilterInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Action Filters', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionFilter_)
    async UpdateEntityActionFilter(
        @Arg('input', () => UpdateEntityActionFilterInput) input: UpdateEntityActionFilterInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Action Filters', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionFilter_)
    async DeleteEntityActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Filters', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Filters
//****************************************************************************
@ObjectType({ description: `Defines filters that can be evaluated ahead of executing an action. Action Filters are usable in any code pipeline you can execute them with the same context as the action itself and use the outcome to determine if the action should execute or not.` })
export class ActionFilter_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    UserDescription: string;
        
    @Field({nullable: true}) 
    UserComments?: string;
        
    @Field() 
    Code: string;
        
    @Field({nullable: true}) 
    CodeExplanation?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityActionFilter_])
    EntityActionFilters_ActionFilterIDArray: EntityActionFilter_[]; // Link to EntityActionFilters
    
}

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class CreateActionFilterInput {
    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Filters
//****************************************************************************
@InputType()
export class UpdateActionFilterInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserDescription?: string;

    @Field({ nullable: true })
    UserComments?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    CodeExplanation?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Filters
//****************************************************************************
@ObjectType()
export class RunActionFilterViewResult {
    @Field(() => [ActionFilter_])
    Results: ActionFilter_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionFilter_)
export class ActionFilterResolver extends ResolverBase {
    @Query(() => RunActionFilterViewResult)
    async RunActionFilterViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionFilterViewResult)
    async RunActionFilterViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionFilterViewResult)
    async RunActionFilterDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Filters';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionFilter_, { nullable: true })
    async ActionFilter(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionFilter_ | null> {
        this.CheckUserReadPermissions('Action Filters', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionFilters] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Filters', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityActionFilter_])
    async EntityActionFilters_ActionFilterIDArray(@Root() actionfilter_: ActionFilter_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Filters', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionFilters] WHERE [ActionFilterID]='${actionfilter_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Filters', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Filters', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ActionFilter_)
    async CreateActionFilter(
        @Arg('input', () => CreateActionFilterInput) input: CreateActionFilterInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Filters', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionFilter_)
    async UpdateActionFilter(
        @Arg('input', () => UpdateActionFilterInput) input: UpdateActionFilterInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Filters', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionFilter_)
    async DeleteActionFilter(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Filters', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Context Types
//****************************************************************************
@ObjectType({ description: `Lists possible contexts for action execution with optional descriptions.` })
export class ActionContextType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the context type.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the context type.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ActionContext_])
    ActionContexts_ContextTypeIDArray: ActionContext_[]; // Link to ActionContexts
    
}

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class CreateActionContextTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Context Types
//****************************************************************************
@InputType()
export class UpdateActionContextTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Context Types
//****************************************************************************
@ObjectType()
export class RunActionContextTypeViewResult {
    @Field(() => [ActionContextType_])
    Results: ActionContextType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionContextType_)
export class ActionContextTypeResolver extends ResolverBase {
    @Query(() => RunActionContextTypeViewResult)
    async RunActionContextTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionContextTypeViewResult)
    async RunActionContextTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionContextTypeViewResult)
    async RunActionContextTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Context Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionContextType_, { nullable: true })
    async ActionContextType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionContextType_ | null> {
        this.CheckUserReadPermissions('Action Context Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContextTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Context Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Context Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ActionContext_])
    async ActionContexts_ContextTypeIDArray(@Root() actioncontexttype_: ActionContextType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ContextTypeID]='${actioncontexttype_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Contexts', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ActionContextType_)
    async CreateActionContextType(
        @Arg('input', () => CreateActionContextTypeInput) input: CreateActionContextTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Context Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionContextType_)
    async UpdateActionContextType(
        @Arg('input', () => UpdateActionContextTypeInput) input: UpdateActionContextTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Context Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionContextType_)
    async DeleteActionContextType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Context Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Result Codes
//****************************************************************************
@ObjectType({ description: `Defines the possible result codes for each action.` })
export class ActionResultCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(510)
    ResultCode: string;
        
    @Field(() => Boolean, {description: `Indicates if the result code is a success or not. It is possible an action might have more than one failure condition/result code and same for success conditions.`}) 
    IsSuccess: boolean;
        
    @Field({nullable: true, description: `Description of the result code.`}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class CreateActionResultCodeInput {
    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Result Codes
//****************************************************************************
@InputType()
export class UpdateActionResultCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ResultCode?: string;

    @Field(() => Boolean, { nullable: true })
    IsSuccess?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Result Codes
//****************************************************************************
@ObjectType()
export class RunActionResultCodeViewResult {
    @Field(() => [ActionResultCode_])
    Results: ActionResultCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionResultCode_)
export class ActionResultCodeResolver extends ResolverBase {
    @Query(() => RunActionResultCodeViewResult)
    async RunActionResultCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionResultCodeViewResult)
    async RunActionResultCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionResultCodeViewResult)
    async RunActionResultCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Result Codes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionResultCode_, { nullable: true })
    async ActionResultCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionResultCode_ | null> {
        this.CheckUserReadPermissions('Action Result Codes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionResultCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Result Codes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Result Codes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ActionResultCode_)
    async CreateActionResultCode(
        @Arg('input', () => CreateActionResultCodeInput) input: CreateActionResultCodeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Result Codes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionResultCode_)
    async UpdateActionResultCode(
        @Arg('input', () => UpdateActionResultCodeInput) input: UpdateActionResultCodeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Result Codes', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionResultCode_)
    async DeleteActionResultCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Result Codes', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Contexts
//****************************************************************************
@ObjectType({ description: `Links actions to their supported context types enabling a given action to be executable in more than one context.` })
export class ActionContext_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ContextTypeID?: string;
        
    @Field({description: `Status of the action context (Pending, Active, Disabled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContextType?: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class CreateActionContextInput {
    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Action Contexts
//****************************************************************************
@InputType()
export class UpdateActionContextInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    ContextTypeID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Contexts
//****************************************************************************
@ObjectType()
export class RunActionContextViewResult {
    @Field(() => [ActionContext_])
    Results: ActionContext_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionContext_)
export class ActionContextResolver extends ResolverBase {
    @Query(() => RunActionContextViewResult)
    async RunActionContextViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionContextViewResult)
    async RunActionContextViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionContextViewResult)
    async RunActionContextDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Contexts';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionContext_, { nullable: true })
    async ActionContext(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionContext_ | null> {
        this.CheckUserReadPermissions('Action Contexts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionContexts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Contexts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Contexts', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ActionContext_)
    async CreateActionContext(
        @Arg('input', () => CreateActionContextInput) input: CreateActionContextInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Contexts', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionContext_)
    async UpdateActionContext(
        @Arg('input', () => UpdateActionContextInput) input: UpdateActionContextInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Contexts', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionContext_)
    async DeleteActionContext(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Contexts', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Execution Logs
//****************************************************************************
@ObjectType({ description: `Tracks every execution of an action, including start and end times, inputs, outputs, and result codes.` })
export class ActionExecutionLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field({description: `Timestamp of when the action started execution.`}) 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp of when the action ended execution.`}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Params?: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ResultCode?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field(() => Int, {nullable: true, description: `Number of days to retain the log; NULL for indefinite retention.`}) 
    RetentionPeriod?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class CreateActionExecutionLogInput {
    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Params: string | null;

    @Field({ nullable: true })
    ResultCode: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Execution Logs
//****************************************************************************
@InputType()
export class UpdateActionExecutionLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Params?: string | null;

    @Field({ nullable: true })
    ResultCode?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => Int, { nullable: true })
    RetentionPeriod?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Execution Logs
//****************************************************************************
@ObjectType()
export class RunActionExecutionLogViewResult {
    @Field(() => [ActionExecutionLog_])
    Results: ActionExecutionLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionExecutionLog_)
export class ActionExecutionLogResolver extends ResolverBase {
    @Query(() => RunActionExecutionLogViewResult)
    async RunActionExecutionLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionExecutionLogViewResult)
    async RunActionExecutionLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionExecutionLogViewResult)
    async RunActionExecutionLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Execution Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionExecutionLog_, { nullable: true })
    async ActionExecutionLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionExecutionLog_ | null> {
        this.CheckUserReadPermissions('Action Execution Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionExecutionLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Execution Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Execution Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ActionExecutionLog_)
    async CreateActionExecutionLog(
        @Arg('input', () => CreateActionExecutionLogInput) input: CreateActionExecutionLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Execution Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionExecutionLog_)
    async UpdateActionExecutionLog(
        @Arg('input', () => UpdateActionExecutionLogInput) input: UpdateActionExecutionLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Execution Logs', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionExecutionLog_)
    async DeleteActionExecutionLog(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Execution Logs', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Params
//****************************************************************************
@ObjectType({ description: `Tracks the input and output parameters for Actions.` })
export class ActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    DefaultValue?: string;
        
    @Field() 
    @MaxLength(20)
    Type: string;
        
    @Field({description: `Tracks the basic value type of the parameter, additional information can be provided in the Description field`}) 
    @MaxLength(60)
    ValueType: string;
        
    @Field(() => Boolean) 
    IsArray: boolean;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field(() => Boolean) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field(() => [EntityActionParam_])
    EntityActionParams_ActionParamIDArray: EntityActionParam_[]; // Link to EntityActionParams
    
    @Field(() => [ScheduledActionParam_])
    ScheduledActionParams_ActionParamIDArray: ScheduledActionParam_[]; // Link to ScheduledActionParams
    
}

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class CreateActionParamInput {
    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Action Params
//****************************************************************************
@InputType()
export class UpdateActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field(() => Boolean, { nullable: true })
    IsArray?: boolean;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Params
//****************************************************************************
@ObjectType()
export class RunActionParamViewResult {
    @Field(() => [ActionParam_])
    Results: ActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionParam_)
export class ActionParamResolver extends ResolverBase {
    @Query(() => RunActionParamViewResult)
    async RunActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionParamViewResult)
    async RunActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionParamViewResult)
    async RunActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Params';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionParam_, { nullable: true })
    async ActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionParam_ | null> {
        this.CheckUserReadPermissions('Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Params', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityActionParam_])
    async EntityActionParams_ActionParamIDArray(@Root() actionparam_: ActionParam_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ActionParamID]='${actionparam_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Action Params', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ScheduledActionParam_])
    async ScheduledActionParams_ActionParamIDArray(@Root() actionparam_: ActionParam_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Scheduled Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwScheduledActionParams] WHERE [ActionParamID]='${actionparam_.ID}' ` + this.getRowLevelSecurityWhereClause('Scheduled Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Scheduled Action Params', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ActionParam_)
    async CreateActionParam(
        @Arg('input', () => CreateActionParamInput) input: CreateActionParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Params', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionParam_)
    async UpdateActionParam(
        @Arg('input', () => UpdateActionParamInput) input: UpdateActionParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Params', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionParam_)
    async DeleteActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Params', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Action Libraries
//****************************************************************************
@ObjectType({ description: `Tracks the list of libraries that a given Action uses, including a list of classes/functions for each library.` })
export class ActionLibrary_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ActionID: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({nullable: true, description: `List of classes and functions used by the action from the library.`}) 
    ItemsUsed?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(850)
    Action: string;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class CreateActionLibraryInput {
    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Action Libraries
//****************************************************************************
@InputType()
export class UpdateActionLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ActionID?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    ItemsUsed?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Action Libraries
//****************************************************************************
@ObjectType()
export class RunActionLibraryViewResult {
    @Field(() => [ActionLibrary_])
    Results: ActionLibrary_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ActionLibrary_)
export class ActionLibraryResolver extends ResolverBase {
    @Query(() => RunActionLibraryViewResult)
    async RunActionLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionLibraryViewResult)
    async RunActionLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunActionLibraryViewResult)
    async RunActionLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Action Libraries';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ActionLibrary_, { nullable: true })
    async ActionLibrary(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ActionLibrary_ | null> {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Action Libraries', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ActionLibrary_)
    async CreateActionLibrary(
        @Arg('input', () => CreateActionLibraryInput) input: CreateActionLibraryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Action Libraries', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ActionLibrary_)
    async UpdateActionLibrary(
        @Arg('input', () => UpdateActionLibraryInput) input: UpdateActionLibraryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Action Libraries', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ActionLibrary_)
    async DeleteActionLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Action Libraries', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Libraries
//****************************************************************************
@ObjectType({ description: `Stores information about the available libraries, including a list of classes/functions, type definitions, and sample code. You can add additional custom libraries here to make them avaialable to code generation features within the system.` })
export class Library_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `Status of the library, only libraries marked as Active will be available for use by generated code. If a library was once active but no longer is, existing code that used the library will not be affected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Code showing the types and functions defined in the library to be used for reference by humans and AI`}) 
    TypeDefinitions?: string;
        
    @Field({nullable: true, description: `Examples of code use of the classes and/or functions from within the library`}) 
    SampleCode?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ActionLibrary_])
    ActionLibraries_LibraryIDArray: ActionLibrary_[]; // Link to ActionLibraries
    
    @Field(() => [LibraryItem_])
    LibraryItems_LibraryIDArray: LibraryItem_[]; // Link to LibraryItems
    
}

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class CreateLibraryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions: string | null;

    @Field({ nullable: true })
    SampleCode: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Libraries
//****************************************************************************
@InputType()
export class UpdateLibraryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    TypeDefinitions?: string | null;

    @Field({ nullable: true })
    SampleCode?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Libraries
//****************************************************************************
@ObjectType()
export class RunLibraryViewResult {
    @Field(() => [Library_])
    Results: Library_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Library_)
export class LibraryResolver extends ResolverBase {
    @Query(() => RunLibraryViewResult)
    async RunLibraryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunLibraryViewResult)
    async RunLibraryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunLibraryViewResult)
    async RunLibraryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Libraries';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Library_, { nullable: true })
    async Library(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Library_ | null> {
        this.CheckUserReadPermissions('Libraries', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraries] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Libraries', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ActionLibrary_])
    async ActionLibraries_LibraryIDArray(@Root() library_: Library_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Action Libraries', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwActionLibraries] WHERE [LibraryID]='${library_.ID}' ` + this.getRowLevelSecurityWhereClause('Action Libraries', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Action Libraries', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [LibraryItem_])
    async LibraryItems_LibraryIDArray(@Root() library_: Library_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [LibraryID]='${library_.ID}' ` + this.getRowLevelSecurityWhereClause('Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Library Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Library_)
    async CreateLibrary(
        @Arg('input', () => CreateLibraryInput) input: CreateLibraryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Libraries', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Library_)
    async UpdateLibrary(
        @Arg('input', () => UpdateLibraryInput) input: UpdateLibraryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Libraries', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Library_)
    async DeleteLibrary(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Libraries', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for List Categories
//****************************************************************************
@ObjectType()
export class ListCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [ListCategory_])
    ListCategories_ParentIDArray: ListCategory_[]; // Link to ListCategories
    
    @Field(() => [List_])
    Lists_CategoryIDArray: List_[]; // Link to Lists
    
}

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class CreateListCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for List Categories
//****************************************************************************
@InputType()
export class UpdateListCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for List Categories
//****************************************************************************
@ObjectType()
export class RunListCategoryViewResult {
    @Field(() => [ListCategory_])
    Results: ListCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ListCategory_)
export class ListCategoryResolver extends ResolverBase {
    @Query(() => RunListCategoryViewResult)
    async RunListCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunListCategoryViewResult)
    async RunListCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunListCategoryViewResult)
    async RunListCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'List Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ListCategory_, { nullable: true })
    async ListCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ListCategory_ | null> {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('List Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ListCategory_])
    async ListCategories_ParentIDArray(@Root() listcategory_: ListCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('List Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwListCategories] WHERE [ParentID]='${listcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('List Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('List Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [List_])
    async Lists_CategoryIDArray(@Root() listcategory_: ListCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Lists', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLists] WHERE [CategoryID]='${listcategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Lists', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Lists', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ListCategory_)
    async CreateListCategory(
        @Arg('input', () => CreateListCategoryInput) input: CreateListCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('List Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ListCategory_)
    async UpdateListCategory(
        @Arg('input', () => UpdateListCategoryInput) input: UpdateListCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('List Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ListCategory_)
    async DeleteListCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('List Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Providers
//****************************************************************************
@ObjectType({ description: `All supported communication providers.` })
export class CommunicationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The status of the communication provider (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports sending messages.`}) 
    SupportsSending: boolean;
        
    @Field(() => Boolean, {description: `Indicates if the provider supports receiving messages.`}) 
    SupportsReceiving: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports sending messages at a specific time`}) 
    SupportsScheduledSending: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports forwarding messages to another recipient `}) 
    SupportsForwarding: boolean;
        
    @Field(() => Boolean, {description: `Whether or not the provider supports replying to messages`}) 
    SupportsReplying: boolean;
        
    @Field(() => [CommunicationLog_])
    CommunicationLogs_CommunicationProviderIDArray: CommunicationLog_[]; // Link to CommunicationLogs
    
    @Field(() => [CommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationProviderIDArray: CommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
}

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class CreateCommunicationProviderInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Communication Providers
//****************************************************************************
@InputType()
export class UpdateCommunicationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReceiving?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsScheduledSending?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsForwarding?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsReplying?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Providers
//****************************************************************************
@ObjectType()
export class RunCommunicationProviderViewResult {
    @Field(() => [CommunicationProvider_])
    Results: CommunicationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationProvider_)
export class CommunicationProviderResolver extends ResolverBase {
    @Query(() => RunCommunicationProviderViewResult)
    async RunCommunicationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderViewResult)
    async RunCommunicationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderViewResult)
    async RunCommunicationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Providers';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CommunicationProvider_, { nullable: true })
    async CommunicationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationProvider_ | null> {
        this.CheckUserReadPermissions('Communication Providers', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Communication Providers', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Communication Providers', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [CommunicationLog_])
    async CommunicationLogs_CommunicationProviderIDArray(@Root() communicationprovider_: CommunicationProvider_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderID]='${communicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause('Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [CommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationProviderIDArray(@Root() communicationprovider_: CommunicationProvider_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationProviderID]='${communicationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause('Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CommunicationProvider_)
    async CreateCommunicationProvider(
        @Arg('input', () => CreateCommunicationProviderInput) input: CreateCommunicationProviderInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Communication Providers', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationProvider_)
    async UpdateCommunicationProvider(
        @Arg('input', () => UpdateCommunicationProviderInput) input: UpdateCommunicationProviderInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Communication Providers', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationProvider_)
    async DeleteCommunicationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Providers', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Runs
//****************************************************************************
@ObjectType({ description: `Runs of bulk message sends and receives.` })
export class CommunicationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `The direction of the communication run (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The status of the communication run (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartedAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({nullable: true}) 
    Comments?: string;
        
    @Field({nullable: true, description: `The error message if the communication run failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [CommunicationLog_])
    CommunicationLogs_CommunicationRunIDArray: CommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class CreateCommunicationRunInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt: Date | null;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Runs
//****************************************************************************
@InputType()
export class UpdateCommunicationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    StartedAt?: Date | null;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Runs
//****************************************************************************
@ObjectType()
export class RunCommunicationRunViewResult {
    @Field(() => [CommunicationRun_])
    Results: CommunicationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationRun_)
export class CommunicationRunResolver extends ResolverBase {
    @Query(() => RunCommunicationRunViewResult)
    async RunCommunicationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationRunViewResult)
    async RunCommunicationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationRunViewResult)
    async RunCommunicationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CommunicationRun_, { nullable: true })
    async CommunicationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationRun_ | null> {
        this.CheckUserReadPermissions('Communication Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Communication Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Communication Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [CommunicationLog_])
    async CommunicationLogs_CommunicationRunIDArray(@Root() communicationrun_: CommunicationRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationRunID]='${communicationrun_.ID}' ` + this.getRowLevelSecurityWhereClause('Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CommunicationRun_)
    async CreateCommunicationRun(
        @Arg('input', () => CreateCommunicationRunInput) input: CreateCommunicationRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Communication Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationRun_)
    async UpdateCommunicationRun(
        @Arg('input', () => UpdateCommunicationRunInput) input: UpdateCommunicationRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Communication Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Provider Message Types
//****************************************************************************
@ObjectType({ description: `Providers and their supported message types with additional attributes.` })
export class CommunicationProviderMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationBaseMessageTypeID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({description: `The status of the provider message type (Disabled or Active).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Additional attributes specific to the provider message type.`}) 
    AdditionalAttributes?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(200)
    CommunicationBaseMessageType: string;
        
    @Field(() => [CommunicationLog_])
    CommunicationLogs_CommunicationProviderMessageTypeIDArray: CommunicationLog_[]; // Link to CommunicationLogs
    
}

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class CreateCommunicationProviderMessageTypeInput {
    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Provider Message Types
//****************************************************************************
@InputType()
export class UpdateCommunicationProviderMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationBaseMessageTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AdditionalAttributes?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Provider Message Types
//****************************************************************************
@ObjectType()
export class RunCommunicationProviderMessageTypeViewResult {
    @Field(() => [CommunicationProviderMessageType_])
    Results: CommunicationProviderMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationProviderMessageType_)
export class CommunicationProviderMessageTypeResolver extends ResolverBase {
    @Query(() => RunCommunicationProviderMessageTypeViewResult)
    async RunCommunicationProviderMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderMessageTypeViewResult)
    async RunCommunicationProviderMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationProviderMessageTypeViewResult)
    async RunCommunicationProviderMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Provider Message Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CommunicationProviderMessageType_, { nullable: true })
    async CommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationProviderMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Communication Provider Message Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [CommunicationLog_])
    async CommunicationLogs_CommunicationProviderMessageTypeIDArray(@Root() communicationprovidermessagetype_: CommunicationProviderMessageType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [CommunicationProviderMessageTypeID]='${communicationprovidermessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Logs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CommunicationProviderMessageType_)
    async CreateCommunicationProviderMessageType(
        @Arg('input', () => CreateCommunicationProviderMessageTypeInput) input: CreateCommunicationProviderMessageTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Communication Provider Message Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationProviderMessageType_)
    async UpdateCommunicationProviderMessageType(
        @Arg('input', () => UpdateCommunicationProviderMessageTypeInput) input: UpdateCommunicationProviderMessageTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Communication Provider Message Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationProviderMessageType_)
    async DeleteCommunicationProviderMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Provider Message Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Logs
//****************************************************************************
@ObjectType({ description: `Logs of sent and received messages.` })
export class CommunicationLog_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderID: string;
        
    @Field() 
    @MaxLength(16)
    CommunicationProviderMessageTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CommunicationRunID?: string;
        
    @Field({description: `The direction of the communication log (Sending or Receiving).`}) 
    @MaxLength(40)
    Direction: string;
        
    @Field({description: `The date and time when the message was logged.`}) 
    @MaxLength(8)
    MessageDate: Date;
        
    @Field({description: `The status of the logged message (Pending, In-Progress, Complete, Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `The content of the logged message.`}) 
    MessageContent?: string;
        
    @Field({nullable: true, description: `The error message if the message sending failed.`}) 
    ErrorMessage?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    CommunicationProvider: string;
        
    @Field() 
    @MaxLength(510)
    CommunicationProviderMessageType: string;
        
}

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class CreateCommunicationLogInput {
    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent: string | null;

    @Field({ nullable: true })
    ErrorMessage: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Logs
//****************************************************************************
@InputType()
export class UpdateCommunicationLogInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    CommunicationProviderID?: string;

    @Field({ nullable: true })
    CommunicationProviderMessageTypeID?: string;

    @Field({ nullable: true })
    CommunicationRunID?: string | null;

    @Field({ nullable: true })
    Direction?: string;

    @Field({ nullable: true })
    MessageDate?: Date;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    MessageContent?: string | null;

    @Field({ nullable: true })
    ErrorMessage?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Logs
//****************************************************************************
@ObjectType()
export class RunCommunicationLogViewResult {
    @Field(() => [CommunicationLog_])
    Results: CommunicationLog_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationLog_)
export class CommunicationLogResolver extends ResolverBase {
    @Query(() => RunCommunicationLogViewResult)
    async RunCommunicationLogViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationLogViewResult)
    async RunCommunicationLogViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationLogViewResult)
    async RunCommunicationLogDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Logs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CommunicationLog_, { nullable: true })
    async CommunicationLog(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationLog_ | null> {
        this.CheckUserReadPermissions('Communication Logs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationLogs] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Communication Logs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Communication Logs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => CommunicationLog_)
    async CreateCommunicationLog(
        @Arg('input', () => CreateCommunicationLogInput) input: CreateCommunicationLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Communication Logs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationLog_)
    async UpdateCommunicationLog(
        @Arg('input', () => UpdateCommunicationLogInput) input: UpdateCommunicationLogInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Communication Logs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Communication Base Message Types
//****************************************************************************
@ObjectType({ description: `Base message types and their supported functionalities.` })
export class CommunicationBaseMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Type: string;
        
    @Field(() => Boolean, {description: `Indicates if attachments are supported.`}) 
    SupportsAttachments: boolean;
        
    @Field(() => Boolean, {description: `Indicates if a subject line is supported.`}) 
    SupportsSubjectLine: boolean;
        
    @Field(() => Boolean, {description: `Indicates if HTML content is supported.`}) 
    SupportsHtml: boolean;
        
    @Field(() => Int, {nullable: true, description: `The maximum size in bytes for the message.`}) 
    MaxBytes?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [CommunicationProviderMessageType_])
    CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray: CommunicationProviderMessageType_[]; // Link to CommunicationProviderMessageTypes
    
    @Field(() => [EntityCommunicationMessageType_])
    EntityCommunicationMessageTypes_BaseMessageTypeIDArray: EntityCommunicationMessageType_[]; // Link to EntityCommunicationMessageTypes
    
}

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class CreateCommunicationBaseMessageTypeInput {
    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Communication Base Message Types
//****************************************************************************
@InputType()
export class UpdateCommunicationBaseMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => Boolean, { nullable: true })
    SupportsAttachments?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsSubjectLine?: boolean;

    @Field(() => Boolean, { nullable: true })
    SupportsHtml?: boolean;

    @Field(() => Int, { nullable: true })
    MaxBytes?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Communication Base Message Types
//****************************************************************************
@ObjectType()
export class RunCommunicationBaseMessageTypeViewResult {
    @Field(() => [CommunicationBaseMessageType_])
    Results: CommunicationBaseMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(CommunicationBaseMessageType_)
export class CommunicationBaseMessageTypeResolver extends ResolverBase {
    @Query(() => RunCommunicationBaseMessageTypeViewResult)
    async RunCommunicationBaseMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationBaseMessageTypeViewResult)
    async RunCommunicationBaseMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunCommunicationBaseMessageTypeViewResult)
    async RunCommunicationBaseMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Communication Base Message Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => CommunicationBaseMessageType_, { nullable: true })
    async CommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<CommunicationBaseMessageType_ | null> {
        this.CheckUserReadPermissions('Communication Base Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationBaseMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Communication Base Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Communication Base Message Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [CommunicationProviderMessageType_])
    async CommunicationProviderMessageTypes_CommunicationBaseMessageTypeIDArray(@Root() communicationbasemessagetype_: CommunicationBaseMessageType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Communication Provider Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwCommunicationProviderMessageTypes] WHERE [CommunicationBaseMessageTypeID]='${communicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Communication Provider Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Communication Provider Message Types', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityCommunicationMessageType_])
    async EntityCommunicationMessageTypes_BaseMessageTypeIDArray(@Root() communicationbasemessagetype_: CommunicationBaseMessageType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [BaseMessageTypeID]='${communicationbasemessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Message Types', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => CommunicationBaseMessageType_)
    async CreateCommunicationBaseMessageType(
        @Arg('input', () => CreateCommunicationBaseMessageTypeInput) input: CreateCommunicationBaseMessageTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Communication Base Message Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => CommunicationBaseMessageType_)
    async UpdateCommunicationBaseMessageType(
        @Arg('input', () => UpdateCommunicationBaseMessageTypeInput) input: UpdateCommunicationBaseMessageTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Communication Base Message Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => CommunicationBaseMessageType_)
    async DeleteCommunicationBaseMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Communication Base Message Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Templates
//****************************************************************************
@ObjectType({ description: `Templates are used for dynamic expansion of a static template with data from a given context. Templates can be used to create documents, messages and anything else that requires dynamic document creation merging together static text, data and lightweight logic` })
export class Template_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    CategoryID?: string;
        
    @Field({nullable: true, description: `This prompt will be used by the AI to generate template content as requested by the user.`}) 
    UserPrompt?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use until the specified date. Requires IsActive to be set to 1`}) 
    @MaxLength(8)
    ActiveAt?: Date;
        
    @Field({nullable: true, description: `Optional, if provided, this template will not be available for use after the specified date. If IsActive=0, this has no effect.`}) 
    @MaxLength(8)
    DisabledAt?: Date;
        
    @Field(() => Boolean, {description: `If set to 0, the template will be disabled regardless of the values in ActiveAt/DisabledAt. `}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Category?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [TemplateContent_])
    TemplateContents_TemplateIDArray: TemplateContent_[]; // Link to TemplateContents
    
    @Field(() => [TemplateParam_])
    TemplateParams_TemplateIDArray: TemplateParam_[]; // Link to TemplateParams
    
    @Field(() => [AIPrompt_])
    AIPrompts_TemplateIDArray: AIPrompt_[]; // Link to AIPrompts
    
    @Field(() => [EntityDocument_])
    EntityDocuments_TemplateIDArray: EntityDocument_[]; // Link to EntityDocuments
    
}

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class CreateTemplateInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CategoryID: string | null;

    @Field({ nullable: true })
    UserPrompt: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt: Date | null;

    @Field({ nullable: true })
    DisabledAt: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Templates
//****************************************************************************
@InputType()
export class UpdateTemplateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CategoryID?: string | null;

    @Field({ nullable: true })
    UserPrompt?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ActiveAt?: Date | null;

    @Field({ nullable: true })
    DisabledAt?: Date | null;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Templates
//****************************************************************************
@ObjectType()
export class RunTemplateViewResult {
    @Field(() => [Template_])
    Results: Template_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Template_)
export class TemplateResolver extends ResolverBase {
    @Query(() => RunTemplateViewResult)
    async RunTemplateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateViewResult)
    async RunTemplateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateViewResult)
    async RunTemplateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Templates';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Template_, { nullable: true })
    async Template(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Template_ | null> {
        this.CheckUserReadPermissions('Templates', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Templates', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Templates', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [TemplateContent_])
    async TemplateContents_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause('Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Template Contents', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [TemplateParam_])
    async TemplateParams_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause('Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Template Params', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [AIPrompt_])
    async AIPrompts_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('AI Prompts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIPrompts] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause('AI Prompts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('AI Prompts', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [EntityDocument_])
    async EntityDocuments_TemplateIDArray(@Root() template_: Template_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Documents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityDocuments] WHERE [TemplateID]='${template_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Documents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Documents', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Template_)
    async CreateTemplate(
        @Arg('input', () => CreateTemplateInput) input: CreateTemplateInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Templates', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Template_)
    async UpdateTemplate(
        @Arg('input', () => UpdateTemplateInput) input: UpdateTemplateInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Templates', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => Template_)
    async DeleteTemplate(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Templates', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Categories
//****************************************************************************
@ObjectType({ description: `Template categories for organizing templates` })
export class TemplateCategory_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template category`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template category`}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    ParentID?: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Parent?: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [Template_])
    Templates_CategoryIDArray: Template_[]; // Link to Templates
    
    @Field(() => [TemplateCategory_])
    TemplateCategories_ParentIDArray: TemplateCategory_[]; // Link to TemplateCategories
    
}

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class CreateTemplateCategoryInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ParentID: string | null;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Categories
//****************************************************************************
@InputType()
export class UpdateTemplateCategoryInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ParentID?: string | null;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Categories
//****************************************************************************
@ObjectType()
export class RunTemplateCategoryViewResult {
    @Field(() => [TemplateCategory_])
    Results: TemplateCategory_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateCategory_)
export class TemplateCategoryResolver extends ResolverBase {
    @Query(() => RunTemplateCategoryViewResult)
    async RunTemplateCategoryViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateCategoryViewResult)
    async RunTemplateCategoryViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateCategoryViewResult)
    async RunTemplateCategoryDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Categories';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => TemplateCategory_, { nullable: true })
    async TemplateCategory(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateCategory_ | null> {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Template Categories', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Template_])
    async Templates_CategoryIDArray(@Root() templatecategory_: TemplateCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Templates', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplates] WHERE [CategoryID]='${templatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Templates', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Templates', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [TemplateCategory_])
    async TemplateCategories_ParentIDArray(@Root() templatecategory_: TemplateCategory_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Categories', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateCategories] WHERE [ParentID]='${templatecategory_.ID}' ` + this.getRowLevelSecurityWhereClause('Template Categories', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Template Categories', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => TemplateCategory_)
    async CreateTemplateCategory(
        @Arg('input', () => CreateTemplateCategoryInput) input: CreateTemplateCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Template Categories', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateCategory_)
    async UpdateTemplateCategory(
        @Arg('input', () => UpdateTemplateCategoryInput) input: UpdateTemplateCategoryInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Template Categories', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateCategory_)
    async DeleteTemplateCategory(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Categories', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Contents
//****************************************************************************
@ObjectType({ description: `Template content for different versions of a template for purposes like HTML/Text/etc` })
export class TemplateContent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field() 
    @MaxLength(16)
    TypeID: string;
        
    @Field({nullable: true, description: `The actual text content for the template`}) 
    TemplateText?: string;
        
    @Field(() => Int, {description: `Priority of the content version, higher priority versions will be used ahead of lower priority versions for a given Type`}) 
    Priority: number;
        
    @Field(() => Boolean, {description: `Indicates whether the content is active or not. Use this to disable a particular Template Content item without having to remove it`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field() 
    @MaxLength(510)
    Type: string;
        
}

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class CreateTemplateContentInput {
    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Template Contents
//****************************************************************************
@InputType()
export class UpdateTemplateContentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    TypeID?: string;

    @Field({ nullable: true })
    TemplateText?: string | null;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Contents
//****************************************************************************
@ObjectType()
export class RunTemplateContentViewResult {
    @Field(() => [TemplateContent_])
    Results: TemplateContent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateContent_)
export class TemplateContentResolver extends ResolverBase {
    @Query(() => RunTemplateContentViewResult)
    async RunTemplateContentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentViewResult)
    async RunTemplateContentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentViewResult)
    async RunTemplateContentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Contents';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => TemplateContent_, { nullable: true })
    async TemplateContent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateContent_ | null> {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Template Contents', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => TemplateContent_)
    async CreateTemplateContent(
        @Arg('input', () => CreateTemplateContentInput) input: CreateTemplateContentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Template Contents', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateContent_)
    async UpdateTemplateContent(
        @Arg('input', () => UpdateTemplateContentInput) input: UpdateTemplateContentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Template Contents', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateContent_)
    async DeleteTemplateContent(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Contents', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Params
//****************************************************************************
@ObjectType({ description: `Parameters allowed for use inside the template` })
export class TemplateParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    TemplateID: string;
        
    @Field({description: `Name of the parameter`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the parameter`}) 
    Description?: string;
        
    @Field({description: `Type of the parameter - Record is an individual record within the entity specified by EntityID. Entity means an entire Entity or an entity filtered by the LinkedParameterName/Field attributes and/or ExtraFilter. Object is any valid JSON object. Array and Scalar have their common meanings.`}) 
    @MaxLength(40)
    Type: string;
        
    @Field({nullable: true, description: `Default value of the parameter`}) 
    DefaultValue?: string;
        
    @Field(() => Boolean) 
    IsRequired: boolean;
        
    @Field({nullable: true, description: `Only used when Type=Entity, this is used to link an Entity parameter with another parameter so that the rows in the Entity parameter can be filtered automatically based on the FKEY relationship between the Record and this Entity parameter. For example, if the Entity-based parameter is for an entity like Activities and there is another parameter of type Record for an entity like Contacts, in that situation the Activities Parameter would point to the Contacts parameter as the LinkedParameterName because we would filter down the Activities in each template render to only those linked to the Contact.`}) 
    @MaxLength(510)
    LinkedParameterName?: string;
        
    @Field({nullable: true, description: `If the LinkedParameterName is specified, this is an optional setting to specify the field within the LinkedParameter that will be used for filtering. This is only needed if there is more than one foreign key relationship between the Entity parameter and the Linked parameter, or if there is no defined foreign key in the database between the two entities.`}) 
    @MaxLength(1000)
    LinkedParameterField?: string;
        
    @Field({nullable: true, description: `Only used when Type = Entity, used to specify an optional filter to reduce the set of rows that are returned for each of the templates being rendered.`}) 
    ExtraFilter?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    EntityID?: string;
        
    @Field({nullable: true, description: `Record ID, used only when Type is Record and a specific hardcoded record ID is desired, this is an uncommon use case, helpful for pulling in static types and metadata in some cases.`}) 
    @MaxLength(4000)
    RecordID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true, description: `This field is used only when the Type of the TemplateParam table is "Entity". It is an optional field used to specify the sorting order for the related entity data that is used in the template for the Entity specified.`}) 
    OrderBy?: string;
        
    @Field() 
    @MaxLength(510)
    Template: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Entity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class CreateTemplateParamInput {
    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName: string | null;

    @Field({ nullable: true })
    LinkedParameterField: string | null;

    @Field({ nullable: true })
    ExtraFilter: string | null;

    @Field({ nullable: true })
    EntityID: string | null;

    @Field({ nullable: true })
    RecordID: string | null;

    @Field({ nullable: true })
    OrderBy: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Template Params
//****************************************************************************
@InputType()
export class UpdateTemplateParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    TemplateID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field({ nullable: true })
    LinkedParameterName?: string | null;

    @Field({ nullable: true })
    LinkedParameterField?: string | null;

    @Field({ nullable: true })
    ExtraFilter?: string | null;

    @Field({ nullable: true })
    EntityID?: string | null;

    @Field({ nullable: true })
    RecordID?: string | null;

    @Field({ nullable: true })
    OrderBy?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Params
//****************************************************************************
@ObjectType()
export class RunTemplateParamViewResult {
    @Field(() => [TemplateParam_])
    Results: TemplateParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateParam_)
export class TemplateParamResolver extends ResolverBase {
    @Query(() => RunTemplateParamViewResult)
    async RunTemplateParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateParamViewResult)
    async RunTemplateParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateParamViewResult)
    async RunTemplateParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Params';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => TemplateParam_, { nullable: true })
    async TemplateParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateParam_ | null> {
        this.CheckUserReadPermissions('Template Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Template Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Template Params', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => TemplateParam_)
    async CreateTemplateParam(
        @Arg('input', () => CreateTemplateParamInput) input: CreateTemplateParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Template Params', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateParam_)
    async UpdateTemplateParam(
        @Arg('input', () => UpdateTemplateParamInput) input: UpdateTemplateParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Template Params', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateParam_)
    async DeleteTemplateParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Params', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Template Content Types
//****************************************************************************
@ObjectType({ description: `Template content types for categorizing content within templates` })
export class TemplateContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Name of the template content type`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of the template content type`}) 
    Description?: string;
        
    @Field({description: `Refers to the primary language or codetype of the templates of this type, HTML, JSON, JavaScript, etc`}) 
    @MaxLength(50)
    CodeType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [TemplateContent_])
    TemplateContents_TypeIDArray: TemplateContent_[]; // Link to TemplateContents
    
}

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class CreateTemplateContentTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    CodeType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Template Content Types
//****************************************************************************
@InputType()
export class UpdateTemplateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    CodeType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Template Content Types
//****************************************************************************
@ObjectType()
export class RunTemplateContentTypeViewResult {
    @Field(() => [TemplateContentType_])
    Results: TemplateContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(TemplateContentType_)
export class TemplateContentTypeResolver extends ResolverBase {
    @Query(() => RunTemplateContentTypeViewResult)
    async RunTemplateContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentTypeViewResult)
    async RunTemplateContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunTemplateContentTypeViewResult)
    async RunTemplateContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Template Content Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => TemplateContentType_, { nullable: true })
    async TemplateContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<TemplateContentType_ | null> {
        this.CheckUserReadPermissions('Template Content Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Template Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Template Content Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [TemplateContent_])
    async TemplateContents_TypeIDArray(@Root() templatecontenttype_: TemplateContentType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Template Contents', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwTemplateContents] WHERE [TypeID]='${templatecontenttype_.ID}' ` + this.getRowLevelSecurityWhereClause('Template Contents', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Template Contents', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => TemplateContentType_)
    async CreateTemplateContentType(
        @Arg('input', () => CreateTemplateContentTypeInput) input: CreateTemplateContentTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Template Content Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => TemplateContentType_)
    async UpdateTemplateContentType(
        @Arg('input', () => UpdateTemplateContentTypeInput) input: UpdateTemplateContentTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Template Content Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => TemplateContentType_)
    async DeleteTemplateContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Template Content Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendations
//****************************************************************************
@ObjectType({ description: `Recommendation headers that store the left side of the recommendation which we track in the SourceEntityID/SourceEntityRecordID` })
export class Recommendation_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationRunID: string;
        
    @Field() 
    @MaxLength(16)
    SourceEntityID: string;
        
    @Field({description: `The record ID of the source entity`}) 
    SourceEntityRecordID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    SourceEntity: string;
        
    @Field(() => [RecommendationItem_])
    RecommendationItems_RecommendationIDArray: RecommendationItem_[]; // Link to RecommendationItems
    
}

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class CreateRecommendationInput {
    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendations
//****************************************************************************
@InputType()
export class UpdateRecommendationInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationRunID?: string;

    @Field({ nullable: true })
    SourceEntityID?: string;

    @Field({ nullable: true })
    SourceEntityRecordID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendations
//****************************************************************************
@ObjectType()
export class RunRecommendationViewResult {
    @Field(() => [Recommendation_])
    Results: Recommendation_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(Recommendation_)
export class RecommendationResolver extends ResolverBase {
    @Query(() => RunRecommendationViewResult)
    async RunRecommendationViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationViewResult)
    async RunRecommendationViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationViewResult)
    async RunRecommendationDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendations';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => Recommendation_, { nullable: true })
    async Recommendation(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<Recommendation_ | null> {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Recommendations', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [RecommendationItem_])
    async RecommendationItems_RecommendationIDArray(@Root() recommendation_: Recommendation_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [RecommendationID]='${recommendation_.ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => Recommendation_)
    async CreateRecommendation(
        @Arg('input', () => CreateRecommendationInput) input: CreateRecommendationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Recommendations', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => Recommendation_)
    async UpdateRecommendation(
        @Arg('input', () => UpdateRecommendationInput) input: UpdateRecommendationInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Recommendations', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Providers
//****************************************************************************
@ObjectType({ description: `Recommendation providers details` })
export class RecommendationProvider_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [RecommendationRun_])
    RecommendationRuns_RecommendationProviderIDArray: RecommendationRun_[]; // Link to RecommendationRuns
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class CreateRecommendationProviderInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Providers
//****************************************************************************
@InputType()
export class UpdateRecommendationProviderInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Providers
//****************************************************************************
@ObjectType()
export class RunRecommendationProviderViewResult {
    @Field(() => [RecommendationProvider_])
    Results: RecommendationProvider_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecommendationProvider_)
export class RecommendationProviderResolver extends ResolverBase {
    @Query(() => RunRecommendationProviderViewResult)
    async RunRecommendationProviderViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationProviderViewResult)
    async RunRecommendationProviderViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationProviderViewResult)
    async RunRecommendationProviderDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Providers';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecommendationProvider_, { nullable: true })
    async RecommendationProvider(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecommendationProvider_ | null> {
        this.CheckUserReadPermissions('Recommendation Providers', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationProviders] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Providers', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Recommendation Providers', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [RecommendationRun_])
    async RecommendationRuns_RecommendationProviderIDArray(@Root() recommendationprovider_: RecommendationProvider_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [RecommendationProviderID]='${recommendationprovider_.ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendation Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => RecommendationProvider_)
    async CreateRecommendationProvider(
        @Arg('input', () => CreateRecommendationProviderInput) input: CreateRecommendationProviderInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Recommendation Providers', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecommendationProvider_)
    async UpdateRecommendationProvider(
        @Arg('input', () => UpdateRecommendationProviderInput) input: UpdateRecommendationProviderInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Recommendation Providers', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => RecommendationProvider_)
    async DeleteRecommendationProvider(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Recommendation Providers', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Runs
//****************************************************************************
@ObjectType({ description: `Recommendation runs log each time a provider is requested to provide recommendations` })
export class RecommendationRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationProviderID: string;
        
    @Field({description: `The start date of the recommendation run`}) 
    @MaxLength(8)
    StartDate: Date;
        
    @Field({nullable: true, description: `The end date of the recommendation run`}) 
    @MaxLength(8)
    EndDate?: Date;
        
    @Field({description: `The status of the recommendation run`}) 
    @MaxLength(100)
    Status: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    RunByUserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    RecommendationProvider: string;
        
    @Field() 
    @MaxLength(200)
    RunByUser: string;
        
    @Field(() => [Recommendation_])
    Recommendations_RecommendationRunIDArray: Recommendation_[]; // Link to Recommendations
    
}

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class CreateRecommendationRunInput {
    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Runs
//****************************************************************************
@InputType()
export class UpdateRecommendationRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationProviderID?: string;

    @Field({ nullable: true })
    StartDate?: Date;

    @Field({ nullable: true })
    EndDate?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RunByUserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Runs
//****************************************************************************
@ObjectType()
export class RunRecommendationRunViewResult {
    @Field(() => [RecommendationRun_])
    Results: RecommendationRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecommendationRun_)
export class RecommendationRunResolver extends ResolverBase {
    @Query(() => RunRecommendationRunViewResult)
    async RunRecommendationRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationRunViewResult)
    async RunRecommendationRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationRunViewResult)
    async RunRecommendationRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecommendationRun_, { nullable: true })
    async RecommendationRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecommendationRun_ | null> {
        this.CheckUserReadPermissions('Recommendation Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Recommendation Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [Recommendation_])
    async Recommendations_RecommendationRunIDArray(@Root() recommendationrun_: RecommendationRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Recommendations', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendations] WHERE [RecommendationRunID]='${recommendationrun_.ID}' ` + this.getRowLevelSecurityWhereClause('Recommendations', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Recommendations', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => RecommendationRun_)
    async CreateRecommendationRun(
        @Arg('input', () => CreateRecommendationRunInput) input: CreateRecommendationRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Recommendation Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecommendationRun_)
    async UpdateRecommendationRun(
        @Arg('input', () => UpdateRecommendationRunInput) input: UpdateRecommendationRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Recommendation Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Recommendation Items
//****************************************************************************
@ObjectType({ description: `Table to store individual recommendation items that are the right side of the recommendation which we track in the DestinationEntityID/DestinationEntityRecordID` })
export class RecommendationItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    RecommendationID: string;
        
    @Field() 
    @MaxLength(16)
    DestinationEntityID: string;
        
    @Field({description: `The record ID of the destination entity`}) 
    @MaxLength(900)
    DestinationEntityRecordID: string;
        
    @Field(() => Float, {nullable: true, description: `A value between 0 and 1 indicating the probability of the match, higher numbers indicating a more certain match/recommendation.`}) 
    MatchProbability?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    DestinationEntity: string;
        
}

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class CreateRecommendationItemInput {
    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Recommendation Items
//****************************************************************************
@InputType()
export class UpdateRecommendationItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    RecommendationID?: string;

    @Field({ nullable: true })
    DestinationEntityID?: string;

    @Field({ nullable: true })
    DestinationEntityRecordID?: string;

    @Field(() => Float, { nullable: true })
    MatchProbability?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Recommendation Items
//****************************************************************************
@ObjectType()
export class RunRecommendationItemViewResult {
    @Field(() => [RecommendationItem_])
    Results: RecommendationItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecommendationItem_)
export class RecommendationItemResolver extends ResolverBase {
    @Query(() => RunRecommendationItemViewResult)
    async RunRecommendationItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationItemViewResult)
    async RunRecommendationItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecommendationItemViewResult)
    async RunRecommendationItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Recommendation Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecommendationItem_, { nullable: true })
    async RecommendationItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecommendationItem_ | null> {
        this.CheckUserReadPermissions('Recommendation Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecommendationItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Recommendation Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Recommendation Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => RecommendationItem_)
    async CreateRecommendationItem(
        @Arg('input', () => CreateRecommendationItemInput) input: CreateRecommendationItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Recommendation Items', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecommendationItem_)
    async UpdateRecommendationItem(
        @Arg('input', () => UpdateRecommendationItemInput) input: UpdateRecommendationItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Recommendation Items', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Message Types
//****************************************************************************
@ObjectType({ description: `Mapping between entities and communication base message types` })
export class EntityCommunicationMessageType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(16)
    BaseMessageTypeID: string;
        
    @Field(() => Boolean, {description: `Indicates whether the message type is active`}) 
    IsActive: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
    @Field() 
    @MaxLength(200)
    BaseMessageType: string;
        
    @Field(() => [EntityCommunicationField_])
    EntityCommunicationFields_EntityCommunicationMessageTypeIDArray: EntityCommunicationField_[]; // Link to EntityCommunicationFields
    
}

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class CreateEntityCommunicationMessageTypeInput {
    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Message Types
//****************************************************************************
@InputType()
export class UpdateEntityCommunicationMessageTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field({ nullable: true })
    BaseMessageTypeID?: string;

    @Field(() => Boolean, { nullable: true })
    IsActive?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Message Types
//****************************************************************************
@ObjectType()
export class RunEntityCommunicationMessageTypeViewResult {
    @Field(() => [EntityCommunicationMessageType_])
    Results: EntityCommunicationMessageType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityCommunicationMessageType_)
export class EntityCommunicationMessageTypeResolver extends ResolverBase {
    @Query(() => RunEntityCommunicationMessageTypeViewResult)
    async RunEntityCommunicationMessageTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationMessageTypeViewResult)
    async RunEntityCommunicationMessageTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationMessageTypeViewResult)
    async RunEntityCommunicationMessageTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Message Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityCommunicationMessageType_, { nullable: true })
    async EntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityCommunicationMessageType_ | null> {
        this.CheckUserReadPermissions('Entity Communication Message Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationMessageTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Communication Message Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Communication Message Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityCommunicationField_])
    async EntityCommunicationFields_EntityCommunicationMessageTypeIDArray(@Root() entitycommunicationmessagetype_: EntityCommunicationMessageType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [EntityCommunicationMessageTypeID]='${entitycommunicationmessagetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Communication Fields', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityCommunicationMessageType_)
    async CreateEntityCommunicationMessageType(
        @Arg('input', () => CreateEntityCommunicationMessageTypeInput) input: CreateEntityCommunicationMessageTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Communication Message Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityCommunicationMessageType_)
    async UpdateEntityCommunicationMessageType(
        @Arg('input', () => UpdateEntityCommunicationMessageTypeInput) input: UpdateEntityCommunicationMessageTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Communication Message Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityCommunicationMessageType_)
    async DeleteEntityCommunicationMessageType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Message Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Communication Fields
//****************************************************************************
@ObjectType({ description: `Mapping between entity fields and communication base message types with priority` })
export class EntityCommunicationField_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityCommunicationMessageTypeID: string;
        
    @Field({description: `Name of the field in the entity that maps to the communication base message type`}) 
    @MaxLength(1000)
    FieldName: string;
        
    @Field(() => Int, {description: `Priority of the field for the communication base message type`}) 
    Priority: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class CreateEntityCommunicationFieldInput {
    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;
}
    

//****************************************************************************
// INPUT TYPE for Entity Communication Fields
//****************************************************************************
@InputType()
export class UpdateEntityCommunicationFieldInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityCommunicationMessageTypeID?: string;

    @Field({ nullable: true })
    FieldName?: string;

    @Field(() => Int, { nullable: true })
    Priority?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Communication Fields
//****************************************************************************
@ObjectType()
export class RunEntityCommunicationFieldViewResult {
    @Field(() => [EntityCommunicationField_])
    Results: EntityCommunicationField_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityCommunicationField_)
export class EntityCommunicationFieldResolver extends ResolverBase {
    @Query(() => RunEntityCommunicationFieldViewResult)
    async RunEntityCommunicationFieldViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationFieldViewResult)
    async RunEntityCommunicationFieldViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityCommunicationFieldViewResult)
    async RunEntityCommunicationFieldDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Communication Fields';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityCommunicationField_, { nullable: true })
    async EntityCommunicationField(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityCommunicationField_ | null> {
        this.CheckUserReadPermissions('Entity Communication Fields', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityCommunicationFields] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Communication Fields', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Communication Fields', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityCommunicationField_)
    async CreateEntityCommunicationField(
        @Arg('input', () => CreateEntityCommunicationFieldInput) input: CreateEntityCommunicationFieldInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Communication Fields', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityCommunicationField_)
    async UpdateEntityCommunicationField(
        @Arg('input', () => UpdateEntityCommunicationFieldInput) input: UpdateEntityCommunicationFieldInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Communication Fields', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityCommunicationField_)
    async DeleteEntityCommunicationField(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Communication Fields', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Record Change Replay Runs
//****************************************************************************
@ObjectType({ description: `Table to track the runs of replaying external record changes` })
export class RecordChangeReplayRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Timestamp when the replay run started`}) 
    @MaxLength(8)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp when the replay run ended`}) 
    @MaxLength(8)
    EndedAt?: Date;
        
    @Field({description: `Status of the replay run (Pending, In Progress, Complete, Error)`}) 
    @MaxLength(100)
    Status: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field(() => [RecordChange_])
    RecordChanges_ReplayRunIDArray: RecordChange_[]; // Link to RecordChanges
    
}

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class CreateRecordChangeReplayRunInput {
    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Record Change Replay Runs
//****************************************************************************
@InputType()
export class UpdateRecordChangeReplayRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Record Change Replay Runs
//****************************************************************************
@ObjectType()
export class RunRecordChangeReplayRunViewResult {
    @Field(() => [RecordChangeReplayRun_])
    Results: RecordChangeReplayRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(RecordChangeReplayRun_)
export class RecordChangeReplayRunResolver extends ResolverBase {
    @Query(() => RunRecordChangeReplayRunViewResult)
    async RunRecordChangeReplayRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeReplayRunViewResult)
    async RunRecordChangeReplayRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunRecordChangeReplayRunViewResult)
    async RunRecordChangeReplayRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Record Change Replay Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => RecordChangeReplayRun_, { nullable: true })
    async RecordChangeReplayRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<RecordChangeReplayRun_ | null> {
        this.CheckUserReadPermissions('Record Change Replay Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChangeReplayRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Record Change Replay Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Record Change Replay Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [RecordChange_])
    async RecordChanges_ReplayRunIDArray(@Root() recordchangereplayrun_: RecordChangeReplayRun_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Record Changes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwRecordChanges] WHERE [ReplayRunID]='${recordchangereplayrun_.ID}' ` + this.getRowLevelSecurityWhereClause('Record Changes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Record Changes', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => RecordChangeReplayRun_)
    async CreateRecordChangeReplayRun(
        @Arg('input', () => CreateRecordChangeReplayRunInput) input: CreateRecordChangeReplayRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Record Change Replay Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => RecordChangeReplayRun_)
    async UpdateRecordChangeReplayRun(
        @Arg('input', () => UpdateRecordChangeReplayRunInput) input: UpdateRecordChangeReplayRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Record Change Replay Runs', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Library Items
//****************************************************************************
@ObjectType({ description: `Table to store individual library items` })
export class LibraryItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field() 
    @MaxLength(16)
    LibraryID: string;
        
    @Field({description: `Type of the library item for example Class, Interface, etc.`}) 
    @MaxLength(100)
    Type: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Library: string;
        
}

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class CreateLibraryItemInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;
}
    

//****************************************************************************
// INPUT TYPE for Library Items
//****************************************************************************
@InputType()
export class UpdateLibraryItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    LibraryID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Library Items
//****************************************************************************
@ObjectType()
export class RunLibraryItemViewResult {
    @Field(() => [LibraryItem_])
    Results: LibraryItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(LibraryItem_)
export class LibraryItemResolver extends ResolverBase {
    @Query(() => RunLibraryItemViewResult)
    async RunLibraryItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunLibraryItemViewResult)
    async RunLibraryItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunLibraryItemViewResult)
    async RunLibraryItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Library Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => LibraryItem_, { nullable: true })
    async LibraryItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<LibraryItem_ | null> {
        this.CheckUserReadPermissions('Library Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwLibraryItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Library Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Library Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => LibraryItem_)
    async CreateLibraryItem(
        @Arg('input', () => CreateLibraryItemInput) input: CreateLibraryItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Library Items', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => LibraryItem_)
    async UpdateLibraryItem(
        @Arg('input', () => UpdateLibraryItemInput) input: UpdateLibraryItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Library Items', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => LibraryItem_)
    async DeleteLibraryItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Library Items', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Relationship Display Components
//****************************************************************************
@ObjectType({ description: `This table stores a list of components that are available for displaying relationships in the MJ Explorer UI` })
export class EntityRelationshipDisplayComponent_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({description: `The type of relationship the component displays. Valid values are "One to Many", "Many to Many", or "Both".`}) 
    @MaxLength(40)
    RelationshipType: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [EntityRelationship_])
    EntityRelationships_DisplayComponentIDArray: EntityRelationship_[]; // Link to EntityRelationships
    
}

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class CreateEntityRelationshipDisplayComponentInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;
}
    

//****************************************************************************
// INPUT TYPE for Entity Relationship Display Components
//****************************************************************************
@InputType()
export class UpdateEntityRelationshipDisplayComponentInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    RelationshipType?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Relationship Display Components
//****************************************************************************
@ObjectType()
export class RunEntityRelationshipDisplayComponentViewResult {
    @Field(() => [EntityRelationshipDisplayComponent_])
    Results: EntityRelationshipDisplayComponent_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityRelationshipDisplayComponent_)
export class EntityRelationshipDisplayComponentResolver extends ResolverBase {
    @Query(() => RunEntityRelationshipDisplayComponentViewResult)
    async RunEntityRelationshipDisplayComponentViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipDisplayComponentViewResult)
    async RunEntityRelationshipDisplayComponentViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityRelationshipDisplayComponentViewResult)
    async RunEntityRelationshipDisplayComponentDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Relationship Display Components';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityRelationshipDisplayComponent_, { nullable: true })
    async EntityRelationshipDisplayComponent(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityRelationshipDisplayComponent_ | null> {
        this.CheckUserReadPermissions('Entity Relationship Display Components', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationshipDisplayComponents] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Relationship Display Components', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Relationship Display Components', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [EntityRelationship_])
    async EntityRelationships_DisplayComponentIDArray(@Root() entityrelationshipdisplaycomponent_: EntityRelationshipDisplayComponent_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Entity Relationships', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityRelationships] WHERE [DisplayComponentID]='${entityrelationshipdisplaycomponent_.ID}' ` + this.getRowLevelSecurityWhereClause('Entity Relationships', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Entity Relationships', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => EntityRelationshipDisplayComponent_)
    async CreateEntityRelationshipDisplayComponent(
        @Arg('input', () => CreateEntityRelationshipDisplayComponentInput) input: CreateEntityRelationshipDisplayComponentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Relationship Display Components', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityRelationshipDisplayComponent_)
    async UpdateEntityRelationshipDisplayComponent(
        @Arg('input', () => UpdateEntityRelationshipDisplayComponentInput) input: UpdateEntityRelationshipDisplayComponentInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Relationship Display Components', input, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Entity Action Params
//****************************************************************************
@ObjectType({ description: `Stores paramater mappings to enable Entity Actions to automatically invoke Actions` })
export class EntityActionParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    EntityActionID: string;
        
    @Field() 
    @MaxLength(16)
    ActionParamID: string;
        
    @Field({description: `Type of the value, which can be Static, Entity Object, or Script.`}) 
    @MaxLength(40)
    ValueType: string;
        
    @Field({nullable: true, description: `Value of the parameter, used only when ValueType is Static or Script. When value is Script, any valid JavaScript code can be provided. The script will have access to an object called EntityActionContext. This object will have a property called EntityObject on it that will contain the BaseEntity derived sub-class with the current data for the entity object this action is operating against. The script must provide the parameter value to the EntityActionContext.result property. This scripting capabilty is designed for very small and simple code, for anything of meaningful complexity, create a sub-class instead.`}) 
    Value?: string;
        
    @Field({nullable: true, description: `Additional comments regarding the parameter.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ActionParam: string;
        
}

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class CreateEntityActionParamInput {
    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Entity Action Params
//****************************************************************************
@InputType()
export class UpdateEntityActionParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    EntityActionID?: string;

    @Field({ nullable: true })
    ActionParamID?: string;

    @Field({ nullable: true })
    ValueType?: string;

    @Field({ nullable: true })
    Value?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Entity Action Params
//****************************************************************************
@ObjectType()
export class RunEntityActionParamViewResult {
    @Field(() => [EntityActionParam_])
    Results: EntityActionParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(EntityActionParam_)
export class EntityActionParamResolver extends ResolverBase {
    @Query(() => RunEntityActionParamViewResult)
    async RunEntityActionParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionParamViewResult)
    async RunEntityActionParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunEntityActionParamViewResult)
    async RunEntityActionParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Entity Action Params';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => EntityActionParam_, { nullable: true })
    async EntityActionParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<EntityActionParam_ | null> {
        this.CheckUserReadPermissions('Entity Action Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwEntityActionParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Entity Action Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Entity Action Params', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => EntityActionParam_)
    async CreateEntityActionParam(
        @Arg('input', () => CreateEntityActionParamInput) input: CreateEntityActionParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Entity Action Params', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => EntityActionParam_)
    async UpdateEntityActionParam(
        @Arg('input', () => UpdateEntityActionParamInput) input: UpdateEntityActionParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Entity Action Params', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => EntityActionParam_)
    async DeleteEntityActionParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Entity Action Params', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Permissions
//****************************************************************************
@ObjectType({ description: `Table for managing sharing of resources to users or roles with time constraints and permission levels` })
export class ResourcePermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the type of resource being shared (View, Dashboard, Report, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being shared`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({description: `The level of sharing either Role or User`}) 
    @MaxLength(20)
    Type: string;
        
    @Field({nullable: true, description: `Optional: Date when sharing starts`}) 
    @MaxLength(10)
    StartSharingAt?: Date;
        
    @Field({nullable: true, description: `Optional: Date when sharing ends`}) 
    @MaxLength(10)
    EndSharingAt?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    RoleID?: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    UserID?: string;
        
    @Field({nullable: true, description: `Permission level defining the type of access (View, Edit, Owner)`}) 
    @MaxLength(40)
    PermissionLevel?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({description: `Status of the resource permission request. Possible values are Requested, Approved, Rejected, or Revoked.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Role?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    User?: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class CreateResourcePermissionInput {
    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt: Date | null;

    @Field({ nullable: true })
    EndSharingAt: Date | null;

    @Field({ nullable: true })
    RoleID: string | null;

    @Field({ nullable: true })
    UserID: string | null;

    @Field({ nullable: true })
    PermissionLevel: string | null;

    @Field({ nullable: true })
    Status?: string;
}
    

//****************************************************************************
// INPUT TYPE for Resource Permissions
//****************************************************************************
@InputType()
export class UpdateResourcePermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    Type?: string;

    @Field({ nullable: true })
    StartSharingAt?: Date | null;

    @Field({ nullable: true })
    EndSharingAt?: Date | null;

    @Field({ nullable: true })
    RoleID?: string | null;

    @Field({ nullable: true })
    UserID?: string | null;

    @Field({ nullable: true })
    PermissionLevel?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Permissions
//****************************************************************************
@ObjectType()
export class RunResourcePermissionViewResult {
    @Field(() => [ResourcePermission_])
    Results: ResourcePermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ResourcePermission_)
export class ResourcePermissionResolver extends ResolverBase {
    @Query(() => RunResourcePermissionViewResult)
    async RunResourcePermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunResourcePermissionViewResult)
    async RunResourcePermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunResourcePermissionViewResult)
    async RunResourcePermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Permissions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ResourcePermission_, { nullable: true })
    async ResourcePermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ResourcePermission_ | null> {
        this.CheckUserReadPermissions('Resource Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourcePermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Resource Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Resource Permissions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ResourcePermission_)
    async CreateResourcePermission(
        @Arg('input', () => CreateResourcePermissionInput) input: CreateResourcePermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Resource Permissions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ResourcePermission_)
    async UpdateResourcePermission(
        @Arg('input', () => UpdateResourcePermissionInput) input: UpdateResourcePermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Resource Permissions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ResourcePermission_)
    async DeleteResourcePermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Permissions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Resource Links
//****************************************************************************
@ObjectType({ description: `Table to track user links to shared resources such as views, dashboards, etc.` })
export class ResourceLink_ {
    @Field({description: `Unique identifier for each resource link`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key to the user linking the resource`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Foreign key to the resource type (view, dashboard, etc.)`}) 
    @MaxLength(16)
    ResourceTypeID: string;
        
    @Field({description: `ID of the specific resource being linked`}) 
    @MaxLength(510)
    ResourceRecordID: string;
        
    @Field({nullable: true, description: `Optional folder where the user organizes the linked resource`}) 
    @MaxLength(510)
    FolderID?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
    @Field() 
    @MaxLength(510)
    ResourceType: string;
        
}

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class CreateResourceLinkInput {
    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Resource Links
//****************************************************************************
@InputType()
export class UpdateResourceLinkInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ResourceTypeID?: string;

    @Field({ nullable: true })
    ResourceRecordID?: string;

    @Field({ nullable: true })
    FolderID?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Resource Links
//****************************************************************************
@ObjectType()
export class RunResourceLinkViewResult {
    @Field(() => [ResourceLink_])
    Results: ResourceLink_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ResourceLink_)
export class ResourceLinkResolver extends ResolverBase {
    @Query(() => RunResourceLinkViewResult)
    async RunResourceLinkViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunResourceLinkViewResult)
    async RunResourceLinkViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunResourceLinkViewResult)
    async RunResourceLinkDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Resource Links';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ResourceLink_, { nullable: true })
    async ResourceLink(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ResourceLink_ | null> {
        this.CheckUserReadPermissions('Resource Links', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwResourceLinks] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Resource Links', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Resource Links', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ResourceLink_)
    async CreateResourceLink(
        @Arg('input', () => CreateResourceLinkInput) input: CreateResourceLinkInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Resource Links', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ResourceLink_)
    async UpdateResourceLink(
        @Arg('input', () => UpdateResourceLinkInput) input: UpdateResourceLinkInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Resource Links', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ResourceLink_)
    async DeleteResourceLink(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Resource Links', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType()
export class ConversationArtifactVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the parent artifact`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field(() => Int, {description: `Sequential version number (starting from 1) for this artifact`}) 
    Version: number;
        
    @Field({description: `JSON configuration and metadata for this artifact version`}) 
    Configuration: string;
        
    @Field({nullable: true, description: `Actual content of the artifact, if stored separately from configuration`}) 
    Content?: string;
        
    @Field({nullable: true, description: `User comments specific to this version`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class CreateConversationArtifactVersionInput {
    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content: string | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Versions
//****************************************************************************
@InputType()
export class UpdateConversationArtifactVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field(() => Int, { nullable: true })
    Version?: number;

    @Field({ nullable: true })
    Configuration?: string;

    @Field({ nullable: true })
    Content?: string | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Versions
//****************************************************************************
@ObjectType()
export class RunConversationArtifactVersionViewResult {
    @Field(() => [ConversationArtifactVersion_])
    Results: ConversationArtifactVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationArtifactVersion_)
export class ConversationArtifactVersionResolver extends ResolverBase {
    @Query(() => RunConversationArtifactVersionViewResult)
    async RunConversationArtifactVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactVersionViewResult)
    async RunConversationArtifactVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactVersionViewResult)
    async RunConversationArtifactVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Versions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ConversationArtifactVersion_, { nullable: true })
    async ConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationArtifactVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ConversationArtifactVersion_)
    async CreateConversationArtifactVersion(
        @Arg('input', () => CreateConversationArtifactVersionInput) input: CreateConversationArtifactVersionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('MJ: Conversation Artifact Versions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationArtifactVersion_)
    async UpdateConversationArtifactVersion(
        @Arg('input', () => UpdateConversationArtifactVersionInput) input: UpdateConversationArtifactVersionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('MJ: Conversation Artifact Versions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationArtifactVersion_)
    async DeleteConversationArtifactVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Versions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Requests
//****************************************************************************
@ObjectType()
export class AIAgentRequest_ {
    @Field({description: `Primary key for the AIAgentRequest table, uniquely identifies each record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Foreign key referencing the ID column in the AIAgent table.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp when the request was made by the agent.`}) 
    @MaxLength(8)
    RequestedAt: Date;
        
    @Field({nullable: true, description: `Optional, a user that the AI specifically is directing the request to, if null intended for general system owner.`}) 
    @MaxLength(16)
    RequestForUserID?: string;
        
    @Field({description: `Current status of the request (Requested, Approved, Rejected, Canceled).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Details of what the AI Agent is requesting.`}) 
    Request: string;
        
    @Field({nullable: true, description: `Response provided by the human to the agent request.`}) 
    Response?: string;
        
    @Field({nullable: true, description: `Populated when a user responds indicating which user responded to the request.`}) 
    @MaxLength(16)
    ResponseByUserID?: string;
        
    @Field({nullable: true, description: `Timestamp when the response was provided by the human.`}) 
    @MaxLength(8)
    RespondedAt?: Date;
        
    @Field({nullable: true, description: `Additional comments about the request. Not shared with the agent, purely record keeping.`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    RequestForUser?: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    ResponseByUser?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class CreateAIAgentRequestInput {
    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response: string | null;

    @Field({ nullable: true })
    ResponseByUserID: string | null;

    @Field({ nullable: true })
    RespondedAt: Date | null;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Requests
//****************************************************************************
@InputType()
export class UpdateAIAgentRequestInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    RequestedAt?: Date;

    @Field({ nullable: true })
    RequestForUserID?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Request?: string;

    @Field({ nullable: true })
    Response?: string | null;

    @Field({ nullable: true })
    ResponseByUserID?: string | null;

    @Field({ nullable: true })
    RespondedAt?: Date | null;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Requests
//****************************************************************************
@ObjectType()
export class RunAIAgentRequestViewResult {
    @Field(() => [AIAgentRequest_])
    Results: AIAgentRequest_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentRequest_)
export class AIAgentRequestResolver extends ResolverBase {
    @Query(() => RunAIAgentRequestViewResult)
    async RunAIAgentRequestViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRequestViewResult)
    async RunAIAgentRequestViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentRequestViewResult)
    async RunAIAgentRequestDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Requests';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgentRequest_, { nullable: true })
    async AIAgentRequest(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentRequest_ | null> {
        this.CheckUserReadPermissions('AI Agent Requests', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentRequests] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Requests', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agent Requests', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AIAgentRequest_)
    async CreateAIAgentRequest(
        @Arg('input', () => CreateAIAgentRequestInput) input: CreateAIAgentRequestInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agent Requests', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentRequest_)
    async UpdateAIAgentRequest(
        @Arg('input', () => UpdateAIAgentRequestInput) input: UpdateAIAgentRequestInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agent Requests', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentRequest_)
    async DeleteAIAgentRequest(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Requests', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report User States
//****************************************************************************
@ObjectType()
export class ReportUserState_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field() 
    @MaxLength(16)
    UserID: string;
        
    @Field({nullable: true, description: `JSON serialized state of user interaction with the report`}) 
    ReportState?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
    @Field() 
    @MaxLength(200)
    User: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class CreateReportUserStateInput {
    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report User States
//****************************************************************************
@InputType()
export class UpdateReportUserStateInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    ReportState?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report User States
//****************************************************************************
@ObjectType()
export class RunReportUserStateViewResult {
    @Field(() => [ReportUserState_])
    Results: ReportUserState_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportUserState_)
export class ReportUserStateResolver extends ResolverBase {
    @Query(() => RunReportUserStateViewResult)
    async RunReportUserStateViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportUserStateViewResult)
    async RunReportUserStateViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportUserStateViewResult)
    async RunReportUserStateDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report User States';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ReportUserState_, { nullable: true })
    async ReportUserState(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportUserState_ | null> {
        this.CheckUserReadPermissions('MJ: Report User States', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportUserStates] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Report User States', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('MJ: Report User States', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ReportUserState_)
    async CreateReportUserState(
        @Arg('input', () => CreateReportUserStateInput) input: CreateReportUserStateInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('MJ: Report User States', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ReportUserState_)
    async UpdateReportUserState(
        @Arg('input', () => UpdateReportUserStateInput) input: UpdateReportUserStateInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('MJ: Report User States', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ReportUserState_)
    async DeleteReportUserState(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report User States', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Query Entities
//****************************************************************************
@ObjectType({ description: `Tracks which entities are involved in a given query. The Queries table stores SQL and descriptions for stored queries that can be executed and serve as examples for AI.` })
export class QueryEntity_ {
    @Field({description: `Unique identifier for the QueryEntity record.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `References the ID of the query in the Queries table.`}) 
    @MaxLength(16)
    QueryID: string;
        
    @Field({description: `References the ID of the entity in the Entities table.`}) 
    @MaxLength(16)
    EntityID: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Query: string;
        
    @Field() 
    @MaxLength(510)
    Entity: string;
        
}

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class CreateQueryEntityInput {
    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;
}
    

//****************************************************************************
// INPUT TYPE for Query Entities
//****************************************************************************
@InputType()
export class UpdateQueryEntityInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    QueryID?: string;

    @Field({ nullable: true })
    EntityID?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Query Entities
//****************************************************************************
@ObjectType()
export class RunQueryEntityViewResult {
    @Field(() => [QueryEntity_])
    Results: QueryEntity_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(QueryEntity_)
export class QueryEntityResolver extends ResolverBase {
    @Query(() => RunQueryEntityViewResult)
    async RunQueryEntityViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryEntityViewResult)
    async RunQueryEntityViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunQueryEntityViewResult)
    async RunQueryEntityDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Query Entities';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => QueryEntity_, { nullable: true })
    async QueryEntity(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<QueryEntity_ | null> {
        this.CheckUserReadPermissions('Query Entities', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwQueryEntities] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Query Entities', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Query Entities', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => QueryEntity_)
    async CreateQueryEntity(
        @Arg('input', () => CreateQueryEntityInput) input: CreateQueryEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Query Entities', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => QueryEntity_)
    async UpdateQueryEntity(
        @Arg('input', () => UpdateQueryEntityInput) input: UpdateQueryEntityInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Query Entities', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => QueryEntity_)
    async DeleteQueryEntity(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Query Entities', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Artifact Types
//****************************************************************************
@ObjectType()
export class ArtifactType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact type`}) 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true, description: `Detailed description of the artifact type`}) 
    Description?: string;
        
    @Field({description: `MIME type or content identifier for this artifact type`}) 
    @MaxLength(200)
    ContentType: string;
        
    @Field(() => Boolean, {description: `Indicates if this artifact type is currently available for use`}) 
    IsEnabled: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ConversationArtifact_])
    MJ_ConversationArtifacts_ArtifactTypeIDArray: ConversationArtifact_[]; // Link to MJ_ConversationArtifacts
    
}

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class CreateArtifactTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Artifact Types
//****************************************************************************
@InputType()
export class UpdateArtifactTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentType?: string;

    @Field(() => Boolean, { nullable: true })
    IsEnabled?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Artifact Types
//****************************************************************************
@ObjectType()
export class RunArtifactTypeViewResult {
    @Field(() => [ArtifactType_])
    Results: ArtifactType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ArtifactType_)
export class ArtifactTypeResolver extends ResolverBase {
    @Query(() => RunArtifactTypeViewResult)
    async RunArtifactTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunArtifactTypeViewResult)
    async RunArtifactTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunArtifactTypeViewResult)
    async RunArtifactTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Artifact Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ArtifactType_, { nullable: true })
    async ArtifactType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ArtifactType_ | null> {
        this.CheckUserReadPermissions('MJ: Artifact Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwArtifactTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Artifact Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('MJ: Artifact Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ConversationArtifact_])
    async MJ_ConversationArtifacts_ArtifactTypeIDArray(@Root() artifacttype_: ArtifactType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ArtifactTypeID]='${artifacttype_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifacts', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ArtifactType_)
    async CreateArtifactType(
        @Arg('input', () => CreateArtifactTypeInput) input: CreateArtifactTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('MJ: Artifact Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ArtifactType_)
    async UpdateArtifactType(
        @Arg('input', () => UpdateArtifactTypeInput) input: UpdateArtifactTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('MJ: Artifact Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ArtifactType_)
    async DeleteArtifactType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Artifact Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType()
export class ConversationArtifact_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Display name of the artifact`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Extended description of the artifact`}) 
    Description?: string;
        
    @Field({description: `Reference to the conversation this artifact belongs to`}) 
    @MaxLength(16)
    ConversationID: string;
        
    @Field({description: `Reference to the type of artifact`}) 
    @MaxLength(16)
    ArtifactTypeID: string;
        
    @Field({description: `Controls who can view this artifact (None, SpecificUsers, Everyone, Public)`}) 
    @MaxLength(100)
    SharingScope: string;
        
    @Field({nullable: true, description: `User comments about the artifact`}) 
    Comments?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Conversation?: string;
        
    @Field() 
    @MaxLength(200)
    ArtifactType: string;
        
    @Field(() => [ConversationArtifactPermission_])
    MJ_ConversationArtifactPermissions_ConversationArtifactIDArray: ConversationArtifactPermission_[]; // Link to MJ_ConversationArtifactPermissions
    
    @Field(() => [ConversationArtifactVersion_])
    MJ_ConversationArtifactVersions_ConversationArtifactIDArray: ConversationArtifactVersion_[]; // Link to MJ_ConversationArtifactVersions
    
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class CreateConversationArtifactInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments: string | null;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifacts
//****************************************************************************
@InputType()
export class UpdateConversationArtifactInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ConversationID?: string;

    @Field({ nullable: true })
    ArtifactTypeID?: string;

    @Field({ nullable: true })
    SharingScope?: string;

    @Field({ nullable: true })
    Comments?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifacts
//****************************************************************************
@ObjectType()
export class RunConversationArtifactViewResult {
    @Field(() => [ConversationArtifact_])
    Results: ConversationArtifact_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationArtifact_)
export class ConversationArtifactResolver extends ResolverBase {
    @Query(() => RunConversationArtifactViewResult)
    async RunConversationArtifactViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactViewResult)
    async RunConversationArtifactViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactViewResult)
    async RunConversationArtifactDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifacts';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ConversationArtifact_, { nullable: true })
    async ConversationArtifact(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationArtifact_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifacts', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifacts] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifacts', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifacts', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ConversationArtifactPermission_])
    async MJ_ConversationArtifactPermissions_ConversationArtifactIDArray(@Root() conversationartifact_: ConversationArtifact_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ConversationArtifactID]='${conversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ConversationArtifactVersion_])
    async MJ_ConversationArtifactVersions_ConversationArtifactIDArray(@Root() conversationartifact_: ConversationArtifact_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Versions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactVersions] WHERE [ConversationArtifactID]='${conversationartifact_.ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifact Versions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('MJ: Conversation Artifact Versions', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ConversationArtifact_)
    async CreateConversationArtifact(
        @Arg('input', () => CreateConversationArtifactInput) input: CreateConversationArtifactInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('MJ: Conversation Artifacts', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationArtifact_)
    async UpdateConversationArtifact(
        @Arg('input', () => UpdateConversationArtifactInput) input: UpdateConversationArtifactInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('MJ: Conversation Artifacts', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationArtifact_)
    async DeleteConversationArtifact(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifacts', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Process Runs
//****************************************************************************
@ObjectType()
export class ContentProcessRun_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    SourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    StartTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(8)
    EndTime?: Date;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Status?: string;
        
    @Field(() => Int, {nullable: true}) 
    ProcessedItems?: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Source?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class CreateContentProcessRunInput {
    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime: Date | null;

    @Field({ nullable: true })
    EndTime: Date | null;

    @Field({ nullable: true })
    Status: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems: number | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Process Runs
//****************************************************************************
@InputType()
export class UpdateContentProcessRunInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    SourceID?: string;

    @Field({ nullable: true })
    StartTime?: Date | null;

    @Field({ nullable: true })
    EndTime?: Date | null;

    @Field({ nullable: true })
    Status?: string | null;

    @Field(() => Int, { nullable: true })
    ProcessedItems?: number | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Process Runs
//****************************************************************************
@ObjectType()
export class RunContentProcessRunViewResult {
    @Field(() => [ContentProcessRun_])
    Results: ContentProcessRun_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentProcessRun_)
export class ContentProcessRunResolver extends ResolverBase {
    @Query(() => RunContentProcessRunViewResult)
    async RunContentProcessRunViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentProcessRunViewResult)
    async RunContentProcessRunViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentProcessRunViewResult)
    async RunContentProcessRunDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Process Runs';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentProcessRun_, { nullable: true })
    async ContentProcessRun(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentProcessRun_ | null> {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Process Runs', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ContentProcessRun_)
    async CreateContentProcessRun(
        @Arg('input', () => CreateContentProcessRunInput) input: CreateContentProcessRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Process Runs', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentProcessRun_)
    async UpdateContentProcessRun(
        @Arg('input', () => UpdateContentProcessRunInput) input: UpdateContentProcessRunInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Process Runs', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentProcessRun_)
    async DeleteContentProcessRun(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Process Runs', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Sources
//****************************************************************************
@ObjectType()
export class ContentSource_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Name?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field() 
    @MaxLength(4000)
    URL: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [ContentProcessRun_])
    ContentProcessRuns_SourceIDArray: ContentProcessRun_[]; // Link to ContentProcessRuns
    
    @Field(() => [ContentSourceParam_])
    ContentSourceParams_ContentSourceIDArray: ContentSourceParam_[]; // Link to ContentSourceParams
    
    @Field(() => [ContentItem_])
    ContentItems_ContentSourceIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class CreateContentSourceInput {
    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Sources
//****************************************************************************
@InputType()
export class UpdateContentSourceInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    URL?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Sources
//****************************************************************************
@ObjectType()
export class RunContentSourceViewResult {
    @Field(() => [ContentSource_])
    Results: ContentSource_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSource_)
export class ContentSourceResolver extends ResolverBase {
    @Query(() => RunContentSourceViewResult)
    async RunContentSourceViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceViewResult)
    async RunContentSourceViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceViewResult)
    async RunContentSourceDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Sources';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentSource_, { nullable: true })
    async ContentSource(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSource_ | null> {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Sources', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ContentProcessRun_])
    async ContentProcessRuns_SourceIDArray(@Root() contentsource_: ContentSource_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Process Runs', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentProcessRuns] WHERE [SourceID]='${contentsource_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Process Runs', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Process Runs', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentSourceParam_])
    async ContentSourceParams_ContentSourceIDArray(@Root() contentsource_: ContentSource_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ContentSourceID]='${contentsource_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Source Params', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentSourceIDArray(@Root() contentsource_: ContentSource_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceID]='${contentsource_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ContentSource_)
    async CreateContentSource(
        @Arg('input', () => CreateContentSourceInput) input: CreateContentSourceInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Sources', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSource_)
    async UpdateContentSource(
        @Arg('input', () => UpdateContentSourceInput) input: UpdateContentSourceInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Sources', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSource_)
    async DeleteContentSource(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Sources', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Params
//****************************************************************************
@ObjectType()
export class ContentSourceParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeParamID: string;
        
    @Field() 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class CreateContentSourceParamInput {
    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Params
//****************************************************************************
@InputType()
export class UpdateContentSourceParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    ContentSourceTypeParamID?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Params
//****************************************************************************
@ObjectType()
export class RunContentSourceParamViewResult {
    @Field(() => [ContentSourceParam_])
    Results: ContentSourceParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSourceParam_)
export class ContentSourceParamResolver extends ResolverBase {
    @Query(() => RunContentSourceParamViewResult)
    async RunContentSourceParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceParamViewResult)
    async RunContentSourceParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceParamViewResult)
    async RunContentSourceParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Params';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentSourceParam_, { nullable: true })
    async ContentSourceParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSourceParam_ | null> {
        this.CheckUserReadPermissions('Content Source Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Source Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Source Params', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ContentSourceParam_)
    async CreateContentSourceParam(
        @Arg('input', () => CreateContentSourceParamInput) input: CreateContentSourceParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Source Params', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSourceParam_)
    async UpdateContentSourceParam(
        @Arg('input', () => UpdateContentSourceParamInput) input: UpdateContentSourceParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Source Params', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSourceParam_)
    async DeleteContentSourceParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Params', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Types
//****************************************************************************
@ObjectType()
export class ContentSourceType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(2000)
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ContentSource_])
    ContentSources_ContentSourceTypeIDArray: ContentSource_[]; // Link to ContentSources
    
    @Field(() => [ContentItem_])
    ContentItems_ContentSourceTypeIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class CreateContentSourceTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Types
//****************************************************************************
@InputType()
export class UpdateContentSourceTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Types
//****************************************************************************
@ObjectType()
export class RunContentSourceTypeViewResult {
    @Field(() => [ContentSourceType_])
    Results: ContentSourceType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSourceType_)
export class ContentSourceTypeResolver extends ResolverBase {
    @Query(() => RunContentSourceTypeViewResult)
    async RunContentSourceTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeViewResult)
    async RunContentSourceTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeViewResult)
    async RunContentSourceTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentSourceType_, { nullable: true })
    async ContentSourceType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSourceType_ | null> {
        this.CheckUserReadPermissions('Content Source Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Source Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Source Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ContentSource_])
    async ContentSources_ContentSourceTypeIDArray(@Root() contentsourcetype_: ContentSourceType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentSourceTypeID]='${contentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentSourceTypeIDArray(@Root() contentsourcetype_: ContentSourceType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentSourceTypeID]='${contentsourcetype_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ContentSourceType_)
    async CreateContentSourceType(
        @Arg('input', () => CreateContentSourceTypeInput) input: CreateContentSourceTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Source Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSourceType_)
    async UpdateContentSourceType(
        @Arg('input', () => UpdateContentSourceTypeInput) input: UpdateContentSourceTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Source Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSourceType_)
    async DeleteContentSourceType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Source Type Params
//****************************************************************************
@ObjectType()
export class ContentSourceTypeParam_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field({nullable: true}) 
    @MaxLength(100)
    Type?: string;
        
    @Field({nullable: true}) 
    DefaultValue?: string;
        
    @Field(() => Boolean) 
    IsRequired: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class CreateContentSourceTypeParamInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Type: string | null;

    @Field({ nullable: true })
    DefaultValue: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for Content Source Type Params
//****************************************************************************
@InputType()
export class UpdateContentSourceTypeParamInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Type?: string | null;

    @Field({ nullable: true })
    DefaultValue?: string | null;

    @Field(() => Boolean, { nullable: true })
    IsRequired?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Source Type Params
//****************************************************************************
@ObjectType()
export class RunContentSourceTypeParamViewResult {
    @Field(() => [ContentSourceTypeParam_])
    Results: ContentSourceTypeParam_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentSourceTypeParam_)
export class ContentSourceTypeParamResolver extends ResolverBase {
    @Query(() => RunContentSourceTypeParamViewResult)
    async RunContentSourceTypeParamViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeParamViewResult)
    async RunContentSourceTypeParamViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentSourceTypeParamViewResult)
    async RunContentSourceTypeParamDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Source Type Params';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentSourceTypeParam_, { nullable: true })
    async ContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentSourceTypeParam_ | null> {
        this.CheckUserReadPermissions('Content Source Type Params', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSourceTypeParams] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Source Type Params', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Source Type Params', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ContentSourceTypeParam_)
    async CreateContentSourceTypeParam(
        @Arg('input', () => CreateContentSourceTypeParamInput) input: CreateContentSourceTypeParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Source Type Params', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentSourceTypeParam_)
    async UpdateContentSourceTypeParam(
        @Arg('input', () => UpdateContentSourceTypeParamInput) input: UpdateContentSourceTypeParamInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Source Type Params', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentSourceTypeParam_)
    async DeleteContentSourceTypeParam(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Source Type Params', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Types
//****************************************************************************
@ObjectType()
export class ContentType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    AIModelID: string;
        
    @Field(() => Int) 
    MinTags: number;
        
    @Field(() => Int) 
    MaxTags: number;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(100)
    AIModel: string;
        
    @Field(() => [ContentSource_])
    ContentSources_ContentTypeIDArray: ContentSource_[]; // Link to ContentSources
    
    @Field(() => [ContentItem_])
    ContentItems_ContentTypeIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class CreateContentTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;
}
    

//****************************************************************************
// INPUT TYPE for Content Types
//****************************************************************************
@InputType()
export class UpdateContentTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    AIModelID?: string;

    @Field(() => Int, { nullable: true })
    MinTags?: number;

    @Field(() => Int, { nullable: true })
    MaxTags?: number;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Types
//****************************************************************************
@ObjectType()
export class RunContentTypeViewResult {
    @Field(() => [ContentType_])
    Results: ContentType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentType_)
export class ContentTypeResolver extends ResolverBase {
    @Query(() => RunContentTypeViewResult)
    async RunContentTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentTypeViewResult)
    async RunContentTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentTypeViewResult)
    async RunContentTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentType_, { nullable: true })
    async ContentType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentType_ | null> {
        this.CheckUserReadPermissions('Content Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ContentSource_])
    async ContentSources_ContentTypeIDArray(@Root() contenttype_: ContentType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentTypeID]='${contenttype_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentTypeIDArray(@Root() contenttype_: ContentType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentTypeID]='${contenttype_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ContentType_)
    async CreateContentType(
        @Arg('input', () => CreateContentTypeInput) input: CreateContentTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentType_)
    async UpdateContentType(
        @Arg('input', () => UpdateContentTypeInput) input: UpdateContentTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentType_)
    async DeleteContentType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Type Attributes
//****************************************************************************
@ObjectType()
export class ContentTypeAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Prompt: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
}

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class CreateContentTypeAttributeInput {
    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Type Attributes
//****************************************************************************
@InputType()
export class UpdateContentTypeAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Prompt?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Type Attributes
//****************************************************************************
@ObjectType()
export class RunContentTypeAttributeViewResult {
    @Field(() => [ContentTypeAttribute_])
    Results: ContentTypeAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentTypeAttribute_)
export class ContentTypeAttributeResolver extends ResolverBase {
    @Query(() => RunContentTypeAttributeViewResult)
    async RunContentTypeAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentTypeAttributeViewResult)
    async RunContentTypeAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentTypeAttributeViewResult)
    async RunContentTypeAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Type Attributes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentTypeAttribute_, { nullable: true })
    async ContentTypeAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentTypeAttribute_ | null> {
        this.CheckUserReadPermissions('Content Type Attributes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentTypeAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Type Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Type Attributes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ContentTypeAttribute_)
    async CreateContentTypeAttribute(
        @Arg('input', () => CreateContentTypeAttributeInput) input: CreateContentTypeAttributeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Type Attributes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentTypeAttribute_)
    async UpdateContentTypeAttribute(
        @Arg('input', () => UpdateContentTypeAttributeInput) input: UpdateContentTypeAttributeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Type Attributes', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentTypeAttribute_)
    async DeleteContentTypeAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Type Attributes', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content File Types
//****************************************************************************
@ObjectType()
export class ContentFileType_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    FileExtension?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field(() => [ContentSource_])
    ContentSources_ContentFileTypeIDArray: ContentSource_[]; // Link to ContentSources
    
    @Field(() => [ContentItem_])
    ContentItems_ContentFileTypeIDArray: ContentItem_[]; // Link to ContentItems
    
}

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class CreateContentFileTypeInput {
    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content File Types
//****************************************************************************
@InputType()
export class UpdateContentFileTypeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    FileExtension?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content File Types
//****************************************************************************
@ObjectType()
export class RunContentFileTypeViewResult {
    @Field(() => [ContentFileType_])
    Results: ContentFileType_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentFileType_)
export class ContentFileTypeResolver extends ResolverBase {
    @Query(() => RunContentFileTypeViewResult)
    async RunContentFileTypeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentFileTypeViewResult)
    async RunContentFileTypeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentFileTypeViewResult)
    async RunContentFileTypeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content File Types';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentFileType_, { nullable: true })
    async ContentFileType(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentFileType_ | null> {
        this.CheckUserReadPermissions('Content File Types', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentFileTypes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content File Types', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content File Types', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ContentSource_])
    async ContentSources_ContentFileTypeIDArray(@Root() contentfiletype_: ContentFileType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Sources', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentSources] WHERE [ContentFileTypeID]='${contentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Sources', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Sources', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentItem_])
    async ContentItems_ContentFileTypeIDArray(@Root() contentfiletype_: ContentFileType_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ContentFileTypeID]='${contentfiletype_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Items', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ContentFileType_)
    async CreateContentFileType(
        @Arg('input', () => CreateContentFileTypeInput) input: CreateContentFileTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content File Types', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentFileType_)
    async UpdateContentFileType(
        @Arg('input', () => UpdateContentFileTypeInput) input: UpdateContentFileTypeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content File Types', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentFileType_)
    async DeleteContentFileType(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content File Types', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Items
//****************************************************************************
@ObjectType()
export class ContentItem_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceID: string;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Name?: string;
        
    @Field({nullable: true}) 
    Description?: string;
        
    @Field() 
    @MaxLength(16)
    ContentTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentSourceTypeID: string;
        
    @Field() 
    @MaxLength(16)
    ContentFileTypeID: string;
        
    @Field({nullable: true}) 
    @MaxLength(200)
    Checksum?: string;
        
    @Field() 
    @MaxLength(4000)
    URL: string;
        
    @Field({nullable: true}) 
    Text?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    ContentSource?: string;
        
    @Field() 
    @MaxLength(510)
    ContentType: string;
        
    @Field() 
    @MaxLength(510)
    ContentSourceType: string;
        
    @Field() 
    @MaxLength(510)
    ContentFileType: string;
        
    @Field(() => [ContentItemAttribute_])
    ContentItemAttributes_ContentItemIDArray: ContentItemAttribute_[]; // Link to ContentItemAttributes
    
    @Field(() => [ContentItemTag_])
    ContentItemTags_ItemIDArray: ContentItemTag_[]; // Link to ContentItemTags
    
}

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class CreateContentItemInput {
    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name: string | null;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text: string | null;
}
    

//****************************************************************************
// INPUT TYPE for Content Items
//****************************************************************************
@InputType()
export class UpdateContentItemInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentSourceID?: string;

    @Field({ nullable: true })
    Name?: string | null;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    ContentTypeID?: string;

    @Field({ nullable: true })
    ContentSourceTypeID?: string;

    @Field({ nullable: true })
    ContentFileTypeID?: string;

    @Field({ nullable: true })
    Checksum?: string | null;

    @Field({ nullable: true })
    URL?: string;

    @Field({ nullable: true })
    Text?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Items
//****************************************************************************
@ObjectType()
export class RunContentItemViewResult {
    @Field(() => [ContentItem_])
    Results: ContentItem_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentItem_)
export class ContentItemResolver extends ResolverBase {
    @Query(() => RunContentItemViewResult)
    async RunContentItemViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentItemViewResult)
    async RunContentItemViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentItemViewResult)
    async RunContentItemDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Items';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentItem_, { nullable: true })
    async ContentItem(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentItem_ | null> {
        this.CheckUserReadPermissions('Content Items', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItems] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Items', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Items', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @FieldResolver(() => [ContentItemAttribute_])
    async ContentItemAttributes_ContentItemIDArray(@Root() contentitem_: ContentItem_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ContentItemID]='${contentitem_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Item Attributes', await dataSource.query(sSQL));
        return result;
    }
        
    @FieldResolver(() => [ContentItemTag_])
    async ContentItemTags_ItemIDArray(@Root() contentitem_: ContentItem_, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ItemID]='${contentitem_.ID}' ` + this.getRowLevelSecurityWhereClause('Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.ArrayMapFieldNamesToCodeNames('Content Item Tags', await dataSource.query(sSQL));
        return result;
    }
        
    @Mutation(() => ContentItem_)
    async CreateContentItem(
        @Arg('input', () => CreateContentItemInput) input: CreateContentItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Items', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentItem_)
    async UpdateContentItem(
        @Arg('input', () => UpdateContentItemInput) input: UpdateContentItemInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Items', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentItem_)
    async DeleteContentItem(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Items', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Attributes
//****************************************************************************
@ObjectType()
export class ContentItemAttribute_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ContentItemID: string;
        
    @Field() 
    @MaxLength(200)
    Name: string;
        
    @Field() 
    Value: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    ContentItem?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class CreateContentItemAttributeInput {
    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Attributes
//****************************************************************************
@InputType()
export class UpdateContentItemAttributeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ContentItemID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Value?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Attributes
//****************************************************************************
@ObjectType()
export class RunContentItemAttributeViewResult {
    @Field(() => [ContentItemAttribute_])
    Results: ContentItemAttribute_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentItemAttribute_)
export class ContentItemAttributeResolver extends ResolverBase {
    @Query(() => RunContentItemAttributeViewResult)
    async RunContentItemAttributeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentItemAttributeViewResult)
    async RunContentItemAttributeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentItemAttributeViewResult)
    async RunContentItemAttributeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Attributes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentItemAttribute_, { nullable: true })
    async ContentItemAttribute(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentItemAttribute_ | null> {
        this.CheckUserReadPermissions('Content Item Attributes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemAttributes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Item Attributes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Item Attributes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ContentItemAttribute_)
    async CreateContentItemAttribute(
        @Arg('input', () => CreateContentItemAttributeInput) input: CreateContentItemAttributeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Item Attributes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentItemAttribute_)
    async UpdateContentItemAttribute(
        @Arg('input', () => UpdateContentItemAttributeInput) input: UpdateContentItemAttributeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Item Attributes', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentItemAttribute_)
    async DeleteContentItemAttribute(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Attributes', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Content Item Tags
//****************************************************************************
@ObjectType()
export class ContentItemTag_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ItemID: string;
        
    @Field() 
    @MaxLength(400)
    Tag: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(500)
    Item?: string;
        
}

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class CreateContentItemTagInput {
    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;
}
    

//****************************************************************************
// INPUT TYPE for Content Item Tags
//****************************************************************************
@InputType()
export class UpdateContentItemTagInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ItemID?: string;

    @Field({ nullable: true })
    Tag?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Content Item Tags
//****************************************************************************
@ObjectType()
export class RunContentItemTagViewResult {
    @Field(() => [ContentItemTag_])
    Results: ContentItemTag_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ContentItemTag_)
export class ContentItemTagResolver extends ResolverBase {
    @Query(() => RunContentItemTagViewResult)
    async RunContentItemTagViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentItemTagViewResult)
    async RunContentItemTagViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunContentItemTagViewResult)
    async RunContentItemTagDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Content Item Tags';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ContentItemTag_, { nullable: true })
    async ContentItemTag(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ContentItemTag_ | null> {
        this.CheckUserReadPermissions('Content Item Tags', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwContentItemTags] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Content Item Tags', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Content Item Tags', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ContentItemTag_)
    async CreateContentItemTag(
        @Arg('input', () => CreateContentItemTagInput) input: CreateContentItemTagInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Content Item Tags', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ContentItemTag_)
    async UpdateContentItemTag(
        @Arg('input', () => UpdateContentItemTagInput) input: UpdateContentItemTagInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Content Item Tags', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ContentItemTag_)
    async DeleteContentItemTag(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Content Item Tags', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for Generated Codes
//****************************************************************************
@ObjectType()
export class GeneratedCode_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `When the code was generated.`}) 
    @MaxLength(10)
    GeneratedAt: Date;
        
    @Field({description: `Reference to the category of generated code.`}) 
    @MaxLength(16)
    CategoryID: string;
        
    @Field({description: `AI model responsible for generating this code.`}) 
    @MaxLength(16)
    GeneratedByModelID: string;
        
    @Field({description: `Descriptive name of the generated code.`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Optional description of the generated code.`}) 
    Description?: string;
        
    @Field({description: `The actual generated code.`}) 
    Code: string;
        
    @Field({description: `Source material used to generate the code, e.g., a SQL CHECK constraint.`}) 
    Source: string;
        
    @Field({nullable: true}) 
    @MaxLength(16)
    LinkedEntityID?: string;
        
    @Field({nullable: true}) 
    LinkedRecordPrimaryKey?: string;
        
    @Field({description: `Status of the generated code, e.g., Pending, Approved, or Rejected.`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({description: `Programming language of the generated code (TypeScript, SQL, HTML, CSS, JavaScript, Python, or Other).`}) 
    @MaxLength(100)
    Language: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Category: string;
        
    @Field() 
    @MaxLength(100)
    GeneratedByModel: string;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    LinkedEntity?: string;
        
}

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class CreateGeneratedCodeInput {
    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;
}
    

//****************************************************************************
// INPUT TYPE for Generated Codes
//****************************************************************************
@InputType()
export class UpdateGeneratedCodeInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    GeneratedAt?: Date;

    @Field({ nullable: true })
    CategoryID?: string;

    @Field({ nullable: true })
    GeneratedByModelID?: string;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Code?: string;

    @Field({ nullable: true })
    Source?: string;

    @Field({ nullable: true })
    LinkedEntityID?: string | null;

    @Field({ nullable: true })
    LinkedRecordPrimaryKey?: string | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    Language?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for Generated Codes
//****************************************************************************
@ObjectType()
export class RunGeneratedCodeViewResult {
    @Field(() => [GeneratedCode_])
    Results: GeneratedCode_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(GeneratedCode_)
export class GeneratedCodeResolver extends ResolverBase {
    @Query(() => RunGeneratedCodeViewResult)
    async RunGeneratedCodeViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeViewResult)
    async RunGeneratedCodeViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunGeneratedCodeViewResult)
    async RunGeneratedCodeDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'Generated Codes';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => GeneratedCode_, { nullable: true })
    async GeneratedCode(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<GeneratedCode_ | null> {
        this.CheckUserReadPermissions('Generated Codes', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwGeneratedCodes] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('Generated Codes', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('Generated Codes', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => GeneratedCode_)
    async CreateGeneratedCode(
        @Arg('input', () => CreateGeneratedCodeInput) input: CreateGeneratedCodeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('Generated Codes', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => GeneratedCode_)
    async UpdateGeneratedCode(
        @Arg('input', () => UpdateGeneratedCodeInput) input: UpdateGeneratedCodeInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('Generated Codes', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => GeneratedCode_)
    async DeleteGeneratedCode(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('Generated Codes', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType()
export class ConversationArtifactPermission_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Reference to the artifact this permission applies to`}) 
    @MaxLength(16)
    ConversationArtifactID: string;
        
    @Field({description: `User this permission applies to`}) 
    @MaxLength(16)
    UserID: string;
        
    @Field({description: `Level of access granted (Read, Edit, Owner)`}) 
    @MaxLength(40)
    AccessLevel: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    ConversationArtifact: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class CreateConversationArtifactPermissionInput {
    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Conversation Artifact Permissions
//****************************************************************************
@InputType()
export class UpdateConversationArtifactPermissionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ConversationArtifactID?: string;

    @Field({ nullable: true })
    UserID?: string;

    @Field({ nullable: true })
    AccessLevel?: string;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Conversation Artifact Permissions
//****************************************************************************
@ObjectType()
export class RunConversationArtifactPermissionViewResult {
    @Field(() => [ConversationArtifactPermission_])
    Results: ConversationArtifactPermission_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ConversationArtifactPermission_)
export class ConversationArtifactPermissionResolver extends ResolverBase {
    @Query(() => RunConversationArtifactPermissionViewResult)
    async RunConversationArtifactPermissionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactPermissionViewResult)
    async RunConversationArtifactPermissionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunConversationArtifactPermissionViewResult)
    async RunConversationArtifactPermissionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Conversation Artifact Permissions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ConversationArtifactPermission_, { nullable: true })
    async ConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ConversationArtifactPermission_ | null> {
        this.CheckUserReadPermissions('MJ: Conversation Artifact Permissions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwConversationArtifactPermissions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Conversation Artifact Permissions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('MJ: Conversation Artifact Permissions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ConversationArtifactPermission_)
    async CreateConversationArtifactPermission(
        @Arg('input', () => CreateConversationArtifactPermissionInput) input: CreateConversationArtifactPermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('MJ: Conversation Artifact Permissions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ConversationArtifactPermission_)
    async UpdateConversationArtifactPermission(
        @Arg('input', () => UpdateConversationArtifactPermissionInput) input: UpdateConversationArtifactPermissionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('MJ: Conversation Artifact Permissions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ConversationArtifactPermission_)
    async DeleteConversationArtifactPermission(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Conversation Artifact Permissions', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for AI Agent Learning Cycles
//****************************************************************************
@ObjectType({ description: `Tracks the learning cycles for AI Agents where the Agent does offline reasoning, reflection, learning, and updates metadata.` })
export class AIAgentLearningCycle_ {
    @Field({description: `Unique identifier for the learning cycle.`}) 
    @MaxLength(16)
    ID: string;
        
    @Field({description: `Identifier for the AI Agent associated with this learning cycle.`}) 
    @MaxLength(16)
    AgentID: string;
        
    @Field({description: `Timestamp indicating when the learning cycle started.`}) 
    @MaxLength(10)
    StartedAt: Date;
        
    @Field({nullable: true, description: `Timestamp indicating when the learning cycle ended.`}) 
    @MaxLength(10)
    EndedAt?: Date;
        
    @Field({description: `Status of the learning cycle (In-Progress, Complete, or Failed).`}) 
    @MaxLength(40)
    Status: string;
        
    @Field({nullable: true, description: `Text summary provided by the agent about what it learned and any changes it requested for stored metadata.`}) 
    AgentSummary?: string;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field({nullable: true}) 
    @MaxLength(510)
    Agent?: string;
        
}

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class CreateAIAgentLearningCycleInput {
    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary: string | null;
}
    

//****************************************************************************
// INPUT TYPE for AI Agent Learning Cycles
//****************************************************************************
@InputType()
export class UpdateAIAgentLearningCycleInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    AgentID?: string;

    @Field({ nullable: true })
    StartedAt?: Date;

    @Field({ nullable: true })
    EndedAt?: Date | null;

    @Field({ nullable: true })
    Status?: string;

    @Field({ nullable: true })
    AgentSummary?: string | null;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for AI Agent Learning Cycles
//****************************************************************************
@ObjectType()
export class RunAIAgentLearningCycleViewResult {
    @Field(() => [AIAgentLearningCycle_])
    Results: AIAgentLearningCycle_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(AIAgentLearningCycle_)
export class AIAgentLearningCycleResolver extends ResolverBase {
    @Query(() => RunAIAgentLearningCycleViewResult)
    async RunAIAgentLearningCycleViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentLearningCycleViewResult)
    async RunAIAgentLearningCycleViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunAIAgentLearningCycleViewResult)
    async RunAIAgentLearningCycleDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'AI Agent Learning Cycles';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => AIAgentLearningCycle_, { nullable: true })
    async AIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<AIAgentLearningCycle_ | null> {
        this.CheckUserReadPermissions('AI Agent Learning Cycles', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwAIAgentLearningCycles] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('AI Agent Learning Cycles', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('AI Agent Learning Cycles', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => AIAgentLearningCycle_)
    async CreateAIAgentLearningCycle(
        @Arg('input', () => CreateAIAgentLearningCycleInput) input: CreateAIAgentLearningCycleInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('AI Agent Learning Cycles', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => AIAgentLearningCycle_)
    async UpdateAIAgentLearningCycle(
        @Arg('input', () => UpdateAIAgentLearningCycleInput) input: UpdateAIAgentLearningCycleInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('AI Agent Learning Cycles', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => AIAgentLearningCycle_)
    async DeleteAIAgentLearningCycle(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('AI Agent Learning Cycles', key, options, dataSource, userPayload, pubSub);
    }
    
}

//****************************************************************************
// ENTITY CLASS for MJ: Report Versions
//****************************************************************************
@ObjectType()
export class ReportVersion_ {
    @Field() 
    @MaxLength(16)
    ID: string;
        
    @Field() 
    @MaxLength(16)
    ReportID: string;
        
    @Field(() => Int, {description: `Report version number, sequential per report starting at 1`}) 
    VersionNumber: number;
        
    @Field({description: `Name of this report version`}) 
    @MaxLength(510)
    Name: string;
        
    @Field({nullable: true, description: `Description of this report version`}) 
    Description?: string;
        
    @Field({nullable: true, description: `JSON configuration of report structure, layout and logic`}) 
    Configuration?: string;
        
    @Field(() => Boolean, {description: `Indicates if the data context was updated in this version`}) 
    DataContextUpdated: boolean;
        
    @Field() 
    @MaxLength(10)
    _mj__CreatedAt: Date;
        
    @Field() 
    @MaxLength(10)
    _mj__UpdatedAt: Date;
        
    @Field() 
    @MaxLength(510)
    Report: string;
        
}

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class CreateReportVersionInput {
    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description: string | null;

    @Field({ nullable: true })
    Configuration: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;
}
    

//****************************************************************************
// INPUT TYPE for MJ: Report Versions
//****************************************************************************
@InputType()
export class UpdateReportVersionInput {
    @Field()
    ID: string;

    @Field({ nullable: true })
    ReportID?: string;

    @Field(() => Int, { nullable: true })
    VersionNumber?: number;

    @Field({ nullable: true })
    Name?: string;

    @Field({ nullable: true })
    Description?: string | null;

    @Field({ nullable: true })
    Configuration?: string | null;

    @Field(() => Boolean, { nullable: true })
    DataContextUpdated?: boolean;

    @Field(() => [KeyValuePairInput], { nullable: true })
    OldValues___?: KeyValuePairInput[];
}
    
//****************************************************************************
// RESOLVER for MJ: Report Versions
//****************************************************************************
@ObjectType()
export class RunReportVersionViewResult {
    @Field(() => [ReportVersion_])
    Results: ReportVersion_[];

    @Field(() => String, {nullable: true})
    UserViewRunID?: string;

    @Field(() => Int, {nullable: true})
    RowCount: number;

    @Field(() => Int, {nullable: true})
    TotalRowCount: number;

    @Field(() => Int, {nullable: true})
    ExecutionTime: number;

    @Field({nullable: true})
    ErrorMessage?: string;

    @Field(() => Boolean, {nullable: false})
    Success: boolean;
}

@Resolver(ReportVersion_)
export class ReportVersionResolver extends ResolverBase {
    @Query(() => RunReportVersionViewResult)
    async RunReportVersionViewByID(@Arg('input', () => RunViewByIDInput) input: RunViewByIDInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByIDGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportVersionViewResult)
    async RunReportVersionViewByName(@Arg('input', () => RunViewByNameInput) input: RunViewByNameInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        return super.RunViewByNameGeneric(input, dataSource, userPayload, pubSub);
    }

    @Query(() => RunReportVersionViewResult)
    async RunReportVersionDynamicView(@Arg('input', () => RunDynamicViewInput) input: RunDynamicViewInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        input.EntityName = 'MJ: Report Versions';
        return super.RunDynamicViewGeneric(input, dataSource, userPayload, pubSub);
    }
    @Query(() => ReportVersion_, { nullable: true })
    async ReportVersion(@Arg('ID', () => String) ID: string, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine): Promise<ReportVersion_ | null> {
        this.CheckUserReadPermissions('MJ: Report Versions', userPayload);
        const dataSource = GetReadOnlyDataSource(dataSources, { allowFallbackToReadWrite: true });
        const sSQL = `SELECT * FROM [${Metadata.Provider.ConfigData.MJCoreSchemaName}].[vwReportVersions] WHERE [ID]='${ID}' ` + this.getRowLevelSecurityWhereClause('MJ: Report Versions', userPayload, EntityPermissionType.Read, 'AND');
        const result = this.MapFieldNamesToCodeNames('MJ: Report Versions', await dataSource.query(sSQL).then((r) => r && r.length > 0 ? r[0] : {}))
        return result;
    }
    
    @Mutation(() => ReportVersion_)
    async CreateReportVersion(
        @Arg('input', () => CreateReportVersionInput) input: CreateReportVersionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.CreateRecord('MJ: Report Versions', input, dataSource, userPayload, pubSub)
    }
        
    @Mutation(() => ReportVersion_)
    async UpdateReportVersion(
        @Arg('input', () => UpdateReportVersionInput) input: UpdateReportVersionInput,
        @Ctx() { dataSources, userPayload }: AppContext,
        @PubSub() pubSub: PubSubEngine
    ) {
        const dataSource = GetReadWriteDataSource(dataSources);
        return this.UpdateRecord('MJ: Report Versions', input, dataSource, userPayload, pubSub);
    }
    
    @Mutation(() => ReportVersion_)
    async DeleteReportVersion(@Arg('ID', () => String) ID: string, @Arg('options___', () => DeleteOptionsInput) options: DeleteOptionsInput, @Ctx() { dataSources, userPayload }: AppContext, @PubSub() pubSub: PubSubEngine) {
        const dataSource = GetReadWriteDataSource(dataSources);
        const key = new CompositeKey([{FieldName: 'ID', Value: ID}]);
        return this.DeleteRecord('MJ: Report Versions', key, options, dataSource, userPayload, pubSub);
    }
    
}