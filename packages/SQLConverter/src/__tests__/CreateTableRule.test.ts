import { describe, it, expect } from 'vitest';
import { CreateTableRule } from '../rules/CreateTableRule.js';
import { createConversionContext } from '../rules/types.js';

const rule = new CreateTableRule();

function convert(sql: string): string {
  const context = createConversionContext('tsql', 'postgres');
  return rule.PostProcess!(sql, sql, context);
}

function convertWithContext(sql: string): { result: string; context: ReturnType<typeof createConversionContext> } {
  const context = createConversionContext('tsql', 'postgres');
  const result = rule.PostProcess!(sql, sql, context);
  return { result, context };
}

describe('CreateTableRule', () => {
  describe('metadata', () => {
    it('should have the correct name, priority, and applies-to types', () => {
      expect(rule.Name).toBe('CreateTableRule');
      expect(rule.Priority).toBe(10);
      expect(rule.AppliesTo).toEqual(['CREATE_TABLE']);
      expect(rule.BypassSqlglot).toBe(true);
    });
  });

  describe('column type conversions', () => {
    it('should convert UNIQUEIDENTIFIER to UUID', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [ID] [uniqueidentifier] NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('UUID NOT NULL');
      expect(result).not.toMatch(/uniqueidentifier/i);
    });

    it('should convert NVARCHAR(50) to VARCHAR(50)', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Name] [nvarchar](50) NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('VARCHAR(50)');
      expect(result).not.toMatch(/nvarchar/i);
    });

    it('should convert NVARCHAR(MAX) to TEXT', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Description] [nvarchar](max) NULL\n)';
      const result = convert(sql);
      expect(result).toContain('TEXT NULL');
      expect(result).not.toMatch(/nvarchar/i);
    });

    it('should convert BIT to BOOLEAN', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [IsActive] [bit] NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('BOOLEAN NOT NULL');
      expect(result).not.toMatch(/\bbit\b/i);
    });

    it('should convert FLOAT to DOUBLE PRECISION', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Score] [float] NULL\n)';
      const result = convert(sql);
      expect(result).toContain('DOUBLE PRECISION');
      expect(result).not.toMatch(/\[float\]/i);
    });

    it('should convert MONEY to NUMERIC(19,4)', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Amount] [money] NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('NUMERIC(19,4)');
      expect(result).not.toMatch(/\bmoney\b/i);
    });

    it('should convert IMAGE to BYTEA', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Photo] [image] NULL\n)';
      const result = convert(sql);
      expect(result).toContain('BYTEA');
      expect(result).not.toMatch(/\bimage\b/i);
    });

    it('should convert DATETIMEOFFSET(7) to TIMESTAMPTZ', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [CreatedAt] [datetimeoffset](7) NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('TIMESTAMPTZ');
      expect(result).not.toMatch(/datetimeoffset/i);
    });

    it('should convert TINYINT to SMALLINT', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Status] [tinyint] NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('SMALLINT');
      expect(result).not.toMatch(/\btinyint\b/i);
    });

    it('should convert SQL_VARIANT to TEXT', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Data] [sql_variant] NULL\n)';
      const result = convert(sql);
      expect(result).toContain('TEXT');
      expect(result).not.toMatch(/sql_variant/i);
    });
  });

  describe('IDENTITY conversion', () => {
    it('should convert IDENTITY(1,1) to GENERATED BY DEFAULT AS IDENTITY', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [ID] [int] IDENTITY(1,1) NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('GENERATED BY DEFAULT AS IDENTITY');
      expect(result).not.toMatch(/IDENTITY\s*\(/i);
    });
  });

  describe('default value conversions', () => {
    it('should convert DEFAULT NEWSEQUENTIALID() to DEFAULT gen_random_uuid()', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [ID] [uniqueidentifier] NOT NULL DEFAULT (newsequentialid())\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT gen_random_uuid()');
      expect(result).not.toMatch(/newsequentialid/i);
    });

    it('should convert DEFAULT GETUTCDATE() to DEFAULT NOW()', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [CreatedAt] [datetimeoffset](7) NOT NULL DEFAULT (getutcdate())\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT NOW()');
      expect(result).not.toMatch(/getutcdate/i);
    });

    it('should convert BIT DEFAULT ((0)) to DEFAULT FALSE', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [IsActive] [bit] NOT NULL DEFAULT ((0))\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT FALSE');
    });

    it('should convert BIT DEFAULT ((1)) to DEFAULT TRUE', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [IsEnabled] [bit] NOT NULL DEFAULT ((1))\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT TRUE');
    });

    it('should convert string default with N prefix: DEFAULT ((N\'value\')) to DEFAULT \'value\'', () => {
      const sql = "CREATE TABLE [__mj].[Foo] (\n  [Status] [nvarchar](50) NOT NULL DEFAULT ((N'Active'))\n)";
      const result = convert(sql);
      expect(result).toContain("DEFAULT 'Active'");
      expect(result).not.toContain("N'");
    });

    it('should convert numeric default: DEFAULT ((42)) to DEFAULT 42', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Priority] [int] NOT NULL DEFAULT ((42))\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT 42');
      expect(result).not.toContain('((42))');
    });
  });

  describe('COLLATE removal', () => {
    it('should remove COLLATE clauses', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [Name] [nvarchar](100) COLLATE SQL_Latin1_General_CP1_CI_AS NOT NULL\n)';
      const result = convert(sql);
      expect(result).not.toMatch(/COLLATE/i);
    });
  });

  describe('constraint handling', () => {
    it('should preserve PRIMARY KEY constraint', () => {
      const sql = `CREATE TABLE [__mj].[Foo] (
  [ID] [uniqueidentifier] NOT NULL,
  CONSTRAINT [PK_Foo] PRIMARY KEY ([ID])
)`;
      const result = convert(sql);
      expect(result).toContain('PRIMARY KEY');
    });

    it('should remove CLUSTERED and NONCLUSTERED keywords', () => {
      const sql = `CREATE TABLE [__mj].[Foo] (
  [ID] [int] IDENTITY(1,1) NOT NULL,
  CONSTRAINT [PK_Foo] PRIMARY KEY CLUSTERED ([ID])
)`;
      const result = convert(sql);
      expect(result).not.toMatch(/\bCLUSTERED\b/i);
      expect(result).toContain('PRIMARY KEY');
    });

    it('should remove inline named DEFAULT constraints', () => {
      const sql = `CREATE TABLE [__mj].[Foo] (
  [IsActive] [bit] NOT NULL CONSTRAINT [DF_Foo_IsActive] DEFAULT ((0))
)`;
      const result = convert(sql);
      expect(result).toContain('DEFAULT FALSE');
      expect(result).not.toContain('DF_Foo_IsActive');
    });
  });

  describe('identifier conversion', () => {
    it('should convert bracket identifiers to double-quoted identifiers', () => {
      const sql = 'CREATE TABLE [__mj].[MyTable] (\n  [ID] [uniqueidentifier] NOT NULL\n)';
      const result = convert(sql);
      expect(result).toContain('__mj."MyTable"');
      expect(result).toContain('"ID"');
      expect(result).not.toContain('[');
      expect(result).not.toContain(']');
    });
  });

  describe('multiple column types', () => {
    it('should handle table with many different column types', () => {
      const sql = `CREATE TABLE [__mj].[ComplexTable] (
  [ID] [uniqueidentifier] NOT NULL DEFAULT (newsequentialid()),
  [Name] [nvarchar](100) NOT NULL,
  [Description] [nvarchar](max) NULL,
  [IsActive] [bit] NOT NULL DEFAULT ((1)),
  [Score] [float] NULL,
  [Amount] [money] NOT NULL DEFAULT ((0)),
  [CreatedAt] [datetimeoffset](7) NOT NULL DEFAULT (getutcdate()),
  [Photo] [image] NULL,
  [Priority] [tinyint] NOT NULL DEFAULT ((5)),
  [Counter] [int] IDENTITY(1,1) NOT NULL,
  CONSTRAINT [PK_ComplexTable] PRIMARY KEY ([ID])
)`;
      const result = convert(sql);
      expect(result).toContain('UUID NOT NULL DEFAULT gen_random_uuid()');
      expect(result).toContain('VARCHAR(100)');
      expect(result).toContain('TEXT NULL');
      expect(result).toContain('BOOLEAN NOT NULL DEFAULT TRUE');
      expect(result).toContain('DOUBLE PRECISION');
      expect(result).toContain('NUMERIC(19,4)');
      expect(result).toContain('TIMESTAMPTZ NOT NULL DEFAULT NOW()');
      expect(result).toContain('BYTEA');
      expect(result).toContain('SMALLINT');
      expect(result).toContain('GENERATED BY DEFAULT AS IDENTITY');
      expect(result).toContain('PRIMARY KEY');
    });
  });

  describe('column type tracking', () => {
    it('should track column types in context.TableColumns', () => {
      const sql = `CREATE TABLE [__mj].[Users] (
  [ID] [uniqueidentifier] NOT NULL,
  [Name] [nvarchar](100) NOT NULL,
  [IsActive] [bit] NOT NULL
)`;
      const { context } = convertWithContext(sql);
      const columns = context.TableColumns.get('users');
      expect(columns).toBeDefined();
      expect(columns!.get('id')).toBe('UUID');
      expect(columns!.get('isactive')).toBe('BOOLEAN');
    });
  });

  describe('output formatting', () => {
    it('should ensure output ends with semicolon and newline', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [ID] [int] NOT NULL\n)';
      const result = convert(sql);
      expect(result).toMatch(/;\n$/);
    });

    it('should collapse multiple spaces into single space', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [ID]   [int]   NOT NULL\n)';
      const result = convert(sql);
      expect(result).not.toMatch(/  /);
    });
  });

  describe('GETDATE and SYSDATETIMEOFFSET defaults', () => {
    it('should convert DEFAULT GETDATE() to DEFAULT NOW()', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [CreatedAt] [datetime] NOT NULL DEFAULT (getdate())\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT NOW()');
    });

    it('should convert DEFAULT SYSDATETIMEOFFSET() to DEFAULT NOW()', () => {
      const sql = 'CREATE TABLE [__mj].[Foo] (\n  [CreatedAt] [datetimeoffset](7) NOT NULL DEFAULT (sysdatetimeoffset())\n)';
      const result = convert(sql);
      expect(result).toContain('DEFAULT NOW()');
    });
  });
});
