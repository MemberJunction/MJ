name: Ensure migrations are valid

on:
  pull_request:
    branches:
      - next
      - main

concurrency:
  group: "changes"
  cancel-in-progress: true

jobs:
  changes_and_migrations:
    name: Check migrations
    timeout-minutes: 5
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Check for migration file changes
        id: check_migrations
        run: |
          MIGRATION_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E '^migrations/.*\.sql$' || true)
          if [ -n "$MIGRATION_FILES" ]; then
            echo "has_migrations=true" >> $GITHUB_OUTPUT
            echo "Migration files found:"
            echo "$MIGRATION_FILES"
          else
            echo "has_migrations=false" >> $GITHUB_OUTPUT
            echo "No migration files in this PR - skipping validation"
          fi

      - name: Set up node
        if: steps.check_migrations.outputs.has_migrations == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: 24
          cache: 'npm'
          cache-dependency-path: 'package-lock.json'

      - name: Get current version
        if: steps.check_migrations.outputs.has_migrations == 'true'
        id: get_version
        run: |
          # Use MJServer package since core and global are pinned at 2.100.3
          CURRENT_VERSION=$(jq -r .version packages/MJServer/package.json)
          echo "Current version: $CURRENT_VERSION"
          echo "CURRENT_VERSION=$CURRENT_VERSION" >> $GITHUB_OUTPUT

      - name: Check migration filenames
        if: steps.check_migrations.outputs.has_migrations == 'true'
        run: |
          CURRENT_VERSION="${{ steps.get_version.outputs.CURRENT_VERSION }}"
          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          NEXT_MINOR_VERSION="${VERSION_PARTS[0]}.$(( ${VERSION_PARTS[1]} + 1 ))"
          EXPECTED_STRING="__v$NEXT_MINOR_VERSION"

          git diff --name-only --diff-filter=A ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E '^migrations/.*\.sql$' | while read file; do
            if [[ ! "$file" =~ $EXPECTED_STRING ]]; then
              echo "::error file=$file::Migration filename doesn't match the next minor version (v$NEXT_MINOR_VERSION)"
              exit 1
            fi
            if [[ ! "$file" =~ "V" ]]; then
              echo "::error file=$file::Migration filename doesn't begin with a  capital \`V\` character"
              exit 1
            fi
          done

      - name: Check migration timestamps are newer than existing
        if: steps.check_migrations.outputs.has_migrations == 'true'
        run: |
          # Get new migration files being added in this PR
          NEW_MIGRATIONS=$(git diff --name-only --diff-filter=A ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E '^migrations/.*\.sql$' || true)

          if [ -z "$NEW_MIGRATIONS" ]; then
            echo "No new migration files to check"
            exit 0
          fi

          # Find the maximum timestamp from all existing migrations on the base branch
          # This ensures new migrations always come after all prior version migrations
          MAX_EXISTING_TIMESTAMP=0

          # Get all existing migration files from the base branch
          for file in $(git ls-tree -r --name-only ${{ github.event.pull_request.base.sha }} -- migrations/ | grep -E '\.sql$'); do
            filename=$(basename "$file")
            # Extract timestamp from filename (VYYYYMMDDHHMM format)
            if [[ "$filename" =~ ^V([0-9]{12})__ ]]; then
              timestamp="${BASH_REMATCH[1]}"
              if [ "$timestamp" -gt "$MAX_EXISTING_TIMESTAMP" ]; then
                MAX_EXISTING_TIMESTAMP=$timestamp
                MAX_EXISTING_FILE="$filename"
              fi
            fi
          done

          echo "Maximum existing migration timestamp: $MAX_EXISTING_TIMESTAMP (from $MAX_EXISTING_FILE)"

          # Check each new migration has a timestamp greater than the max existing
          echo "$NEW_MIGRATIONS" | while read file; do
            filename=$(basename "$file")
            if [[ "$filename" =~ ^V([0-9]{12})__ ]]; then
              new_timestamp="${BASH_REMATCH[1]}"
              if [ "$new_timestamp" -le "$MAX_EXISTING_TIMESTAMP" ]; then
                echo "::error file=$file::Migration timestamp ($new_timestamp) must be greater than the latest existing migration timestamp ($MAX_EXISTING_TIMESTAMP from $MAX_EXISTING_FILE). This prevents out-of-order execution when upgrading between versions."
                exit 1
              else
                echo "âœ“ $filename timestamp ($new_timestamp) is valid (> $MAX_EXISTING_TIMESTAMP)"
              fi
            fi
          done

      - name: Check migration content
        if: steps.check_migrations.outputs.has_migrations == 'true'
        run: |
          git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E '^migrations/.*\.sql$' | while read file; do
            if grep -qP "__mj[^_]" "$file"; then
              echo "::error file=$file::Migration script contains a reference to a hard-coded \`__mj\` schema"
              exit 1
            fi
            if grep -qP "\\$\{flyway:defaultSchema\}_([A-Z][a-z]+At)" "$file"; then
              echo "::error file=$file::Migration script is using the Flyway schema placeholder in a timestamp column"
              exit 1
            fi
          done

      - name: Check for minor version change
        if: steps.check_migrations.outputs.has_migrations == 'true'
        run: |
          MIGRATION_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} | grep -E '^migrations/.*\.sql$' || true)
          if [ -n "$MIGRATION_FILES" ]; then
            MINOR_CHANGE=$(grep 'minor' .changeset/*.md || true)
            if [ -z "$MINOR_CHANGE" ]; then
              echo "::error::Migration files were added, but no minor version changeset was found"
              exit 1
            fi
          fi
