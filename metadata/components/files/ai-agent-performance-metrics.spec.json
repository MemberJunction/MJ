{
  "name": "AIAgentPerformanceMetrics",
  "title": "AI Agent Performance Metrics",
  "description": "Comprehensive performance analytics panel showing execution time distributions, token usage analytics, cost breakdown by agent, error analysis, and trend charts",
  "type": "chart",
  "functionalRequirements": "Display execution time histograms, token usage over time, cost breakdown pie chart, error pattern analysis, performance trend lines, and SLA compliance metrics",
  "dataRequirements": null,
  "technicalDesign": "Multi-section panel with histogram for execution times, line chart for token trends, pie chart for cost distribution, error heatmap, and metric cards for key performance indicators",
  "properties": [
    {"name": "agentRuns", "type": "array", "required": true, "description": "Array of agent run objects with performance data"},
    {"name": "agentRunSteps", "type": "array", "required": true, "description": "Array of agent run step objects"},
    {"name": "promptRuns", "type": "array", "required": false, "description": "Array of prompt run objects for token analysis"},
    {"name": "selectedAgentId", "type": "string", "required": false, "description": "Filter metrics by agent ID"},
    {"name": "timeRange", "type": "string", "required": true, "description": "Time range for metrics"}
  ],
  "events": [],
  "exampleUsage": "<AIAgentPerformanceMetrics ... />",
  "code": "function AIAgentPerformanceMetrics({ \n  agentRuns,\n  agentRunSteps,\n  promptRuns,\n  selectedAgentId,\n  timeRange,\n  utilities, \n  styles, \n  components, \n  callbacks, \n  savedUserSettings, \n  onSaveUserSettings \n}) {\n  const [selectedMetric, setSelectedMetric] = useState(savedUserSettings?.selectedMetric || 'execution');\n  \n  // Helper function to get border radius\n  const getBorderRadius = (size) => {\n    return typeof styles.borders?.radius === 'object' ? styles.borders.radius[size] : styles.borders?.radius || '4px';\n  };\n  \n  // Filter data based on selection\n  const filteredRuns = useMemo(() => {\n    if (!selectedAgentId) return agentRuns;\n    return agentRuns.filter(r => r.AgentID === selectedAgentId);\n  }, [agentRuns, selectedAgentId]);\n  \n  const filteredSteps = useMemo(() => {\n    const runIds = filteredRuns.map(r => r.ID);\n    return agentRunSteps.filter(s => runIds.includes(s.AgentRunID));\n  }, [agentRunSteps, filteredRuns]);\n  \n  const filteredPromptRuns = useMemo(() => {\n    if (!promptRuns) return [];\n    const runIds = filteredRuns.map(r => r.ID);\n    return promptRuns.filter(p => runIds.includes(p.AgentRunID));\n  }, [promptRuns, filteredRuns]);\n  \n  // Calculate performance metrics\n  const metrics = useMemo(() => {\n    const totalRuns = filteredRuns.length;\n    const successfulRuns = filteredRuns.filter(r => r.Success).length;\n    const failedRuns = filteredRuns.filter(r => !r.Success).length;\n    \n    // Execution time metrics\n    const executionTimes = filteredRuns.map(r => r.ExecutionTimeMS || 0).filter(t => t > 0);\n    const avgExecutionTime = executionTimes.length > 0 \n      ? executionTimes.reduce((a, b) => a + b, 0) / executionTimes.length : 0;\n    const medianExecutionTime = executionTimes.length > 0\n      ? executionTimes.sort((a, b) => a - b)[Math.floor(executionTimes.length / 2)] : 0;\n    const p95ExecutionTime = executionTimes.length > 0\n      ? executionTimes.sort((a, b) => a - b)[Math.floor(executionTimes.length * 0.95)] : 0;\n    \n    // Token metrics\n    const totalTokens = filteredRuns.reduce((sum, r) => sum + (r.TotalTokens || 0), 0);\n    const avgTokensPerRun = totalRuns > 0 ? totalTokens / totalRuns : 0;\n    \n    // Cost metrics\n    const totalCost = filteredRuns.reduce((sum, r) => sum + (r.TotalCost || 0), 0);\n    const avgCostPerRun = totalRuns > 0 ? totalCost / totalRuns : 0;\n    \n    // Error analysis\n    const errorsByType = {};\n    filteredRuns.filter(r => !r.Success && r.ErrorMessage).forEach(r => {\n      const errorType = r.ErrorMessage.split(':')[0].substring(0, 50);\n      errorsByType[errorType] = (errorsByType[errorType] || 0) + 1;\n    });\n    \n    return {\n      totalRuns,\n      successfulRuns,\n      failedRuns,\n      successRate: totalRuns > 0 ? (successfulRuns / totalRuns) * 100 : 0,\n      avgExecutionTime,\n      medianExecutionTime,\n      p95ExecutionTime,\n      totalTokens,\n      avgTokensPerRun,\n      totalCost,\n      avgCostPerRun,\n      errorsByType\n    };\n  }, [filteredRuns]);\n  \n  // Calculate execution time distribution for histogram\n  const executionTimeDistribution = useMemo(() => {\n    const times = filteredRuns.map(r => r.ExecutionTimeMS || 0).filter(t => t > 0);\n    if (times.length === 0) return [];\n    \n    const min = Math.min(...times);\n    const max = Math.max(...times);\n    const bucketCount = 10;\n    const bucketSize = (max - min) / bucketCount;\n    \n    const buckets = [];\n    for (let i = 0; i < bucketCount; i++) {\n      const rangeStart = min + (i * bucketSize);\n      const rangeEnd = min + ((i + 1) * bucketSize);\n      const count = times.filter(t => t >= rangeStart && t < rangeEnd).length;\n      \n      buckets.push({\n        range: `${(rangeStart / 1000).toFixed(1)}-${(rangeEnd / 1000).toFixed(1)}s`,\n        count,\n        percentage: (count / times.length) * 100\n      });\n    }\n    \n    return buckets;\n  }, [filteredRuns]);\n  \n  // Calculate cost breakdown by agent\n  const costByAgent = useMemo(() => {\n    const costs = {};\n    filteredRuns.forEach(run => {\n      const agent = run.Agent || 'Unknown';\n      if (!costs[agent]) {\n        costs[agent] = { cost: 0, runs: 0, tokens: 0 };\n      }\n      costs[agent].cost += run.TotalCost || 0;\n      costs[agent].runs++;\n      costs[agent].tokens += run.TotalTokens || 0;\n    });\n    \n    return Object.entries(costs)\n      .map(([agent, data]) => ({\n        agent,\n        cost: data.cost,\n        runs: data.runs,\n        tokens: data.tokens,\n        avgCost: data.runs > 0 ? data.cost / data.runs : 0\n      }))\n      .sort((a, b) => b.cost - a.cost)\n      .slice(0, 10);\n  }, [filteredRuns]);\n  \n  // Calculate time series data\n  const timeSeriesData = useMemo(() => {\n    const now = new Date();\n    const points = [];\n    const hoursToShow = timeRange === '1h' ? 1 : timeRange === '24h' ? 24 : timeRange === '7d' ? 168 : 720;\n    const interval = hoursToShow <= 24 ? 1 : hoursToShow <= 168 ? 6 : 24; // 1h, 6h, or 24h intervals\n    \n    for (let i = 0; i < Math.min(hoursToShow / interval, 30); i++) {\n      const periodEnd = new Date(now);\n      periodEnd.setHours(now.getHours() - (i * interval));\n      const periodStart = new Date(periodEnd);\n      periodStart.setHours(periodEnd.getHours() - interval);\n      \n      const runsInPeriod = filteredRuns.filter(r => {\n        const runTime = new Date(r.StartedAt);\n        return runTime >= periodStart && runTime < periodEnd;\n      });\n      \n      points.unshift({\n        time: periodEnd.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),\n        runs: runsInPeriod.length,\n        tokens: runsInPeriod.reduce((sum, r) => sum + (r.TotalTokens || 0), 0),\n        cost: runsInPeriod.reduce((sum, r) => sum + (r.TotalCost || 0), 0),\n        errors: runsInPeriod.filter(r => !r.Success).length\n      });\n    }\n    \n    return points;\n  }, [filteredRuns, timeRange]);\n  \n  // Render histogram\n  const renderHistogram = () => {\n    const maxCount = Math.max(...executionTimeDistribution.map(d => d.count));\n    const barWidth = 100 / executionTimeDistribution.length;\n    \n    return (\n      <div style={{ height: '150px', position: 'relative' }}>\n        <svg width=\"100%\" height=\"100%\">\n          {executionTimeDistribution.map((bucket, index) => {\n            const barHeight = maxCount > 0 ? (bucket.count / maxCount) * 130 : 0;\n            \n            return (\n              <g key={index}>\n                <rect\n                  x={`${index * barWidth}%`}\n                  y={130 - barHeight}\n                  width={`${barWidth - 2}%`}\n                  height={barHeight}\n                  fill={styles.colors.primary}\n                  opacity={0.7}\n                />\n                <text\n                  x={`${index * barWidth + barWidth / 2}%`}\n                  y={145}\n                  textAnchor=\"middle\"\n                  fontSize=\"9\"\n                  fill={styles.colors.textSecondary}\n                  transform={`rotate(-45 ${index * barWidth + barWidth / 2} 145)`}\n                >\n                  {bucket.range}\n                </text>\n              </g>\n            );\n          })}\n        </svg>\n      </div>\n    );\n  };\n  \n  // Render pie chart for cost breakdown\n  const renderPieChart = () => {\n    const size = 150;\n    const radius = size / 2;\n    let cumulativeAngle = 0;\n    const totalCost = costByAgent.reduce((sum, a) => sum + a.cost, 0);\n    \n    return (\n      <svg width={size} height={size}>\n        {costByAgent.slice(0, 5).map((item, index) => {\n          const percentage = totalCost > 0 ? (item.cost / totalCost) * 100 : 0;\n          const angle = (percentage / 100) * 360;\n          const startAngle = cumulativeAngle;\n          const endAngle = cumulativeAngle + angle;\n          cumulativeAngle += angle;\n          \n          const startAngleRad = (startAngle * Math.PI) / 180;\n          const endAngleRad = (endAngle * Math.PI) / 180;\n          \n          const x1 = radius + radius * Math.cos(startAngleRad);\n          const y1 = radius + radius * Math.sin(startAngleRad);\n          const x2 = radius + radius * Math.cos(endAngleRad);\n          const y2 = radius + radius * Math.sin(endAngleRad);\n          \n          const largeArcFlag = angle > 180 ? 1 : 0;\n          \n          const colors = [\n            styles.colors.primary,\n            styles.colors.secondary,\n            styles.colors.success,\n            styles.colors.warning,\n            styles.colors.info || styles.colors.primary\n          ];\n          \n          return (\n            <path\n              key={item.agent}\n              d={`M ${radius} ${radius} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`}\n              fill={colors[index % colors.length]}\n              opacity={0.8}\n              title={`${item.agent}: $${item.cost.toFixed(2)}`}\n            />\n          );\n        })}\n      </svg>\n    );\n  };\n  \n  // Render time series chart\n  const renderTimeSeriesChart = () => {\n    if (timeSeriesData.length === 0) return null;\n    \n    const maxValue = Math.max(\n      ...timeSeriesData.map(d => \n        selectedMetric === 'runs' ? d.runs :\n        selectedMetric === 'tokens' ? d.tokens :\n        selectedMetric === 'cost' ? d.cost :\n        d.errors\n      )\n    );\n    \n    const width = 300;\n    const height = 100;\n    const pointSpacing = width / (timeSeriesData.length - 1);\n    \n    return (\n      <svg width={width} height={height}>\n        {/* Grid lines */}\n        {[0, 25, 50, 75, 100].map(y => (\n          <line\n            key={y}\n            x1={0}\n            y1={y}\n            x2={width}\n            y2={y}\n            stroke={styles.colors.border}\n            strokeWidth={0.5}\n            opacity={0.3}\n          />\n        ))}\n        \n        {/* Data line */}\n        <polyline\n          points={timeSeriesData.map((d, i) => {\n            const value = selectedMetric === 'runs' ? d.runs :\n                         selectedMetric === 'tokens' ? d.tokens :\n                         selectedMetric === 'cost' ? d.cost :\n                         d.errors;\n            const y = maxValue > 0 ? height - (value / maxValue) * height : height;\n            return `${i * pointSpacing},${y}`;\n          }).join(' ')}\n          fill=\"none\"\n          stroke={styles.colors.primary}\n          strokeWidth={2}\n        />\n        \n        {/* Data points */}\n        {timeSeriesData.map((d, i) => {\n          const value = selectedMetric === 'runs' ? d.runs :\n                       selectedMetric === 'tokens' ? d.tokens :\n                       selectedMetric === 'cost' ? d.cost :\n                       d.errors;\n          const y = maxValue > 0 ? height - (value / maxValue) * height : height;\n          \n          return (\n            <circle\n              key={i}\n              cx={i * pointSpacing}\n              cy={y}\n              r={3}\n              fill={styles.colors.primary}\n              title={`${d.time}: ${value}`}\n            />\n          );\n        })}\n      </svg>\n    );\n  };\n  \n  return (\n    <div style={{\n      height: '100%',\n      padding: styles.spacing.lg,\n      backgroundColor: styles.colors.background,\n      overflow: 'auto'\n    }}>\n      <h3 style={{\n        margin: 0,\n        marginBottom: styles.spacing.md,\n        fontSize: styles.typography.fontSize.lg,\n        fontWeight: styles.typography.fontWeight?.semibold || '600',\n        color: styles.colors.text\n      }}>\n        Performance Metrics\n      </h3>\n      \n      {/* Key Metrics Cards */}\n      <div style={{\n        display: 'grid',\n        gridTemplateColumns: 'repeat(2, 1fr)',\n        gap: styles.spacing.sm,\n        marginBottom: styles.spacing.lg\n      }}>\n        <div style={{\n          padding: styles.spacing.sm,\n          backgroundColor: styles.colors.surface,\n          borderRadius: getBorderRadius('sm'),\n          borderLeft: `3px solid ${styles.colors.primary}`\n        }}>\n          <div style={{\n            fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n            color: styles.colors.textSecondary\n          }}>\n            Success Rate\n          </div>\n          <div style={{\n            fontSize: styles.typography.fontSize.lg,\n            fontWeight: styles.typography.fontWeight?.bold || '700',\n            color: metrics.successRate >= 90 ? styles.colors.success : \n                  metrics.successRate >= 70 ? styles.colors.warning : \n                  styles.colors.error\n          }}>\n            {metrics.successRate.toFixed(1)}%\n          </div>\n        </div>\n        \n        <div style={{\n          padding: styles.spacing.sm,\n          backgroundColor: styles.colors.surface,\n          borderRadius: getBorderRadius('sm'),\n          borderLeft: `3px solid ${styles.colors.secondary}`\n        }}>\n          <div style={{\n            fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n            color: styles.colors.textSecondary\n          }}>\n            Avg Time\n          </div>\n          <div style={{\n            fontSize: styles.typography.fontSize.lg,\n            fontWeight: styles.typography.fontWeight?.bold || '700',\n            color: styles.colors.text\n          }}>\n            {(metrics.avgExecutionTime / 1000).toFixed(2)}s\n          </div>\n        </div>\n        \n        <div style={{\n          padding: styles.spacing.sm,\n          backgroundColor: styles.colors.surface,\n          borderRadius: getBorderRadius('sm'),\n          borderLeft: `3px solid ${styles.colors.warning || styles.colors.secondary}`\n        }}>\n          <div style={{\n            fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n            color: styles.colors.textSecondary\n          }}>\n            Total Cost\n          </div>\n          <div style={{\n            fontSize: styles.typography.fontSize.lg,\n            fontWeight: styles.typography.fontWeight?.bold || '700',\n            color: styles.colors.text\n          }}>\n            ${metrics.totalCost.toFixed(2)}\n          </div>\n        </div>\n        \n        <div style={{\n          padding: styles.spacing.sm,\n          backgroundColor: styles.colors.surface,\n          borderRadius: getBorderRadius('sm'),\n          borderLeft: `3px solid ${styles.colors.info || styles.colors.primary}`\n        }}>\n          <div style={{\n            fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n            color: styles.colors.textSecondary\n          }}>\n            Total Tokens\n          </div>\n          <div style={{\n            fontSize: styles.typography.fontSize.lg,\n            fontWeight: styles.typography.fontWeight?.bold || '700',\n            color: styles.colors.text\n          }}>\n            {metrics.totalTokens.toLocaleString()}\n          </div>\n        </div>\n      </div>\n      \n      {/* Execution Time Distribution */}\n      <div style={{\n        marginBottom: styles.spacing.lg,\n        padding: styles.spacing.md,\n        backgroundColor: styles.colors.surface,\n        borderRadius: getBorderRadius('sm')\n      }}>\n        <h4 style={{\n          margin: 0,\n          marginBottom: styles.spacing.sm,\n          fontSize: styles.typography.fontSize.md,\n          fontWeight: styles.typography.fontWeight?.medium || '500',\n          color: styles.colors.text\n        }}>\n          Execution Time Distribution\n        </h4>\n        {renderHistogram()}\n        <div style={{\n          display: 'flex',\n          justifyContent: 'space-between',\n          marginTop: styles.spacing.sm,\n          fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n          color: styles.colors.textSecondary\n        }}>\n          <span>Median: {(metrics.medianExecutionTime / 1000).toFixed(2)}s</span>\n          <span>P95: {(metrics.p95ExecutionTime / 1000).toFixed(2)}s</span>\n        </div>\n      </div>\n      \n      {/* Cost Breakdown */}\n      <div style={{\n        marginBottom: styles.spacing.lg,\n        padding: styles.spacing.md,\n        backgroundColor: styles.colors.surface,\n        borderRadius: getBorderRadius('sm')\n      }}>\n        <h4 style={{\n          margin: 0,\n          marginBottom: styles.spacing.sm,\n          fontSize: styles.typography.fontSize.md,\n          fontWeight: styles.typography.fontWeight?.medium || '500',\n          color: styles.colors.text\n        }}>\n          Cost by Agent\n        </h4>\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.md,\n          alignItems: 'center'\n        }}>\n          {renderPieChart()}\n          <div style={{\n            flex: 1,\n            fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm\n          }}>\n            {costByAgent.slice(0, 5).map((item, index) => {\n              const colors = [\n                styles.colors.primary,\n                styles.colors.secondary,\n                styles.colors.success,\n                styles.colors.warning,\n                styles.colors.info || styles.colors.primary\n              ];\n              \n              return (\n                <div\n                  key={item.agent}\n                  style={{\n                    display: 'flex',\n                    alignItems: 'center',\n                    marginBottom: styles.spacing.xs\n                  }}\n                >\n                  <div style={{\n                    width: '8px',\n                    height: '8px',\n                    borderRadius: '2px',\n                    backgroundColor: colors[index % colors.length],\n                    marginRight: styles.spacing.xs\n                  }} />\n                  <div style={{ flex: 1, color: styles.colors.text }}>\n                    {item.agent}\n                  </div>\n                  <div style={{ color: styles.colors.textSecondary }}>\n                    ${item.cost.toFixed(2)}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </div>\n      </div>\n      \n      {/* Time Series */}\n      <div style={{\n        padding: styles.spacing.md,\n        backgroundColor: styles.colors.surface,\n        borderRadius: getBorderRadius('sm')\n      }}>\n        <div style={{\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          marginBottom: styles.spacing.sm\n        }}>\n          <h4 style={{\n            margin: 0,\n            fontSize: styles.typography.fontSize.md,\n            fontWeight: styles.typography.fontWeight?.medium || '500',\n            color: styles.colors.text\n          }}>\n            Trend Analysis\n          </h4>\n          \n          <div style={{\n            display: 'flex',\n            gap: styles.spacing.xs\n          }}>\n            {['runs', 'tokens', 'cost', 'errors'].map(metric => (\n              <button\n                key={metric}\n                onClick={() => {\n                  setSelectedMetric(metric);\n                  onSaveUserSettings?.({ ...savedUserSettings, selectedMetric: metric });\n                }}\n                style={{\n                  padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n                  backgroundColor: selectedMetric === metric ? styles.colors.primary : styles.colors.background,\n                  color: selectedMetric === metric ? 'white' : styles.colors.text,\n                  border: `1px solid ${styles.colors.border}`,\n                  borderRadius: getBorderRadius('xs') || getBorderRadius('sm'),\n                  cursor: 'pointer',\n                  fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n                  textTransform: 'capitalize'\n                }}\n              >\n                {metric}\n              </button>\n            ))}\n          </div>\n        </div>\n        \n        {renderTimeSeriesChart()}\n      </div>\n      \n      {/* Error Analysis */}\n      {Object.keys(metrics.errorsByType).length > 0 && (\n        <div style={{\n          marginTop: styles.spacing.lg,\n          padding: styles.spacing.md,\n          backgroundColor: styles.colors.surface,\n          borderRadius: getBorderRadius('sm'),\n          borderLeft: `3px solid ${styles.colors.error}`\n        }}>\n          <h4 style={{\n            margin: 0,\n            marginBottom: styles.spacing.sm,\n            fontSize: styles.typography.fontSize.md,\n            fontWeight: styles.typography.fontWeight?.medium || '500',\n            color: styles.colors.text\n          }}>\n            Error Patterns\n          </h4>\n          <div style={{\n            fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm\n          }}>\n            {Object.entries(metrics.errorsByType)\n              .sort((a, b) => b[1] - a[1])\n              .slice(0, 5)\n              .map(([error, count]) => (\n                <div\n                  key={error}\n                  style={{\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                    padding: styles.spacing.xs,\n                    borderBottom: `1px solid ${styles.colors.border}`\n                  }}\n                >\n                  <span style={{ color: styles.colors.text }}>{error}</span>\n                  <span style={{ color: styles.colors.error }}>{count} occurrences</span>\n                </div>\n              ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}",
  "dependencies": [],
  "libraries": []
}