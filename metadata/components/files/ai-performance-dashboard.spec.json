{
  "name": "AIPerformanceDashboard",
  "location": "embedded",
  "title": "AI Performance Dashboard",
  "description": "Comprehensive dashboard for analyzing AI agent and prompt performance with time-series charts, cost analysis, and drill-down capabilities",
  "type": "dashboard",
  "functionalRequirements": "## AI Performance Dashboard Requirements\n\n### Core Functionality\n- Display multi-line time series charts showing total runs, tokens, and costs over time\n- Support multiple time groupings: day, week, month, quarter\n- Dual Y-axis display (tokens on left, runs/costs on right)\n- Click-to-drill-down on any chart point to see details for that period\n- Show distribution charts (pie/bar) for selected time period\n- Separate tabs for Agent Runs and Prompt Runs analysis\n- Real-time data refresh capabilities\n- Export functionality for charts and data\n\n### Analytics Features\n- Time series trends with moving averages\n- Cost breakdown by agent/prompt\n- Token usage distribution\n- Success/failure rate analysis\n- Performance comparisons across periods\n- Top consumers identification\n- Anomaly detection and alerts\n\n### UX Considerations\n- Responsive layout adapting to container size\n- Interactive tooltips on hover\n- Smooth chart animations\n- Loading states during data fetch\n- Clear visual hierarchy\n- Consistent color coding across charts\n- Mobile-responsive design",
  "dataRequirements": {
    "mode": "views",
    "description": "Loads AI performance data including agent runs, prompt runs, and aggregated metrics",
    "entities": [
      {
        "name": "MJ: AI Agent Runs",
        "description": "Historical agent execution data for performance analysis",
        "displayFields": [
          "ID",
          "AgentID",
          "Agent",
          "StartedAt",
          "CompletedAt",
          "Success",
          "TotalTokensUsed",
          "TotalCost"
        ],
        "filterFields": [
          "StartedAt",
          "Success",
          "AgentID"
        ],
        "sortFields": [
          "StartedAt"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "type": "uniqueidentifier",
            "isPrimaryKey": true,
            "allowsNull": false,
            "description": "Unique run identifier"
          },
          {
            "name": "AgentID",
            "type": "uniqueidentifier",
            "allowsNull": false,
            "description": "Reference to AI Agent"
          },
          {
            "name": "Agent",
            "type": "nvarchar",
            "allowsNull": true,
            "description": "Agent name (denormalized)"
          },
          {
            "name": "StartedAt",
            "type": "datetime",
            "allowsNull": false,
            "description": "Execution start timestamp"
          },
          {
            "name": "TotalTokensUsed",
            "type": "int",
            "allowsNull": true,
            "description": "Total tokens consumed"
          },
          {
            "name": "TotalCost",
            "type": "decimal",
            "allowsNull": true,
            "description": "Total cost in USD"
          }
        ],
        "permissionLevelNeeded": ["read"]
      },
      {
        "name": "MJ: AI Prompt Runs",
        "description": "Historical prompt execution data for performance analysis",
        "displayFields": [
          "ID",
          "PromptID",
          "Prompt",
          "ModelID",
          "Model",
          "RunAt",
          "CompletedAt",
          "Success",
          "TokensUsed",
          "TotalCost"
        ],
        "filterFields": [
          "RunAt",
          "Success",
          "PromptID",
          "ModelID"
        ],
        "sortFields": [
          "RunAt"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "type": "uniqueidentifier",
            "isPrimaryKey": true,
            "allowsNull": false,
            "description": "Unique run identifier"
          },
          {
            "name": "PromptID",
            "type": "uniqueidentifier",
            "allowsNull": false,
            "description": "Reference to AI Prompt"
          },
          {
            "name": "Prompt",
            "type": "nvarchar",
            "allowsNull": true,
            "description": "Prompt name (denormalized)"
          },
          {
            "name": "RunAt",
            "type": "datetime",
            "allowsNull": false,
            "description": "Execution timestamp"
          },
          {
            "name": "TokensUsed",
            "type": "int",
            "allowsNull": true,
            "description": "Total tokens consumed"
          },
          {
            "name": "TotalCost",
            "type": "decimal",
            "allowsNull": true,
            "description": "Total cost in USD"
          }
        ],
        "permissionLevelNeeded": ["read"]
      }
    ],
    "queries": []
  },
  "technicalDesign": "## Component Architecture\n\n### Root Component (AIPerformanceDashboard)\n- Manages overall dashboard state and data loading\n- Handles time range selection and grouping\n- Coordinates drill-down state between components\n- Manages tab switching between Agent and Prompt views\n\n### Child Components\n1. **AITimeSeriesChart**: Multi-line chart with dual Y-axes for runs/tokens/costs\n2. **AIDistributionChart**: Pie/bar charts showing breakdown by agent or prompt\n3. **AIDetailTable**: Detailed table view for drill-down data\n4. **AIMetricsSummary**: Key metrics cards for selected period\n\n### Data Flow\n- Root component loads data based on selected time range\n- Aggregates data by selected grouping (day/week/month/quarter)\n- Passes aggregated data to chart components\n- Handles drill-down events and updates detail views\n- Manages state persistence through savedUserSettings\n\n### State Management\n- Selected time range and grouping\n- Active tab (agents vs prompts)\n- Drill-down selection (selected date/period)\n- Chart view preferences\n- Filter states",
  "properties": [],
  "events": [],
  "exampleUsage": "<AIPerformanceDashboard />",
  "code": "function AIPerformanceDashboard({ utilities, styles, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIPerformanceDashboard] Initializing with settings:', savedUserSettings);\n  console.log('[AIPerformanceDashboard] Available components:', components ? Object.keys(components) : 'none');\n  \n  // Extract child components with fallbacks\n  const AITimeSeriesChart = components?.AITimeSeriesChart;\n  const AIDistributionChart = components?.AIDistributionChart;\n  const AIDetailTable = components?.AIDetailTable;\n  const AIMetricsSummary = components?.AIMetricsSummary;\n  \n  // Check if required components are available\n  if (!AITimeSeriesChart || !AIDistributionChart || !AIDetailTable || !AIMetricsSummary) {\n    return (\n      <div style={{\n        padding: styles?.spacing?.lg || '20px',\n        color: styles?.colors?.error || 'red',\n        textAlign: 'center'\n      }}>\n        Error: Required child components are not available. Please ensure all dashboard components are loaded.\n        <br />\n        Missing: {[\n          !AITimeSeriesChart && 'AITimeSeriesChart',\n          !AIDistributionChart && 'AIDistributionChart',\n          !AIDetailTable && 'AIDetailTable',\n          !AIMetricsSummary && 'AIMetricsSummary'\n        ].filter(Boolean).join(', ')}\n      </div>\n    );\n  }\n  \n  // Initialize state from saved settings\n  const [timeRange, setTimeRange] = useState(savedUserSettings?.timeRange || '30d');\n  const [groupBy, setGroupBy] = useState(savedUserSettings?.groupBy || 'day');\n  const [activeTab, setActiveTab] = useState(savedUserSettings?.activeTab || 'agents');\n  const [selectedPoint, setSelectedPoint] = useState(null);\n  \n  // Data state\n  const [agentRuns, setAgentRuns] = useState([]);\n  const [promptRuns, setPromptRuns] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Calculate date range\n  const getDateRange = useCallback(() => {\n    const end = new Date();\n    const start = new Date();\n    \n    switch(timeRange) {\n      case '7d':\n        start.setDate(end.getDate() - 7);\n        break;\n      case '30d':\n        start.setDate(end.getDate() - 30);\n        break;\n      case '90d':\n        start.setDate(end.getDate() - 90);\n        break;\n      case '1y':\n        start.setFullYear(end.getFullYear() - 1);\n        break;\n      default:\n        start.setDate(end.getDate() - 30);\n    }\n    \n    return { start, end };\n  }, [timeRange]);\n  \n  // Load data\n  useEffect(() => {\n    const loadData = async () => {\n      console.log('[AIPerformanceDashboard] Loading data for range:', timeRange);\n      setLoading(true);\n      setError(null);\n      \n      const { start, end } = getDateRange();\n      \n      try {\n        // Load agent runs\n        const agentFilter = `StartedAt >= '${start.toISOString()}' AND StartedAt <= '${end.toISOString()}'`;\n        console.log('[AIPerformanceDashboard] Loading agent runs with filter:', agentFilter);\n        \n        const agentResult = await utilities.rv.RunView({\n          EntityName: 'MJ: AI Agent Runs',\n          ExtraFilter: agentFilter,\n          OrderBy: 'StartedAt ASC',\n          Fields: ['ID', 'AgentID', 'Agent', 'StartedAt', 'CompletedAt', 'Success', 'TotalTokensUsed', 'TotalCost'],\n          MaxRows: 10000\n        });\n        \n        console.log('[AIPerformanceDashboard] Agent runs loaded:', {\n          success: agentResult?.Success,\n          count: agentResult?.Results?.length,\n          error: agentResult?.ErrorMessage\n        });\n        \n        if (agentResult?.Success) {\n          setAgentRuns(agentResult.Results || []);\n        } else {\n          console.error('[AIPerformanceDashboard] Failed to load agent runs:', agentResult?.ErrorMessage);\n        }\n        \n        // Load prompt runs\n        const promptFilter = `RunAt >= '${start.toISOString()}' AND RunAt <= '${end.toISOString()}'`;\n        console.log('[AIPerformanceDashboard] Loading prompt runs with filter:', promptFilter);\n        \n        const promptResult = await utilities.rv.RunView({\n          EntityName: 'MJ: AI Prompt Runs',\n          ExtraFilter: promptFilter,\n          OrderBy: 'RunAt ASC',\n          Fields: ['ID', 'PromptID', 'Prompt', 'ModelID', 'Model', 'RunAt', 'CompletedAt', 'Success', 'TokensUsed', 'TotalCost'],\n          MaxRows: 10000\n        });\n        \n        console.log('[AIPerformanceDashboard] Prompt runs loaded:', {\n          success: promptResult?.Success,\n          count: promptResult?.Results?.length,\n          error: promptResult?.ErrorMessage\n        });\n        \n        if (promptResult?.Success) {\n          setPromptRuns(promptResult.Results || []);\n        } else {\n          console.error('[AIPerformanceDashboard] Failed to load prompt runs:', promptResult?.ErrorMessage);\n        }\n        \n      } catch (error) {\n        console.error('[AIPerformanceDashboard] Error loading data:', error);\n        setError(error.message || 'Failed to load data');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadData();\n  }, [timeRange, utilities.rv, getDateRange]);\n  \n  // Aggregate data by time period\n  const aggregateData = useCallback((data, dateField, grouping) => {\n    console.log(`[AIPerformanceDashboard] Aggregating ${data.length} records by ${grouping}`);\n    \n    const grouped = {};\n    \n    data.forEach(item => {\n      const date = new Date(item[dateField]);\n      let key;\n      \n      switch(grouping) {\n        case 'day':\n          key = date.toISOString().split('T')[0];\n          break;\n        case 'week':\n          const weekStart = new Date(date);\n          weekStart.setDate(date.getDate() - date.getDay());\n          key = weekStart.toISOString().split('T')[0];\n          break;\n        case 'month':\n          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n          break;\n        case 'quarter':\n          const quarter = Math.floor(date.getMonth() / 3) + 1;\n          key = `${date.getFullYear()}-Q${quarter}`;\n          break;\n        default:\n          key = date.toISOString().split('T')[0];\n      }\n      \n      if (!grouped[key]) {\n        grouped[key] = {\n          date: key,\n          runs: 0,\n          tokens: 0,\n          cost: 0,\n          items: []\n        };\n      }\n      \n      grouped[key].runs++;\n      grouped[key].tokens += (item.TotalTokensUsed || item.TokensUsed || 0);\n      grouped[key].cost += (item.TotalCost || 0);\n      grouped[key].items.push(item);\n    });\n    \n    const result = Object.values(grouped).sort((a, b) => a.date.localeCompare(b.date));\n    console.log(`[AIPerformanceDashboard] Aggregated into ${result.length} groups`);\n    return result;\n  }, []);\n  \n  // Get aggregated data for current view\n  const chartData = useMemo(() => {\n    const data = activeTab === 'agents' ? agentRuns : promptRuns;\n    const dateField = activeTab === 'agents' ? 'StartedAt' : 'RunAt';\n    return aggregateData(data, dateField, groupBy);\n  }, [activeTab, agentRuns, promptRuns, groupBy, aggregateData]);\n  \n  // Handle drill-down\n  const handleChartClick = useCallback((dataPoint) => {\n    console.log('[AIPerformanceDashboard] Chart clicked:', dataPoint);\n    setSelectedPoint(dataPoint);\n  }, []);\n  \n  // Handle time range change\n  const handleTimeRangeChange = useCallback((range) => {\n    console.log('[AIPerformanceDashboard] Time range changed to:', range);\n    setTimeRange(range);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      timeRange: range\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Handle grouping change\n  const handleGroupByChange = useCallback((grouping) => {\n    console.log('[AIPerformanceDashboard] Grouping changed to:', grouping);\n    setGroupBy(grouping);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      groupBy: grouping\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Handle tab change\n  const handleTabChange = useCallback((tab) => {\n    console.log('[AIPerformanceDashboard] Tab changed to:', tab);\n    setActiveTab(tab);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      activeTab: tab\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Calculate summary metrics\n  const metrics = useMemo(() => {\n    const data = activeTab === 'agents' ? agentRuns : promptRuns;\n    return {\n      totalRuns: data.length,\n      totalTokens: data.reduce((sum, item) => sum + (item.TotalTokensUsed || item.TokensUsed || 0), 0),\n      totalCost: data.reduce((sum, item) => sum + (item.TotalCost || 0), 0),\n      avgTokensPerRun: data.length > 0 ? Math.round(data.reduce((sum, item) => sum + (item.TotalTokensUsed || item.TokensUsed || 0), 0) / data.length) : 0,\n      avgCostPerRun: data.length > 0 ? data.reduce((sum, item) => sum + (item.TotalCost || 0), 0) / data.length : 0\n    };\n  }, [activeTab, agentRuns, promptRuns]);\n  \n  console.log('[AIPerformanceDashboard] Current state:', {\n    timeRange,\n    groupBy,\n    activeTab,\n    agentRunsCount: agentRuns.length,\n    promptRunsCount: promptRuns.length,\n    chartDataPoints: chartData.length,\n    selectedPoint: selectedPoint?.date\n  });\n  \n  if (loading) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100%',\n        color: styles.colors.textSecondary\n      }}>\n        Loading performance data...\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100%',\n        color: styles.colors.error\n      }}>\n        Error: {error}\n      </div>\n    );\n  }\n  \n  return (\n    <div style={{\n      height: '100%',\n      display: 'flex',\n      flexDirection: 'column',\n      backgroundColor: styles.colors.background,\n      padding: styles.spacing.md\n    }}>\n      {/* Header Controls */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        marginBottom: styles.spacing.lg,\n        flexWrap: 'wrap',\n        gap: styles.spacing.md\n      }}>\n        {/* Tab Selector */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.xs,\n          backgroundColor: styles.colors.surface,\n          padding: styles.spacing.xs,\n          borderRadius: styles.borders?.radius || '4px'\n        }}>\n          <button\n            onClick={() => handleTabChange('agents')}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: activeTab === 'agents' ? styles.colors.primary : 'transparent',\n              color: activeTab === 'agents' ? 'white' : styles.colors.text,\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: 'pointer',\n              fontWeight: activeTab === 'agents' ? '600' : '400'\n            }}\n          >\n            Agent Runs\n          </button>\n          <button\n            onClick={() => handleTabChange('prompts')}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: activeTab === 'prompts' ? styles.colors.primary : 'transparent',\n              color: activeTab === 'prompts' ? 'white' : styles.colors.text,\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: 'pointer',\n              fontWeight: activeTab === 'prompts' ? '600' : '400'\n            }}\n          >\n            Prompt Runs\n          </button>\n        </div>\n        \n        {/* Time Controls */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.md,\n          alignItems: 'center'\n        }}>\n          {/* Time Range */}\n          <select\n            value={timeRange}\n            onChange={(e) => handleTimeRangeChange(e.target.value)}\n            style={{\n              padding: styles.spacing.sm,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.surface,\n              color: styles.colors.text\n            }}\n          >\n            <option value=\"7d\">Last 7 Days</option>\n            <option value=\"30d\">Last 30 Days</option>\n            <option value=\"90d\">Last 90 Days</option>\n            <option value=\"1y\">Last Year</option>\n          </select>\n          \n          {/* Group By */}\n          <select\n            value={groupBy}\n            onChange={(e) => handleGroupByChange(e.target.value)}\n            style={{\n              padding: styles.spacing.sm,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.surface,\n              color: styles.colors.text\n            }}\n          >\n            <option value=\"day\">By Day</option>\n            <option value=\"week\">By Week</option>\n            <option value=\"month\">By Month</option>\n            <option value=\"quarter\">By Quarter</option>\n          </select>\n        </div>\n      </div>\n      \n      {/* Metrics Summary */}\n      <AIMetricsSummary\n        metrics={metrics}\n        styles={styles}\n        utilities={utilities}\n        components={components}\n        callbacks={callbacks}\n        savedUserSettings={savedUserSettings?.metricsSummary}\n        onSaveUserSettings={(settings) => onSaveUserSettings?.({\n          ...savedUserSettings,\n          metricsSummary: settings\n        })}\n      />\n      \n      {/* Main Chart Area */}\n      <div style={{\n        flex: 1,\n        display: 'flex',\n        flexDirection: 'column',\n        gap: styles.spacing.lg,\n        minHeight: 0\n      }}>\n        {/* Time Series Chart */}\n        <div style={{\n          flex: selectedPoint ? '0 0 400px' : '1',\n          minHeight: '300px'\n        }}>\n          <AITimeSeriesChart\n            data={chartData}\n            groupBy={groupBy}\n            activeTab={activeTab}\n            selectedPoint={selectedPoint}\n            onPointClick={handleChartClick}\n            styles={styles}\n            utilities={utilities}\n            components={components}\n            callbacks={callbacks}\n            savedUserSettings={savedUserSettings?.timeSeriesChart}\n            onSaveUserSettings={(settings) => onSaveUserSettings?.({\n              ...savedUserSettings,\n              timeSeriesChart: settings\n            })}\n          />\n        </div>\n        \n        {/* Drill-down Area */}\n        {selectedPoint && (\n          <div style={{\n            flex: 1,\n            display: 'flex',\n            gap: styles.spacing.md,\n            minHeight: 0\n          }}>\n            {/* Distribution Chart */}\n            <div style={{ flex: '0 0 400px' }}>\n              <AIDistributionChart\n                data={selectedPoint.items}\n                activeTab={activeTab}\n                groupBy={groupBy}\n                styles={styles}\n                utilities={utilities}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings?.distributionChart}\n                onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                  ...savedUserSettings,\n                  distributionChart: settings\n                })}\n              />\n            </div>\n            \n            {/* Detail Table */}\n            <div style={{ flex: 1, overflow: 'auto' }}>\n              <AIDetailTable\n                data={selectedPoint.items}\n                activeTab={activeTab}\n                styles={styles}\n                utilities={utilities}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings?.detailTable}\n                onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                  ...savedUserSettings,\n                  detailTable: settings\n                })}\n              />\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
  "dependencies": [
    {
      "name": "AITimeSeriesChart",
      "location": "embedded",
      "title": "AI Time Series Chart",
      "description": "Multi-line time series chart with dual Y-axes showing AI runs, token usage, and costs over time",
      "type": "chart",
      "functionalRequirements": "## Time Series Chart Requirements\n\n### Core Functionality\n- Display three data series: total runs, total tokens, total cost\n- Dual Y-axis configuration (left: tokens, right: runs and cost)\n- Interactive tooltips showing all values on hover\n- Click on data points to trigger drill-down\n- Smooth line interpolation with data point markers\n- Legend with series toggle capability\n\n### Visual Features\n- Different colors for each series\n- Hover effects on data points\n- Animated transitions\n- Responsive sizing\n- Grid lines for readability",
      "dataRequirements": {
        "mode": "views",
        "description": "Receives aggregated data from parent component",
        "entities": [],
        "queries": []
      },
      "technicalDesign": "## Technical Design\n\n### Props\n- data: Array of aggregated data points\n- groupBy: Time grouping (day/week/month/quarter)\n- activeTab: Current view context (agents/prompts)\n- selectedPoint: Currently selected data point\n- onPointClick: Callback for drill-down\n\n### Chart Implementation\n- SVG-based rendering for performance\n- Custom scales for dual Y-axes\n- D3-style data binding\n- Synchronized tooltips across series",
      "properties": [
        {
          "name": "data",
          "type": "array",
          "required": true,
          "description": "Array of aggregated time series data"
        },
        {
          "name": "groupBy",
          "type": "string",
          "required": true,
          "description": "Time grouping: day, week, month, quarter"
        },
        {
          "name": "onPointClick",
          "type": "function",
          "required": false,
          "description": "Callback when data point is clicked"
        }
      ],
      "events": [
        {
          "name": "onPointClick",
          "description": "Fired when user clicks on a data point",
          "payload": "{ date: string, runs: number, tokens: number, cost: number, items: array }"
        }
      ],
      "exampleUsage": "<AITimeSeriesChart data={chartData} groupBy=\"day\" onPointClick={handleDrillDown} />",
      "code": "function AITimeSeriesChart({ data, groupBy, activeTab, selectedPoint, onPointClick, styles, utilities, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AITimeSeriesChart] Rendering with', data?.length || 0, 'data points');\n  \n  const [hoveredPoint, setHoveredPoint] = useState(null);\n  const [showRuns, setShowRuns] = useState(savedUserSettings?.showRuns !== false);\n  const [showTokens, setShowTokens] = useState(savedUserSettings?.showTokens !== false);\n  const [showCost, setShowCost] = useState(savedUserSettings?.showCost !== false);\n  \n  const chartRef = useRef(null);\n  const [dimensions, setDimensions] = useState({ width: 800, height: 400 });\n  \n  // Update dimensions on resize\n  useEffect(() => {\n    const updateDimensions = () => {\n      if (chartRef.current) {\n        const { width, height } = chartRef.current.getBoundingClientRect();\n        setDimensions({ width: Math.max(width, 400), height: Math.max(height, 300) });\n      }\n    };\n    \n    updateDimensions();\n    window.addEventListener('resize', updateDimensions);\n    return () => window.removeEventListener('resize', updateDimensions);\n  }, []);\n  \n  // Calculate chart dimensions\n  const margin = { top: 20, right: 60, bottom: 40, left: 70 };\n  const chartWidth = dimensions.width - margin.left - margin.right;\n  const chartHeight = dimensions.height - margin.top - margin.bottom;\n  \n  // Calculate scales\n  const { xScale, yLeftScale, yRightScale, maxTokens, maxRuns, maxCost } = useMemo(() => {\n    if (!data || data.length === 0) {\n      return {\n        xScale: () => 0,\n        yLeftScale: () => 0,\n        yRightScale: () => 0,\n        maxTokens: 0,\n        maxRuns: 0,\n        maxCost: 0\n      };\n    }\n    \n    const maxTokens = Math.max(...data.map(d => d.tokens || 0));\n    const maxRuns = Math.max(...data.map(d => d.runs || 0));\n    const maxCost = Math.max(...data.map(d => d.cost || 0));\n    \n    // X scale (time)\n    const xScale = (index) => (index / (data.length - 1 || 1)) * chartWidth;\n    \n    // Y scales\n    const yLeftScale = (value) => chartHeight - (value / (maxTokens || 1)) * chartHeight;\n    const yRightScale = (value, max) => chartHeight - (value / (max || 1)) * chartHeight;\n    \n    return { xScale, yLeftScale, yRightScale, maxTokens, maxRuns, maxCost };\n  }, [data, chartWidth, chartHeight]);\n  \n  // Generate line paths\n  const { runsPath, tokensPath, costPath } = useMemo(() => {\n    if (!data || data.length === 0) {\n      return { runsPath: '', tokensPath: '', costPath: '' };\n    }\n    \n    const runsPoints = data.map((d, i) => `${xScale(i)},${yRightScale(d.runs, maxRuns)}`);\n    const tokensPoints = data.map((d, i) => `${xScale(i)},${yLeftScale(d.tokens)}`);\n    const costPoints = data.map((d, i) => `${xScale(i)},${yRightScale(d.cost, maxCost)}`);\n    \n    return {\n      runsPath: `M ${runsPoints.join(' L ')}`,\n      tokensPath: `M ${tokensPoints.join(' L ')}`,\n      costPath: `M ${costPoints.join(' L ')}`\n    };\n  }, [data, xScale, yLeftScale, yRightScale, maxTokens, maxRuns, maxCost]);\n  \n  // Format numbers for display\n  const formatNumber = (num) => {\n    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;\n    if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;\n    return num.toFixed(0);\n  };\n  \n  const formatCost = (cost) => {\n    if (cost >= 1000) return `$${(cost / 1000).toFixed(1)}K`;\n    if (cost >= 1) return `$${cost.toFixed(2)}`;\n    return `$${cost.toFixed(4)}`;\n  };\n  \n  // Handle series toggle\n  const toggleSeries = (series) => {\n    const updates = {\n      showRuns: showRuns,\n      showTokens: showTokens,\n      showCost: showCost\n    };\n    \n    switch(series) {\n      case 'runs':\n        updates.showRuns = !showRuns;\n        setShowRuns(!showRuns);\n        break;\n      case 'tokens':\n        updates.showTokens = !showTokens;\n        setShowTokens(!showTokens);\n        break;\n      case 'cost':\n        updates.showCost = !showCost;\n        setShowCost(!showCost);\n        break;\n    }\n    \n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      ...updates\n    });\n  };\n  \n  if (!data || data.length === 0) {\n    return (\n      <div style={{\n        width: '100%',\n        height: '100%',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        backgroundColor: styles.colors.surface,\n        borderRadius: styles.borders?.radius || '4px',\n        color: styles.colors.textSecondary\n      }}>\n        No data available for the selected time range\n      </div>\n    );\n  }\n  \n  return (\n    <div \n      ref={chartRef}\n      style={{\n        width: '100%',\n        height: '100%',\n        backgroundColor: styles.colors.surface,\n        borderRadius: styles.borders?.radius || '4px',\n        padding: styles.spacing.md\n      }}\n    >\n      {/* Legend */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        gap: styles.spacing.lg,\n        marginBottom: styles.spacing.md\n      }}>\n        <label \n          style={{\n            display: 'flex',\n            alignItems: 'center',\n            gap: styles.spacing.xs,\n            cursor: 'pointer',\n            opacity: showRuns ? 1 : 0.5\n          }}\n        >\n          <input\n            type=\"checkbox\"\n            checked={showRuns}\n            onChange={() => toggleSeries('runs')}\n            style={{ cursor: 'pointer' }}\n          />\n          <span style={{\n            width: '20px',\n            height: '3px',\n            backgroundColor: styles.colors.primary\n          }} />\n          <span style={{ color: styles.colors.text, fontSize: styles.typography.fontSize.sm }}>Runs</span>\n        </label>\n        \n        <label \n          style={{\n            display: 'flex',\n            alignItems: 'center',\n            gap: styles.spacing.xs,\n            cursor: 'pointer',\n            opacity: showTokens ? 1 : 0.5\n          }}\n        >\n          <input\n            type=\"checkbox\"\n            checked={showTokens}\n            onChange={() => toggleSeries('tokens')}\n            style={{ cursor: 'pointer' }}\n          />\n          <span style={{\n            width: '20px',\n            height: '3px',\n            backgroundColor: styles.colors.success\n          }} />\n          <span style={{ color: styles.colors.text, fontSize: styles.typography.fontSize.sm }}>Tokens</span>\n        </label>\n        \n        <label \n          style={{\n            display: 'flex',\n            alignItems: 'center',\n            gap: styles.spacing.xs,\n            cursor: 'pointer',\n            opacity: showCost ? 1 : 0.5\n          }}\n        >\n          <input\n            type=\"checkbox\"\n            checked={showCost}\n            onChange={() => toggleSeries('cost')}\n            style={{ cursor: 'pointer' }}\n          />\n          <span style={{\n            width: '20px',\n            height: '3px',\n            backgroundColor: styles.colors.warning\n          }} />\n          <span style={{ color: styles.colors.text, fontSize: styles.typography.fontSize.sm }}>Cost</span>\n        </label>\n      </div>\n      \n      {/* Chart */}\n      <svg \n        width={dimensions.width} \n        height={dimensions.height - 50}\n        style={{ display: 'block' }}\n      >\n        <g transform={`translate(${margin.left},${margin.top})`}>\n          {/* Grid lines */}\n          {[0, 0.25, 0.5, 0.75, 1].map((val) => (\n            <line\n              key={val}\n              x1={0}\n              y1={chartHeight * (1 - val)}\n              x2={chartWidth}\n              y2={chartHeight * (1 - val)}\n              stroke={styles.colors.border}\n              strokeOpacity={0.3}\n              strokeDasharray=\"2,2\"\n            />\n          ))}\n          \n          {/* Lines */}\n          {showTokens && (\n            <path\n              d={tokensPath}\n              fill=\"none\"\n              stroke={styles.colors.success}\n              strokeWidth={2}\n            />\n          )}\n          {showRuns && (\n            <path\n              d={runsPath}\n              fill=\"none\"\n              stroke={styles.colors.primary}\n              strokeWidth={2}\n            />\n          )}\n          {showCost && (\n            <path\n              d={costPath}\n              fill=\"none\"\n              stroke={styles.colors.warning}\n              strokeWidth={2}\n            />\n          )}\n          \n          {/* Data points */}\n          {data.map((point, i) => (\n            <g key={i}>\n              {showRuns && (\n                <circle\n                  cx={xScale(i)}\n                  cy={yRightScale(point.runs, maxRuns)}\n                  r={selectedPoint?.date === point.date ? 6 : 4}\n                  fill={styles.colors.primary}\n                  stroke=\"white\"\n                  strokeWidth={2}\n                  style={{ cursor: 'pointer' }}\n                  onClick={() => onPointClick?.(point)}\n                  onMouseEnter={() => setHoveredPoint({ ...point, index: i })}\n                  onMouseLeave={() => setHoveredPoint(null)}\n                />\n              )}\n              {showTokens && (\n                <circle\n                  cx={xScale(i)}\n                  cy={yLeftScale(point.tokens)}\n                  r={selectedPoint?.date === point.date ? 6 : 4}\n                  fill={styles.colors.success}\n                  stroke=\"white\"\n                  strokeWidth={2}\n                  style={{ cursor: 'pointer' }}\n                  onClick={() => onPointClick?.(point)}\n                  onMouseEnter={() => setHoveredPoint({ ...point, index: i })}\n                  onMouseLeave={() => setHoveredPoint(null)}\n                />\n              )}\n              {showCost && (\n                <circle\n                  cx={xScale(i)}\n                  cy={yRightScale(point.cost, maxCost)}\n                  r={selectedPoint?.date === point.date ? 6 : 4}\n                  fill={styles.colors.warning}\n                  stroke=\"white\"\n                  strokeWidth={2}\n                  style={{ cursor: 'pointer' }}\n                  onClick={() => onPointClick?.(point)}\n                  onMouseEnter={() => setHoveredPoint({ ...point, index: i })}\n                  onMouseLeave={() => setHoveredPoint(null)}\n                />\n              )}\n            </g>\n          ))}\n          \n          {/* Axes */}\n          {/* X-axis */}\n          <line\n            x1={0}\n            y1={chartHeight}\n            x2={chartWidth}\n            y2={chartHeight}\n            stroke={styles.colors.border}\n          />\n          \n          {/* X-axis labels */}\n          {data.map((point, i) => {\n            if (data.length > 10 && i % Math.ceil(data.length / 10) !== 0) return null;\n            return (\n              <text\n                key={i}\n                x={xScale(i)}\n                y={chartHeight + 20}\n                textAnchor=\"middle\"\n                fontSize={10}\n                fill={styles.colors.textSecondary}\n              >\n                {point.date}\n              </text>\n            );\n          })}\n          \n          {/* Y-axis left (tokens) */}\n          <line\n            x1={0}\n            y1={0}\n            x2={0}\n            y2={chartHeight}\n            stroke={styles.colors.border}\n          />\n          \n          {/* Y-axis left labels */}\n          <text\n            x={-10}\n            y={chartHeight}\n            textAnchor=\"end\"\n            fontSize={10}\n            fill={styles.colors.textSecondary}\n          >\n            0\n          </text>\n          <text\n            x={-10}\n            y={5}\n            textAnchor=\"end\"\n            fontSize={10}\n            fill={styles.colors.textSecondary}\n          >\n            {formatNumber(maxTokens)}\n          </text>\n          \n          {/* Y-axis left title */}\n          <text\n            x={-40}\n            y={chartHeight / 2}\n            textAnchor=\"middle\"\n            fontSize={12}\n            fill={styles.colors.success}\n            transform={`rotate(-90, -40, ${chartHeight / 2})`}\n          >\n            Tokens\n          </text>\n          \n          {/* Y-axis right (runs/cost) */}\n          <line\n            x1={chartWidth}\n            y1={0}\n            x2={chartWidth}\n            y2={chartHeight}\n            stroke={styles.colors.border}\n          />\n          \n          {/* Y-axis right labels */}\n          <text\n            x={chartWidth + 10}\n            y={chartHeight}\n            textAnchor=\"start\"\n            fontSize={10}\n            fill={styles.colors.textSecondary}\n          >\n            0\n          </text>\n          <text\n            x={chartWidth + 10}\n            y={5}\n            textAnchor=\"start\"\n            fontSize={10}\n            fill={styles.colors.textSecondary}\n          >\n            {formatNumber(Math.max(maxRuns, maxCost))}\n          </text>\n          \n          {/* Y-axis right title */}\n          <text\n            x={chartWidth + 40}\n            y={chartHeight / 2}\n            textAnchor=\"middle\"\n            fontSize={12}\n            fill={styles.colors.primary}\n            transform={`rotate(90, ${chartWidth + 40}, ${chartHeight / 2})`}\n          >\n            Runs / Cost\n          </text>\n        </g>\n        \n        {/* Tooltip */}\n        {hoveredPoint && (\n          <g transform={`translate(${margin.left},${margin.top})`}>\n            <rect\n              x={Math.min(xScale(hoveredPoint.index) + 10, chartWidth - 180)}\n              y={10}\n              width={170}\n              height={80}\n              fill={styles.colors.surface}\n              stroke={styles.colors.border}\n              rx={4}\n            />\n            <text\n              x={Math.min(xScale(hoveredPoint.index) + 20, chartWidth - 170)}\n              y={30}\n              fontSize={12}\n              fontWeight=\"bold\"\n              fill={styles.colors.text}\n            >\n              {hoveredPoint.date}\n            </text>\n            <text\n              x={Math.min(xScale(hoveredPoint.index) + 20, chartWidth - 170)}\n              y={50}\n              fontSize={11}\n              fill={styles.colors.primary}\n            >\n              Runs: {hoveredPoint.runs.toLocaleString()}\n            </text>\n            <text\n              x={Math.min(xScale(hoveredPoint.index) + 20, chartWidth - 170)}\n              y={65}\n              fontSize={11}\n              fill={styles.colors.success}\n            >\n              Tokens: {formatNumber(hoveredPoint.tokens)}\n            </text>\n            <text\n              x={Math.min(xScale(hoveredPoint.index) + 20, chartWidth - 170)}\n              y={80}\n              fontSize={11}\n              fill={styles.colors.warning}\n            >\n              Cost: {formatCost(hoveredPoint.cost)}\n            </text>\n          </g>\n        )}\n      </svg>\n    </div>\n  );\n}",
      "dependencies": [],
      "libraries": []
    },
    {
      "name": "AIDistributionChart",
      "location": "embedded",
      "title": "AI Distribution Chart",
      "description": "Pie and bar charts showing distribution of runs, tokens, and costs by agent or prompt for drill-down analysis",
      "type": "chart",
      "functionalRequirements": "## Distribution Chart Requirements\n\n### Core Functionality\n- Display distribution breakdown for selected time period\n- Toggle between pie chart and bar chart views\n- Show top 10 items with 'Others' grouping\n- Display runs, tokens, and cost metrics\n- Interactive tooltips with detailed values\n- Color-coded segments with legend\n\n### Visual Features\n- Smooth transitions between chart types\n- Hover effects on segments\n- Click to filter/highlight\n- Responsive sizing\n- Data labels for major segments",
      "dataRequirements": {
        "mode": "views",
        "description": "Receives drill-down data from parent component",
        "entities": [],
        "queries": []
      },
      "technicalDesign": "## Technical Design\n\n### Props\n- data: Array of individual run records\n- activeTab: Current view context (agents/prompts)\n- groupBy: Time grouping context\n\n### Chart Implementation\n- Aggregates data by agent/prompt\n- Calculates percentages\n- Sorts by total value\n- Groups small items into 'Others' category",
      "properties": [
        {
          "name": "data",
          "type": "array",
          "required": true,
          "description": "Array of run records to analyze"
        },
        {
          "name": "activeTab",
          "type": "string",
          "required": true,
          "description": "Current tab: agents or prompts"
        }
      ],
      "events": [],
      "exampleUsage": "<AIDistributionChart data={selectedPoint.items} activeTab=\"agents\" />",
      "code": "function AIDistributionChart({ data, activeTab, groupBy, styles, utilities, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIDistributionChart] Rendering with', data?.length || 0, 'items');\n  \n  const [chartType, setChartType] = useState(savedUserSettings?.chartType || 'pie');\n  const [metric, setMetric] = useState(savedUserSettings?.metric || 'runs');\n  \n  // Aggregate data by agent/prompt\n  const aggregatedData = useMemo(() => {\n    if (!data || data.length === 0) return [];\n    \n    const nameField = activeTab === 'agents' ? 'Agent' : 'Prompt';\n    const idField = activeTab === 'agents' ? 'AgentID' : 'PromptID';\n    const grouped = {};\n    \n    data.forEach(item => {\n      const key = item[nameField] || item[idField] || 'Unknown';\n      \n      if (!grouped[key]) {\n        grouped[key] = {\n          name: key,\n          runs: 0,\n          tokens: 0,\n          cost: 0\n        };\n      }\n      \n      grouped[key].runs++;\n      grouped[key].tokens += (item.TotalTokensUsed || item.TokensUsed || 0);\n      grouped[key].cost += (item.TotalCost || 0);\n    });\n    \n    // Sort by selected metric and take top 10\n    const sorted = Object.values(grouped)\n      .sort((a, b) => b[metric] - a[metric])\n      .slice(0, 10);\n    \n    // Calculate totals for percentage\n    const total = sorted.reduce((sum, item) => sum + item[metric], 0);\n    \n    return sorted.map(item => ({\n      ...item,\n      percentage: total > 0 ? (item[metric] / total) * 100 : 0\n    }));\n  }, [data, activeTab, metric]);\n  \n  // Generate colors\n  const colors = [\n    styles.colors.primary,\n    styles.colors.success,\n    styles.colors.warning,\n    styles.colors.error,\n    '#9b59b6',\n    '#3498db',\n    '#1abc9c',\n    '#f39c12',\n    '#95a5a6',\n    '#34495e'\n  ];\n  \n  const handleChartTypeChange = (type) => {\n    setChartType(type);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      chartType: type\n    });\n  };\n  \n  const handleMetricChange = (newMetric) => {\n    setMetric(newMetric);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      metric: newMetric\n    });\n  };\n  \n  const formatValue = (value) => {\n    if (metric === 'cost') return `$${value.toFixed(2)}`;\n    if (metric === 'tokens' && value > 1000) return `${(value / 1000).toFixed(1)}K`;\n    return value.toLocaleString();\n  };\n  \n  const renderPieChart = () => {\n    const size = 300;\n    const center = size / 2;\n    const radius = size / 2 - 20;\n    \n    let currentAngle = -Math.PI / 2;\n    \n    return (\n      <svg width={size} height={size}>\n        {aggregatedData.map((item, index) => {\n          const angle = (item.percentage / 100) * Math.PI * 2;\n          const startX = center + Math.cos(currentAngle) * radius;\n          const startY = center + Math.sin(currentAngle) * radius;\n          const endX = center + Math.cos(currentAngle + angle) * radius;\n          const endY = center + Math.sin(currentAngle + angle) * radius;\n          const largeArc = angle > Math.PI ? 1 : 0;\n          \n          const path = `\n            M ${center} ${center}\n            L ${startX} ${startY}\n            A ${radius} ${radius} 0 ${largeArc} 1 ${endX} ${endY}\n            Z\n          `;\n          \n          // Calculate label position\n          const labelAngle = currentAngle + angle / 2;\n          const labelRadius = radius * 0.7;\n          const labelX = center + Math.cos(labelAngle) * labelRadius;\n          const labelY = center + Math.sin(labelAngle) * labelRadius;\n          \n          currentAngle += angle;\n          \n          return (\n            <g key={index}>\n              <path\n                d={path}\n                fill={colors[index]}\n                stroke=\"white\"\n                strokeWidth={2}\n                opacity={0.8}\n                style={{ cursor: 'pointer' }}\n              >\n                <title>\n                  {item.name}: {formatValue(item[metric])} ({item.percentage.toFixed(1)}%)\n                </title>\n              </path>\n              {item.percentage > 5 && (\n                <text\n                  x={labelX}\n                  y={labelY}\n                  textAnchor=\"middle\"\n                  dominantBaseline=\"middle\"\n                  fontSize={12}\n                  fill=\"white\"\n                  fontWeight=\"bold\"\n                  pointerEvents=\"none\"\n                >\n                  {item.percentage.toFixed(0)}%\n                </text>\n              )}\n            </g>\n          );\n        })}\n      </svg>\n    );\n  };\n  \n  const renderBarChart = () => {\n    const maxValue = Math.max(...aggregatedData.map(d => d[metric]));\n    const barHeight = 30;\n    const chartWidth = 400;\n    const chartHeight = aggregatedData.length * (barHeight + 10);\n    \n    return (\n      <svg width={chartWidth} height={chartHeight}>\n        {aggregatedData.map((item, index) => {\n          const barWidth = (item[metric] / maxValue) * (chartWidth - 150);\n          const y = index * (barHeight + 10);\n          \n          return (\n            <g key={index}>\n              <rect\n                x={0}\n                y={y}\n                width={barWidth}\n                height={barHeight}\n                fill={colors[index]}\n                opacity={0.8}\n              />\n              <text\n                x={barWidth + 5}\n                y={y + barHeight / 2}\n                dominantBaseline=\"middle\"\n                fontSize={12}\n                fill={styles.colors.text}\n              >\n                {formatValue(item[metric])}\n              </text>\n              <text\n                x={chartWidth - 5}\n                y={y + barHeight / 2}\n                textAnchor=\"end\"\n                dominantBaseline=\"middle\"\n                fontSize={11}\n                fill={styles.colors.textSecondary}\n              >\n                {item.name.length > 20 ? item.name.substring(0, 20) + '...' : item.name}\n              </text>\n            </g>\n          );\n        })}\n      </svg>\n    );\n  };\n  \n  return (\n    <div style={{\n      width: '100%',\n      height: '100%',\n      backgroundColor: styles.colors.surface,\n      borderRadius: styles.borders?.radius || '4px',\n      padding: styles.spacing.md,\n      display: 'flex',\n      flexDirection: 'column'\n    }}>\n      {/* Header */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        marginBottom: styles.spacing.md\n      }}>\n        <h3 style={{\n          margin: 0,\n          color: styles.colors.text,\n          fontSize: styles.typography.fontSize.lg\n        }}>\n          Distribution Analysis\n        </h3>\n        \n        {/* Controls */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.sm\n        }}>\n          {/* Metric selector */}\n          <select\n            value={metric}\n            onChange={(e) => handleMetricChange(e.target.value)}\n            style={{\n              padding: styles.spacing.xs,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.background,\n              color: styles.colors.text,\n              fontSize: styles.typography.fontSize.sm\n            }}\n          >\n            <option value=\"runs\">Runs</option>\n            <option value=\"tokens\">Tokens</option>\n            <option value=\"cost\">Cost</option>\n          </select>\n          \n          {/* Chart type toggle */}\n          <div style={{\n            display: 'flex',\n            gap: '2px',\n            backgroundColor: styles.colors.background,\n            padding: '2px',\n            borderRadius: styles.borders?.radius || '4px'\n          }}>\n            <button\n              onClick={() => handleChartTypeChange('pie')}\n              style={{\n                padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n                backgroundColor: chartType === 'pie' ? styles.colors.primary : 'transparent',\n                color: chartType === 'pie' ? 'white' : styles.colors.text,\n                border: 'none',\n                borderRadius: styles.borders?.radius || '4px',\n                cursor: 'pointer',\n                fontSize: styles.typography.fontSize.sm\n              }}\n            >\n              Pie\n            </button>\n            <button\n              onClick={() => handleChartTypeChange('bar')}\n              style={{\n                padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n                backgroundColor: chartType === 'bar' ? styles.colors.primary : 'transparent',\n                color: chartType === 'bar' ? 'white' : styles.colors.text,\n                border: 'none',\n                borderRadius: styles.borders?.radius || '4px',\n                cursor: 'pointer',\n                fontSize: styles.typography.fontSize.sm\n              }}\n            >\n              Bar\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      {/* Chart */}\n      <div style={{\n        flex: 1,\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        minHeight: 0\n      }}>\n        {aggregatedData.length === 0 ? (\n          <div style={{\n            textAlign: 'center',\n            color: styles.colors.textSecondary\n          }}>\n            No data to display\n          </div>\n        ) : (\n          <div style={{\n            display: 'flex',\n            gap: styles.spacing.lg,\n            alignItems: 'center'\n          }}>\n            {/* Chart */}\n            <div>\n              {chartType === 'pie' ? renderPieChart() : renderBarChart()}\n            </div>\n            \n            {/* Legend */}\n            <div style={{\n              display: 'flex',\n              flexDirection: 'column',\n              gap: styles.spacing.xs,\n              maxHeight: '300px',\n              overflowY: 'auto'\n            }}>\n              {aggregatedData.map((item, index) => (\n                <div\n                  key={index}\n                  style={{\n                    display: 'flex',\n                    alignItems: 'center',\n                    gap: styles.spacing.xs\n                  }}\n                >\n                  <div\n                    style={{\n                      width: '12px',\n                      height: '12px',\n                      backgroundColor: colors[index],\n                      borderRadius: '2px'\n                    }}\n                  />\n                  <span style={{\n                    fontSize: styles.typography.fontSize.sm,\n                    color: styles.colors.text\n                  }}>\n                    {item.name.length > 25 ? item.name.substring(0, 25) + '...' : item.name}\n                  </span>\n                  <span style={{\n                    fontSize: styles.typography.fontSize.xs,\n                    color: styles.colors.textSecondary\n                  }}>\n                    ({item.percentage.toFixed(1)}%)\n                  </span>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n      \n      {/* Summary */}\n      {aggregatedData.length > 0 && (\n        <div style={{\n          marginTop: styles.spacing.md,\n          padding: styles.spacing.sm,\n          backgroundColor: styles.colors.background,\n          borderRadius: styles.borders?.radius || '4px',\n          display: 'flex',\n          justifyContent: 'space-around',\n          fontSize: styles.typography.fontSize.sm\n        }}>\n          <div style={{ textAlign: 'center' }}>\n            <div style={{ color: styles.colors.textSecondary }}>Total Runs</div>\n            <div style={{ color: styles.colors.text, fontWeight: 'bold' }}>\n              {data.length.toLocaleString()}\n            </div>\n          </div>\n          <div style={{ textAlign: 'center' }}>\n            <div style={{ color: styles.colors.textSecondary }}>Total Tokens</div>\n            <div style={{ color: styles.colors.text, fontWeight: 'bold' }}>\n              {formatValue(aggregatedData.reduce((sum, item) => sum + item.tokens, 0))}\n            </div>\n          </div>\n          <div style={{ textAlign: 'center' }}>\n            <div style={{ color: styles.colors.textSecondary }}>Total Cost</div>\n            <div style={{ color: styles.colors.text, fontWeight: 'bold' }}>\n              {formatValue(aggregatedData.reduce((sum, item) => sum + item.cost, 0))}\n            </div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}",
      "dependencies": [],
      "libraries": []
    },
    {
      "name": "AIDetailTable",
      "location": "embedded",
      "title": "AI Detail Table",
      "description": "Detailed table view showing individual runs for drill-down analysis with sorting and filtering",
      "type": "table",
      "functionalRequirements": "## Detail Table Requirements\n\n### Core Functionality\n- Display individual run records in a sortable table\n- Show key fields: timestamp, name, success status, tokens, cost, execution time\n- Color-coded success/failure indicators\n- Sortable columns with visual indicators\n- Paginated results for large datasets\n- Export to CSV functionality\n- Expandable rows for additional details\n\n### Table Features\n- Responsive column widths\n- Hover row highlighting\n- Sticky header during scroll\n- Loading state for data updates\n- Empty state message",
      "dataRequirements": {
        "mode": "views",
        "description": "Receives detailed run data from parent component",
        "entities": [],
        "queries": []
      },
      "technicalDesign": "## Technical Design\n\n### Props\n- data: Array of run records\n- activeTab: Current view context (agents/prompts)\n\n### Table Management\n- Client-side sorting\n- Pagination with 25 rows per page\n- Column sorting state management\n- Row expansion for details",
      "properties": [
        {
          "name": "data",
          "type": "array",
          "required": true,
          "description": "Array of run records to display"
        },
        {
          "name": "activeTab",
          "type": "string",
          "required": true,
          "description": "Current tab: agents or prompts"
        }
      ],
      "events": [],
      "exampleUsage": "<AIDetailTable data={selectedPoint.items} activeTab=\"agents\" />",
      "code": "function AIDetailTable({ data, activeTab, styles, utilities, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIDetailTable] Rendering with', data?.length || 0, 'items');\n  \n  const [sortField, setSortField] = useState(savedUserSettings?.sortField || 'timestamp');\n  const [sortDirection, setSortDirection] = useState(savedUserSettings?.sortDirection || 'desc');\n  const [currentPage, setCurrentPage] = useState(0);\n  const [expandedRows, setExpandedRows] = useState(new Set());\n  \n  const rowsPerPage = 25;\n  \n  // Get the correct timestamp field\n  const timestampField = activeTab === 'agents' ? 'StartedAt' : 'RunAt';\n  const nameField = activeTab === 'agents' ? 'Agent' : 'Prompt';\n  const idField = activeTab === 'agents' ? 'AgentID' : 'PromptID';\n  \n  // Sort data\n  const sortedData = useMemo(() => {\n    if (!data || data.length === 0) return [];\n    \n    const sorted = [...data].sort((a, b) => {\n      let aVal = a[sortField];\n      let bVal = b[sortField];\n      \n      // Handle null/undefined\n      if (aVal == null) return sortDirection === 'asc' ? 1 : -1;\n      if (bVal == null) return sortDirection === 'asc' ? -1 : 1;\n      \n      // Compare values\n      if (typeof aVal === 'string') {\n        aVal = aVal.toLowerCase();\n        bVal = bVal.toLowerCase();\n      }\n      \n      if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;\n      if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;\n      return 0;\n    });\n    \n    return sorted;\n  }, [data, sortField, sortDirection]);\n  \n  // Paginate data\n  const paginatedData = useMemo(() => {\n    const start = currentPage * rowsPerPage;\n    const end = start + rowsPerPage;\n    return sortedData.slice(start, end);\n  }, [sortedData, currentPage, rowsPerPage]);\n  \n  const totalPages = Math.ceil(sortedData.length / rowsPerPage);\n  \n  const handleSort = (field) => {\n    if (sortField === field) {\n      const newDirection = sortDirection === 'asc' ? 'desc' : 'asc';\n      setSortDirection(newDirection);\n      onSaveUserSettings?.({\n        ...savedUserSettings,\n        sortField: field,\n        sortDirection: newDirection\n      });\n    } else {\n      setSortField(field);\n      setSortDirection('asc');\n      onSaveUserSettings?.({\n        ...savedUserSettings,\n        sortField: field,\n        sortDirection: 'asc'\n      });\n    }\n    setCurrentPage(0);\n  };\n  \n  const toggleRowExpansion = (id) => {\n    const newExpanded = new Set(expandedRows);\n    if (newExpanded.has(id)) {\n      newExpanded.delete(id);\n    } else {\n      newExpanded.add(id);\n    }\n    setExpandedRows(newExpanded);\n  };\n  \n  const formatTimestamp = (timestamp) => {\n    if (!timestamp) return '-';\n    const date = new Date(timestamp);\n    return date.toLocaleString('en-US', {\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  };\n  \n  const formatDuration = (ms) => {\n    if (!ms) return '-';\n    if (ms < 1000) return `${ms}ms`;\n    if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;\n    return `${(ms / 60000).toFixed(1)}m`;\n  };\n  \n  const exportToCSV = () => {\n    console.log('[AIDetailTable] Exporting to CSV');\n    \n    const headers = [\n      'Timestamp',\n      activeTab === 'agents' ? 'Agent' : 'Prompt',\n      'Success',\n      'Tokens',\n      'Cost'\n    ];\n    \n    // Add Duration header only for prompts\n    if (activeTab === 'prompts') {\n      headers.push('Duration');\n    }\n    \n    const rows = sortedData.map(item => {\n      const row = [\n        item[timestampField],\n        item[nameField] || item[idField],\n        item.Success ? 'Yes' : 'No',\n        (item.TotalTokensUsed || item.TokensUsed) || 0,\n        item.TotalCost || 0\n      ];\n      \n      // Add Duration value only for prompts\n      if (activeTab === 'prompts') {\n        row.push(item.ExecutionTimeMS || 0);\n      }\n      \n      return row;\n    });\n    \n    const csv = [\n      headers.join(','),\n      ...rows.map(row => row.join(','))\n    ].join('\\n');\n    \n    const blob = new Blob([csv], { type: 'text/csv' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `ai-${activeTab}-details-${new Date().toISOString().split('T')[0]}.csv`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n  \n  const columns = [\n    { field: timestampField, label: 'Timestamp', width: '150px' },\n    { field: nameField, label: activeTab === 'agents' ? 'Agent' : 'Prompt', width: 'auto' },\n    { field: 'Success', label: 'Status', width: '80px' },\n    { field: 'TotalTokens', label: 'Tokens', width: '100px' },\n    { field: 'TotalCost', label: 'Cost', width: '100px' }\n  ];\n  \n  // Add Duration column only for Prompt Runs (Agent Runs don't have ExecutionTimeMS)\n  if (activeTab === 'prompts') {\n    columns.push({ field: 'ExecutionTimeMS', label: 'Duration', width: '100px' });\n  }\n  \n  return (\n    <div style={{\n      width: '100%',\n      height: '100%',\n      backgroundColor: styles.colors.surface,\n      borderRadius: styles.borders?.radius || '4px',\n      display: 'flex',\n      flexDirection: 'column'\n    }}>\n      {/* Header */}\n      <div style={{\n        padding: styles.spacing.md,\n        borderBottom: `1px solid ${styles.colors.border}`,\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center'\n      }}>\n        <h3 style={{\n          margin: 0,\n          color: styles.colors.text,\n          fontSize: styles.typography.fontSize.lg\n        }}>\n          Detailed Records ({sortedData.length})\n        </h3>\n        \n        <button\n          onClick={exportToCSV}\n          style={{\n            padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n            backgroundColor: styles.colors.primary,\n            color: 'white',\n            border: 'none',\n            borderRadius: styles.borders?.radius || '4px',\n            cursor: 'pointer',\n            fontSize: styles.typography.fontSize.sm\n          }}\n        >\n          Export CSV\n        </button>\n      </div>\n      \n      {/* Table */}\n      <div style={{ flex: 1, overflow: 'auto' }}>\n        {paginatedData.length === 0 ? (\n          <div style={{\n            padding: styles.spacing.xl,\n            textAlign: 'center',\n            color: styles.colors.textSecondary\n          }}>\n            No records to display\n          </div>\n        ) : (\n          <table style={{\n            width: '100%',\n            borderCollapse: 'collapse'\n          }}>\n            <thead style={{\n              position: 'sticky',\n              top: 0,\n              backgroundColor: styles.colors.surface,\n              borderBottom: `2px solid ${styles.colors.border}`\n            }}>\n              <tr>\n                <th style={{ width: '30px', padding: styles.spacing.sm }} />\n                {columns.map(col => (\n                  <th\n                    key={col.field}\n                    onClick={() => handleSort(col.field)}\n                    style={{\n                      padding: styles.spacing.sm,\n                      textAlign: 'left',\n                      color: styles.colors.text,\n                      fontSize: styles.typography.fontSize.sm,\n                      fontWeight: '600',\n                      cursor: 'pointer',\n                      userSelect: 'none',\n                      width: col.width\n                    }}\n                  >\n                    <div style={{\n                      display: 'flex',\n                      alignItems: 'center',\n                      gap: styles.spacing.xs\n                    }}>\n                      {col.label}\n                      {sortField === col.field && (\n                        <span style={{ fontSize: '10px' }}>\n                          {sortDirection === 'asc' ? '▲' : '▼'}\n                        </span>\n                      )}\n                    </div>\n                  </th>\n                ))}\n              </tr>\n            </thead>\n            <tbody>\n              {paginatedData.map((row, index) => {\n                const isExpanded = expandedRows.has(row.ID);\n                return (\n                  <React.Fragment key={row.ID || index}>\n                    <tr style={{\n                      borderBottom: `1px solid ${styles.colors.border}`,\n                      transition: 'background-color 0.2s',\n                      backgroundColor: index % 2 === 0 ? 'transparent' : styles.colors.background\n                    }}>\n                      <td style={{\n                        padding: styles.spacing.sm,\n                        textAlign: 'center'\n                      }}>\n                        <button\n                          onClick={() => toggleRowExpansion(row.ID)}\n                          style={{\n                            background: 'none',\n                            border: 'none',\n                            cursor: 'pointer',\n                            color: styles.colors.textSecondary,\n                            padding: 0,\n                            fontSize: '12px'\n                          }}\n                        >\n                          {isExpanded ? '▼' : '▶'}\n                        </button>\n                      </td>\n                      <td style={{\n                        padding: styles.spacing.sm,\n                        fontSize: styles.typography.fontSize.sm,\n                        color: styles.colors.text\n                      }}>\n                        {formatTimestamp(row[timestampField])}\n                      </td>\n                      <td style={{\n                        padding: styles.spacing.sm,\n                        fontSize: styles.typography.fontSize.sm,\n                        color: styles.colors.text,\n                        overflow: 'hidden',\n                        textOverflow: 'ellipsis',\n                        whiteSpace: 'nowrap',\n                        maxWidth: '200px'\n                      }}>\n                        {row[nameField] || row[idField] || '-'}\n                      </td>\n                      <td style={{\n                        padding: styles.spacing.sm,\n                        fontSize: styles.typography.fontSize.sm\n                      }}>\n                        <span style={{\n                          display: 'inline-block',\n                          padding: `2px 8px`,\n                          borderRadius: '12px',\n                          backgroundColor: row.Success ? styles.colors.success + '20' : styles.colors.error + '20',\n                          color: row.Success ? styles.colors.success : styles.colors.error,\n                          fontSize: '11px',\n                          fontWeight: '600'\n                        }}>\n                          {row.Success ? 'Success' : 'Failed'}\n                        </span>\n                      </td>\n                      <td style={{\n                        padding: styles.spacing.sm,\n                        fontSize: styles.typography.fontSize.sm,\n                        color: styles.colors.text,\n                        textAlign: 'right'\n                      }}>\n                        {(row.TotalTokensUsed || row.TokensUsed) ? (row.TotalTokensUsed || row.TokensUsed).toLocaleString() : '-'}\n                      </td>\n                      <td style={{\n                        padding: styles.spacing.sm,\n                        fontSize: styles.typography.fontSize.sm,\n                        color: styles.colors.text,\n                        textAlign: 'right'\n                      }}>\n                        {row.TotalCost ? `$${row.TotalCost.toFixed(4)}` : '-'}\n                      </td>\n                      {activeTab === 'prompts' && (\n                        <td style={{\n                          padding: styles.spacing.sm,\n                          fontSize: styles.typography.fontSize.sm,\n                          color: styles.colors.text,\n                          textAlign: 'right'\n                        }}>\n                          {formatDuration(row.ExecutionTimeMS)}\n                        </td>\n                      )}\n                    </tr>\n                    {isExpanded && (\n                      <tr>\n                        <td colSpan={columns.length + 1} style={{\n                          padding: styles.spacing.md,\n                          backgroundColor: styles.colors.background,\n                          borderBottom: `1px solid ${styles.colors.border}`\n                        }}>\n                          <div style={{\n                            display: 'grid',\n                            gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',\n                            gap: styles.spacing.md,\n                            fontSize: styles.typography.fontSize.sm\n                          }}>\n                            <div>\n                              <strong style={{ color: styles.colors.textSecondary }}>ID:</strong>\n                              <div style={{ color: styles.colors.text, fontFamily: 'monospace' }}>\n                                {row.ID}\n                              </div>\n                            </div>\n                            {row.ErrorMessage && (\n                              <div style={{ gridColumn: '1 / -1' }}>\n                                <strong style={{ color: styles.colors.textSecondary }}>Error:</strong>\n                                <div style={{ color: styles.colors.error }}>\n                                  {row.ErrorMessage}\n                                </div>\n                              </div>\n                            )}\n                            {row.Model && (\n                              <div>\n                                <strong style={{ color: styles.colors.textSecondary }}>Model:</strong>\n                                <div style={{ color: styles.colors.text }}>\n                                  {row.Model}\n                                </div>\n                              </div>\n                            )}\n                            {row.CompletedAt && (\n                              <div>\n                                <strong style={{ color: styles.colors.textSecondary }}>Completed:</strong>\n                                <div style={{ color: styles.colors.text }}>\n                                  {formatTimestamp(row.CompletedAt)}\n                                </div>\n                              </div>\n                            )}\n                          </div>\n                        </td>\n                      </tr>\n                    )}\n                  </React.Fragment>\n                );\n              })}\n            </tbody>\n          </table>\n        )}\n      </div>\n      \n      {/* Pagination */}\n      {totalPages > 1 && (\n        <div style={{\n          padding: styles.spacing.md,\n          borderTop: `1px solid ${styles.colors.border}`,\n          display: 'flex',\n          justifyContent: 'center',\n          alignItems: 'center',\n          gap: styles.spacing.sm\n        }}>\n          <button\n            onClick={() => setCurrentPage(Math.max(0, currentPage - 1))}\n            disabled={currentPage === 0}\n            style={{\n              padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n              backgroundColor: currentPage === 0 ? styles.colors.background : styles.colors.primary,\n              color: currentPage === 0 ? styles.colors.textSecondary : 'white',\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: currentPage === 0 ? 'not-allowed' : 'pointer',\n              fontSize: styles.typography.fontSize.sm\n            }}\n          >\n            Previous\n          </button>\n          \n          <span style={{\n            color: styles.colors.text,\n            fontSize: styles.typography.fontSize.sm\n          }}>\n            Page {currentPage + 1} of {totalPages}\n          </span>\n          \n          <button\n            onClick={() => setCurrentPage(Math.min(totalPages - 1, currentPage + 1))}\n            disabled={currentPage === totalPages - 1}\n            style={{\n              padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n              backgroundColor: currentPage === totalPages - 1 ? styles.colors.background : styles.colors.primary,\n              color: currentPage === totalPages - 1 ? styles.colors.textSecondary : 'white',\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: currentPage === totalPages - 1 ? 'not-allowed' : 'pointer',\n              fontSize: styles.typography.fontSize.sm\n            }}\n          >\n            Next\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}",
      "dependencies": [],
      "libraries": []
    },
    {
      "name": "AIMetricsSummary",
      "location": "embedded",
      "title": "AI Metrics Summary",
      "description": "Summary cards displaying key performance metrics for the selected time period",
      "type": "other",
      "functionalRequirements": "## Metrics Summary Requirements\n\n### Core Functionality\n- Display key metrics in card format\n- Show total runs, tokens, and costs\n- Calculate averages per run\n- Display success rate percentage\n- Show trend indicators\n- Responsive card layout\n\n### Visual Features\n- Icon for each metric\n- Color-coded values\n- Hover effects\n- Smooth animations\n- Responsive grid",
      "dataRequirements": {
        "mode": "views",
        "description": "Receives calculated metrics from parent component",
        "entities": [],
        "queries": []
      },
      "technicalDesign": "## Technical Design\n\n### Props\n- metrics: Object with calculated metric values\n\n### Display\n- Responsive grid of metric cards\n- Each card shows metric name, value, and icon\n- Consistent styling with theme",
      "properties": [
        {
          "name": "metrics",
          "type": "object",
          "required": true,
          "description": "Calculated metrics object"
        }
      ],
      "events": [],
      "exampleUsage": "<AIMetricsSummary metrics={calculatedMetrics} />",
      "code": "function AIMetricsSummary({ metrics, styles, utilities, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIMetricsSummary] Rendering metrics:', metrics);\n  \n  const formatNumber = (num) => {\n    if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`;\n    if (num >= 1000) return `${(num / 1000).toFixed(1)}K`;\n    return num.toFixed(0);\n  };\n  \n  const formatCost = (cost) => {\n    if (cost >= 1000) return `$${(cost / 1000).toFixed(1)}K`;\n    if (cost >= 1) return `$${cost.toFixed(2)}`;\n    return `$${cost.toFixed(4)}`;\n  };\n  \n  const cards = [\n    {\n      label: 'Total Runs',\n      value: formatNumber(metrics?.totalRuns || 0),\n      icon: '▶',\n      color: styles.colors.primary\n    },\n    {\n      label: 'Total Tokens',\n      value: formatNumber(metrics?.totalTokens || 0),\n      icon: '◆',\n      color: styles.colors.success\n    },\n    {\n      label: 'Total Cost',\n      value: formatCost(metrics?.totalCost || 0),\n      icon: '$',\n      color: styles.colors.warning\n    },\n    {\n      label: 'Avg Tokens/Run',\n      value: formatNumber(metrics?.avgTokensPerRun || 0),\n      icon: '⟳',\n      color: styles.colors.info || styles.colors.primary\n    },\n    {\n      label: 'Avg Cost/Run',\n      value: formatCost(metrics?.avgCostPerRun || 0),\n      icon: '¢',\n      color: styles.colors.info || styles.colors.primary\n    }\n  ];\n  \n  return (\n    <div style={{\n      display: 'grid',\n      gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))',\n      gap: styles.spacing.md,\n      marginBottom: styles.spacing.lg\n    }}>\n      {cards.map((card, index) => (\n        <div\n          key={index}\n          style={{\n            backgroundColor: styles.colors.surface,\n            borderRadius: styles.borders?.radius || '4px',\n            padding: styles.spacing.md,\n            boxShadow: '0 1px 3px rgba(0,0,0,0.1)',\n            transition: 'transform 0.2s, box-shadow 0.2s',\n            cursor: 'default'\n          }}\n          onMouseEnter={(e) => {\n            e.currentTarget.style.transform = 'translateY(-2px)';\n            e.currentTarget.style.boxShadow = '0 4px 6px rgba(0,0,0,0.15)';\n          }}\n          onMouseLeave={(e) => {\n            e.currentTarget.style.transform = 'translateY(0)';\n            e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';\n          }}\n        >\n          <div style={{\n            display: 'flex',\n            alignItems: 'center',\n            justifyContent: 'space-between',\n            marginBottom: styles.spacing.sm\n          }}>\n            <span style={{\n              fontSize: styles.typography.fontSize.sm,\n              color: styles.colors.textSecondary,\n              fontWeight: '500'\n            }}>\n              {card.label}\n            </span>\n            <span style={{\n              fontSize: '20px',\n              color: card.color,\n              opacity: 0.7\n            }}>\n              {card.icon}\n            </span>\n          </div>\n          <div style={{\n            fontSize: styles.typography.fontSize.xl || '24px',\n            fontWeight: 'bold',\n            color: card.color\n          }}>\n            {card.value}\n          </div>\n        </div>\n      ))}\n    </div>\n  );\n}",
      "dependencies": [],
      "libraries": []
    }
  ],
  "libraries": []
}