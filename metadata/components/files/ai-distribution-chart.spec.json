{
  "name": "AIDistributionChart",
  "location": "embedded",
  "title": "AI Distribution Chart",
  "description": "Pie and bar charts showing distribution of runs, tokens, and costs by agent or prompt for drill-down analysis",
  "type": "chart",
  "functionalRequirements": "## Distribution Chart Requirements\n\n### Core Functionality\n- Display distribution breakdown for selected time period\n- Toggle between pie chart and bar chart views\n- Show top 10 items with 'Others' grouping\n- Display runs, tokens, and cost metrics\n- Interactive tooltips with detailed values\n- Click on segments to filter detail table\n- Color-coded segments with legend\n\n### Visual Features\n- Smooth transitions between chart types\n- Percentage labels on pie segments\n- Value labels on bar chart\n- Responsive sizing\n- Hover effects for interactivity",
  "dataRequirements": {
    "mode": "views",
    "description": "Receives drill-down data from parent component",
    "entities": [],
    "queries": []
  },
  "technicalDesign": "## Technical Design\n\n### Props\n- data: Array of items for selected period\n- activeTab: Current view (agents/prompts)\n- groupBy: Time grouping context\n\n### Chart Features\n- Aggregates data by agent/prompt\n- Calculates percentages\n- Sorts by total value\n- Groups small items into 'Others'",
  "properties": [
    {
      "name": "data",
      "type": "array",
      "required": true,
      "description": "Array of run items for distribution analysis"
    },
    {
      "name": "activeTab",
      "type": "string",
      "required": true,
      "description": "Current tab: agents or prompts"
    },
    {
      "name": "groupBy",
      "type": "string",
      "required": false,
      "description": "Time grouping context"
    }
  ],
  "events": [],
  "exampleUsage": "<AIDistributionChart data={selectedPoint.items} activeTab=\"agents\" />",
  "code": "function AIDistributionChart({ data, activeTab, groupBy, styles, utilities, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIDistributionChart] Rendering with', data?.length || 0, 'items');\n  \n  const [chartType, setChartType] = useState(savedUserSettings?.chartType || 'pie');\n  const [metric, setMetric] = useState(savedUserSettings?.metric || 'cost');\n  \n  // Aggregate data by agent or prompt\n  const aggregatedData = useMemo(() => {\n    if (!data || data.length === 0) return [];\n    \n    const grouped = {};\n    const groupField = activeTab === 'agents' ? 'Agent' : 'Prompt';\n    const idField = activeTab === 'agents' ? 'AgentID' : 'PromptID';\n    \n    data.forEach(item => {\n      const key = item[groupField] || item[idField] || 'Unknown';\n      if (!grouped[key]) {\n        grouped[key] = {\n          name: key,\n          runs: 0,\n          tokens: 0,\n          cost: 0\n        };\n      }\n      grouped[key].runs++;\n      grouped[key].tokens += (item.TotalTokensUsed || item.TokensUsed || 0);\n      grouped[key].cost += (item.TotalCost || 0);\n    });\n    \n    // Sort by selected metric and take top 10\n    const sorted = Object.values(grouped)\n      .sort((a, b) => b[metric] - a[metric])\n      .slice(0, 10);\n    \n    // Calculate total for percentages\n    const total = sorted.reduce((sum, item) => sum + item[metric], 0);\n    \n    return sorted.map(item => ({\n      ...item,\n      percentage: total > 0 ? (item[metric] / total) * 100 : 0\n    }));\n  }, [data, activeTab, metric]);\n  \n  // Color palette\n  const colors = [\n    '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',\n    '#ec4899', '#14b8a6', '#f97316', '#06b6d4', '#84cc16'\n  ];\n  \n  const handleChartTypeChange = (type) => {\n    setChartType(type);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      chartType: type\n    });\n  };\n  \n  const handleMetricChange = (newMetric) => {\n    setMetric(newMetric);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      metric: newMetric\n    });\n  };\n  \n  const formatValue = (value) => {\n    if (metric === 'cost') {\n      return `$${value.toFixed(2)}`;\n    } else if (metric === 'tokens') {\n      return value >= 1000000 ? `${(value / 1000000).toFixed(1)}M` : value >= 1000 ? `${(value / 1000).toFixed(1)}K` : value.toString();\n    }\n    return value.toString();\n  };\n  \n  // Calculate pie chart segments\n  const calculatePieSegments = () => {\n    let startAngle = -90; // Start from top\n    return aggregatedData.map((item, index) => {\n      const angle = (item.percentage / 100) * 360;\n      const segment = {\n        ...item,\n        startAngle,\n        endAngle: startAngle + angle,\n        color: colors[index % colors.length]\n      };\n      startAngle += angle;\n      return segment;\n    });\n  };\n  \n  const pieSegments = chartType === 'pie' ? calculatePieSegments() : [];\n  \n  // Create pie slice path\n  const createPieSlice = (startAngle, endAngle, outerRadius, innerRadius = 0) => {\n    const startAngleRad = (startAngle * Math.PI) / 180;\n    const endAngleRad = (endAngle * Math.PI) / 180;\n    \n    const x1 = Math.cos(startAngleRad) * outerRadius;\n    const y1 = Math.sin(startAngleRad) * outerRadius;\n    const x2 = Math.cos(endAngleRad) * outerRadius;\n    const y2 = Math.sin(endAngleRad) * outerRadius;\n    \n    const largeArc = endAngle - startAngle > 180 ? 1 : 0;\n    \n    if (innerRadius > 0) {\n      const ix1 = Math.cos(startAngleRad) * innerRadius;\n      const iy1 = Math.sin(startAngleRad) * innerRadius;\n      const ix2 = Math.cos(endAngleRad) * innerRadius;\n      const iy2 = Math.sin(endAngleRad) * innerRadius;\n      \n      return `M ${ix1} ${iy1} L ${x1} ${y1} A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${x2} ${y2} L ${ix2} ${iy2} A ${innerRadius} ${innerRadius} 0 ${largeArc} 0 ${ix1} ${iy1}`;\n    }\n    \n    return `M 0 0 L ${x1} ${y1} A ${outerRadius} ${outerRadius} 0 ${largeArc} 1 ${x2} ${y2} Z`;\n  };\n  \n  return (\n    <div style={{\n      width: '100%',\n      height: '100%',\n      backgroundColor: styles.colors.surface,\n      borderRadius: styles.borders?.radius || '4px',\n      padding: styles.spacing.md,\n      display: 'flex',\n      flexDirection: 'column'\n    }}>\n      {/* Header */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        marginBottom: styles.spacing.md\n      }}>\n        <h3 style={{\n          margin: 0,\n          color: styles.colors.text,\n          fontSize: styles.typography.fontSize.lg\n        }}>\n          Distribution by {activeTab === 'agents' ? 'Agent' : 'Prompt'}\n        </h3>\n        \n        {/* Controls */}\n        <div style={{ display: 'flex', gap: styles.spacing.sm }}>\n          {/* Metric Selector */}\n          <select\n            value={metric}\n            onChange={(e) => handleMetricChange(e.target.value)}\n            style={{\n              padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.background,\n              color: styles.colors.text,\n              fontSize: styles.typography.fontSize.sm\n            }}\n          >\n            <option value=\"cost\">Cost</option>\n            <option value=\"tokens\">Tokens</option>\n            <option value=\"runs\">Runs</option>\n          </select>\n          \n          {/* Chart Type Toggle */}\n          <div style={{\n            display: 'flex',\n            backgroundColor: styles.colors.background,\n            borderRadius: styles.borders?.radius || '4px',\n            border: `1px solid ${styles.colors.border}`\n          }}>\n            <button\n              onClick={() => handleChartTypeChange('pie')}\n              style={{\n                padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n                backgroundColor: chartType === 'pie' ? styles.colors.primary : 'transparent',\n                color: chartType === 'pie' ? 'white' : styles.colors.text,\n                border: 'none',\n                borderRadius: styles.borders?.radius || '4px',\n                cursor: 'pointer'\n              }}\n            >\n              Pie\n            </button>\n            <button\n              onClick={() => handleChartTypeChange('bar')}\n              style={{\n                padding: `${styles.spacing.xs} ${styles.spacing.sm}`,\n                backgroundColor: chartType === 'bar' ? styles.colors.primary : 'transparent',\n                color: chartType === 'bar' ? 'white' : styles.colors.text,\n                border: 'none',\n                borderRadius: styles.borders?.radius || '4px',\n                cursor: 'pointer'\n              }}\n            >\n              Bar\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      {/* Chart */}\n      <div style={{ flex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>\n        {aggregatedData.length === 0 ? (\n          <div style={{ color: styles.colors.textSecondary }}>\n            No data available\n          </div>\n        ) : chartType === 'pie' ? (\n          /* Pie Chart */\n          <svg viewBox=\"-150 -150 300 300\" style={{ maxWidth: '300px', maxHeight: '300px' }}>\n            {pieSegments.map((segment, index) => (\n              <g key={index}>\n                <path\n                  d={createPieSlice(segment.startAngle, segment.endAngle, 100, 50)}\n                  fill={segment.color}\n                  stroke=\"white\"\n                  strokeWidth=\"2\"\n                  opacity=\"0.9\"\n                  style={{ cursor: 'pointer' }}\n                >\n                  <title>{segment.name}: {formatValue(segment[metric])} ({segment.percentage.toFixed(1)}%)</title>\n                </path>\n                {/* Label for large segments */}\n                {segment.percentage > 5 && (\n                  <text\n                    x={Math.cos(((segment.startAngle + segment.endAngle) / 2) * Math.PI / 180) * 75}\n                    y={Math.sin(((segment.startAngle + segment.endAngle) / 2) * Math.PI / 180) * 75}\n                    textAnchor=\"middle\"\n                    fill=\"white\"\n                    fontSize=\"12\"\n                    fontWeight=\"bold\"\n                  >\n                    {segment.percentage.toFixed(0)}%\n                  </text>\n                )}\n              </g>\n            ))}\n          </svg>\n        ) : (\n          /* Bar Chart */\n          <div style={{\n            width: '100%',\n            maxWidth: '400px',\n            display: 'flex',\n            flexDirection: 'column',\n            gap: styles.spacing.xs\n          }}>\n            {aggregatedData.map((item, index) => {\n              const maxValue = Math.max(...aggregatedData.map(d => d[metric]));\n              const width = (item[metric] / maxValue) * 100;\n              \n              return (\n                <div key={index} style={{ display: 'flex', alignItems: 'center', gap: styles.spacing.sm }}>\n                  <div style={{\n                    width: '120px',\n                    fontSize: styles.typography.fontSize.sm,\n                    color: styles.colors.text,\n                    overflow: 'hidden',\n                    textOverflow: 'ellipsis',\n                    whiteSpace: 'nowrap'\n                  }}>\n                    {item.name}\n                  </div>\n                  <div style={{\n                    flex: 1,\n                    height: '24px',\n                    backgroundColor: styles.colors.background,\n                    borderRadius: styles.borders?.radius || '4px',\n                    position: 'relative',\n                    overflow: 'hidden'\n                  }}>\n                    <div style={{\n                      width: `${width}%`,\n                      height: '100%',\n                      backgroundColor: colors[index % colors.length],\n                      transition: 'width 0.3s ease'\n                    }} />\n                    <div style={{\n                      position: 'absolute',\n                      right: styles.spacing.sm,\n                      top: '50%',\n                      transform: 'translateY(-50%)',\n                      fontSize: styles.typography.fontSize.xs,\n                      color: width > 50 ? 'white' : styles.colors.text,\n                      fontWeight: '500'\n                    }}>\n                      {formatValue(item[metric])}\n                    </div>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        )}\n      </div>\n      \n      {/* Legend */}\n      {chartType === 'pie' && aggregatedData.length > 0 && (\n        <div style={{\n          display: 'flex',\n          flexWrap: 'wrap',\n          gap: styles.spacing.sm,\n          justifyContent: 'center',\n          marginTop: styles.spacing.md\n        }}>\n          {aggregatedData.slice(0, 5).map((item, index) => (\n            <div key={index} style={{\n              display: 'flex',\n              alignItems: 'center',\n              gap: styles.spacing.xs\n            }}>\n              <div style={{\n                width: '12px',\n                height: '12px',\n                backgroundColor: colors[index % colors.length],\n                borderRadius: '2px'\n              }} />\n              <span style={{\n                fontSize: styles.typography.fontSize.xs,\n                color: styles.colors.text,\n                maxWidth: '100px',\n                overflow: 'hidden',\n                textOverflow: 'ellipsis',\n                whiteSpace: 'nowrap'\n              }}>\n                {item.name}\n              </span>\n            </div>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}",
  "dependencies": [],
  "libraries": []
}