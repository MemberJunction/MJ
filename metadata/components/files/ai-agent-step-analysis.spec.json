{
  "name": "AIAgentStepAnalysis",
  "title": "AI Agent Step Analysis",
  "description": "Detailed step-by-step execution analysis with waterfall charts, step type distribution, execution timelines, and error pattern detection",
  "type": "chart",
  "functionalRequirements": "Display execution waterfall showing step sequence and timing, visualize step type distribution with donut chart, show execution timeline with concurrent steps, identify error patterns and bottlenecks",
  "dataRequirements": null,
  "technicalDesign": "Multi-panel visualization with waterfall chart for execution flow, donut chart for step type distribution, timeline view for concurrent execution patterns, and error analysis section",
  "properties": [
    {"name": "agentRunSteps", "type": "array", "required": true, "description": "Array of agent run step objects"},
    {"name": "agentRuns", "type": "array", "required": true, "description": "Array of agent run objects for context"},
    {"name": "selectedAgentId", "type": "string", "required": false, "description": "Filter steps by agent ID"}
  ],
  "events": [],
  "exampleUsage": "<AIAgentStepAnalysis ... />",
  "code": "function AIAgentStepAnalysis({ \n  agentRunSteps,\n  agentRuns,\n  selectedAgentId,\n  utilities, \n  styles, \n  components, \n  callbacks, \n  savedUserSettings, \n  onSaveUserSettings \n}) {\n  const [selectedRunId, setSelectedRunId] = useState(savedUserSettings?.selectedRunId);\n  const [viewMode, setViewMode] = useState(savedUserSettings?.viewMode || 'waterfall');\n  \n  // Helper function to get border radius\n  const getBorderRadius = (size) => {\n    return typeof styles.borders?.radius === 'object' ? styles.borders.radius[size] : styles.borders?.radius || '4px';\n  };\n  \n  // Filter steps based on selection\n  const filteredSteps = useMemo(() => {\n    let steps = agentRunSteps;\n    \n    if (selectedRunId) {\n      steps = steps.filter(s => s.AgentRunID === selectedRunId);\n    } else if (selectedAgentId) {\n      const agentRunIds = agentRuns\n        .filter(r => r.AgentID === selectedAgentId)\n        .map(r => r.ID);\n      steps = steps.filter(s => agentRunIds.includes(s.AgentRunID));\n    }\n    \n    return steps.sort((a, b) => {\n      if (a.AgentRunID === b.AgentRunID) {\n        return a.StepNumber - b.StepNumber;\n      }\n      return new Date(a.StartedAt) - new Date(b.StartedAt);\n    });\n  }, [agentRunSteps, agentRuns, selectedRunId, selectedAgentId]);\n  \n  // Calculate step type distribution\n  const stepTypeDistribution = useMemo(() => {\n    const distribution = {};\n    filteredSteps.forEach(step => {\n      const type = step.StepType || 'Unknown';\n      if (!distribution[type]) {\n        distribution[type] = { count: 0, totalTime: 0, errors: 0 };\n      }\n      distribution[type].count++;\n      distribution[type].totalTime += step.ExecutionTimeMS || 0;\n      if (!step.Success) distribution[type].errors++;\n    });\n    \n    const total = filteredSteps.length;\n    return Object.entries(distribution).map(([type, data]) => ({\n      type,\n      count: data.count,\n      percentage: total > 0 ? (data.count / total) * 100 : 0,\n      avgTime: data.count > 0 ? data.totalTime / data.count : 0,\n      errorRate: data.count > 0 ? (data.errors / data.count) * 100 : 0\n    }));\n  }, [filteredSteps]);\n  \n  // Get color for step type\n  const getStepTypeColor = (type) => {\n    const colors = [\n      styles.colors.primary,\n      styles.colors.secondary,\n      styles.colors.success,\n      styles.colors.warning,\n      styles.colors.error,\n      styles.colors.info || styles.colors.primary\n    ];\n    const typeIndex = ['Prompt', 'Actions', 'Sub-Agent', 'Decision', 'Chat', 'Validation'].indexOf(type);\n    return typeIndex >= 0 ? colors[typeIndex] : styles.colors.textSecondary;\n  };\n  \n  // Group steps by run for waterfall view\n  const runGroups = useMemo(() => {\n    const groups = {};\n    filteredSteps.forEach(step => {\n      if (!groups[step.AgentRunID]) {\n        const run = agentRuns.find(r => r.ID === step.AgentRunID);\n        groups[step.AgentRunID] = {\n          runId: step.AgentRunID,\n          agent: run?.Agent || 'Unknown',\n          steps: [],\n          totalTime: 0,\n          startTime: null,\n          endTime: null\n        };\n      }\n      groups[step.AgentRunID].steps.push(step);\n    });\n    \n    // Calculate timings for each group\n    Object.values(groups).forEach(group => {\n      group.steps.sort((a, b) => a.StepNumber - b.StepNumber);\n      if (group.steps.length > 0) {\n        group.startTime = new Date(group.steps[0].StartedAt);\n        const lastStep = group.steps[group.steps.length - 1];\n        group.endTime = lastStep.CompletedAt ? new Date(lastStep.CompletedAt) : new Date();\n        group.totalTime = group.endTime - group.startTime;\n      }\n    });\n    \n    return Object.values(groups).slice(0, 10); // Limit to 10 most recent runs\n  }, [filteredSteps, agentRuns]);\n  \n  // Render donut chart for step type distribution\n  const renderDonutChart = () => {\n    const size = 200;\n    const radius = size / 2;\n    const innerRadius = radius * 0.6;\n    let cumulativeAngle = 0;\n    \n    return (\n      <svg width={size} height={size}>\n        {stepTypeDistribution.map((item, index) => {\n          const angle = (item.percentage / 100) * 360;\n          const startAngle = cumulativeAngle;\n          const endAngle = cumulativeAngle + angle;\n          cumulativeAngle += angle;\n          \n          const startAngleRad = (startAngle * Math.PI) / 180;\n          const endAngleRad = (endAngle * Math.PI) / 180;\n          \n          const x1 = radius + radius * Math.cos(startAngleRad);\n          const y1 = radius + radius * Math.sin(startAngleRad);\n          const x2 = radius + radius * Math.cos(endAngleRad);\n          const y2 = radius + radius * Math.sin(endAngleRad);\n          \n          const x1Inner = radius + innerRadius * Math.cos(startAngleRad);\n          const y1Inner = radius + innerRadius * Math.sin(startAngleRad);\n          const x2Inner = radius + innerRadius * Math.cos(endAngleRad);\n          const y2Inner = radius + innerRadius * Math.sin(endAngleRad);\n          \n          const largeArcFlag = angle > 180 ? 1 : 0;\n          \n          const path = `\n            M ${x1Inner} ${y1Inner}\n            L ${x1} ${y1}\n            A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2}\n            L ${x2Inner} ${y2Inner}\n            A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${x1Inner} ${y1Inner}\n            Z\n          `;\n          \n          return (\n            <g key={item.type}>\n              <path\n                d={path}\n                fill={getStepTypeColor(item.type)}\n                opacity={0.8}\n                style={{ transition: 'opacity 0.2s' }}\n                onMouseEnter={(e) => e.target.style.opacity = 1}\n                onMouseLeave={(e) => e.target.style.opacity = 0.8}\n              />\n            </g>\n          );\n        })}\n        \n        {/* Center text */}\n        <text\n          x={radius}\n          y={radius - 10}\n          textAnchor=\"middle\"\n          fontSize={styles.typography.fontSize.xl}\n          fontWeight={styles.typography.fontWeight?.bold || '700'}\n          fill={styles.colors.text}\n        >\n          {filteredSteps.length}\n        </text>\n        <text\n          x={radius}\n          y={radius + 10}\n          textAnchor=\"middle\"\n          fontSize={styles.typography.fontSize.sm}\n          fill={styles.colors.textSecondary}\n        >\n          Total Steps\n        </text>\n      </svg>\n    );\n  };\n  \n  // Render waterfall chart\n  const renderWaterfall = () => {\n    return (\n      <div style={{\n        flex: 1,\n        overflow: 'auto',\n        padding: styles.spacing.md\n      }}>\n        {runGroups.map((group, groupIndex) => (\n          <div\n            key={group.runId}\n            style={{\n              marginBottom: styles.spacing.lg,\n              backgroundColor: styles.colors.surface,\n              borderRadius: getBorderRadius('sm'),\n              padding: styles.spacing.md,\n              border: selectedRunId === group.runId ? `2px solid ${styles.colors.primary}` : `1px solid ${styles.colors.border}`\n            }}\n            onClick={() => {\n              setSelectedRunId(group.runId);\n              onSaveUserSettings?.({ ...savedUserSettings, selectedRunId: group.runId });\n            }}\n          >\n            {/* Run Header */}\n            <div style={{\n              display: 'flex',\n              justifyContent: 'space-between',\n              alignItems: 'center',\n              marginBottom: styles.spacing.sm\n            }}>\n              <div style={{\n                fontSize: styles.typography.fontSize.sm,\n                fontWeight: styles.typography.fontWeight?.semibold || '600',\n                color: styles.colors.text\n              }}>\n                {group.agent}\n              </div>\n              <div style={{\n                fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n                color: styles.colors.textSecondary\n              }}>\n                {(group.totalTime / 1000).toFixed(2)}s total\n              </div>\n            </div>\n            \n            {/* Steps Timeline */}\n            <div style={{\n              position: 'relative',\n              height: '40px',\n              backgroundColor: styles.colors.background,\n              borderRadius: getBorderRadius('xs') || getBorderRadius('sm'),\n              overflow: 'hidden'\n            }}>\n              {group.steps.map((step, stepIndex) => {\n                const stepStart = new Date(step.StartedAt);\n                const stepEnd = step.CompletedAt ? new Date(step.CompletedAt) : new Date();\n                const startOffset = ((stepStart - group.startTime) / group.totalTime) * 100;\n                const duration = ((stepEnd - stepStart) / group.totalTime) * 100;\n                \n                return (\n                  <div\n                    key={step.ID}\n                    style={{\n                      position: 'absolute',\n                      left: `${startOffset}%`,\n                      width: `${Math.max(duration, 1)}%`,\n                      height: '100%',\n                      backgroundColor: step.Success ? getStepTypeColor(step.StepType) : styles.colors.error,\n                      opacity: 0.7,\n                      display: 'flex',\n                      alignItems: 'center',\n                      justifyContent: 'center',\n                      borderLeft: stepIndex > 0 ? `1px solid ${styles.colors.background}` : 'none'\n                    }}\n                    title={`${step.StepName} (${step.StepType}) - ${(step.ExecutionTimeMS / 1000).toFixed(2)}s`}\n                  >\n                    {duration > 10 && (\n                      <span style={{\n                        fontSize: '10px',\n                        color: 'white',\n                        fontWeight: styles.typography.fontWeight?.medium || '500'\n                      }}>\n                        {step.StepNumber}\n                      </span>\n                    )}\n                  </div>\n                );\n              })}\n            </div>\n            \n            {/* Step Details */}\n            {selectedRunId === group.runId && (\n              <div style={{\n                marginTop: styles.spacing.md,\n                fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm\n              }}>\n                {group.steps.map(step => (\n                  <div\n                    key={step.ID}\n                    style={{\n                      display: 'flex',\n                      alignItems: 'center',\n                      padding: styles.spacing.xs,\n                      borderBottom: `1px solid ${styles.colors.border}`\n                    }}\n                  >\n                    <div style={{\n                      width: '20px',\n                      textAlign: 'center',\n                      color: styles.colors.textSecondary,\n                      marginRight: styles.spacing.sm\n                    }}>\n                      {step.StepNumber}\n                    </div>\n                    <div style={{\n                      width: '8px',\n                      height: '8px',\n                      borderRadius: '50%',\n                      backgroundColor: step.Success ? getStepTypeColor(step.StepType) : styles.colors.error,\n                      marginRight: styles.spacing.sm\n                    }} />\n                    <div style={{ flex: 1 }}>\n                      <div style={{ color: styles.colors.text }}>\n                        {step.StepName}\n                      </div>\n                      <div style={{ color: styles.colors.textSecondary }}>\n                        {step.StepType} • {(step.ExecutionTimeMS / 1000).toFixed(2)}s\n                        {step.TokensUsed && ` • ${step.TokensUsed} tokens`}\n                      </div>\n                    </div>\n                    {!step.Success && (\n                      <div style={{\n                        color: styles.colors.error,\n                        fontSize: '10px'\n                      }}>\n                        Failed\n                      </div>\n                    )}\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    );\n  };\n  \n  return (\n    <div style={{\n      height: '100%',\n      display: 'flex',\n      backgroundColor: styles.colors.background\n    }}>\n      {/* Left Panel - Step Type Distribution */}\n      <div style={{\n        width: '300px',\n        padding: styles.spacing.lg,\n        borderRight: `1px solid ${styles.colors.border}`,\n        backgroundColor: styles.colors.surface\n      }}>\n        <h3 style={{\n          margin: 0,\n          marginBottom: styles.spacing.md,\n          fontSize: styles.typography.fontSize.lg,\n          fontWeight: styles.typography.fontWeight?.semibold || '600',\n          color: styles.colors.text\n        }}>\n          Step Analysis\n        </h3>\n        \n        {/* View Mode Selector */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.xs,\n          marginBottom: styles.spacing.lg\n        }}>\n          {['waterfall', 'distribution'].map(mode => (\n            <button\n              key={mode}\n              onClick={() => {\n                setViewMode(mode);\n                onSaveUserSettings?.({ ...savedUserSettings, viewMode: mode });\n              }}\n              style={{\n                flex: 1,\n                padding: styles.spacing.sm,\n                backgroundColor: viewMode === mode ? styles.colors.primary : styles.colors.background,\n                color: viewMode === mode ? 'white' : styles.colors.text,\n                border: `1px solid ${styles.colors.border}`,\n                borderRadius: getBorderRadius('sm'),\n                cursor: 'pointer',\n                fontSize: styles.typography.fontSize.sm,\n                textTransform: 'capitalize'\n              }}\n            >\n              {mode}\n            </button>\n          ))}\n        </div>\n        \n        {/* Donut Chart */}\n        <div style={{\n          display: 'flex',\n          justifyContent: 'center',\n          marginBottom: styles.spacing.lg\n        }}>\n          {renderDonutChart()}\n        </div>\n        \n        {/* Step Type Legend */}\n        <div style={{\n          display: 'flex',\n          flexDirection: 'column',\n          gap: styles.spacing.xs\n        }}>\n          {stepTypeDistribution.map(item => (\n            <div\n              key={item.type}\n              style={{\n                display: 'flex',\n                alignItems: 'center',\n                padding: styles.spacing.sm,\n                backgroundColor: styles.colors.background,\n                borderRadius: getBorderRadius('xs') || getBorderRadius('sm')\n              }}\n            >\n              <div style={{\n                width: '12px',\n                height: '12px',\n                borderRadius: '2px',\n                backgroundColor: getStepTypeColor(item.type),\n                marginRight: styles.spacing.sm\n              }} />\n              <div style={{ flex: 1 }}>\n                <div style={{\n                  fontSize: styles.typography.fontSize.sm,\n                  color: styles.colors.text\n                }}>\n                  {item.type}\n                </div>\n                <div style={{\n                  fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n                  color: styles.colors.textSecondary\n                }}>\n                  {item.count} steps • {item.percentage.toFixed(1)}%\n                </div>\n              </div>\n              {item.errorRate > 0 && (\n                <div style={{\n                  fontSize: styles.typography.fontSize.xs || styles.typography.fontSize.sm,\n                  color: styles.colors.error\n                }}>\n                  {item.errorRate.toFixed(0)}% failed\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n      </div>\n      \n      {/* Right Panel - Waterfall View */}\n      {renderWaterfall()}\n    </div>\n  );\n}",
  "dependencies": [],
  "libraries": []
}