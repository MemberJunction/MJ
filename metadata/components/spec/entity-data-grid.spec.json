{
  "name": "EntityDataGrid",
  "title": "Entity Data Grid",
  "description": "Entity-aware data grid that automatically loads records via RunView with adaptive caching. Perfect for drill-down targets showing detail records from aggregated charts/queries. Implements smart caching: loads all data if totalRecords <= maxCachedRows (instant client-side sort/filter), otherwise uses paginated server-side loading. Unlike DataGrid which accepts arbitrary data via props, EntityDataGrid manages its own data loading from MemberJunction entities. Use when you need 'click to see actual records' functionality without manual RunView calls.",
  "type": "table",
  "location": "embedded",
  "functionalRequirements": "WHEN TO USE: Drill-down destination from aggregated charts showing detail entity records; Browse large entity datasets with automatic pagination; Load and display filtered entity records (e.g., 'show all invoices for this member'); Master-detail patterns where detail panel shows entity records. WHEN NOT TO USE: Display custom/aggregated/joined data that isn't direct entity records (use DataGrid); Single record display (use SingleRecordView); Pre-loaded data passed via props (use DataGrid). ADAPTIVE CACHING MODES: FULL CACHE MODE (totalRecords <= maxCachedRows): Loads all entity records upfront into memory; Client-side sorting and filtering (instant, no server calls); Pagination slices cached array (no RunView on page change); Perfect for drilldown scenarios (filtered datasets usually small); User sees 'All X records loaded' indicator. PARTIAL CACHE MODE (totalRecords > maxCachedRows): Loads first maxCachedRows records initially; Shows warning banner: 'Showing first 1,000 of 15,000 records'; Server-side sorting (new RunView with OrderBy parameter); Server-side filtering warns user to use extraFilter prop; Pagination triggers new RunView with Skip/MaxRows; Caches visited pages to avoid re-fetching. CACHE STRATEGY: Initial load fetches maxCachedRows rows (default 1000); If RowCount <= maxCachedRows: Enter full cache mode, cache all data; If RowCount > maxCachedRows: Enter partial cache mode, cache pages as visited; Page cache: Map<pageNumber, pageData> for partial mode; Clear all caches when entityName, extraFilter, or orderBy change; Smart cache eviction in partial mode (keep last 10 pages, LRU). CORE FEATURES: Automatic entity record loading via utilities.rv.RunView; Adaptive caching with full/partial modes; Built-in pagination with configurable page size (default 20 rows per page); Smart sort/filter (client-side in full mode, server-side in partial mode); Warning banners when viewing partial results; Page cache for instant back/forward navigation; Accepts entityName (required), extraFilter (optional SQL WHERE clause), fields (optional field names); Supports all DataGrid features: sorting, filtering, selection, row click, OpenEntityRecord; Metadata-aware formatting inherited from DataGrid; Empty state with contextual message; Refresh capability to reload and clear cache. SORTING BEHAVIOR: Full cache mode: Client-side instant sorting of all cached records; Partial cache mode: Server-side sorting (new RunView with OrderBy, clears cache); DataGrid enableSorting prop controls column sort UI; orderBy prop sets initial/default sort order. FILTERING BEHAVIOR: extraFilter prop: Always server-side (RunView ExtraFilter parameter), affects all modes; DataGrid text filter (enableFiltering=true): Full cache mode filters cached records instantly; Partial cache mode shows warning: 'Text filtering searches loaded records only. Use extraFilter for database-level filtering'; filterDebounceTime prevents excessive re-renders. PAGINATION STRATEGY: Full cache mode: Pure client-side array slicing, no server calls; Partial cache mode: RunView with Skip/MaxRows on page change, caches result; Page size changes reset to page 1; Pagination shows 'Page X of Y' or 'Page X' if total unknown. DATA LOADING: Uses utilities.rv.RunView with ResultType='entity_object'; Builds ExtraFilter from extraFilter prop; OrderBy defaults to primary key if not specified; Initial load: MaxRows=maxCachedRows to determine cache mode; Handles RunView errors gracefully with retry option. INTEGRATION WITH DATAGRID: EntityDataGrid wraps DataGrid and passes loaded data; All DataGrid props supported (enableSorting, enableFiltering, selection, etc.); DataGrid handles UI rendering, EntityDataGrid handles data loading and caching; entityName and entityPrimaryKeys passed for OpenEntityRecord; fields prop maps to DataGrid columns; Events bubble up from DataGrid. ERROR HANDLING: Network errors show 'Unable to load data. [Retry]' message; Invalid filters show error with filter details; Permission errors show 'You do not have access to this entity'; Empty results show 'No {entityName} found' or 'No {entityName} match your filters'; RunView.Success=false shows ErrorMessage with retry. USER EXPERIENCE INDICATORS: Loading spinner on initial load; Subtle loading overlay on pagination in partial mode; Cache mode indicator: 'All X records loaded' or 'Showing first X of Y records'; Warning banner in partial mode with suggestion to refine extraFilter; Text filter warning in partial mode; Refresh button clears cache and reloads.",
  "technicalDesign": "React functional component with adaptive caching logic. STATE MANAGEMENT: data (Array<object> | null): Current page records for display; allDataCache (Array<object> | null): All records in full cache mode; pageCache (Map<number, Array<object>>): Cached pages in partial cache mode; cacheMode ('full' | 'partial' | 'loading'): Current cache strategy; loading (boolean): Data fetch in progress; error (string | null): Error message if load failed; currentPage (number, 1-based): Current pagination page; currentPageSize (number): Records per page; totalRecords (number | null): Total record count from RowCount; entityInfo (object): Entity metadata from utilities.md; currentOrderBy (string): Active sort order (tracks server vs client sort); refreshTrigger (number): Increment to force reload. INITIAL LOAD LOGIC: useEffect triggers on entityName, extraFilter, refreshTrigger; Calls RunView with MaxRows=maxCachedRows, Skip=0; On success: Check result.RowCount vs maxCachedRows; If RowCount <= maxCachedRows OR RowCount is null: setCacheMode('full'), setAllDataCache(result.Results), setData(result.Results.slice(0, pageSize)); If RowCount > maxCachedRows: setCacheMode('partial'), setPageCache(Map with page 1), setData(first page slice); Store totalRecords from RowCount; On failure: Set error, clear caches. FULL CACHE MODE BEHAVIOR: All data stored in allDataCache; Pagination: Slice allDataCache without server calls; Sorting: Client-side array.sort(), update data slice; Text filtering: Client-side array.filter(), update data slice; No loading states on pagination/sort/filter (instant). PARTIAL CACHE MODE BEHAVIOR: pageCache stores Map<pageNum, data[]>; Pagination: Check if pageCache.has(pageNum), if yes use cache, if no fetch via RunView; Sorting: Clear caches, set orderBy, trigger new initial load; Text filtering: Show warning banner, filter visible data only (doesn't refetch); Loading overlay shows during page fetches; Smart eviction: Keep last 10 pages in cache (LRU strategy). CACHE INVALIDATION: Clear allDataCache and pageCache when: entityName changes, extraFilter changes, orderBy changes (in partial mode), refreshTrigger increments; Reset to page 1 and cacheMode='loading'. SORT HANDLING: If cacheMode='full': sortClientSide() - sorts allDataCache, updates data slice; If cacheMode='partial': sortServerSide() - clears caches, sets orderBy state, triggers useEffect reload; DataGrid onSortChanged event triggers sort handler. FILTER HANDLING: extraFilter prop change: Always clears cache and reloads from server; DataGrid text filter (onFilterChanged event): If cacheMode='full': filters allDataCache, shows filtered results; If cacheMode='partial': filters current page data, shows warning banner. PAGE NAVIGATION: handlePageChange(newPage): Validates bounds; If cacheMode='full': slices allDataCache at new offset, instant; If cacheMode='partial': checks pageCache.has(newPage), if hit uses cache (instant), if miss fetches via RunView (loading state); Updates currentPage state. ENTITY METADATA: useEffect on entityName loads entity from utilities.md.Entities; Extracts primary key fields for default orderBy; Auto-detects fields if not provided (first 15 non-system fields); Stores in entityInfo state. PAGINATION CALCULATION: totalPages = totalRecords && pageSize ? Math.ceil(totalRecords / pageSize) : null; hasPrevious = currentPage > 1; hasNext: In full mode checks allDataCache.length, in partial mode checks currentPage < totalPages; startRecord, endRecord calculated for display. RENDER LOGIC: If error: Error UI with retry button; If loading && data===null: Full loading spinner; If success: Warning banner (if partial mode), DataGrid component with current data, Custom pagination controls below grid, Cache mode indicator, Loading overlay (if fetching page in partial mode). PROPS TO DATAGRID: data prop (current page records), entityName, entityPrimaryKeys (auto-detected), columns=fields prop (auto-detected if omitted), sorting=false (we handle sorting), paging=false (we handle pagination), filtering=enableFiltering, selectionMode, autoFitColumns, onRowClick, onSelectionChanged, onFilterChanged (triggers our filter logic), Pass through utilities, styles, components, callbacks. EVENT FIRING: onPageChanged: Fires after page change completes; onDataLoaded: Fires after successful data load; onLoadError: Fires on errors; onCacheModeChanged: Fires when switching between full/partial (optional). PERFORMANCE OPTIMIZATIONS: useMemo for tableColumns, paginationInfo, autoDetectedFields; useCallback for handlers to prevent re-renders; Debounce text filter input (300ms default); AbortController to cancel in-flight requests; LRU cache eviction in partial mode.",
  "dataRequirements": {
    "mode": "views",
    "description": "Component performs RunView internally with adaptive caching. Initial load fetches maxCachedRows to determine cache mode. Does NOT accept data via props."
  },
  "typeDefinitions": {
    "FieldDefinition": {
      "description": "Field definition object for advanced field configuration",
      "properties": {
        "field": {
          "type": "string",
          "required": true,
          "description": "Field name from entity"
        },
        "header": {
          "type": "string",
          "required": false,
          "description": "Display header text (defaults to field DisplayName or field name)"
        },
        "render": {
          "type": "function",
          "signature": "(value: any, record: object, fieldInfo?: object) => ReactNode",
          "required": false,
          "description": "Custom render function for cell content"
        },
        "width": {
          "type": "string | number",
          "required": false,
          "description": "Column width (e.g., '200px' or 200)"
        },
        "sortable": {
          "type": "boolean",
          "required": false,
          "description": "Override global sorting setting for this column"
        }
      }
    }
  },
  "properties": [
    {
      "name": "entityName",
      "type": "string",
      "description": "REQUIRED. Name of the MemberJunction entity to load records from. Must match entity name in metadata (e.g., 'Invoices', 'Members', 'CRM: Contacts').",
      "required": true,
      "exampleValue": "Invoices"
    },
    {
      "name": "extraFilter",
      "type": "string",
      "description": "Optional SQL WHERE clause to filter records (without 'WHERE' keyword). Always applied server-side via RunView ExtraFilter parameter. Supports full SQL syntax: comparison operators, AND/OR logic, IN clauses, date functions, etc. Clearing cache and reloading data when changed. Examples: \"Status='Active'\", \"InvoiceDate >= '2024-01-01' AND Total > 1000\", \"MemberID IN (SELECT ID FROM Members WHERE MembershipType='Gold')\"",
      "required": false,
      "exampleValue": "Status='Active' AND InvoiceDate >= '2024-01-01'",
      "constraints": [
        {
          "type": "sql-where-clause",
          "dependsOn": "entityName",
          "description": "Validates SQL WHERE clause syntax and field references against the entity schema",
          "errorTemplate": "SQL WHERE clause error: {message}"
        }
      ]
    },
    {
      "name": "fields",
      "type": "Array<string | FieldDefinition>",
      "description": "Optional field definitions. Can be simple strings (field names) or FieldDefinition objects for advanced configuration. If omitted, auto-detects first 15 non-system fields. When using FieldDefinition objects, the 'field' property is validated against entity fields.",
      "required": false,
      "exampleValue": "[\"Name\", {field: \"Price\", header: \"Unit Price\", width: \"120px\", render: (v) => `$${v.toFixed(2)}`}, \"Status\"]",
      "constraints": [
        {
          "type": "subset-of-entity-fields",
          "dependsOn": "entityName",
          "description": "Validates that field names (strings or FieldDefinition.field properties) exist on the specified entity",
          "config": {
            "allowWildcard": false,
            "caseSensitive": false
          },
          "errorTemplate": "Field '{field}' does not exist on entity '{entityName}'"
        }
      ]
    },
    {
      "name": "orderBy",
      "type": "string",
      "description": "Optional SQL ORDER BY clause (without 'ORDER BY' keyword). Defaults to primary key field(s) if not specified. In full cache mode: only sets initial sort (client-side sorting available). In partial cache mode: changing this triggers new RunView and clears cache. Examples: \"InvoiceDate DESC\", \"LastName ASC, FirstName ASC\", \"Total DESC\"",
      "required": false,
      "exampleValue": "InvoiceDate DESC"
    },
    {
      "name": "pageSize",
      "type": "number",
      "description": "Number of records to display per page. Must be one of: 10, 20, 50, 100, 200. In full cache mode: slices cached array. In partial cache mode: MaxRows parameter for RunView.",
      "required": false,
      "defaultValue": 20,
      "exampleValue": "50"
    },
    {
      "name": "initialPage",
      "type": "number",
      "description": "Initial page number to load (1-based). Useful for deep linking or restoring user state.",
      "required": false,
      "defaultValue": 1
    },
    {
      "name": "maxCachedRows",
      "type": "number",
      "description": "Maximum number of rows to cache. Determines cache mode: if totalRecords <= maxCachedRows, enters full cache mode (loads all data upfront for instant sort/filter). If totalRecords > maxCachedRows, enters partial cache mode (server-side sort/filter, paginated loading). Higher values improve UX for larger datasets but use more memory. Typical drilldown scenarios have < 1000 rows.",
      "required": false,
      "defaultValue": 1000,
      "exampleValue": "2000"
    },
    {
      "name": "enablePageCache",
      "type": "boolean",
      "description": "Enable page caching in partial cache mode. When true, visited pages are cached for instant back/forward navigation. Cache cleared when entityName, extraFilter, or orderBy change. Keeps last 10 pages in memory (LRU eviction).",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "showPageSizeChanger",
      "type": "boolean",
      "description": "Show page size selector dropdown in pagination controls",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "enableSorting",
      "type": "boolean",
      "description": "Enable column sorting in DataGrid UI. In full cache mode: client-side instant sorting. In partial cache mode: triggers new RunView with OrderBy and clears cache. Different from 'orderBy' prop which sets the initial/default sort order.",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "enableFiltering",
      "type": "boolean",
      "description": "Enable DataGrid's text search filter UI. In full cache mode: instantly filters cached records. In partial cache mode: filters visible page data only and shows warning to use 'extraFilter' prop for database-level filtering. Different from 'extraFilter' prop which is always server-side SQL filtering.",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "selectionMode",
      "type": "'none' | 'checkbox' | 'radio' | 'row'",
      "description": "Row selection mode (passed to DataGrid)",
      "required": false,
      "defaultValue": "none"
    },
    {
      "name": "autoFitColumns",
      "type": "boolean",
      "description": "When true, columns auto-fit to container width. When false, uses fixed widths with horizontal scrolling (passed to DataGrid)",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "showRefreshButton",
      "type": "boolean",
      "description": "Show refresh button to manually reload and clear all caches",
      "required": false,
      "defaultValue": false
    },
    {
      "name": "showCacheModeIndicator",
      "type": "boolean",
      "description": "Show indicator badge displaying current cache mode ('All X records loaded' or 'Showing first X of Y records'). Useful for developers debugging performance or power users who want to understand data loading behavior. Most end users don't need to see this.",
      "required": false,
      "defaultValue": false
    },
    {
      "name": "warnOnPartialResults",
      "type": "boolean",
      "description": "Show warning banner in partial cache mode suggesting user refine extraFilter for better results. Useful when users might be confused about not seeing all data, but adaptive caching is designed to work transparently without requiring user awareness.",
      "required": false,
      "defaultValue": false
    }
  ],
  "events": [
    {
      "name": "pageChanged",
      "description": "Fired when page or page size changes, after data is loaded",
      "parameters": [
        {
          "name": "pageInfo",
          "type": "{ pageNumber: number, pageSize: number, totalRecords: number | null, totalPages: number | null, visibleRows: Array<object>, cacheMode: 'full' | 'partial', cacheHit: boolean }",
          "description": "Complete pagination state including cache information"
        }
      ]
    },
    {
      "name": "dataLoaded",
      "description": "Fired when data successfully loads from RunView",
      "parameters": [
        {
          "name": "loadResult",
          "type": "{ data: Array<object>, totalRecords: number | null, pageNumber: number, pageSize: number, cacheMode: 'full' | 'partial' }",
          "description": "Loaded data and cache mode metadata"
        }
      ]
    },
    {
      "name": "loadError",
      "description": "Fired when RunView fails or network error occurs",
      "parameters": [
        {
          "name": "errorInfo",
          "type": "{ error: string, extraFilter?: string, entityName: string }",
          "description": "Error details for logging or user notification"
        }
      ]
    },
    {
      "name": "cacheModeChanged",
      "description": "Fired when cache mode switches between full and partial",
      "parameters": [
        {
          "name": "cacheModeInfo",
          "type": "{ cacheMode: 'full' | 'partial', totalRecords: number, maxCachedRows: number }",
          "description": "Cache mode transition information"
        }
      ]
    },
    {
      "name": "rowClick",
      "description": "Bubbled from DataGrid - fired when row clicked",
      "parameters": [
        {
          "name": "event",
          "type": "{ record: object, cancel: boolean }",
          "description": "Row click event with cancelable pattern"
        }
      ]
    },
    {
      "name": "selectionChanged",
      "description": "Bubbled from DataGrid - fired when selection changes",
      "parameters": [
        {
          "name": "selectionInfo",
          "type": "{ selectedRows: Array<object> }",
          "description": "Array of selected records"
        }
      ]
    }
  ],
  "dependencies": [
    {
      "name": "DataGrid",
      "namespace": "Generic/UI/Table",
      "location": "registry",
      "description": "Wrapped data grid component for rendering"
    }
  ],
  "code": "@file:../code/entity-data-grid.js",
  "exampleUsage": "// Basic usage - auto-detects fields, enters full cache mode for small datasets\n<EntityDataGrid\n  entityName=\"Invoices\"\n  extraFilter=\"Status='Unpaid'\"\n  pageSize={50}\n/>\n// If < 1000 unpaid invoices: Full cache mode, instant sort/filter\n// If > 1000 unpaid invoices: Partial cache mode, shows warning banner\n\n// ADVANCED COLUMN STYLING EXAMPLES:\n\n// Example 1: Custom Renderers with Formatting\n<EntityDataGrid\n  entityName=\"Products\"\n  fields={[\n    'Name',\n    'SKU',\n    {\n      field: 'Price',\n      header: 'Unit Price',\n      width: '120px',\n      render: (value, record) => {\n        const formatted = `$${value.toFixed(2)}`;\n        return record.OnSale ? \n          <span style={{color: '#cf1322', fontWeight: 'bold'}}>{formatted} SALE!</span> :\n          formatted;\n      }\n    },\n    {\n      field: 'Stock',\n      header: 'In Stock',\n      width: '100px',\n      render: (value) => {\n        const color = value > 10 ? '#389e0d' : value > 0 ? '#d48806' : '#cf1322';\n        return <span style={{color, fontWeight: 600}}>{value}</span>;\n      }\n    },\n    'Status'\n  ]}\n/>\n\n// Example 2: Calculated Columns\n<EntityDataGrid\n  entityName=\"Orders\"\n  fields={[\n    'OrderNumber',\n    'SubTotal',\n    'Tax',\n    {\n      field: 'SubTotal', // Use existing field for data\n      header: 'Total (with Tax)',\n      width: '140px',\n      render: (value, record) => {\n        const total = value + (record.Tax || 0);\n        return `$${total.toFixed(2)}`;\n      }\n    },\n    'Status'\n  ]}\n/>\n\n// Example 3: Conditional Styling & Icons\n<EntityDataGrid\n  entityName=\"Tasks\"\n  fields={[\n    {\n      field: 'Priority',\n      width: '100px',\n      render: (value) => {\n        const styles = {\n          High: { color: '#cf1322', icon: 'ðŸ”´' },\n          Medium: { color: '#d48806', icon: 'ðŸŸ¡' },\n          Low: { color: '#389e0d', icon: 'ðŸŸ¢' }\n        };\n        const style = styles[value] || {};\n        return <span style={{color: style.color}}>{style.icon} {value}</span>;\n      }\n    },\n    'Title',\n    'AssignedTo',\n    {\n      field: 'DueDate',\n      header: 'Due',\n      width: '120px',\n      render: (value) => {\n        const date = new Date(value);\n        const isOverdue = date < new Date();\n        return <span style={{color: isOverdue ? '#cf1322' : '#262626'}}>\n          {date.toLocaleDateString()}\n        </span>;\n      }\n    }\n  ]}\n/>\n\n// Example 4: Links and Actions\n<EntityDataGrid\n  entityName=\"Customers\"\n  fields={[\n    'Name',\n    {\n      field: 'Email',\n      width: '200px',\n      render: (value) => <a href={`mailto:${value}`}>{value}</a>\n    },\n    {\n      field: 'Phone',\n      width: '150px',\n      render: (value) => <a href={`tel:${value}`}>{value}</a>\n    },\n    'City',\n    'Status'\n  ]}\n/>\n\n// Example 5: Mix Simple and Advanced\n<EntityDataGrid\n  entityName=\"Invoices\"\n  fields={[\n    'InvoiceNumber',  // Simple string\n    'CustomerName',   // Simple string\n    { field: 'Total', header: 'Amount', width: '120px' },  // Custom header & width\n    'Status',  // Simple string (gets colored tag from value list)\n    {\n      field: 'DueDate',\n      width: '140px',\n      sortable: false,  // Disable sorting for this column only\n      render: (value, record) => {\n        const daysUntil = Math.ceil((new Date(value) - new Date()) / (1000 * 60 * 60 * 24));\n        if (daysUntil < 0) return <span style={{color: '#cf1322'}}>OVERDUE</span>;\n        if (daysUntil < 7) return <span style={{color: '#d48806'}}>Due soon ({daysUntil}d)</span>;\n        return new Date(value).toLocaleDateString();\n      }\n    }\n  ]}\n/>\n\n// Drill-down from chart - typically small filtered datasets (full cache mode)\nconst handleMemberClick = (segment) => {\n  setSelectedMemberId(segment.records[0]?.MemberID);\n};\n\n<EntityDataGrid\n  entityName=\"Invoices\"\n  extraFilter={`MemberID='${selectedMemberId}'`}\n  fields={['InvoiceNumber', 'InvoiceDate', 'Total', 'Status', 'DueDate']}\n  orderBy=\"InvoiceDate DESC\"\n  pageSize={20}\n  entityPrimaryKeys={['ID']}\n  onRowClick={handleInvoiceClick}\n  onCacheModeChanged={(info) => console.log('Cache mode:', info.cacheMode)}\n/>\n// Single member's invoices usually < 1000 â†’ Full cache, instant UX\n\n// Large dataset with higher cache limit\n<EntityDataGrid\n  entityName=\"CRM: Contacts\"\n  extraFilter=\"Status='Active' AND LastContactDate >= DATEADD(day, -30, GETDATE())\"\n  fields={[\n    'FirstName',\n    'LastName',\n    { field: 'Email', header: 'Email Address', width: '250px' },\n    'LastContactDate',\n    'Status'\n  ]}\n  orderBy=\"LastContactDate DESC\"\n  pageSize={100}\n  maxCachedRows={2000}\n  enablePageCache={true}\n  showCacheModeIndicator={true}\n  warnOnPartialResults={true}\n  enableSorting={true}\n  enableFiltering={true}\n  showRefreshButton={true}\n  onPageChanged={(info) => {\n    console.log(`Page ${info.pageNumber}, Cache hit: ${info.cacheHit}`);\n  }}\n/>\n// If 1500 contacts: Enters full cache mode (< 2000), instant sort/filter\n// If 5000 contacts: Enters partial cache mode, server-side sort, page caching\n\n// Drilldown pattern with SimpleChart + EntityDataGrid\nconst [selectedCategory, setSelectedCategory] = React.useState(null);\n\n<div>\n  <SimpleChart\n    data={aggregatedData}  // Pre-aggregated from RunQuery\n    groupBy=\"Category\"\n    valueField=\"TotalRevenue\"\n    chartType=\"bar\"\n    title=\"Revenue by Category\"\n    onDataPointClick={(segment) => setSelectedCategory(segment.label)}\n  />\n  \n  {selectedCategory && (\n    <div style={{ marginTop: 20 }}>\n      <h3>Products in {selectedCategory}</h3>\n      <EntityDataGrid\n        entityName=\"Products\"\n        extraFilter={`Category='${selectedCategory}'`}\n        fields={['ProductName', 'UnitPrice', 'StockQuantity', 'Status']}\n        orderBy=\"ProductName ASC\"\n        pageSize={50}\n        maxCachedRows={500}\n      />\n      {/* Category drill-down usually has < 500 products â†’ Full cache mode */}\n    </div>\n  )}\n</div>\n\n// CACHE MODE BEHAVIOR EXAMPLES:\n\n// Scenario 1: Small filtered dataset (100 invoices for one account)\n// - Initial load: Fetches all 100 rows\n// - Cache mode: 'full'\n// - User sorts by Total: Instant client-side sort\n// - User pages: Instant array slicing\n// - User filters text: Instant client-side filter\n// - Result: Perfect instant UX\n\n// Scenario 2: Large dataset (50,000 total contacts)\n// - Initial load: Fetches first 1000 rows\n// - Cache mode: 'partial'\n// - Shows banner: 'Showing first 1,000 of 50,000 records. Refine your filter for better results.'\n// - User sorts by LastName: Triggers new RunView with OrderBy, clears cache\n// - User pages to page 2: Fetches page 2 (rows 21-40), caches it\n// - User pages back to page 1: Instant (cache hit)\n// - User text filters: Filters visible 20 rows, shows warning about using extraFilter\n// - Result: Transparent UX with guidance"
}
