{
  "name": "SimpleChart",
  "title": "Simple Chart",
  "description": "Standalone single-level chart component with NO built-in drill-down functionality. Renders bar/line/pie/doughnut/area/scatter charts using Chart.js 4.4.1. Emits onClick events but doesn't handle navigation - parent component must wire up drill-down logic. USE for: standalone visualizations, dashboard widgets, building blocks in custom multi-level drill-downs. DO NOT USE when user explicitly wants 'drill-down to table' (use SimpleDrilldownChart instead). Auto-aggregates data client-side by groupBy field with count/sum/average/min/max methods. Smart auto-type selection: date fields→line, ≤5 categories→doughnut, else→bar. Formats values automatically: currency ($ for Amount fields), dates (locale format), numbers (commas). Exports as PNG image. Click events return {label, value, records: Array<object>, percentage} for parent to implement custom drill logic.",
  "type": "chart",
  "location": "embedded",
  "functionalRequirements": "WHEN TO USE: Standalone chart without any drill-down behavior; Building custom multi-level drill-downs where you compose multiple SimpleChart instances with custom navigation logic; Dashboard widgets that are view-only; Charts needing custom onClick handling in parent component; Chart as reusable building block in larger component. WHEN NOT TO USE: User explicitly asks for 'drill-down to table' (use SimpleDrilldownChart which has built-in drill behavior); User wants automatic drill behavior without writing custom code; Need built-in two-level chart-to-table pattern. CORE FEATURES: Zero-configuration charting with smart defaults; Chart types: bar, line, pie, doughnut, area, scatter; Auto chart-type selection based on data characteristics and field types; Client-side data aggregation: groups records by specified field, aggregates using method (count/sum/average/min/max); Smart value formatting: currencies (detects Amount fields or money type, formats as $USD), dates (toLocaleDateString with month/day/year), numbers (Intl.NumberFormat with commas); Click events emit full context {chartType, seriesName, label, value, records: Array<object>, percentage} - parent must handle for drill-down; Responsive canvas that resizes with container; Export chart as PNG image with button overlay (enableExport prop); Top-N limiting with limit prop (e.g., top 10 categories); Custom color palettes via colors prop; Configurable legend: position (auto/top/bottom/left/right), fontSize, show/hide; Optional data labels on chart (showDataLabels prop); Loading state when data processing; Empty state with gray background when no data; Metadata-aware: loads entity info for field type detection. AUTO TYPE SELECTION LOGIC: If groupBy field is date/datetime type (from metadata or value detection) → line chart; If ≤5 categories after aggregation → doughnut chart; Else → bar chart (default). AGGREGATION METHODS: count (default, counts records per group); sum (sums valueField for each group); average (averages valueField); min (minimum valueField); max (maximum valueField). SORTING: By default, input data order is PRESERVED (sortBy=undefined). This is ideal for time-series data where you pre-sort by date, or when your query already returns data in desired order. To explicitly sort: sortBy='value' sorts by aggregated values (useful for rankings like top products), sortBy='label' sorts alphabetically by category labels. sortOrder='asc'|'desc' controls direction when sorting is enabled. For drill-down functionality, parent component must: (1) Pass onDataPointClick event handler, (2) Receive clickData containing records array and segment info, (3) Implement custom navigation/state logic (show DataGrid, navigate to detail page, render child SimpleChart with filtered data, etc.).",
  "technicalDesign": "NO built-in drill-down - emits click events only, parent must handle navigation. Uses Chart.js 4.4.1 canvas rendering via unwrapLibraryComponents(Chart, 'Chart') to handle various package formats. React hooks: useRef for canvasRef and chartInstanceRef, useState for error and entityInfo, useMemo for processData pipeline, useEffect for chart rendering and export setup. Processing pipeline (useMemo): (1) Validate groupBy and valueField exist in data[0], throw error if missing with available fields list; (2) Group records by groupBy field value (special date handling: if date field detected, format as YYYY-MM-DD ISO for consistent grouping); (3) Aggregate each group based on aggregateMethod: count→records.length, sum/avg/min/max→apply to valueField numeric values; (4) Convert grouped object to array; (5) Sort by label or value based on sortBy/sortOrder props; (6) Apply limit for top-N filtering if specified; (7) Extract categories (labels array) and values (numbers array) for Chart.js datasets. Auto chart type determination: Check if groupBy is date field (entity metadata Type=datetime/date OR value is Date instance OR string parseable as date) → line chart; Check if ≤5 categories → doughnut chart; Else → bar chart (default). Maps 'donut' → 'doughnut', 'column' → 'bar' for Chart.js compatibility. Chart.js config object: type (bar/line/pie/doughnut/area/scatter, area uses line with fill:true), datasets with label (valueField or 'Count'), data (values array), backgroundColor/borderColor from colors prop or default 10-color palette, borderWidth, fill and tension for line/area; options with responsive:true, maintainAspectRatio:false, onClick handler (extracts clicked index, finds chartData[index], calls onDataPointClick with full segment), plugins for title/legend/datalabels/tooltip, scales for non-pie charts (y-axis with formatValue callback, x-axis with label rotation). Value formatting function: null→'N/A', dates→toLocaleDateString(month short/day/year), currency (isCurrency flag OR valueField includes 'amount')→Intl.NumberFormat USD style, numbers→Intl.NumberFormat with commas. useEffect for chart rendering: Checks processData.isEmpty and canvasRef.current; Validates Chart.js loaded, sets error if not; Destroys existing chartInstanceRef if exists; Gets 2d context from canvas; Creates new Chart.js instance with config; Fires onChartRendered event with {chartType, dataPointCount, aggregateMethod, totalValue}; Cleanup destroys chart on unmount. Export functionality (useEffect): If enableExport, stores handler in window.SimpleChartExport, uses canvas.toDataURL('image/png') for download, button positioned absolute top-right with z-index:10. Metadata loading (useEffect): Finds entity in utilities.md.Entities array, stores in entityInfo state for field type access. Error state: Returns red error div with height prop, shows error message. Empty state: Returns gray background div with 'No data available' centered. Component returns: Wrapper div with optional export button (absolute positioned), inner div with height prop containing canvas element. For drill-down, parent receives dataPointClick event with records array and must implement logic - SimpleChart does NOT navigate or show child components itself.",
  "dataRequirements": {
    "mode": "props",
    "description": "Component receives entity data through props and performs client-side aggregation"
  },
  "properties": [
    {
      "name": "entityName",
      "type": "string",
      "description": "Optional entity name for metadata-aware formatting (dates, money, value lists). If omitted, component uses basic type detection and works with any data array. Note: This property is NOT used for generating the chart title - always provide an explicit 'title' property to avoid undefined titles.",
      "required": false
    },
    {
      "name": "data",
      "type": "Array<object>",
      "description": "Array of entity records to visualize. Typically detail-level records (invoices, transactions, events) that component will aggregate by groupBy field. Can also accept pre-aggregated data if you're building custom charts without drill-down needs. For drill-down charts, use SimpleDrilldownChart which requires detail records.",
      "required": true
    },
    {
      "name": "groupBy",
      "type": "string",
      "description": "Field name to group data by. Works with any field in the data array.",
      "required": true
    },
    {
      "name": "valueField",
      "type": "string",
      "description": "Field name to aggregate for chart values. REQUIRED when using aggregateMethod 'sum', 'average', 'min', or 'max'. OMIT when using 'count' (counts records regardless of field values). Examples: 'Total' for revenue, 'Amount' for sales, 'Quantity' for inventory. Component groups records by groupBy field and aggregates this valueField according to aggregateMethod.",
      "required": false,
      "constraints": [
        {
          "type": "required-when",
          "dependsOn": "aggregateMethod",
          "description": "valueField is required when aggregateMethod is sum, average, min, or max",
          "config": {
            "condition": "siblingProp === 'sum' || siblingProp === 'average' || siblingProp === 'min' || siblingProp === 'max'"
          },
          "errorTemplate": "valueField is required when aggregateMethod is '{aggregateMethod}'"
        }
      ]
    },
    {
      "name": "aggregateMethod",
      "type": "'count' | 'sum' | 'average' | 'min' | 'max'",
      "description": "How to aggregate records within each group. CRITICAL: Choose based on what you're measuring. Use 'count' ONLY when counting records (omit valueField). Use 'sum' for totals (revenue, sales, costs - REQUIRES valueField). Use 'average' for means (average deal size, average rating). Use 'min'/'max' for extremes. COMMON MISTAKE: Using default 'count' when valueField is specified - this counts records instead of summing values! Example: For 'revenue by month', use aggregateMethod='sum' with valueField='Total', NOT count.",
      "required": false,
      "defaultValue": "count",
      "possibleValues": ["count", "sum", "average", "min", "max"]
    },
    {
      "name": "chartType",
      "type": "'auto' | 'bar' | 'line' | 'pie' | 'doughnut' | 'area' | 'scatter'",
      "description": "Chart type to render. 'auto' selects based on data",
      "required": false,
      "defaultValue": "auto",
      "possibleValues": ["auto", "bar", "line", "pie", "doughnut", "area", "scatter"]
    },
    {
      "name": "title",
      "type": "string",
      "description": "Chart title displayed above the chart. If not provided, no title will be shown. Best practice: Always provide a descriptive title when using the component to avoid undefined values in the display.",
      "required": false
    },
    {
      "name": "height",
      "type": "number",
      "description": "Chart height in pixels",
      "required": false,
      "defaultValue": 400
    },
    {
      "name": "sortBy",
      "type": "'label' | 'value' | undefined",
      "description": "How to sort chart data. By default (undefined), input data order is PRESERVED - this is ideal for time-series data where your query already returns data sorted by date, or when you want full control over ordering. 'value' sorts by aggregated values - useful for ranking charts (top products by revenue, most active users). 'label' sorts alphabetically by category labels. IMPORTANT: If you pass pre-sorted time-series data, do NOT set sortBy - let it default to undefined to preserve your chronological ordering.",
      "required": false,
      "defaultValue": "undefined",
      "possibleValues": ["label", "value", "undefined"]
    },
    {
      "name": "sortOrder",
      "type": "'asc' | 'desc'",
      "description": "Sort direction when sortBy is specified. 'asc' = ascending (low to high, A to Z, old to new). 'desc' = descending (high to low, Z to A, new to old). Only applies when sortBy is 'label' or 'value'. For rankings with sortBy='value', typically use 'desc' for highest-first (top 10 products). For alphabetical sorting with sortBy='label', use 'asc' for A→Z.",
      "required": false,
      "defaultValue": "asc",
      "possibleValues": ["asc", "desc"]
    },
    {
      "name": "limit",
      "type": "number",
      "description": "Limit number of data points shown (e.g., top 10)",
      "required": false
    },
    {
      "name": "colors",
      "type": "Array<string>",
      "description": "Custom color palette for the chart",
      "required": false
    },
    {
      "name": "showLegend",
      "type": "boolean",
      "description": "Whether to show the legend",
      "required": false,
      "defaultValue": true
    },
    {
      "name": "legendPosition",
      "type": "'auto' | 'top' | 'bottom' | 'left' | 'right'",
      "description": "Position of the legend. 'auto' uses bottom for pie/doughnut, top for others",
      "required": false,
      "defaultValue": "auto",
      "possibleValues": ["auto", "top", "bottom", "left", "right"]
    },
    {
      "name": "legendFontSize",
      "type": "number",
      "description": "Font size for legend labels in pixels",
      "required": false,
      "defaultValue": 12
    },
    {
      "name": "showDataLabels",
      "type": "boolean",
      "description": "Whether to show data labels on chart",
      "required": false,
      "defaultValue": false
    },
    {
      "name": "enableExport",
      "type": "boolean",
      "description": "When true, displays an export button in the top-right corner above the chart to download chart as PNG image. Button is positioned outside the chart canvas to avoid overlaying the visualization.",
      "required": false,
      "defaultValue": true
    }
  ],
  "events": [
    {
      "name": "dataPointClick",
      "description": "Fired when user clicks on a data point",
      "parameters": [
        {
          "name": "clickData",
          "type": "{ seriesName: string; value: number; label: string; records: Array<object>; chartType: string; percentage?: number }",
          "description": "Object containing series name, data value, label, original records, and chart type"
        }
      ]
    },
    {
      "name": "chartRendered",
      "description": "Fired when chart has finished rendering",
      "parameters": [
        {
          "name": "chartInfo",
          "type": "{ chartType: string; dataPointCount: number; aggregationMethod: string; isEmpty: boolean }",
          "description": "Information about the rendered chart including type, data point count, and aggregation method"
        }
      ]
    }
  ],
  "libraries": [
    {
      "name": "chart.js",
      "version": "4.4.1",
      "globalVariable": "Chart"
    }
  ],
  "dependencies": [],
  "code": "@file:../code/simple-chart.js",
  "exampleUsage": "<!-- Ranking Example: Top products by revenue (explicit sort by value) -->\n<SimpleChart\n  entityName=\"Invoice Line Items\"\n  data={invoiceItems}\n  groupBy=\"ProductCategory\"\n  valueField=\"TotalAmount\"\n  aggregateMethod=\"sum\"\n  chartType=\"bar\"\n  title=\"Top 10 Products by Revenue\"\n  limit={10}\n  sortBy=\"value\"  // Explicit sort by revenue for ranking\n  sortOrder=\"desc\"  // Highest first\n  onDataPointClick={handleDrillDown}\n/>\n\n<!-- Time-Series Example: Revenue by month (preserve query order) -->\n<SimpleChart\n  entityName=\"Invoices\"\n  data={preAggregatedMonthlyData}  // Query returns data already sorted by Year/Month\n  groupBy=\"DateLabel\"  // e.g. \"January 2024\", \"February 2024\"\n  valueField=\"TotalRevenue\"\n  aggregateMethod=\"sum\"\n  chartType=\"bar\"\n  title=\"Monthly Revenue\"\n  // No sortBy - preserves chronological order from query (default behavior)\n  onDataPointClick={handleDrillDown}\n/>\n\n<!-- Counting Example: Tickets by status (no explicit sorting needed) -->\n<SimpleChart\n  entityName=\"Support Tickets\"\n  data={tickets}\n  groupBy=\"Status\"\n  // No valueField - counting records\n  aggregateMethod=\"count\"\n  chartType=\"doughnut\"\n  title=\"Tickets by Status\"\n  // sortBy omitted - preserves input order or can add sortBy=\"value\" for ranking\n/>"
}