{
  "name": "AIPerformanceDashboard",
  "location": "embedded",
  "title": "AI Performance Dashboard",
  "description": "Comprehensive dashboard for analyzing AI agent and prompt performance with time-series charts, cost analysis, and drill-down capabilities.",
  "type": "dashboard",
  "functionalRequirements": "## AI Performance Dashboard Requirements\n\n### Core Functionality\n- Display multi-line time series charts showing total runs, tokens, and costs over time\n- Support multiple time groupings: day, week, month, quarter\n- Dual Y-axis display (tokens on left, runs/costs on right)\n- Click-to-drill-down on any chart point to see details for that period\n- Show distribution charts (pie/bar) for selected time period\n- Separate tabs for Agent Runs and Prompt Runs analysis\n- Real-time data refresh capabilities\n- Export functionality for charts and data\n\n### Analytics Features\n- Time series trends with moving averages\n- Cost breakdown by agent/prompt\n- Token usage distribution\n- Success/failure rate analysis\n- Performance comparisons across periods\n- Top consumers identification\n- Anomaly detection and alerts\n\n### UX Considerations\n- Responsive layout adapting to container size\n- Interactive tooltips on hover\n- Smooth chart animations\n- Loading states during data fetch\n- Clear visual hierarchy\n- Consistent color coding across charts\n- Mobile-responsive design",
  "dataRequirements": {
    "mode": "views",
    "description": "Loads AI performance data including agent runs, prompt runs, and aggregated metrics",
    "entities": [
      {
        "name": "MJ: AI Agent Runs",
        "description": "Historical agent execution data for performance analysis",
        "displayFields": [
          "ID",
          "AgentID",
          "Agent",
          "StartedAt",
          "CompletedAt",
          "Success",
          "TotalTokensUsed",
          "TotalCost"
        ], 
        "filterFields": [
          "StartedAt",
          "Success",
          "AgentID"
        ],
        "sortFields": [
          "StartedAt"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "type": "uniqueidentifier",
            "isPrimaryKey": true,
            "allowsNull": false,
            "description": "Unique run identifier"
          },
          {
            "name": "AgentID",
            "type": "uniqueidentifier",
            "allowsNull": false,
            "description": "Reference to AI Agent"
          },
          {
            "name": "Agent",
            "type": "nvarchar",
            "allowsNull": true,
            "description": "Agent name (denormalized)"
          },
          {
            "name": "StartedAt",
            "type": "datetime",
            "allowsNull": false,
            "description": "Execution start timestamp"
          },
          {
            "name": "TotalTokensUsed",
            "type": "int",
            "allowsNull": true,
            "description": "Total tokens consumed"
          },
          {
            "name": "TotalCost",
            "type": "decimal",
            "allowsNull": true,
            "description": "Total cost in USD"
          }
        ],
        "permissionLevelNeeded": ["read"]
      },
      {
        "name": "MJ: AI Prompt Runs",
        "description": "Historical prompt execution data for performance analysis",
        "displayFields": [
          "ID",
          "PromptID",
          "Prompt",
          "ModelID",
          "Model",
          "RunAt",
          "CompletedAt",
          "Success",
          "TokensUsed",
          "TotalCost"
        ],
        "filterFields": [
          "RunAt",
          "Success",
          "PromptID",
          "ModelID"
        ],
        "sortFields": [
          "RunAt"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "type": "uniqueidentifier",
            "isPrimaryKey": true,
            "allowsNull": false,
            "description": "Unique run identifier"
          },
          {
            "name": "PromptID",
            "type": "uniqueidentifier",
            "allowsNull": false,
            "description": "Reference to AI Prompt"
          },
          {
            "name": "Prompt",
            "type": "nvarchar",
            "allowsNull": true,
            "description": "Prompt name (denormalized)"
          },
          {
            "name": "RunAt",
            "type": "datetime",
            "allowsNull": false,
            "description": "Execution timestamp"
          },
          {
            "name": "TokensUsed",
            "type": "int",
            "allowsNull": true,
            "description": "Total tokens consumed"
          },
          {
            "name": "TotalCost",
            "type": "decimal",
            "allowsNull": true,
            "description": "Total cost in USD"
          }
        ],
        "permissionLevelNeeded": ["read"]
      }
    ],
    "queries": []
  },
  "technicalDesign": "## Component Architecture\n\n### Root Component (AIPerformanceDashboard)\n- Manages overall dashboard state and data loading\n- Handles time range selection and grouping\n- Coordinates drill-down state between components\n- Manages tab switching between Agent and Prompt views\n\n### Child Components\n1. **AITimeSeriesChart**: Multi-line chart with dual Y-axes for runs/tokens/costs\n2. **AIDistributionChart**: Pie/bar charts showing breakdown by agent or prompt\n3. **AIDetailTable**: Detailed table view for drill-down data\n4. **AIMetricsSummary**: Key metrics cards for selected period\n\n### Data Flow\n- Root component loads data based on selected time range\n- Aggregates data by selected grouping (day/week/month/quarter)\n- Passes aggregated data to chart components\n- Handles drill-down events and updates detail views\n- Manages state persistence through savedUserSettings\n\n### State Management\n- Selected time range and grouping\n- Active tab (agents vs prompts)\n- Drill-down selection (selected date/period)\n- Chart view preferences\n- Filter states",
  "properties": [],
  "events": [],
  "exampleUsage": "<AIPerformanceDashboard />",
  "code": "function AIPerformanceDashboard({ utilities, styles, components, callbacks, savedUserSettings, onSaveUserSettings }) {\n  console.log('[AIPerformanceDashboard] Initializing with settings:', savedUserSettings);\n  console.log('[AIPerformanceDashboard] Available components:', components ? Object.keys(components) : 'none');\n  \n  // Extract child components with fallbacks\n  const AITimeSeriesChart = components?.AITimeSeriesChart;\n  const AIDistributionChart = components?.AIDistributionChart;\n  const AIDetailTable = components?.AIDetailTable;\n  const AIMetricsSummary = components?.AIMetricsSummary;\n  \n  // Check if required components are available\n  if (!AITimeSeriesChart || !AIDistributionChart || !AIDetailTable || !AIMetricsSummary) {\n    return (\n      <div style={{\n        padding: styles?.spacing?.lg || '20px',\n        color: styles?.colors?.error || 'red',\n        textAlign: 'center'\n      }}>\n        Error: Required child components are not available. Please ensure all dashboard components are loaded.\n        <br />\n        Missing: {[\n          !AITimeSeriesChart && 'AITimeSeriesChart',\n          !AIDistributionChart && 'AIDistributionChart',\n          !AIDetailTable && 'AIDetailTable',\n          !AIMetricsSummary && 'AIMetricsSummary'\n        ].filter(Boolean).join(', ')}\n      </div>\n    );\n  }\n  \n  // Initialize state from saved settings\n  const [timeRange, setTimeRange] = useState(savedUserSettings?.timeRange || '30d');\n  const [groupBy, setGroupBy] = useState(savedUserSettings?.groupBy || 'day');\n  const [activeTab, setActiveTab] = useState(savedUserSettings?.activeTab || 'agents');\n  const [selectedPoint, setSelectedPoint] = useState(null);\n  \n  // Data state\n  const [agentRuns, setAgentRuns] = useState([]);\n  const [promptRuns, setPromptRuns] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  // Calculate date range\n  const getDateRange = useCallback(() => {\n    const end = new Date();\n    const start = new Date();\n    \n    switch(timeRange) {\n      case '7d':\n        start.setDate(end.getDate() - 7);\n        break;\n      case '30d':\n        start.setDate(end.getDate() - 30);\n        break;\n      case '90d':\n        start.setDate(end.getDate() - 90);\n        break;\n      case '1y':\n        start.setFullYear(end.getFullYear() - 1);\n        break;\n      default:\n        start.setDate(end.getDate() - 30);\n    }\n    \n    return { start, end };\n  }, [timeRange]);\n  \n  // Load data\n  useEffect(() => {\n    const loadData = async () => {\n      console.log('[AIPerformanceDashboard] Loading data for range:', timeRange);\n      setLoading(true);\n      setError(null);\n      \n      const { start, end } = getDateRange();\n      \n      try {\n        // Load agent runs\n        const agentFilter = `StartedAt >= '${start.toISOString()}' AND StartedAt <= '${end.toISOString()}'`;\n        console.log('[AIPerformanceDashboard] Loading agent runs with filter:', agentFilter);\n        \n        const agentResult = await utilities.rv.RunView({\n          EntityName: 'MJ: AI Agent Runs',\n          ExtraFilter: agentFilter,\n          OrderBy: 'StartedAt ASC',\n          Fields: ['ID', 'AgentID', 'Agent', 'StartedAt', 'CompletedAt', 'Success', 'TotalTokensUsed', 'TotalCost'],\n          MaxRows: 10000\n        });\n        \n        console.log('[AIPerformanceDashboard] Agent runs loaded:', {\n          success: agentResult?.Success,\n          count: agentResult?.Results?.length,\n          error: agentResult?.ErrorMessage\n        });\n        \n        if (agentResult?.Success) {\n          setAgentRuns(agentResult.Results || []);\n        } else {\n          console.error('[AIPerformanceDashboard] Failed to load agent runs:', agentResult?.ErrorMessage);\n        }\n        \n        // Load prompt runs\n        const promptFilter = `RunAt >= '${start.toISOString()}' AND RunAt <= '${end.toISOString()}'`;\n        console.log('[AIPerformanceDashboard] Loading prompt runs with filter:', promptFilter);\n        \n        const promptResult = await utilities.rv.RunView({\n          EntityName: 'MJ: AI Prompt Runs',\n          ExtraFilter: promptFilter,\n          OrderBy: 'RunAt ASC',\n          Fields: ['ID', 'PromptID', 'Prompt', 'ModelID', 'Model', 'RunAt', 'CompletedAt', 'Success', 'TokensUsed', 'TotalCost'],\n          MaxRows: 10000\n        });\n        \n        console.log('[AIPerformanceDashboard] Prompt runs loaded:', {\n          success: promptResult?.Success,\n          count: promptResult?.Results?.length,\n          error: promptResult?.ErrorMessage\n        });\n        \n        if (promptResult?.Success) {\n          setPromptRuns(promptResult.Results || []);\n        } else {\n          console.error('[AIPerformanceDashboard] Failed to load prompt runs:', promptResult?.ErrorMessage);\n        }\n        \n      } catch (error) {\n        console.error('[AIPerformanceDashboard] Error loading data:', error);\n        setError(error.message || 'Failed to load data');\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    loadData();\n  }, [timeRange, utilities.rv, getDateRange]);\n  \n  // Aggregate data by time period\n  const aggregateData = useCallback((data, dateField, grouping) => {\n    console.log(`[AIPerformanceDashboard] Aggregating ${data.length} records by ${grouping}`);\n    \n    const grouped = {};\n    \n    data.forEach(item => {\n      const date = new Date(item[dateField]);\n      let key;\n      \n      switch(grouping) {\n        case 'day':\n          key = date.toISOString().split('T')[0];\n          break;\n        case 'week':\n          const weekStart = new Date(date);\n          weekStart.setDate(date.getDate() - date.getDay());\n          key = weekStart.toISOString().split('T')[0];\n          break;\n        case 'month':\n          key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n          break;\n        case 'quarter':\n          const quarter = Math.floor(date.getMonth() / 3) + 1;\n          key = `${date.getFullYear()}-Q${quarter}`;\n          break;\n        default:\n          key = date.toISOString().split('T')[0];\n      }\n      \n      if (!grouped[key]) {\n        grouped[key] = {\n          date: key,\n          runs: 0,\n          tokens: 0,\n          cost: 0,\n          items: []\n        };\n      }\n      \n      grouped[key].runs++;\n      grouped[key].tokens += (item.TotalTokensUsed || item.TokensUsed || 0);\n      grouped[key].cost += (item.TotalCost || 0);\n      grouped[key].items.push(item);\n    });\n    \n    const result = Object.values(grouped).sort((a, b) => a.date.localeCompare(b.date));\n    console.log(`[AIPerformanceDashboard] Aggregated into ${result.length} groups`);\n    return result;\n  }, []);\n  \n  // Get aggregated data for current view\n  const chartData = useMemo(() => {\n    const data = activeTab === 'agents' ? agentRuns : promptRuns;\n    const dateField = activeTab === 'agents' ? 'StartedAt' : 'RunAt';\n    return aggregateData(data, dateField, groupBy);\n  }, [activeTab, agentRuns, promptRuns, groupBy, aggregateData]);\n  \n  // Handle drill-down\n  const handleChartClick = useCallback((dataPoint) => {\n    console.log('[AIPerformanceDashboard] Chart clicked:', dataPoint);\n    setSelectedPoint(dataPoint);\n  }, []);\n  \n  // Handle time range change\n  const handleTimeRangeChange = useCallback((range) => {\n    console.log('[AIPerformanceDashboard] Time range changed to:', range);\n    setTimeRange(range);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      timeRange: range\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Handle grouping change\n  const handleGroupByChange = useCallback((grouping) => {\n    console.log('[AIPerformanceDashboard] Grouping changed to:', grouping);\n    setGroupBy(grouping);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      groupBy: grouping\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Handle tab change\n  const handleTabChange = useCallback((tab) => {\n    console.log('[AIPerformanceDashboard] Tab changed to:', tab);\n    setActiveTab(tab);\n    setSelectedPoint(null);\n    onSaveUserSettings?.({\n      ...savedUserSettings,\n      activeTab: tab\n    });\n  }, [savedUserSettings, onSaveUserSettings]);\n  \n  // Calculate summary metrics\n  const metrics = useMemo(() => {\n    const data = activeTab === 'agents' ? agentRuns : promptRuns;\n    return {\n      totalRuns: data.length,\n      totalTokens: data.reduce((sum, item) => sum + (item.TotalTokensUsed || item.TokensUsed || 0), 0),\n      totalCost: data.reduce((sum, item) => sum + (item.TotalCost || 0), 0),\n      avgTokensPerRun: data.length > 0 ? Math.round(data.reduce((sum, item) => sum + (item.TotalTokensUsed || item.TokensUsed || 0), 0) / data.length) : 0,\n      avgCostPerRun: data.length > 0 ? data.reduce((sum, item) => sum + (item.TotalCost || 0), 0) / data.length : 0\n    };\n  }, [activeTab, agentRuns, promptRuns]);\n  \n  console.log('[AIPerformanceDashboard] Current state:', {\n    timeRange,\n    groupBy,\n    activeTab,\n    agentRunsCount: agentRuns.length,\n    promptRunsCount: promptRuns.length,\n    chartDataPoints: chartData.length,\n    selectedPoint: selectedPoint?.date\n  });\n  \n  if (loading) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100%',\n        color: styles.colors.textSecondary\n      }}>\n        Loading performance data...\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100%',\n        color: styles.colors.error\n      }}>\n        Error: {error}\n      </div>\n    );\n  }\n  \n  return (\n    <div style={{\n      height: '100%',\n      display: 'flex',\n      flexDirection: 'column',\n      backgroundColor: styles.colors.background,\n      padding: styles.spacing.md\n    }}>\n      {/* Header Controls */}\n      <div style={{\n        display: 'flex',\n        justifyContent: 'space-between',\n        alignItems: 'center',\n        marginBottom: styles.spacing.lg,\n        flexWrap: 'wrap',\n        gap: styles.spacing.md\n      }}>\n        {/* Tab Selector */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.xs,\n          backgroundColor: styles.colors.surface,\n          padding: styles.spacing.xs,\n          borderRadius: styles.borders?.radius || '4px'\n        }}>\n          <button\n            onClick={() => handleTabChange('agents')}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: activeTab === 'agents' ? styles.colors.primary : 'transparent',\n              color: activeTab === 'agents' ? 'white' : styles.colors.text,\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: 'pointer',\n              fontWeight: activeTab === 'agents' ? '600' : '400'\n            }}\n          >\n            Agent Runs\n          </button>\n          <button\n            onClick={() => handleTabChange('prompts')}\n            style={{\n              padding: `${styles.spacing.sm} ${styles.spacing.md}`,\n              backgroundColor: activeTab === 'prompts' ? styles.colors.primary : 'transparent',\n              color: activeTab === 'prompts' ? 'white' : styles.colors.text,\n              border: 'none',\n              borderRadius: styles.borders?.radius || '4px',\n              cursor: 'pointer',\n              fontWeight: activeTab === 'prompts' ? '600' : '400'\n            }}\n          >\n            Prompt Runs\n          </button>\n        </div>\n        \n        {/* Time Controls */}\n        <div style={{\n          display: 'flex',\n          gap: styles.spacing.md,\n          alignItems: 'center'\n        }}>\n          {/* Time Range */}\n          <select\n            value={timeRange}\n            onChange={(e) => handleTimeRangeChange(e.target.value)}\n            style={{\n              padding: styles.spacing.sm,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.surface,\n              color: styles.colors.text\n            }}\n          >\n            <option value=\"7d\">Last 7 Days</option>\n            <option value=\"30d\">Last 30 Days</option>\n            <option value=\"90d\">Last 90 Days</option>\n            <option value=\"1y\">Last Year</option>\n          </select>\n          \n          {/* Group By */}\n          <select\n            value={groupBy}\n            onChange={(e) => handleGroupByChange(e.target.value)}\n            style={{\n              padding: styles.spacing.sm,\n              border: `1px solid ${styles.colors.border}`,\n              borderRadius: styles.borders?.radius || '4px',\n              backgroundColor: styles.colors.surface,\n              color: styles.colors.text\n            }}\n          >\n            <option value=\"day\">By Day</option>\n            <option value=\"week\">By Week</option>\n            <option value=\"month\">By Month</option>\n            <option value=\"quarter\">By Quarter</option>\n          </select>\n        </div>\n      </div>\n      \n      {/* Metrics Summary */}\n      <AIMetricsSummary\n        metrics={metrics}\n        styles={styles}\n        utilities={utilities}\n        components={components}\n        callbacks={callbacks}\n        savedUserSettings={savedUserSettings?.metricsSummary}\n        onSaveUserSettings={(settings) => onSaveUserSettings?.({\n          ...savedUserSettings,\n          metricsSummary: settings\n        })}\n      />\n      \n      {/* Main Chart Area */}\n      <div style={{\n        flex: 1,\n        display: 'flex',\n        flexDirection: 'column',\n        gap: styles.spacing.lg,\n        minHeight: 0\n      }}>\n        {/* Time Series Chart */}\n        <div style={{\n          flex: selectedPoint ? '0 0 400px' : '1',\n          minHeight: '300px'\n        }}>\n          <AITimeSeriesChart\n            data={chartData}\n            groupBy={groupBy}\n            activeTab={activeTab}\n            selectedPoint={selectedPoint}\n            onPointClick={handleChartClick}\n            styles={styles}\n            utilities={utilities}\n            components={components}\n            callbacks={callbacks}\n            savedUserSettings={savedUserSettings?.timeSeriesChart}\n            onSaveUserSettings={(settings) => onSaveUserSettings?.({\n              ...savedUserSettings,\n              timeSeriesChart: settings\n            })}\n          />\n        </div>\n        \n        {/* Drill-down Area */}\n        {selectedPoint && (\n          <div style={{\n            flex: 1,\n            display: 'flex',\n            gap: styles.spacing.md,\n            minHeight: 0\n          }}>\n            {/* Distribution Chart */}\n            <div style={{ flex: '0 0 400px' }}>\n              <AIDistributionChart\n                data={selectedPoint.items}\n                activeTab={activeTab}\n                groupBy={groupBy}\n                styles={styles}\n                utilities={utilities}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings?.distributionChart}\n                onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                  ...savedUserSettings,\n                  distributionChart: settings\n                })}\n              />\n            </div>\n            \n            {/* Detail Table */}\n            <div style={{ flex: 1, overflow: 'auto' }}>\n              <AIDetailTable\n                data={selectedPoint.items}\n                activeTab={activeTab}\n                styles={styles}\n                utilities={utilities}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings?.detailTable}\n                onSaveUserSettings={(settings) => onSaveUserSettings?.({\n                  ...savedUserSettings,\n                  detailTable: settings\n                })}\n              />\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}",
  "dependencies": [
    "@include:ai-time-series-chart.spec.json",
    "@include:ai-distribution-chart.spec.json",
    "@include:ai-detail-table.spec.json",
    "@include:ai-metrics-summary.spec.json"
  ],
  "libraries": []
}