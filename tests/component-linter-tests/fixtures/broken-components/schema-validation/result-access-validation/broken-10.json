{
  "title": "Active Members by Membership Type",
  "type": "chart",
  "name": "MembershipTypeChart",
  "userExplanation": "A concise visual showing the count of active members per membership type. Click any segment to view a detailed list of members in that category.",
  "functionalRequirements": "- Render an interactive chart (bar or pie) displaying the number of **active** members per membership type (using the Membership Type name).\n- Each chart segment is clickable; clicking opens a list view showing the members of that type. The list view displays each member’s first name, last name, email, and join date (status is implicitly active and thus not shown).\n- The data source includes only members whose membership record has a status of **Active**.\n- The chart should automatically refresh when membership data changes.\n- The list view should be sortable (e.g., by last name, join date) and searchable.\n- Provide an optional filter to limit the view by a join‑date range.",
  "dataRequirements": {
    "mode": "queries",
    "description": "Data for active members chart with drill‑down list of members per membership type.",
    "entities": [
      {
        "name": "Members",
        "description": "Individual members of the association",
        "displayFields": [
          "ID",
          "FirstName",
          "LastName",
          "Email",
          "JoinDate",
          "Organization",
          "City",
          "State",
          "Country"
        ],
        "filterFields": [
          "City",
          "State",
          "Country",
          "Organization"
        ],
        "sortFields": [
          "LastName",
          "FirstName"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "sequence": 1,
            "defaultInView": false,
            "type": "uniqueidentifier",
            "allowsNull": false,
            "isPrimaryKey": true,
            "description": null
          },
          {
            "name": "FirstName",
            "sequence": 3,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Member first name"
          },
          {
            "name": "LastName",
            "sequence": 4,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Member last name"
          },
          {
            "name": "Email",
            "sequence": 2,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Primary email address (unique)",
            "extendedType": "Email"
          },
          {
            "name": "JoinDate",
            "sequence": 10,
            "defaultInView": true,
            "type": "date",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Date member joined the association"
          },
          {
            "name": "Organization",
            "sequence": 26,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": true,
            "isPrimaryKey": false,
            "description": null
          },
          {
            "name": "City",
            "sequence": 17,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": true,
            "isPrimaryKey": false,
            "description": null
          },
          {
            "name": "State",
            "sequence": 18,
            "defaultInView": false,
            "type": "nvarchar",
            "allowsNull": true,
            "isPrimaryKey": false,
            "description": null
          },
          {
            "name": "Country",
            "sequence": 19,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": true,
            "isPrimaryKey": false,
            "description": null
          }
        ],
        "usageContext": "Drill‑down list of active members for a selected membership type",
        "permissionLevelNeeded": [
          "read"
        ]
      },
      {
        "name": "Membership Types",
        "description": "Types of memberships offered by the association",
        "displayFields": [
          "ID",
          "Name",
          "AnnualDues",
          "IsActive"
        ],
        "filterFields": [
          "IsActive"
        ],
        "sortFields": [
          "DisplayOrder",
          "Name"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "sequence": 1,
            "defaultInView": false,
            "type": "uniqueidentifier",
            "allowsNull": false,
            "isPrimaryKey": true,
            "description": null
          },
          {
            "name": "Name",
            "sequence": 2,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Name of membership type (e.g., Individual, Corporate, Student)"
          },
          {
            "name": "AnnualDues",
            "sequence": 4,
            "defaultInView": true,
            "type": "decimal",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Annual membership dues amount"
          },
          {
            "name": "IsActive",
            "sequence": 6,
            "defaultInView": true,
            "type": "bit",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": null
          }
        ],
        "usageContext": "Lookup for membership type names in queries and UI",
        "permissionLevelNeeded": [
          "read"
        ]
      },
      {
        "name": "Memberships",
        "description": "Membership records tracking member subscriptions and renewals",
        "displayFields": [
          "ID",
          "MemberID",
          "MembershipTypeID",
          "Status",
          "StartDate",
          "EndDate",
          "AutoRenew",
          "MembershipType"
        ],
        "filterFields": [
          "Status",
          "MembershipTypeID",
          "AutoRenew"
        ],
        "sortFields": [
          "StartDate"
        ],
        "fieldMetadata": [
          {
            "name": "ID",
            "sequence": 1,
            "defaultInView": false,
            "type": "uniqueidentifier",
            "allowsNull": false,
            "isPrimaryKey": true,
            "description": null
          },
          {
            "name": "MemberID",
            "sequence": 2,
            "defaultInView": false,
            "type": "uniqueidentifier",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Member who holds this membership"
          },
          {
            "name": "MembershipTypeID",
            "sequence": 3,
            "defaultInView": false,
            "type": "uniqueidentifier",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Type of membership"
          },
          {
            "name": "Status",
            "sequence": 4,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Current status: Active, Pending, Lapsed, Suspended, or Cancelled",
            "possibleValues": [
              {
                "value": "Active",
                "displayValue": "Active"
              },
              {
                "value": "Suspended",
                "displayValue": "Suspended"
              },
              {
                "value": "Pending",
                "displayValue": "Pending"
              },
              {
                "value": "Cancelled",
                "displayValue": "Cancelled"
              },
              {
                "value": "Lapsed",
                "displayValue": "Lapsed"
              }
            ]
          },
          {
            "name": "StartDate",
            "sequence": 5,
            "defaultInView": true,
            "type": "date",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Membership start date"
          },
          {
            "name": "EndDate",
            "sequence": 6,
            "defaultInView": true,
            "type": "date",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Membership end/expiration date"
          },
          {
            "name": "AutoRenew",
            "sequence": 8,
            "defaultInView": true,
            "type": "bit",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Whether membership will automatically renew"
          },
          {
            "name": "MembershipType",
            "sequence": 13,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": null
          }
        ],
        "usageContext": "Filtering active memberships for chart aggregation",
        "permissionLevelNeeded": [
          "read"
        ]
      }
    ],
    "queries": [
      {
        "name": "ActiveMemberCountByMembershipType",
        "categoryPath": "Skip/Reporting/Membership",
        "description": "Counts of active members per membership type for the chart.",
        "fields": [
          {
            "name": "MembershipType",
            "sequence": 1,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Membership type name"
          },
          {
            "name": "ActiveMemberCount",
            "sequence": 2,
            "defaultInView": true,
            "type": "int",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Number of active members for this type"
          }
        ],
        "entityNames": [
          "Memberships",
          "Membership Types",
          "Members"
        ],
        "parameters": [
          {
            "name": "Status",
            "value": "@runtime",
            "testValue": "Active",
            "description": "The membership status to count (e.g., 'Active', 'Pending')."
          },
          {
            "name": "IncludeInactiveTypes",
            "value": "@runtime",
            "testValue": "0",
            "description": "Set to 1 to include membership types that are marked as inactive; 0 (default) excludes them."
          }
        ],
        "newQuerySQL": "SELECT\n    mt.[Name] AS MembershipType,\n    COUNT(DISTINCT m.[MemberID]) AS ActiveMemberCount\nFROM [AssociationDemo].[vwMemberships] m\nJOIN [AssociationDemo].[vwMembershipTypes] mt\n    ON m.[MembershipTypeID] = mt.[ID]\nWHERE m.[Status] = {{ Status | sqlString }}\n{% if IncludeInactiveTypes != 1 %}\n    AND mt.[IsActive] = 1\n{% endif %}\nGROUP BY mt.[Name], mt.[DisplayOrder]\nORDER BY mt.[DisplayOrder], mt.[Name];"
      },
      {
        "name": "ActiveMembersByMembershipType",
        "categoryPath": "Skip/Reporting/Membership",
        "description": "List of active members for a selected membership type (used for drill‑down).",
        "fields": [
          {
            "name": "MemberID",
            "sequence": 1,
            "defaultInView": true,
            "type": "uniqueidentifier",
            "allowsNull": false,
            "isPrimaryKey": true,
            "description": "Member ID"
          },
          {
            "name": "FirstName",
            "sequence": 2,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "First name"
          },
          {
            "name": "LastName",
            "sequence": 3,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Last name"
          },
          {
            "name": "Email",
            "sequence": 4,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Primary email address"
          },
          {
            "name": "JoinDate",
            "sequence": 5,
            "defaultInView": true,
            "type": "date",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Date member joined"
          },
          {
            "name": "MembershipType",
            "sequence": 6,
            "defaultInView": true,
            "type": "nvarchar",
            "allowsNull": false,
            "isPrimaryKey": false,
            "description": "Membership type name"
          }
        ],
        "entityNames": [
          "Members",
          "Memberships",
          "Membership Types"
        ],
        "parameters": [
          {
            "name": "MembershipTypeID",
            "value": "@runtime",
            "testValue": "0A04020D-1AA1-495C-8D90-26784F4A5830",
            "description": "Unique identifier of the membership type to filter the active members. Provide a GUID value (e.g., 0A04020D-1AA1-495C-8D90-26784F4A5830)."
          }
        ],
        "newQuerySQL": "SELECT\n    m.ID AS MemberID,\n    m.FirstName,\n    m.LastName,\n    m.Email,\n    m.JoinDate,\n    mt.Name AS MembershipType\nFROM [AssociationDemo].[vwMembers] AS m\nINNER JOIN [AssociationDemo].[vwMemberships] AS ms ON m.ID = ms.MemberID\nINNER JOIN [AssociationDemo].[vwMembershipTypes] AS mt ON ms.MembershipTypeID = mt.ID\nWHERE ms.Status = 'Active'\n  AND mt.ID = {{ MembershipTypeID | sqlString }};"
      }
    ]
  },
  "description": "An interactive chart that displays the count of active members per membership type. Clicking a chart segment opens a searchable, sortable list of the members for that type.",
  "location": "embedded",
  "technicalDesign": "## Component Architecture\n- **Root Component (MembershipTypeChart)**: Embedded component that orchestrates data fetching and renders a drill‑down chart.\n- **Dependency**: `SimpleDrilldownChart` (registry) provides the chart‑to‑table UI. It internally uses Chart.js for visualization and Ant Design Table for the detail list.\n- **Data Flow**:\n  1. On mount the component runs the `ActiveMemberCountByMembershipType` query (parameters: `Status='Active'`, `IncludeInactiveTypes=0`).\n  2. The result populates the chart series (membership type name → active member count).\n  3. When a user clicks a chart segment, `SimpleDrilldownChart` automatically invokes the `ActiveMembersByMembershipType` query with the clicked `MembershipTypeID` (passed via the component's `onDrilldown` event).\n  4. The table below the chart displays member details (FirstName, LastName, Email, JoinDate). The table supports sorting, searching, and pagination out‑of‑the‑box via Ant Design Table.\n- **Props** (passed to `SimpleDrilldownChart`):\n  - `chartQuery`: definition of the chart data query (name, parameters).\n  - `detailQuery`: definition of the drill‑down table query.\n  - `onDrilldown`: event emitted when a segment is selected, providing the `MembershipTypeID`.\n- **State Management**: All UI state (selected segment, table pagination, filters) is managed internally by `SimpleDrilldownChart` using React `useState`. The root component only supplies query definitions and listens to the `onDrilldown` event for any external side‑effects (e.g., analytics).\n- **Refresh Logic**: The component subscribes to a global `utilities.refresh` signal. When triggered, it re‑executes the chart query to reflect any data changes.\n- **Libraries**: Chart.js for rendering the chart, Ant Design for the table and general UI styling.\n- **Readiness Level**: beta (fully functional, awaiting extensive UI testing).\n- **Example Usage**: `<MembershipTypeChart />`\n\n## Dependency – SimpleDrilldownChart (registry)\n- **Location**: registry\n- **Namespace**: Generic/UI/Chart\n- **Selection Reasoning**: Provides the exact two‑level drill‑down behavior required (chart segment click → detailed table) without needing custom implementation. Handles sorting, searching, and pagination internally.\n- **Functional Requirements**: Render a chart based on supplied data, emit `onDrilldown` with the selected entity identifier, and display a data grid for the drill‑down records.\n- **Technical Design**: Uses Chart.js for the chart and Ant Design Table for the grid. Accepts `chartQuery` and `detailQuery` props, and an `onDrilldown` callback.\n- **Example Usage**: `<SimpleDrilldownChart chartQuery={...} detailQuery={...} onDrilldown={(typeId) => console.log(typeId)} />`",
  "libraries": [
    {
      "name": "chart.js",
      "globalVariable": "Chart",
      "version": "^4.4.1"
    }
  ],
  "dependencies": [
    {
      "name": "SimpleDrilldownChart",
      "title": "Simple Drilldown Chart",
      "description": "FIXED TWO-LEVEL DRILL-DOWN ONLY: Chart-to-table component with HARDCODED vertical layout. Shows chart at top, data grid at bottom when clicking segments. ONLY USE for simple 'click chart to see matching records in table' scenarios. DO NOT USE for: multi-level drill-downs (chart→chart→table or 3+ levels), nested visualizations, progressive dimension drill-downs (Industry→Region→Accounts), or when user asks for 'sub-charts'. This component CANNOT support custom drill hierarchies - must create custom component for complex multi-level patterns. Example that requires custom component: 'Accounts by Industry, click to see chart by Region, click to see table of accounts' (3 levels).",
      "type": "chart",
      "location": "embedded",
      "functionalRequirements": "WHEN TO USE: Two-level 'click-chart-see-table' pattern only; Single aggregation dimension showing detail records; User wants 'show X by Y, click to see records'; Simple drill-down to tabular details; Works with entity data or aggregated/joined results. Example: 'Revenue by Product Category - click to see line items'. WHEN NOT TO USE: Multi-level drill-downs with 3+ levels (chart→chart→table or deeper); User requests 'sub-chart' or 'nested chart' or 'drill into another chart'; Progressive multi-dimensional drill-downs like 'by Industry then by Region then table'; Custom visualization at any drill-down level; Any scenario requiring chart-to-chart transitions. CORE FEATURES: Composes SimpleChart + DataGrid + optional SingleRecordView; Click chart segment → shows filtered records in grid below; Split-view vertical layout: chart (top), info bar (middle), grid (bottom); Info bar displays: segment label, aggregated value, record count, percentage of total; Clear selection button returns to chart-only view; Auto-detects grid columns from data or uses gridFields prop to specify columns; Works with or without entityName (entityName enables metadata formatting and OpenEntityRecord/SingleRecordView features); Optional OpenEntityRecord integration via entityPrimaryKeys prop: when entityName and entityPrimaryKeys provided and showSingleRecordView=false, clicking grid row opens entity record form; Optional 3-column layout with showSingleRecordView=true (requires entityName): chart spans full width at top, grid (60% width) and SingleRecordView (40% width) side-by-side below; Smooth CSS animations for expand/collapse; Blue border highlights chart when segment selected; Inherits all SimpleChart aggregation capabilities (count/sum/average/min/max) and chart types (bar/line/pie/doughnut/area). LAYOUT MODES: 2-column (default, showSingleRecordView=false): vertical stack with chart, info bar, grid with optional OpenEntityRecord on row click; 3-column (showSingleRecordView=true, requires entityName): chart at top full width, then grid 60% left and SingleRecordView 40% right. ARCHITECTURAL LIMITATION: This is a FIXED two-level pattern. It cannot be extended to support dynamic levels, chart-to-chart navigation, or custom hierarchies beyond chart→table.",
      "technicalDesign": "CRITICAL ARCHITECTURAL CONSTRAINT: HARDCODED two-level vertical structure (chart → table). Cannot support: chart-to-chart transitions, dynamic level insertion, custom hierarchy depths, multiple chart children, or any drill pattern beyond the fixed layout. Implementation: React functional component using three useState hooks: selectedSegment (stores {label, value, records: Array<object>, percentage}), showGrid (boolean to control grid visibility), selectedRecord (for optional SingleRecordView panel). Three-component composition: (1) SimpleChart at top receives full data prop and optional entityName for client-side aggregation and rendering, handles onDataPointClick event; (2) DataGrid in middle/left receives segment.records filtered array, optional entityName, and optional entityPrimaryKeys, displays in table with sorting/filtering/paging; (3) Optional SingleRecordView in right panel (when showSingleRecordView=true and entityName provided) displays selected grid row details. State flow: Initial state (chart only, showGrid=false) → User clicks chart segment → handleChartClick fires → Set selectedSegment with click data + showGrid=true → Grid renders with segment.records filtered data + info bar appears between chart and grid → Optional: user clicks grid row → handleRowClick fires → Set selectedRecord → SingleRecordView renders in side panel (if enabled). Info bar renders between chart and grid when selectedSegment exists, displays segment.label, segment.value (formatted with toLocaleString), segment.records.length, segment.percentage (if available). Clear selection button in info bar calls handleClearSelection → resets selectedSegment=null, showGrid=false, selectedRecord=null. Grid columns: If gridFields prop provided, uses those field names; Else auto-detects from first record in segment.records, filters out __mj system fields and ID field and object types, limits to first 10 fields. DataGrid integration: Passes data, optional entityName, optional entityPrimaryKeys props to DataGrid; entityName optional allows working with aggregated/joined data without entity metadata; When entityName provided: enables metadata formatting; When showSingleRecordView=false and entityName+entityPrimaryKeys provided, DataGrid handles OpenEntityRecord automatically on row click (no custom onRowClick needed); When showSingleRecordView=true and entityName provided, onRowClick=handleRowClick to populate SingleRecordView panel (entityPrimaryKeys ignored for grid, OpenEntityRecord must be manual from SingleRecordView). Layout styling: Chart wrapped in div with conditional blue 2px border when selectedSegment exists; Info bar has light blue background (#f0f5ff) with 4px left border (#1890ff); Grid wrapped in div with drilldownHeight prop (default 300px), border, overflow:auto; When showSingleRecordView=true, grid and SingleRecordView containers use flex layout (60%/40% split); CSS @keyframes slideDown and slideIn animations for smooth transitions. Data flow: Input data array never mutates, only filtered views (segment.records) passed to DataGrid. Event emission: segmentSelected event fires with {segment} wrapper when segment clicked; selectionCleared fires when clear button clicked; dataPointClick bubbles up from SimpleChart; rowSelected fires with {record, segment} when grid row clicked. Dependency injection: Receives SimpleChart, DataGrid, SingleRecordView from components registry; Shows error message if DataGrid not found; Passes utilities, styles, components, callbacks, savedUserSettings down to all child components. For multi-level drill-downs or custom hierarchies, this component is ARCHITECTURALLY UNSUITABLE - developer must create custom component with multiple SimpleChart instances, custom state management, and navigation logic for chart-to-chart drill flow.",
      "dataRequirements": {
        "mode": "props",
        "description": "Receives data through props, uses it for both chart and drill-down"
      },
      "properties": [
        {
          "name": "data",
          "type": "Array<object>",
          "description": "Array of records to visualize. Can be from any source: single entity, joined tables, or aggregated results.",
          "required": true
        },
        {
          "name": "groupBy",
          "type": "string",
          "description": "Field name to group data by",
          "required": true
        },
        {
          "name": "entityName",
          "type": "string",
          "description": "Optional entity name for metadata lookup (enables smart formatting in chart and grid) and OpenEntityRecord integration. Required if using entityPrimaryKeys or showSingleRecordView. If omitted, component works with basic type detection for aggregated/joined data.",
          "required": false
        },
        {
          "name": "entityPrimaryKeys",
          "type": "Array<string>",
          "description": "Array of field names that constitute the primary key(s) for opening entity records when drill-down grid rows are clicked. When provided (and showSingleRecordView is false), clicking a row in the drill-down grid will open the entity record using OpenEntityRecord. Example: ['ID'] for single key, ['OrderID', 'LineNumber'] for composite key. If showSingleRecordView is true, this is ignored and SingleRecordView displays instead.",
          "required": false,
          "exampleValue": "[\"ID\"]"
        },
        {
          "name": "valueField",
          "type": "string",
          "description": "Field to aggregate for values",
          "required": false
        },
        {
          "name": "aggregateMethod",
          "type": "'count' | 'sum' | 'average' | 'min' | 'max'",
          "description": "How to aggregate values",
          "required": false,
          "defaultValue": "count"
        },
        {
          "name": "chartType",
          "type": "'auto' | 'bar' | 'line' | 'pie' | 'doughnut' | 'area'",
          "description": "Chart type to render",
          "required": false,
          "defaultValue": "auto"
        },
        {
          "name": "title",
          "type": "string",
          "description": "Chart title",
          "required": false
        },
        {
          "name": "gridFields",
          "type": "Array<string>",
          "description": "Fields to show in drill-down grid",
          "required": false
        },
        {
          "name": "showDrilldown",
          "type": "boolean",
          "description": "Whether to enable drill-down functionality",
          "required": false,
          "defaultValue": true
        },
        {
          "name": "drilldownHeight",
          "type": "number",
          "description": "Height of drill-down panel in pixels",
          "required": false,
          "defaultValue": 300
        },
        {
          "name": "showSingleRecordView",
          "type": "boolean",
          "description": "Whether to show SingleRecordView when a row is selected in the grid",
          "required": false,
          "defaultValue": false
        },
        {
          "name": "singleRecordViewFields",
          "type": "Array<string>",
          "description": "Fields to display in the SingleRecordView",
          "required": false
        }
      ],
      "events": [
        {
          "name": "segmentSelected",
          "description": "Fired when a chart segment is selected",
          "parameters": [
            {
              "name": "segment",
              "type": "{ segment: { label: string; value: number; records: Array<object>; percentage?: number } }",
              "description": "Selected segment info including label, value, and records"
            }
          ]
        },
        {
          "name": "selectionCleared",
          "description": "Fired when selection is cleared",
          "parameters": []
        },
        {
          "name": "dataPointClick",
          "description": "Bubbled event from chart when any data point is clicked",
          "parameters": [
            {
              "name": "clickData",
              "type": "{ seriesName: string; value: number; label: string; records: Array<object>; chartType: string; percentage?: number }",
              "description": "Click data from the chart including label, value, and records"
            }
          ]
        },
        {
          "name": "rowSelected",
          "description": "Fired when a row is selected in the drill-down grid",
          "parameters": [
            {
              "name": "selectionData",
              "type": "{ record: object; segment: { label: string; value: number; records: Array<object> } }",
              "description": "Object containing selected record and current segment context"
            }
          ]
        }
      ],
      "dependencies": [
        {
          "name": "SimpleChart",
          "title": "Simple Chart",
          "description": "Standalone single-level chart component with NO built-in drill-down functionality. Renders bar/line/pie/doughnut/area/scatter charts using Chart.js 4.4.1. Emits onClick events but doesn't handle navigation - parent component must wire up drill-down logic. USE for: standalone visualizations, dashboard widgets, building blocks in custom multi-level drill-downs. DO NOT USE when user explicitly wants 'drill-down to table' (use SimpleDrilldownChart instead). Auto-aggregates data client-side by groupBy field with count/sum/average/min/max methods. Smart auto-type selection: date fields→line, ≤5 categories→doughnut, else→bar. Formats values automatically: currency ($ for Amount fields), dates (locale format), numbers (commas). Exports as PNG image. Click events return {label, value, records: Array<object>, percentage} for parent to implement custom drill logic.",
          "type": "chart",
          "location": "embedded",
          "functionalRequirements": "WHEN TO USE: Standalone chart without any drill-down behavior; Building custom multi-level drill-downs where you compose multiple SimpleChart instances with custom navigation logic; Dashboard widgets that are view-only; Charts needing custom onClick handling in parent component; Chart as reusable building block in larger component. WHEN NOT TO USE: User explicitly asks for 'drill-down to table' (use SimpleDrilldownChart which has built-in drill behavior); User wants automatic drill behavior without writing custom code; Need built-in two-level chart-to-table pattern. CORE FEATURES: Zero-configuration charting with smart defaults; Chart types: bar, line, pie, doughnut, area, scatter; Auto chart-type selection based on data characteristics and field types; Client-side data aggregation: groups records by specified field, aggregates using method (count/sum/average/min/max); Smart value formatting: currencies (detects Amount fields or money type, formats as $USD), dates (toLocaleDateString with month/day/year), numbers (Intl.NumberFormat with commas); Click events emit full context {chartType, seriesName, label, value, records: Array<object>, percentage} - parent must handle for drill-down; Responsive canvas that resizes with container; Export chart as PNG image with button overlay (enableExport prop); Top-N limiting with limit prop (e.g., top 10 categories); Custom color palettes via colors prop; Configurable legend: position (auto/top/bottom/left/right), fontSize, show/hide; Optional data labels on chart (showDataLabels prop); Loading state when data processing; Empty state with gray background when no data; Metadata-aware: loads entity info for field type detection. AUTO TYPE SELECTION LOGIC: If groupBy field is date/datetime type (from metadata or value detection) → line chart; If ≤5 categories after aggregation → doughnut chart; Else → bar chart (default). AGGREGATION METHODS: count (default, counts records per group); sum (sums valueField for each group); average (averages valueField); min (minimum valueField); max (maximum valueField). SORTING: sortBy='value'|'label'|'none' (default 'value'), sortOrder='asc'|'desc' (default 'desc'). For drill-down functionality, parent component must: (1) Pass onDataPointClick event handler, (2) Receive clickData containing records array and segment info, (3) Implement custom navigation/state logic (show DataGrid, navigate to detail page, render child SimpleChart with filtered data, etc.).",
          "technicalDesign": "NO built-in drill-down - emits click events only, parent must handle navigation. Uses Chart.js 4.4.1 canvas rendering via unwrapLibraryComponents(Chart, 'Chart') to handle various package formats. React hooks: useRef for canvasRef and chartInstanceRef, useState for error and entityInfo, useMemo for processData pipeline, useEffect for chart rendering and export setup. Processing pipeline (useMemo): (1) Validate groupBy and valueField exist in data[0], throw error if missing with available fields list; (2) Group records by groupBy field value (special date handling: if date field detected, format as YYYY-MM-DD ISO for consistent grouping); (3) Aggregate each group based on aggregateMethod: count→records.length, sum/avg/min/max→apply to valueField numeric values; (4) Convert grouped object to array; (5) Sort by label or value based on sortBy/sortOrder props; (6) Apply limit for top-N filtering if specified; (7) Extract categories (labels array) and values (numbers array) for Chart.js datasets. Auto chart type determination: Check if groupBy is date field (entity metadata Type=datetime/date OR value is Date instance OR string parseable as date) → line chart; Check if ≤5 categories → doughnut chart; Else → bar chart (default). Maps 'donut' → 'doughnut', 'column' → 'bar' for Chart.js compatibility. Chart.js config object: type (bar/line/pie/doughnut/area/scatter, area uses line with fill:true), datasets with label (valueField or 'Count'), data (values array), backgroundColor/borderColor from colors prop or default 10-color palette, borderWidth, fill and tension for line/area; options with responsive:true, maintainAspectRatio:false, onClick handler (extracts clicked index, finds chartData[index], calls onDataPointClick with full segment), plugins for title/legend/datalabels/tooltip, scales for non-pie charts (y-axis with formatValue callback, x-axis with label rotation). Value formatting function: null→'N/A', dates→toLocaleDateString(month short/day/year), currency (isCurrency flag OR valueField includes 'amount')→Intl.NumberFormat USD style, numbers→Intl.NumberFormat with commas. useEffect for chart rendering: Checks processData.isEmpty and canvasRef.current; Validates Chart.js loaded, sets error if not; Destroys existing chartInstanceRef if exists; Gets 2d context from canvas; Creates new Chart.js instance with config; Fires onChartRendered event with {chartType, dataPointCount, aggregateMethod, totalValue}; Cleanup destroys chart on unmount. Export functionality (useEffect): If enableExport, stores handler in window.SimpleChartExport, uses canvas.toDataURL('image/png') for download, button positioned absolute top-right with z-index:10. Metadata loading (useEffect): Finds entity in utilities.md.Entities array, stores in entityInfo state for field type access. Error state: Returns red error div with height prop, shows error message. Empty state: Returns gray background div with 'No data available' centered. Component returns: Wrapper div with optional export button (absolute positioned), inner div with height prop containing canvas element. For drill-down, parent receives dataPointClick event with records array and must implement logic - SimpleChart does NOT navigate or show child components itself.",
          "dataRequirements": {
            "mode": "props",
            "description": "Component receives entity data through props and performs client-side aggregation"
          },
          "properties": [
            {
              "name": "entityName",
              "type": "string",
              "description": "Name of the entity being visualized",
              "required": true
            },
            {
              "name": "data",
              "type": "Array<object>",
              "description": "Array of entity objects to visualize",
              "required": true
            },
            {
              "name": "groupBy",
              "type": "string",
              "description": "Field name to group data by",
              "required": true
            },
            {
              "name": "valueField",
              "type": "string",
              "description": "Field to aggregate for values. If not specified, counts records",
              "required": false
            },
            {
              "name": "aggregateMethod",
              "type": "'count' | 'sum' | 'average' | 'min' | 'max'",
              "description": "How to aggregate values",
              "required": false,
              "defaultValue": "count",
              "possibleValues": [
                "count",
                "sum",
                "average",
                "min",
                "max"
              ]
            },
            {
              "name": "chartType",
              "type": "'auto' | 'bar' | 'line' | 'pie' | 'doughnut' | 'area' | 'scatter'",
              "description": "Chart type to render. 'auto' selects based on data",
              "required": false,
              "defaultValue": "auto",
              "possibleValues": [
                "auto",
                "bar",
                "line",
                "pie",
                "doughnut",
                "area",
                "scatter"
              ]
            },
            {
              "name": "title",
              "type": "string",
              "description": "Chart title. If not provided, generates from entity and groupBy field",
              "required": false
            },
            {
              "name": "height",
              "type": "number",
              "description": "Chart height in pixels",
              "required": false,
              "defaultValue": 400
            },
            {
              "name": "sortBy",
              "type": "'label' | 'value' | 'none'",
              "description": "How to sort the chart data",
              "required": false,
              "defaultValue": "value",
              "possibleValues": [
                "label",
                "value",
                "none"
              ]
            },
            {
              "name": "sortOrder",
              "type": "'asc' | 'desc'",
              "description": "Sort direction",
              "required": false,
              "defaultValue": "desc",
              "possibleValues": [
                "asc",
                "desc"
              ]
            },
            {
              "name": "limit",
              "type": "number",
              "description": "Limit number of data points shown (e.g., top 10)",
              "required": false
            },
            {
              "name": "colors",
              "type": "Array<string>",
              "description": "Custom color palette for the chart",
              "required": false
            },
            {
              "name": "showLegend",
              "type": "boolean",
              "description": "Whether to show the legend",
              "required": false,
              "defaultValue": true
            },
            {
              "name": "legendPosition",
              "type": "'auto' | 'top' | 'bottom' | 'left' | 'right'",
              "description": "Position of the legend. 'auto' uses bottom for pie/doughnut, top for others",
              "required": false,
              "defaultValue": "auto",
              "possibleValues": [
                "auto",
                "top",
                "bottom",
                "left",
                "right"
              ]
            },
            {
              "name": "legendFontSize",
              "type": "number",
              "description": "Font size for legend labels in pixels",
              "required": false,
              "defaultValue": 12
            },
            {
              "name": "showDataLabels",
              "type": "boolean",
              "description": "Whether to show data labels on chart",
              "required": false,
              "defaultValue": false
            },
            {
              "name": "enableExport",
              "type": "boolean",
              "description": "Show export button to download chart as image",
              "required": false,
              "defaultValue": true
            }
          ],
          "events": [
            {
              "name": "dataPointClick",
              "description": "Fired when user clicks on a data point",
              "parameters": [
                {
                  "name": "clickData",
                  "type": "{ seriesName: string; value: number; label: string; records: Array<object>; chartType: string; percentage?: number }",
                  "description": "Object containing series name, data value, label, original records, and chart type"
                }
              ]
            },
            {
              "name": "chartRendered",
              "description": "Fired when chart has finished rendering",
              "parameters": [
                {
                  "name": "chartInfo",
                  "type": "{ chartType: string; dataPointCount: number; aggregationMethod: string; isEmpty: boolean }",
                  "description": "Information about the rendered chart including type, data point count, and aggregation method"
                }
              ]
            }
          ],
          "libraries": [
            {
              "name": "chart.js",
              "version": "4.4.1",
              "globalVariable": "Chart"
            }
          ],
          "dependencies": [],
          "code": "function SimpleChart({\n  entityName,\n  data,\n  groupBy,\n  valueField,\n  aggregateMethod = 'count',\n  chartType = 'auto',\n  title,\n  height = 400,\n  sortBy = 'value',\n  sortOrder = 'desc',\n  limit,\n  colors,\n  showLegend = true,\n  legendPosition = 'auto', // New prop: 'auto', 'top', 'bottom', 'left', 'right'\n  legendFontSize = 12, // New prop for legend font size\n  showDataLabels = false,\n  enableExport = true,\n  onDataPointClick,\n  onChartRendered,\n  utilities,\n  styles,\n  components,\n  callbacks,\n  savedUserSettings,\n  onSaveUserSettings\n}) {\n  // Always use the MJ unwrapLibraryComponents function to get components from global libraries\n  // This ensures that various library build/package formats are handled correctly and transparently\n  // Chart.js is available as a global 'Chart' based on the spec's globalVariable setting\n  // Since Chart.js exports a single constructor function, unwrapLibraryComponents returns it for the requested name\n  const { Chart: ChartJS } = unwrapLibraryComponents(Chart, 'Chart');\n  \n  const canvasRef = React.useRef(null);\n  const chartInstanceRef = React.useRef(null);\n  const [error, setError] = React.useState(null);\n  const [entityInfo, setEntityInfo] = React.useState(null);\n\n  // Default color palette - accessible and visually distinct\n  const defaultColors = [\n    '#1890ff', // Blue\n    '#52c41a', // Green\n    '#fa8c16', // Orange\n    '#f5222d', // Red\n    '#722ed1', // Purple\n    '#13c2c2', // Cyan\n    '#fa541c', // Red-orange\n    '#2f54eb', // Deep blue\n    '#a0d911', // Lime\n    '#eb2f96'  // Magenta\n  ];\n\n  // Load entity metadata\n  React.useEffect(() => {\n    if (!entityName || !utilities?.md?.Entities) {\n      if (!entityName) console.error('Entity name not provided');\n      if (!utilities?.md?.Entities) console.error('Entity metadata not loaded.');\n      return;\n    }\n    \n    const entity = utilities.md.Entities.find(e => e.Name === entityName);\n    if (entity) {\n      setEntityInfo(entity);\n    }\n  }, [entityName, utilities]);\n\n  // Helper function to format values based on type\n  const formatValue = (value, isDate = false, isCurrency = false) => {\n    if (value == null) return 'N/A';\n    \n    if (isDate) {\n      try {\n        const date = new Date(value);\n        if (isNaN(date.getTime())) return value;\n        return date.toLocaleDateString('en-US', { \n          month: 'short', \n          day: 'numeric',\n          year: 'numeric'\n        });\n      } catch {\n        return value;\n      }\n    }\n    \n    if (isCurrency || (typeof value === 'number' && valueField && valueField.toLowerCase().includes('amount'))) {\n      if (typeof value === 'number') {\n        return new Intl.NumberFormat('en-US', {\n          style: 'currency',\n          currency: 'USD',\n          minimumFractionDigits: 0,\n          maximumFractionDigits: 0\n        }).format(value);\n      }\n    }\n    \n    if (typeof value === 'number') {\n      // Format large numbers with commas\n      return new Intl.NumberFormat('en-US').format(value);\n    }\n    \n    return value;\n  };\n\n  // Process and aggregate data\n  const processData = React.useMemo(() => {\n    if (!data || !Array.isArray(data) || data.length === 0) {\n      return { chartData: [], categories: [], values: [], isEmpty: true };\n    }\n\n    try {\n      // Validate that fields exist in the actual data, not just entity metadata\n      // This allows for calculated fields from queries that don't exist in base entity\n      if (data.length > 0) {\n        // Check if fields exist in data\n        if (!(groupBy in data[0])) {\n          const error = `Field \"${groupBy}\" not found in data. Available fields: ${Object.keys(data[0]).join(', ')}`;\n          console.error(error);\n          setError(error);\n          return { chartData: [], categories: [], values: [], isEmpty: true };\n        }\n\n        if (valueField && !(valueField in data[0])) {\n          const error = `Value field \"${valueField}\" not found in data. Available fields: ${Object.keys(data[0]).join(', ')}`;\n          console.error(error);\n          setError(error);\n          return { chartData: [], categories: [], values: [], isEmpty: true };\n        }\n      }\n      \n      // Group data by the specified field\n      const grouped = {};\n      \n      // Check if groupBy field is a date field using entity metadata\n      let isDateField = false;\n      if (entityInfo && entityInfo.Fields) {\n        const fieldInfo = entityInfo.Fields.find(f => f.Name === groupBy);\n        isDateField = fieldInfo && (fieldInfo.Type === 'datetime' || fieldInfo.Type === 'date');\n      }\n      \n      // Fallback to value-based detection if no metadata available\n      if (!isDateField && data.length > 0) {\n        const sampleValue = data[0][groupBy];\n        isDateField = sampleValue && (\n          sampleValue instanceof Date ||\n          (typeof sampleValue === 'string' && !isNaN(Date.parse(sampleValue)))\n        );\n      }\n      \n      data.forEach(record => {\n        let key = record[groupBy] || 'Unknown';\n        \n        // Format date values for display\n        if (isDateField && key !== 'Unknown') {\n          const date = new Date(key);\n          if (!isNaN(date.getTime())) {\n            // Format as YYYY-MM-DD for grouping\n            key = date.toISOString().split('T')[0];\n          }\n        }\n        \n        if (!grouped[key]) {\n          grouped[key] = {\n            label: key,\n            records: [],\n            value: 0\n          };\n        }\n        grouped[key].records.push(record);\n      });\n\n      // Aggregate based on method\n      Object.keys(grouped).forEach(key => {\n        const group = grouped[key];\n        \n        if (aggregateMethod === 'count') {\n          group.value = group.records.length;\n        } else if (valueField) {\n          const values = group.records\n            .map(r => parseFloat(r[valueField]))\n            .filter(v => !isNaN(v));\n          \n          if (values.length > 0) {\n            switch (aggregateMethod) {\n              case 'sum':\n                group.value = values.reduce((a, b) => a + b, 0);\n                break;\n              case 'average':\n                group.value = values.reduce((a, b) => a + b, 0) / values.length;\n                break;\n              case 'min':\n                group.value = Math.min(...values);\n                break;\n              case 'max':\n                group.value = Math.max(...values);\n                break;\n              default:\n                group.value = values.length;\n            }\n          }\n        }\n      });\n\n      // Convert to array and sort\n      let dataArray = Object.values(grouped);\n      \n      if (sortBy === 'label') {\n        dataArray.sort((a, b) => {\n          const comparison = String(a.label).localeCompare(String(b.label));\n          return sortOrder === 'asc' ? comparison : -comparison;\n        });\n      } else if (sortBy === 'value') {\n        dataArray.sort((a, b) => {\n          const comparison = a.value - b.value;\n          return sortOrder === 'asc' ? comparison : -comparison;\n        });\n      }\n      \n      // Apply limit if specified\n      if (limit && limit > 0) {\n        dataArray = dataArray.slice(0, limit);\n      }\n\n      const categories = dataArray.map(d => String(d.label));\n      const values = dataArray.map(d => d.value);\n\n      return {\n        chartData: dataArray,\n        categories,\n        values,\n        isEmpty: false\n      };\n    } catch (err) {\n      console.error('Error processing chart data:', err);\n      setError(err.message);\n      return { chartData: [], categories: [], values: [], isEmpty: true };\n    }\n  }, [data, groupBy, valueField, aggregateMethod, sortBy, sortOrder, limit, entityInfo]);\n\n  // Determine chart type automatically\n  const determineChartType = () => {\n    if (chartType !== 'auto') {\n      // Map 'donut' to Chart.js 'doughnut' \n      if (chartType === 'donut') return 'doughnut';\n      // Map 'column' to Chart.js 'bar'\n      if (chartType === 'column') return 'bar';\n      return chartType;\n    }\n    \n    // Check if groupBy field is a date field using entity metadata\n    let isDateField = false;\n    if (entityInfo && entityInfo.Fields) {\n      const fieldInfo = entityInfo.Fields.find(f => f.Name === groupBy);\n      isDateField = fieldInfo && (fieldInfo.Type === 'datetime' || fieldInfo.Type === 'date');\n    }\n    \n    // Fallback to value-based detection if no metadata available\n    if (!isDateField && data && data.length > 0) {\n      const sampleValue = data[0][groupBy];\n      isDateField = sampleValue && (\n        sampleValue instanceof Date ||\n        (typeof sampleValue === 'string' && !isNaN(Date.parse(sampleValue)))\n      );\n    }\n    \n    if (isDateField) {\n      return 'line';\n    }\n    \n    // Use pie/doughnut for small number of categories\n    if (processData.categories && processData.categories.length <= 5) {\n      return 'doughnut';\n    }\n    \n    // Default to bar chart\n    return 'bar';\n  };\n\n  const actualChartType = determineChartType();\n\n  // Generate chart configuration for Chart.js\n  const getChartConfig = () => {\n    const isPieOrDoughnut = actualChartType === 'pie' || actualChartType === 'doughnut';\n    const isLineOrArea = actualChartType === 'line' || actualChartType === 'area';\n    \n    const config = {\n      type: actualChartType === 'area' ? 'line' : actualChartType,\n      data: {\n        labels: processData.categories,\n        datasets: [{\n          label: valueField || 'Count',\n          data: processData.values,\n          backgroundColor: isPieOrDoughnut \n            ? (colors || defaultColors).slice(0, processData.values.length)\n            : isLineOrArea \n              ? 'rgba(24, 144, 255, 0.2)'\n              : (colors || defaultColors)[0],\n          borderColor: isPieOrDoughnut\n            ? undefined\n            : isLineOrArea\n              ? (colors || defaultColors)[0]\n              : (colors || defaultColors)[0],\n          borderWidth: isLineOrArea ? 2 : 1,\n          fill: actualChartType === 'area',\n          tension: isLineOrArea ? 0.1 : undefined\n        }]\n      },\n      options: {\n        responsive: true,\n        maintainAspectRatio: false,\n        onClick: (_event, elements) => {\n          if (elements && elements.length > 0 && onDataPointClick) {\n            const index = elements[0].index;\n            const clickedData = processData.chartData[index];\n            onDataPointClick({\n              chartType: actualChartType,\n              series: valueField || 'Count',\n              label: clickedData.label,\n              value: clickedData.value,\n              records: clickedData.records,\n              percentage: (clickedData.value / processData.values.reduce((a, b) => a + b, 0)) * 100\n            });\n          }\n        },\n        plugins: {\n          title: {\n            display: !!title,\n            text: title || `${entityName} by ${groupBy}`,\n            font: {\n              size: 16,\n              weight: 600\n            },\n            padding: {\n              bottom: 10\n            }\n          },\n          legend: {\n            display: showLegend && (isPieOrDoughnut || processData.categories.length <= 10),\n            position: legendPosition === 'auto'\n              ? (isPieOrDoughnut ? 'bottom' : 'top')\n              : legendPosition,\n            labels: {\n              font: {\n                size: legendFontSize\n              }\n            }\n          },\n          datalabels: showDataLabels ? {\n            display: true,\n            formatter: (value) => formatValue(value),\n            color: isPieOrDoughnut ? '#fff' : '#666'\n          } : undefined,\n          tooltip: {\n            callbacks: {\n              label: (context) => {\n                const label = context.dataset.label || '';\n                const value = formatValue(context.parsed.y !== undefined ? context.parsed.y : context.parsed);\n                return `${label}: ${value}`;\n              }\n            }\n          }\n        }\n      }\n    };\n\n    // Add scales for non-pie/doughnut charts\n    if (!isPieOrDoughnut) {\n      config.options.scales = {\n        y: {\n          beginAtZero: true,\n          ticks: {\n            callback: (value) => formatValue(value)\n          }\n        },\n        x: {\n          ticks: {\n            autoSkip: true,\n            maxRotation: 45,\n            minRotation: 0\n          }\n        }\n      };\n    }\n\n    // Add export functionality if enabled\n    if (enableExport && config.options.plugins) {\n      config.options.plugins.title = {\n        ...config.options.plugins.title,\n        display: true // Always show title when export is enabled\n      };\n    }\n\n    return config;\n  };\n\n  // Render chart\n  React.useEffect(() => {\n    if (processData.isEmpty || !canvasRef.current) {\n      return;\n    }\n\n    if (!ChartJS) {\n      console.error('[SimpleChart] Chart.js library not loaded');\n      setError('Chart.js library not loaded. Please ensure it is included in the component libraries.');\n      return;\n    }\n\n    try {\n      setError(null);\n\n      // Destroy existing chart\n      if (chartInstanceRef.current) {\n        chartInstanceRef.current.destroy();\n        chartInstanceRef.current = null;\n      }\n\n      const config = getChartConfig();\n      \n      // Create new chart instance\n      const ctx = canvasRef.current.getContext('2d');\n      chartInstanceRef.current = new ChartJS(ctx, config);\n\n      // Fire rendered event\n      if (onChartRendered) {\n        onChartRendered({\n          chartType: actualChartType,\n          dataPointCount: processData.chartData.length,\n          aggregateMethod: aggregateMethod,\n          totalValue: processData.values.reduce((a, b) => a + b, 0)\n        });\n      }\n\n    } catch (err) {\n      console.error('[SimpleChart] Error rendering chart:', err);\n      setError(`Failed to render chart: ${err.message}`);\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (chartInstanceRef.current) {\n        chartInstanceRef.current.destroy();\n        chartInstanceRef.current = null;\n      }\n    };\n  }, [processData, actualChartType, title, height, colors, showLegend, legendPosition, legendFontSize, showDataLabels, enableExport, ChartJS]);\n\n  // Download chart as image\n  React.useEffect(() => {\n    if (enableExport && chartInstanceRef.current && canvasRef.current) {\n      // Add a simple export button overlay\n      const exportHandler = () => {\n        const url = canvasRef.current.toDataURL('image/png');\n        const link = document.createElement('a');\n        link.download = `${title || 'chart'}.png`;\n        link.href = url;\n        link.click();\n      };\n      \n      // Store handler for cleanup\n      window.SimpleChartExport = exportHandler;\n    }\n    \n    return () => {\n      delete window.SimpleChartExport;\n    };\n  }, [enableExport, title]);\n\n  // Error state\n  if (error) {\n    return (\n      <div style={{ \n        display: 'flex', \n        flexDirection: 'column',\n        justifyContent: 'center', \n        alignItems: 'center', \n        height: height,\n        color: '#ff4d4f',\n        padding: '20px'\n      }}>\n        <div>Error rendering chart</div>\n        <div style={{ fontSize: '12px', marginTop: '8px', color: '#999' }}>{error}</div>\n      </div>\n    );\n  }\n\n  // Empty state\n  if (!data || data.length === 0 || processData.isEmpty) {\n    return (\n      <div style={{ \n        display: 'flex', \n        justifyContent: 'center', \n        alignItems: 'center', \n        height: height,\n        color: '#999',\n        backgroundColor: '#f5f5f5',\n        borderRadius: '4px'\n      }}>\n        No data available to display\n      </div>\n    );\n  }\n\n  // Render chart container with canvas\n  return (\n    <div style={{ width: '100%', position: 'relative' }}>\n      {enableExport && (\n        <button\n          onClick={() => window.SimpleChartExport && window.SimpleChartExport()}\n          style={{\n            position: 'absolute',\n            top: 10,\n            right: 10,\n            padding: '4px 8px',\n            fontSize: '12px',\n            backgroundColor: '#fff',\n            border: '1px solid #d9d9d9',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            zIndex: 10,\n            display: 'flex',\n            alignItems: 'center',\n            gap: '4px'\n          }}\n          title=\"Download as PNG\"\n        >\n          📥 Export\n        </button>\n      )}\n      <div style={{ width: '100%', height: `${height}px` }}>\n        <canvas ref={canvasRef} />\n      </div>\n    </div>\n  );\n}",
          "exampleUsage": "<SimpleChart\n  entityName=\"Invoice Line Items\"\n  data={invoiceItems}\n  groupBy=\"ProductCategory\"\n  valueField=\"TotalAmount\"\n  aggregateMethod=\"sum\"\n  chartType=\"bar\"\n  title=\"Revenue by Product Category\"\n  limit={10}\n  onDataPointClick={handleDrillDown}\n/>",
          "namespace": "Generic/UI/Chart",
          "version": "1.0.0",
          "registry": "Skip"
        },
        {
          "name": "DataGrid",
          "title": "Data Grid",
          "description": "Flexible, feature-rich data grid component wrapping Ant Design Table 5.12.0 for displaying tabular data with sorting, filtering, paging, and row selection. Data-agnostic (works with single entities, joins, or aggregated results). Optional native record opening: provide entityName + entityPrimaryKeys to open records on row click. Perfect for drill-down targets (final level showing detail records), master-detail patterns, search results, or standalone tables. Supports custom column rendering with two modes: simple (string array) or advanced (ColumnDef objects with {field, header, render, width, sortable}). Metadata-aware formatting: dates (locale with time), booleans (Yes/No), value lists (colored tags with 50+ status colors + 50 fallback colors), money ($USD), decimals (2 places), integers (commas). Long text handling modes: truncate (ellipsis), expand (click 'show more/less'), tooltip (hover), wrap (word-break), none. USE for lists/tables of records. DO NOT USE for single record (use SingleRecordView) or charts (use SimpleChart/SimpleDrilldownChart).",
          "type": "table",
          "location": "embedded",
          "functionalRequirements": "WHEN TO USE: Displaying lists or tables of records; Drill-down destination (bottom level of hierarchy showing detail records); Master-detail detail panel; Search results or filtered record lists; Data exploration with sorting/filtering/paging; Bulk operations requiring multi-select; Report tables; Any tabular data display including aggregated/joined data. WHEN NOT TO USE: Single record display (use SingleRecordView instead); Chart/graph visualizations (use SimpleChart or SimpleDrilldownChart); Need built-in chart-to-table drill-down (use SimpleDrilldownChart). CORE FEATURES: Universal table component for any data structure - works with single entities, joined tables, or aggregated results; Configurable columns with two modes: (1) Simple mode - string array of field names ['Name', 'SKU', 'Price'] uses smart defaults, (2) Advanced mode - ColumnDef objects [{field: 'Price', header: 'Unit Price', render: (value, record, fieldInfo) => `$${value}`, width: '120px', sortable: true}] for full control; Auto-detects columns from data if columns prop omitted; Smart type detection from entity metadata for alignment (numbers right-aligned) and formatting when entityName provided; Column-level and global text filtering with configurable debounce (default 300ms); Search highlighting with match count display ('Found N matching records'); Pagination with configurable page sizes and range display; Row selection modes: none (default), checkbox (multi-select), radio (single-select), row (click anywhere to select); Row click events with full record data for drill-down or navigation; Native OpenEntityRecord integration: When entityName and entityPrimaryKeys provided, clicking row opens entity record form (use for 1:1 record-to-row scenarios only, not aggregated data); Metadata-aware field formatting: dates (formatDate to locale with hour/minute), booleans (Yes/No text), value lists (colored Tag components), money fields (Intl.NumberFormat $USD), decimals/floats (2 decimal places with commas), integers (commas); Value list coloring system: statusColorMap with 50+ predefined colors for active/pending/complete/failed/error states, 50 fallback colors for other values, consistent color assignment per value; Long text field handling with 5 modes: truncate (substring+'...'), expand (click to toggle 'show more/less' with expandedCells state tracking), tooltip (Ant Tooltip on hover), wrap (word-break normal), none (default); Auto-fit columns to container width OR fixed widths with horizontal scroll (autoFitColumns prop); Column widths intelligently set based on SQL type and field length: GUIDs (280px), long text varchar(max) or >200 chars (400px), dates (160px), bit (80px), int (100px), money (130px); Loading state (spinner) when data===null; Empty state with contextual message 'No {entityName||'records'} found'; Filter match highlighting using Typography.Text mark prop; Debounced filter input prevents thrashing on large datasets; CSS overrides disable Ant Design animations to prevent render loop detection; Responsive design adapts to any container. COLUMN SYSTEM: Accepts Array<string | ColumnDef>; ColumnDef structure: {field: string (required), header: string (optional, uses DisplayName from metadata or field name), render: function(value, record, fieldInfo) => ReactNode (optional custom renderer), width: string|number (optional like '200px' or 200), sortable: boolean (optional, overrides global sorting prop)}; Backward compatible - existing code using string arrays continues to work; If columns omitted, auto-discovers from first data record filtering out 'key' field. ROW SELECTION: selectionMode='none'|'checkbox'|'radio'|'row'; Manages selectedRowKeys state; Fires selectionChanged event with full selected record objects. ROW CLICK BEHAVIOR: onRowClick handler takes priority over OpenEntityRecord (custom handler overrides default); If onRowClick NOT provided and entityName+entityPrimaryKeys ARE provided: row clicks trigger OpenEntityRecord callback as default behavior; Extracts primary key values from record using entityPrimaryKeys field names; Passes entityName and key-value pairs to callbacks.OpenEntityRecord; Only fires if all primary key fields have values; Logs warning if keys missing. EVENTS: rowClick(record: object) - fired on row click (overrides default OpenEntityRecord behavior); selectionChanged(selectedRows: Array<object>) - fired when selection changes; pageChanged(pageNumber: number 0-based, visibleRows: Array<object>) - fired on page change; sortChanged(sortState: {column: string, direction: 'asc'|'desc'}) - fired when sort changes; filterChanged(filterValue: string, matchingData: Array<object>) - fired when filter text changes with all matching records. FILTERING: Searches specified filterFields array or all display fields if not provided; Debounces input by filterDebounceTime (default 300ms); Highlights matching text across all visible cells; Shows 'Found N matching records' count below search box.",
          "technicalDesign": "Wraps Ant Design Table component with MJ-aware enhancements. React hooks: useState for filterText (raw input), debouncedFilter (processed search term), selectedRowKeys (selection state), currentPage (pagination), sortConfig (sort state), entityInfo (entity metadata), expandedCells (object tracking which long text cells are expanded with keys like ${recordKey}_${fieldName}). Loads entity metadata from utilities.md.Entities on mount if entityName provided for field type detection (Type, Length, DisplayName, ValueListType, EntityFieldValues); If no entityName, sets entityInfo to null and uses basic type detection. Library unwrapping: Uses unwrapLibraryComponents(antd, 'Table', 'Input', 'Space', 'Typography', 'Tag', 'Tooltip') to handle various Ant Design package formats (ESM/CJS/UMD). Column normalization (useMemo): Accepts columns as strings OR ColumnDef objects; If not provided, auto-discovers from Object.keys(data[0]) excluding 'key' field; Normalizes all to standard format {field, header, render, width, sortable}; Handles invalid configs gracefully with console.warn. Column building (useMemo): Maps normalized columns to Ant Design column configs; Determines alignment based on SQL type (int/decimal/float/numeric/money/bit → right-aligned, others left); Sets column widths based on SQL type and field length (only when autoFitColumns=false): uniqueidentifier→280px, long text (text type OR varchar(max) with length=-1 OR varchar with length>200)→400px, varchar/char based on length (≤50→100-200px, ≤100→250px, ≤200→300px, else→350px), date/time→160px, bit→80px, int→100px, decimal/numeric→120px, money→130px; When autoFitColumns=true, no widths set so table auto-sizes; Uses colDef.width if provided to override calculated width; Sets ellipsis=false (handle manually for click expansion); Creates sorter function if sortable (string localeCompare, number subtraction, null handling); render function priority: (1) Custom colDef.render if provided, (2) Metadata-driven default formatting. Field rendering logic: If custom render, call it with (value, record, fieldInfo); If value is null, return '-'; Create unique cellKey ${record.key/ID/id}_${fieldName} for expandedCells tracking; Format based on field type: date/time (formatDate with locale, hour/minute), bit (Yes/No), value lists (Tag component with getValueColor), money (Intl.NumberFormat USD currency), decimal/float (toLocaleString 2 decimals), int (toLocaleString); Long text handling: Check if field is long text (SQL types: text, varchar/char with length=-1 for (max), varchar/char with length>200); If length > longTextThreshold AND not value list: truncate mode (substring+'...'), expand mode (click toggles expandedCells[cellKey], shows 'show more/less' links), tooltip mode (Ant Tooltip wrapper), wrap mode (whiteSpace:normal, wordBreak:break-word), none (default); Apply filter highlighting: If filtering enabled and debouncedFilter exists, find match index in string, split and wrap match in Typography.Text mark component. Value list coloring: statusColorMap object with 50+ colors (active→#389e0d green, pending→#d48806 orange, failed→#a8071a red, processing→#096dd9 blue, etc.); fallbackColors array with 50 distinct colors (purple #722ed1, magenta #c41d7f, teal #08979c, indigo #1d39c4, vermillion #fa541c, brown #614700, etc.); getValueColor function: Build colorAssignments Map, iterate possibleValues from entity metadata, assign statusColorMap color if exists else next fallbackColor, ensures consistent colors for all values; For unknown values, check statusColorMap first then use hash-based fallback index. Filter debouncing (useEffect): setTimeout with filterDebounceTime (300ms), updates debouncedFilter; Cleanup clears timer. Filtered data (useMemo): If !filtering or !debouncedFilter, return original data; Determine searchFields (filterFields prop or all displayFields); Filter rows where any searchField value includes searchTerm (case-insensitive); Handle null/undefined rows gracefully. Filter change effect (useEffect): Fires onFilterChanged event with {filterValue: debouncedFilter, matchingData: filteredData}. Row selection config: If selectionMode !== 'none', create rowSelection object with type ('radio' or 'checkbox'), selectedRowKeys state, onChange handler (updates state, fires onSelectionChanged); For 'row' mode, adds onSelect handler. Pagination config: If paging=true, create pagination object with current (currentPage), pageSize, total (filteredData.length), showSizeChanger=false, showTotal formatter, onChange handler (updates currentPage, fires onPageChanged with 0-based page number and visible rows slice). Sort change handler: handleTableChange extracts sorter from Ant Table onChange, updates sortConfig state, fires onSortChanged with {sortState: {column: sorter.field, direction: sorter.order === 'ascend' ? 'asc' : 'desc'}}. Row click handler: handleRowClick function with priority logic: (1) If onRowClick provided, call it with record and return early (custom handler overrides default), (2) Else if entityName AND entityPrimaryKeys AND callbacks.OpenEntityRecord exist: maps entityPrimaryKeys array to key-value pairs [{FieldName, Value}] by extracting values from record, checks all key values exist (!=null), if yes calls callbacks.OpenEntityRecord(entityName, keyValues), else logs warning with entity/keys/record; Wrapped in try/catch logging errors. Data with keys (useMemo): Maps filteredData to add unique key prop (uses existing key/ID/id or falls back to index); Required for Ant Design Table row selection. CSS style injection: Disables all Ant Design animations (animation: none, transition: none, animation-duration: 0s, transition-duration: 0s) on .data-grid-component and descendants to prevent render loop detection. Render output: Wrapper div with .data-grid-component class; If filtering=true: Search input (Ant Input.Search) with value/onChange/allowClear/onClear, placeholder shows filterFields or 'all fields', full width style, fix for search button alignment; Text showing 'Found N matching records' if debouncedFilter exists; Ant Table component with columns (tableColumns), dataSource (dataWithKeys), rowSelection (if enabled), pagination (if enabled), onChange (handleTableChange for sort), scroll (x: 'max-content' only if autoFitColumns=false for horizontal scrolling), loading (true only when data===null), locale with emptyText (uses entityName if provided else 'records'), size='middle', onRow returns object with onClick handler (calls handleRowClick) and cursor style (pointer if onRowClick OR (entityName AND entityPrimaryKeys AND OpenEntityRecord exist) else default).",
          "dataRequirements": {
            "mode": "views",
            "description": "Component is data-agnostic and works with any entity data passed via props"
          },
          "properties": [
            {
              "name": "data",
              "type": "Array<object>",
              "description": "Array of records to display. Can be from any source: single entity, joined tables, aggregated results, or any array of objects.",
              "required": true
            },
            {
              "name": "entityName",
              "type": "string",
              "description": "Optional entity name for metadata lookup (enables smart formatting for dates, money, value lists) and OpenEntityRecord integration. If omitted, component uses basic type detection and does not support record opening.",
              "required": false
            },
            {
              "name": "entityPrimaryKeys",
              "type": "Array<string>",
              "description": "Array of field names that constitute the primary key(s) for opening entity records. Required for OpenEntityRecord integration. When provided with entityName, clicking a row will open the entity record using these fields. Use for 1:1 record-to-row scenarios (not aggregated data). Example: ['ID'] for single key, ['OrderID', 'LineNumber'] for composite key.",
              "required": false,
              "exampleValue": "[\"ID\"]"
            },
            {
              "name": "columns",
              "type": "Array<string | object>",
              "description": "Array of column definitions. Can be simple strings (field names) for default behavior, or column definition objects with properties: field (required), header, render, width, sortable. If not provided, all fields will be displayed. See technical design section for complete ColumnDef structure.",
              "required": false,
              "exampleValue": "[\"Name\", { field: \"Price\", header: \"Unit Price\", render: (v) => `$${v}`, width: \"120px\", sortable: true }]"
            },
            {
              "name": "sorting",
              "type": "boolean",
              "description": "Enable/disable column sorting",
              "required": false,
              "defaultValue": true
            },
            {
              "name": "paging",
              "type": "boolean",
              "description": "Enable/disable pagination",
              "required": false,
              "defaultValue": true
            },
            {
              "name": "pageSize",
              "type": "number",
              "description": "Number of rows per page when paging is enabled",
              "required": false,
              "defaultValue": 10
            },
            {
              "name": "filtering",
              "type": "boolean",
              "description": "Enable/disable text filtering",
              "required": false,
              "defaultValue": true
            },
            {
              "name": "highlightFilterMatches",
              "type": "boolean",
              "description": "Highlight matching text when filtering",
              "required": false,
              "defaultValue": true
            },
            {
              "name": "filterFields",
              "type": "Array<string>",
              "description": "Fields to search when filtering. If not specified, searches all fields",
              "required": false
            },
            {
              "name": "filterDebounceTime",
              "type": "number",
              "description": "Debounce time in ms for filter input",
              "required": false,
              "defaultValue": 300
            },
            {
              "name": "selectionMode",
              "type": "'none' | 'checkbox' | 'radio' | 'row'",
              "description": "Row selection mode: 'none', 'checkbox', 'radio', or 'row'",
              "required": false,
              "defaultValue": "none",
              "possibleValues": [
                "none",
                "checkbox",
                "radio",
                "row"
              ]
            },
            {
              "name": "longTextDisplay",
              "type": "'truncate' | 'expand' | 'tooltip' | 'wrap' | 'none'",
              "description": "How to display long text that exceeds the threshold: 'truncate' shows ellipsis, 'expand' allows click to expand/collapse, 'tooltip' shows full text on hover, 'wrap' shows all text with wrapping, 'none' uses default behavior",
              "required": false,
              "defaultValue": "expand",
              "possibleValues": [
                "truncate",
                "expand",
                "tooltip",
                "wrap",
                "none"
              ]
            },
            {
              "name": "longTextThreshold",
              "type": "number",
              "description": "Number of characters before long text display behavior is triggered",
              "required": false,
              "defaultValue": 100
            },
            {
              "name": "autoFitColumns",
              "type": "boolean",
              "description": "When true, columns auto-fit to container width. When false, columns use fixed widths with horizontal scrolling",
              "required": false,
              "defaultValue": true
            }
          ],
          "events": [
            {
              "name": "rowClick",
              "description": "Fired when a row is clicked. Uses cancelable event pattern - set event.cancel = true to prevent default OpenEntityRecord behavior.",
              "parameters": [
                {
                  "name": "event",
                  "type": "{ record: object, cancel: boolean }",
                  "description": "Event object containing the clicked row record and cancel flag. Set cancel = true to prevent default behavior (OpenEntityRecord when entityName and entityPrimaryKeys are provided)."
                }
              ]
            },
            {
              "name": "selectionChanged",
              "description": "Fired when row selection changes",
              "parameters": [
                {
                  "name": "selectedRows",
                  "type": "Array<object>",
                  "description": "Array of selected entity objects"
                }
              ]
            },
            {
              "name": "pageChanged",
              "description": "Fired when page changes",
              "parameters": [
                {
                  "name": "pageNumber",
                  "type": "number",
                  "description": "Current page number (0-based)"
                },
                {
                  "name": "visibleRows",
                  "type": "Array<object>",
                  "description": "Array of entity objects visible on current page"
                }
              ]
            },
            {
              "name": "sortChanged",
              "description": "Fired when sort configuration changes",
              "parameters": [
                {
                  "name": "sortState",
                  "type": "{column: string, direction: 'asc' | 'desc'}",
                  "description": "Object with 'column' and 'direction' properties"
                }
              ]
            },
            {
              "name": "filterChanged",
              "description": "Fired when filter changes",
              "parameters": [
                {
                  "name": "filterValue",
                  "type": "string",
                  "description": "Current filter text"
                },
                {
                  "name": "matchingData",
                  "type": "Array<object>",
                  "description": "Array of all matching entity objects"
                }
              ]
            }
          ],
          "libraries": [
            {
              "name": "antd",
              "version": "5.12.0",
              "globalVariable": "antd"
            }
          ],
          "dependencies": [],
          "code": "function DataGrid({\n  data,\n  entityName,\n  entityPrimaryKeys,\n  columns, // Array of column definitions: [{field: 'Name', header: 'Product Name', render: fn, width: '200px', sortable: true}]\n  sorting = true,\n  paging = true,\n  pageSize = 20,\n  showPageSizeChanger = true,\n  filtering = true,  // Changed default to true\n  highlightFilterMatches = true,\n  filterFields,\n  filterDebounceTime = 300,\n  selectionMode = 'none',\n  longTextDisplay = 'expand', // Options: 'truncate', 'expand', 'tooltip', 'wrap', 'none'\n  longTextThreshold = 100, // Characters before truncation\n  autoFitColumns = true, // Auto-fit columns to container width vs fixed widths with scroll\n  onSelectionChanged,\n  onPageChanged,\n  onSortChanged,\n  onFilterChanged,\n  onRowClick,\n  utilities,\n  styles,\n  components,\n  callbacks,\n  savedUserSettings,\n  onSaveUserSettings\n}) {\n  // Always use the MJ unwrapLibraryComponents function to get components from global libraries like antd, this ensures\n  // that various library build/package formats are handled correctly and transparently for your code!\n  const { Table, Input, Space, Typography, Tag, Tooltip } = unwrapLibraryComponents(antd, 'Table', 'Input', 'Space', 'Typography', 'Tag', 'Tooltip');\n  const { Search } = Input;\n  const { Text } = Typography;\n  const [filterText, setFilterText] = React.useState('');\n  const [debouncedFilter, setDebouncedFilter] = React.useState('');\n  const [selectedRowKeys, setSelectedRowKeys] = React.useState([]);\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const [currentPageSize, setCurrentPageSize] = React.useState(pageSize);\n  const [sortConfig, setSortConfig] = React.useState(null);\n  const [entityInfo, setEntityInfo] = React.useState(null);\n  const [expandedCells, setExpandedCells] = React.useState({}); // Track which cells are expanded\n\n\n  // Update current page size when pageSize prop changes\n  React.useEffect(() => {\n    setCurrentPageSize(pageSize);\n  }, [pageSize]);\n\n  // Load entity metadata if we have an entity name\n  React.useEffect(() => {\n    if (entityName && utilities?.md?.Entities) {\n      const entity = utilities.md.Entities.find(e => e.Name === entityName);\n      setEntityInfo(entity || null);\n    } else {\n      setEntityInfo(null);\n    }\n  }, [entityName, utilities]);\n  \n  // Helper function to format dates\n  const formatDate = (value) => {\n    if (!value) return '-';\n    try {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) return value; // Invalid date, return as-is\n      // Format as YYYY-MM-DD HH:MM\n      return date.toLocaleString('en-US', {\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n    } catch {\n      return value;\n    }\n  };\n  \n  // Color mapping for common status values (darker for better contrast with white text)\n  const statusColorMap = {\n    // Green colors for positive states\n    active: '#389e0d',      // darker green\n    approved: '#52c41a',    // green\n    complete: '#237804',    // dark green\n    completed: '#135200',   // very dark green\n    success: '#3f6600',     // olive green\n    successful: '#5b8c00',  // light olive\n    enabled: '#7cb305',     // lime\n    published: '#a0d911',   // light lime\n    \n    // Red colors for negative states\n    inactive: '#cf1322',    // darker red\n    rejected: '#f5222d',    // red\n    failed: '#a8071a',      // dark red\n    error: '#820014',       // very dark red\n    disabled: '#ff4d4f',    // light red\n    cancelled: '#ff7875',   // salmon\n    canceled: '#ff9c9c',    // light salmon\n    terminated: '#873800',  // burnt orange\n    expired: '#ad4e00',     // dark orange\n    deprecated: '#d4380d',  // rust orange\n    \n    // Yellow/Orange for pending states\n    pending: '#d48806',     // darker orange\n    paused: '#fa8c16',      // orange\n    temporary: '#faad14',   // gold\n    draft: '#d4b106',       // dark gold\n    review: '#ad8b00',      // darker gold\n    waiting: '#ffc53d',     // light gold\n    \n    // Blue for informational states\n    processing: '#096dd9',  // darker blue\n    running: '#1890ff',     // blue\n    inprogress: '#0050b3',  // dark blue\n    'in progress': '#003a8c', // very dark blue\n    'in-progress': '#40a9ff' // light blue\n  };\n  \n  // 50 distinct colors for value lists (excluding colors used in statusColorMap)\n  // These are carefully selected to be visually distinct from each other\n  const fallbackColors = [\n    '#722ed1', // purple\n    '#9254de', // light purple\n    '#531dab', // dark purple\n    '#391085', // very dark purple\n    '#b37feb', // lavender\n    \n    '#c41d7f', // magenta\n    '#eb2f96', // pink\n    '#f759ab', // light pink\n    '#9e1068', // dark magenta\n    '#780650', // very dark magenta\n    \n    '#08979c', // teal\n    '#13c2c2', // cyan\n    '#006d75', // dark teal\n    '#36cfc9', // light cyan\n    '#5cdbd3', // pale cyan\n    \n    '#1d39c4', // indigo\n    '#2f54eb', // royal blue\n    '#597ef7', // periwinkle\n    '#10239e', // dark indigo\n    '#061178', // navy\n    \n    '#fa541c', // vermillion\n    '#ff7a45', // coral\n    '#ff9c6e', // peach\n    '#d4380d', // rust (if not used above)\n    '#ad2102', // brick red\n    \n    '#8c8c8c', // gray\n    '#595959', // dark gray\n    '#bfbfbf', // light gray\n    '#434343', // charcoal\n    '#262626', // near black\n    \n    '#614700', // brown\n    '#874d00', // tan\n    '#a8730f', // amber\n    '#c79816', // mustard\n    '#d4a017', // goldenrod\n    \n    '#00474f', // dark cyan\n    '#006064', // petrol\n    '#004851', // dark petrol\n    '#1a535c', // ocean\n    '#2c5f2d', // forest green\n    \n    '#4a7c59', // sage\n    '#6b8e23', // olive drab\n    '#556b2f', // dark olive\n    '#8fbc8f', // dark sea green\n    '#3cb371', // medium sea green\n    \n    '#cd5c5c', // indian red\n    '#bc8f8f', // rosy brown\n    '#daa520', // goldenrod\n    '#b8860b', // dark goldenrod\n    '#ff6347'  // tomato\n  ];\n  \n  // Get color for a value in a value list - ensures unique colors for all values\n  const getValueColor = (value, possibleValues) => {\n    if (!value) return null;\n    \n    const normalized = value.toString().toLowerCase().trim();\n    \n    // Build a complete color assignment map for this column\n    const colorAssignments = new Map();\n    let nextColorIndex = 0;\n    \n    // First, assign colors to all possible values in order\n    if (possibleValues && Array.isArray(possibleValues)) {\n      possibleValues.forEach(pv => {\n        const pvValue = (pv.Value || pv.Code || '').toLowerCase().trim();\n        if (pvValue && !colorAssignments.has(pvValue)) {\n          // Check if this value has a predefined color in statusColorMap\n          if (statusColorMap[pvValue]) {\n            colorAssignments.set(pvValue, statusColorMap[pvValue]);\n          } else {\n            // Assign next available fallback color\n            colorAssignments.set(pvValue, fallbackColors[nextColorIndex % fallbackColors.length]);\n            nextColorIndex++;\n          }\n        }\n      });\n    }\n    \n    // Return the assigned color for this value\n    if (colorAssignments.has(normalized)) {\n      return colorAssignments.get(normalized);\n    }\n    \n    // If value wasn't in possibleValues, check statusColorMap first\n    if (statusColorMap[normalized]) {\n      return statusColorMap[normalized];\n    }\n    \n    // Otherwise assign a fallback color based on hash\n    // This ensures consistency even for unexpected values\n    let hash = 0;\n    for (let i = 0; i < normalized.length; i++) {\n      hash = normalized.charCodeAt(i) + ((hash << 5) - hash);\n    }\n    return fallbackColors[Math.abs(hash) % fallbackColors.length];\n  };\n  \n  // Debounce filter input\n  React.useEffect(() => {\n    const timer = setTimeout(() => {\n      setDebouncedFilter(filterText);\n    }, filterDebounceTime);\n    return () => clearTimeout(timer);\n  }, [filterText, filterDebounceTime]);\n  \n  // Normalize column definitions - support both simple strings and full column definitions\n  const normalizedColumns = React.useMemo(() => {\n    if (!columns || columns.length === 0) {\n      // Auto-discover columns from data if none provided\n      if (data && Array.isArray(data) && data.length > 0) {\n        const allKeys = new Set();\n        data.forEach(row => {\n          if (row && typeof row === 'object') {\n            Object.keys(row).forEach(key => {\n              if (key !== 'key') {\n                allKeys.add(key);\n              }\n            });\n          }\n        });\n        return Array.from(allKeys).map(key => ({ field: key }));\n      }\n      return [];\n    }\n\n    // Normalize columns to standard format\n    return columns.map(col => {\n      if (typeof col === 'string') {\n        // Simple string field name - use defaults\n        return { field: col };\n      } else if (typeof col === 'object' && col.field) {\n        // Already a column definition object\n        return col;\n      } else {\n        console.warn('Invalid column configuration:', col);\n        return null;\n      }\n    }).filter(Boolean);\n  }, [columns, data]);\n\n  // Extract just the field names for filtering and other operations\n  const displayFields = React.useMemo(() => {\n    return normalizedColumns.map(col => col.field);\n  }, [normalizedColumns]);\n  \n  // Build table columns from column definitions with metadata-aware formatting\n  const tableColumns = React.useMemo(() => {\n    return normalizedColumns.map(colDef => {\n      const fieldName = colDef.field;\n\n      // Get field metadata if available\n      const fieldInfo = entityInfo?.Fields?.find(f => f.Name === fieldName);\n      const fieldType = fieldInfo?.Type?.toLowerCase() || '';\n      const hasValueList = fieldInfo?.ValueListType === 'List' || fieldInfo?.ValueListType === 'ListOrUserEntry';\n      const possibleValues = fieldInfo?.EntityFieldValues;\n      \n      \n      // Determine alignment based on field type\n      let align = 'left';\n      if (fieldType.includes('int') || fieldType.includes('decimal') || \n          fieldType.includes('float') || fieldType.includes('numeric') || \n          fieldType.includes('money') || fieldType === 'bit') {\n        align = 'right';\n      }\n      \n      // Set column width based on field metadata (type and length)\n      // In autoFit mode, we don't set widths (let table auto-size)\n      // In fixed mode, set proper widths for all columns with horizontal scroll\n      let columnWidth = autoFitColumns ? undefined : 150; // Default width or auto\n      const fieldLength = fieldInfo?.Length;\n      \n      // Determine if this is a long text field based on SQL type\n      // Note: SQL Server returns length = -1 for max fields (varchar(max), nvarchar(max))\n      const isLongTextField = fieldType.includes('text') || // text, ntext types\n                              (fieldType.includes('varchar') && fieldLength === -1) || // varchar(max) or nvarchar(max)\n                              (fieldType.includes('char') && fieldLength === -1) || // char(max) or nchar(max)\n                              (fieldType.includes('varchar') && fieldLength && fieldLength > 200) ||\n                              (fieldType.includes('char') && fieldLength && fieldLength > 200);\n      \n      \n      // Set appropriate widths based on data type (only when not auto-fitting)\n      if (!autoFitColumns) {\n        if (fieldType.includes('uniqueidentifier')) {\n          columnWidth = 280; // GUIDs need space\n        } else if (isLongTextField) {\n          columnWidth = 400; // Generous width for long text fields\n        } else if (fieldType.includes('varchar') || fieldType.includes('char')) {\n          // Scale width based on field length\n          if (fieldLength && fieldLength <= 50) {\n            columnWidth = Math.min(200, Math.max(100, fieldLength * 3));\n          } else if (fieldLength && fieldLength <= 100) {\n            columnWidth = 250;\n          } else if (fieldLength && fieldLength <= 200) {\n            columnWidth = 300;\n          } else {\n            columnWidth = 350; // Default for varchar without length\n          }\n        } else if (fieldType.includes('date') || fieldType.includes('time')) {\n          columnWidth = 160;\n        } else if (fieldType === 'bit') {\n          columnWidth = 80;\n        } else if (fieldType.includes('int')) {\n          columnWidth = 100;\n        } else if (fieldType.includes('decimal') || fieldType.includes('numeric')) {\n          columnWidth = 120;\n        } else if (fieldType.includes('money')) {\n          columnWidth = 130;\n        }\n      }\n      \n      // If no metadata available, use default width\n      // We don't make assumptions based on field names\n      \n      \n      // Enable ellipsis for long text fields\n      const useEllipsis = isLongTextField;\n      \n      // Handle special __mj fields display names\n      // Priority: colDef.header > fieldInfo.DisplayName > default handling\n      let displayName = colDef.header || fieldInfo?.DisplayName || fieldName;\n      if (!colDef.header) {\n        if (fieldName === '__mj_CreatedAt') {\n          displayName = 'Created At';\n        } else if (fieldName === '__mj_UpdatedAt') {\n          displayName = 'Updated At';\n        } else if (fieldName === '__mj_DeletedAt') {\n          displayName = 'Deleted At';\n        }\n      }\n\n      return {\n        title: displayName,\n        dataIndex: fieldName,\n        key: fieldName,\n        align: align,\n        width: colDef.width || columnWidth, // Use column-specific width if provided\n        ellipsis: false, // We'll handle ellipsis manually for click expansion\n        sorter: (colDef.sortable !== undefined ? colDef.sortable : sorting) ? (a, b) => {\n          const valA = a[fieldName];\n          const valB = b[fieldName];\n          if (valA == null) return 1;\n          if (valB == null) return -1;\n          if (typeof valA === 'string') {\n            return valA.localeCompare(valB);\n          }\n          return valA - valB;\n        } : false,\n        render: (value, record) => {\n          // Check for custom render function first\n          if (colDef.render && typeof colDef.render === 'function') {\n            return colDef.render(value, record, fieldInfo);\n          }\n\n          // Default handling for null values\n          if (value == null) return '-';\n\n          // Create a unique key for this cell\n          const cellKey = `${record.key || record.ID || record.id}_${fieldName}`;\n          const isExpanded = expandedCells[cellKey];\n\n          // Format based on field type (default behavior)\n          let displayValue = value;\n          let formattedContent = null;\n          \n          // Handle date/time fields\n          if (fieldType.includes('date') || fieldType.includes('time')) {\n            displayValue = formatDate(value);\n            formattedContent = displayValue;\n          }\n          // Handle boolean fields\n          else if (fieldType === 'bit') {\n            displayValue = value ? 'Yes' : 'No';\n            formattedContent = displayValue;\n          }\n          // Handle fields with value lists - render as tags\n          else if (hasValueList && possibleValues) {\n            const color = getValueColor(value, possibleValues);\n            formattedContent = (\n              <Tag \n                color={color}\n                style={{ \n                  borderRadius: '12px',\n                  fontSize: '12px',\n                  padding: '2px 8px'\n                }}\n              >\n                {value}\n              </Tag>\n            );\n          }\n          // Handle numeric fields with formatting\n          else if (fieldType.includes('money')) {\n            displayValue = typeof value === 'number'\n              ? new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(value)\n              : value;\n            formattedContent = displayValue;\n          }\n          else if (fieldType.includes('decimal') || fieldType.includes('float')) {\n            displayValue = typeof value === 'number' \n              ? value.toLocaleString('en-US', { maximumFractionDigits: 2 })\n              : value;\n            formattedContent = displayValue;\n          }\n          else if (fieldType.includes('int')) {\n            displayValue = typeof value === 'number' \n              ? value.toLocaleString('en-US')\n              : value;\n            formattedContent = displayValue;\n          }\n          else {\n            formattedContent = displayValue;\n          }\n          \n          // Handle long text fields based on longTextDisplay mode\n          if (useEllipsis && typeof displayValue === 'string' && displayValue.length > longTextThreshold && !hasValueList) {\n            const shouldTruncate = displayValue.length > longTextThreshold;\n            \n            // Mode: truncate - simple ellipsis\n            if (longTextDisplay === 'truncate') {\n              const truncated = displayValue.substring(0, longTextThreshold) + '...';\n              return (\n                <div style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>\n                  {truncated}\n                </div>\n              );\n            }\n            \n            // Mode: tooltip - show full text on hover\n            if (longTextDisplay === 'tooltip') {\n              const truncated = displayValue.substring(0, longTextThreshold) + '...';\n              return (\n                <Tooltip title={displayValue} placement=\"topLeft\">\n                  <div style={{ whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis' }}>\n                    {truncated}\n                  </div>\n                </Tooltip>\n              );\n            }\n            \n            // Mode: wrap - show all text with wrapping\n            if (longTextDisplay === 'wrap') {\n              return (\n                <div style={{ whiteSpace: 'normal', wordBreak: 'break-word' }}>\n                  {displayValue}\n                </div>\n              );\n            }\n            \n            // Mode: expand (default) - click to expand/collapse\n            if (longTextDisplay === 'expand') {\n              const shouldTruncate = !isExpanded && displayValue.length > longTextThreshold;\n              const displayText = shouldTruncate \n                ? displayValue.substring(0, longTextThreshold) \n                : displayValue;\n              \n              // Apply highlight for filter matches\n              let finalContent = displayText;\n              if (filtering && highlightFilterMatches && debouncedFilter) {\n                const str = String(displayText);\n                const searchTerm = debouncedFilter.toLowerCase();\n                const index = str.toLowerCase().indexOf(searchTerm);\n                if (index >= 0) {\n                  finalContent = (\n                    <span>\n                      {str.substring(0, index)}\n                      <Text mark>{str.substring(index, index + searchTerm.length)}</Text>\n                      {str.substring(index + searchTerm.length)}\n                    </span>\n                  );\n                }\n              }\n              \n              return (\n                <div \n                  style={{ \n                    cursor: shouldTruncate ? 'pointer' : 'default',\n                    whiteSpace: isExpanded ? 'normal' : 'nowrap',\n                    wordBreak: isExpanded ? 'break-word' : 'normal'\n                  }}\n                  onClick={() => {\n                    if (displayValue.length > longTextThreshold) {\n                      setExpandedCells(prev => ({\n                        ...prev,\n                        [cellKey]: !prev[cellKey]\n                      }));\n                    }\n                  }}\n                >\n                  {finalContent}\n                  {shouldTruncate && (\n                    <Text type=\"secondary\" style={{ marginLeft: 2 }}>\n                      ... <Text type=\"link\">[show more]</Text>\n                    </Text>\n                  )}\n                  {isExpanded && displayValue.length > longTextThreshold && (\n                    <Text type=\"link\" style={{ marginLeft: 4 }}>\n                      [show less]\n                    </Text>\n                  )}\n                </div>\n              );\n            }\n            \n            // Mode: none - no special handling\n            // Falls through to regular display\n          }\n          \n          // Apply highlight for filter matches (for non-expandable content)\n          if (filtering && highlightFilterMatches && debouncedFilter && !hasValueList) {\n            const str = String(displayValue);\n            const index = str.toLowerCase().indexOf(debouncedFilter.toLowerCase());\n            if (index >= 0) {\n              return (\n                <span>\n                  {str.substring(0, index)}\n                  <Text mark>{str.substring(index, index + debouncedFilter.length)}</Text>\n                  {str.substring(index + debouncedFilter.length)}\n                </span>\n              );\n            }\n          }\n          \n          return formattedContent;\n        }\n      };\n    });\n  }, [normalizedColumns, entityInfo, sorting, filtering, highlightFilterMatches, debouncedFilter, expandedCells]);\n  \n  // Filter data based on search term\n  // Handles null/undefined data gracefully and returns appropriate defaults\n  const filteredData = React.useMemo(() => {\n    // If data is null/undefined, return empty array\n    if (!data || !Array.isArray(data)) {\n      return [];\n    }\n    \n    // If filtering is disabled or no filter text, return original data\n    if (!filtering || !debouncedFilter) {\n      return data;\n    }\n    \n    // Determine which fields to search - use specified fields or all display fields\n    const searchFields = filterFields || displayFields;\n    const searchTerm = debouncedFilter.toLowerCase();\n    \n    // Filter rows that match the search term in any of the specified fields\n    return data.filter(row => {\n      // Skip null/undefined rows\n      if (!row || typeof row !== 'object') return false;\n      \n      return searchFields.some(field => {\n        const value = row[field];\n        if (value == null) return false;\n        return String(value).toLowerCase().includes(searchTerm);\n      });\n    });\n  }, [data, displayFields, filtering, filterFields, debouncedFilter]);\n  \n  // Handle filter change\n  React.useEffect(() => {\n    if (onFilterChanged && filtering) {\n      onFilterChanged({ filterValue: debouncedFilter, matchingData: filteredData });\n    }\n  }, [debouncedFilter, filteredData, onFilterChanged, filtering]);\n  \n  // Selection configuration\n  const rowSelection = selectionMode !== 'none' ? {\n    type: selectionMode === 'radio' ? 'radio' : 'checkbox',\n    selectedRowKeys,\n    onChange: (keys, rows) => {\n      setSelectedRowKeys(keys);\n      if (onSelectionChanged) {\n        onSelectionChanged({ selectedRows: rows });\n      }\n    },\n    ...(selectionMode === 'row' ? {\n      onSelect: (record) => {\n        const key = record.key || record.ID || record.id;\n        const isSelected = selectedRowKeys.includes(key);\n        const newKeys = isSelected \n          ? selectedRowKeys.filter(k => k !== key)\n          : [...selectedRowKeys, key];\n        setSelectedRowKeys(newKeys);\n        if (onSelectionChanged) {\n          const rows = filteredData.filter(r => \n            newKeys.includes(r.key || r.ID || r.id)\n          );\n          onSelectionChanged({ selectedRows: rows });\n        }\n      }\n    } : {})\n  } : undefined;\n  \n  // Pagination configuration\n  const pagination = paging ? {\n    current: currentPage,\n    pageSize: currentPageSize,\n    total: filteredData.length,\n    showSizeChanger: showPageSizeChanger,\n    pageSizeOptions: ['5', '10', '20', '50', '100'],\n    showTotal: (total, range) => `${range[0]}-${range[1]} of ${total}`,\n    onChange: (page, newPageSize) => {\n      setCurrentPage(page);\n      if (newPageSize !== currentPageSize) {\n        setCurrentPageSize(newPageSize);\n      }\n      if (onPageChanged) {\n        const startIdx = (page - 1) * (newPageSize || currentPageSize);\n        const endIdx = Math.min(startIdx + (newPageSize || currentPageSize), filteredData.length);\n        onPageChanged({\n          pageNumber: page - 1,\n          pageSize: newPageSize || currentPageSize,\n          visibleRows: filteredData.slice(startIdx, endIdx)\n        });\n      }\n    },\n    onShowSizeChange: (current, size) => {\n      setCurrentPageSize(size);\n      setCurrentPage(1); // Reset to first page when changing page size\n      if (onPageChanged) {\n        const endIdx = Math.min(size, filteredData.length);\n        onPageChanged({\n          pageNumber: 0,\n          pageSize: size,\n          visibleRows: filteredData.slice(0, endIdx)\n        });\n      }\n    }\n  } : false;\n  \n  // Handle table sort change\n  const handleTableChange = (pag, filters, sorter) => {\n    if (sorter && onSortChanged) {\n      setSortConfig(sorter);\n      onSortChanged({\n        sortState: {\n          column: sorter.field,\n          direction: sorter.order === 'ascend' ? 'asc' : 'desc'\n        }\n      });\n    }\n  };\n\n  // Handle row click with cancelable event pattern\n  const handleRowClick = (record) => {\n    // Create event object with cancel property (cancelable event pattern)\n    const rowClickEvent = {\n      record: record,\n      cancel: false\n    };\n\n    // Always call onRowClick first if provided (allows custom handling + optional cancellation)\n    if (onRowClick) {\n      onRowClick(rowClickEvent);\n    }\n\n    // If the event was cancelled, don't execute default behavior\n    if (rowClickEvent.cancel) {\n      return;\n    }\n\n    // Default behavior: If entityName and entityPrimaryKeys are provided, open the record\n    if (entityName && entityPrimaryKeys && Array.isArray(entityPrimaryKeys) && entityPrimaryKeys.length > 0 && callbacks?.OpenEntityRecord) {\n      try {\n        // Build the key-value pairs for OpenEntityRecord\n        const keyValues = entityPrimaryKeys.map(fieldName => ({\n          FieldName: fieldName,\n          Value: record[fieldName]\n        }));\n\n        // Check that all primary key values exist\n        const hasAllKeys = keyValues.every(kv => kv.Value != null);\n        if (hasAllKeys) {\n          callbacks.OpenEntityRecord(entityName, keyValues);\n        } else {\n          console.warn('[DataGrid] Cannot open record: missing primary key values', {\n            entityName,\n            entityPrimaryKeys,\n            record\n          });\n        }\n      } catch (err) {\n        console.error('[DataGrid] Error opening record:', err);\n      }\n    }\n  };\n  \n  // Add keys to data for row selection\n  // React tables need a unique key for each row to track selection state\n  const dataWithKeys = React.useMemo(() => {\n    // Handle empty/null data gracefully\n    if (!filteredData || !Array.isArray(filteredData)) {\n      return [];\n    }\n    \n    return filteredData.map((row, index) => ({\n      ...row,\n      // Use existing key, ID fields, or fall back to index\n      key: row?.key || row?.ID || row?.id || index\n    }));\n  }, [filteredData]);\n  \n  return (\n    <div className=\"data-grid-component\" style={{ width: '100%' }}>\n      <style>{`\n        .data-grid-component .ant-table-wrapper,\n        .data-grid-component .ant-table,\n        .data-grid-component .ant-table-tbody,\n        .data-grid-component .ant-table-row,\n        .data-grid-component .ant-table-cell,\n        .data-grid-component .ant-table-tbody > tr {\n          animation: none !important;\n          transition: none !important;\n        }\n        .data-grid-component .ant-table-tbody > tr.ant-table-row {\n          animation: none !important;\n        }\n        .data-grid-component * {\n          animation-duration: 0s !important;\n          transition-duration: 0s !important;\n        }\n      `}</style>\n      {filtering && (\n        <Space direction=\"vertical\" style={{ width: '100%', marginBottom: 16 }}>\n          <div style={{ position: 'relative' }}>\n            <Search\n              placeholder={`Search in ${filterFields ? filterFields.join(', ') : 'all fields'}`}\n              value={filterText}\n              onChange={e => setFilterText(e.target.value)}\n              allowClear\n              onClear={() => setFilterText('')}\n              style={{ width: '100%' }}  // Full width to match grid\n            />\n            <style>{`\n              .data-grid-component .ant-btn.ant-input-search-button {\n                margin-top: -1px;\n              }\n            `}</style>\n          </div>\n          {debouncedFilter && (\n            <Text type=\"secondary\">\n              Found {filteredData.length} matching records\n            </Text>\n          )}\n        </Space>\n      )}\n      \n      <Table\n        columns={tableColumns}\n        dataSource={dataWithKeys}\n        rowSelection={rowSelection}\n        pagination={pagination}\n        onChange={handleTableChange}\n        scroll={autoFitColumns ? undefined : { x: 'max-content' }}  // Enable horizontal scrolling only when not auto-fitting\n        loading={data === null}  // Only show loading when data is explicitly null (not yet loaded)\n        locale={{\n          emptyText: `No ${entityName || 'records'} found`\n        }}\n        size=\"middle\"\n        onRow={(record) => ({\n          onClick: () => handleRowClick(record),\n          style: {\n            cursor: (onRowClick || (entityName && entityPrimaryKeys && callbacks?.OpenEntityRecord)) ? 'pointer' : 'default'\n          }\n        })}\n      />\n    </div>\n  );\n} ",
          "exampleUsage": "// Simple column configuration (backward compatible)\n<DataGrid\n  entityName=\"Products\"\n  data={products}\n  columns={['Name', 'SKU', 'Price', 'Category', 'InStock']}\n  onRowClick={handleRowClick}\n/>\n\n// Advanced column configuration with custom rendering\n<DataGrid\n  entityName=\"Products\"\n  data={products}\n  columns={[\n    { field: 'Name', header: 'Product Name', width: '200px' },\n    { \n      field: 'Price',\n      header: 'Unit Price',\n      render: (value) => (\n        <span style={{ fontWeight: 'bold', color: '#059669' }}>\n          {value >= 1000 ? `$${(value/1000).toFixed(1)}K` : `$${value}`}\n        </span>\n      ),\n      width: '120px',\n      sortable: true\n    },\n    {\n      field: 'InStock',\n      header: 'Availability',\n      render: (value) => (\n        <span style={{ \n          padding: '2px 8px',\n          borderRadius: '12px',\n          backgroundColor: value ? '#D1FAE5' : '#FEE2E2',\n          color: value ? '#065F46' : '#991B1B'\n        }}>\n          {value ? 'In Stock' : 'Out of Stock'}\n        </span>\n      ),\n      width: '130px',\n      sortable: false\n    },\n    'Category'  // Simple string still works\n  ]}\n  sorting={true}\n  paging={true}\n  pageSize={20}\n  filtering={true}\n  filterFields={['Name', 'SKU', 'Category']}\n  selectionMode=\"none\"\n  onRowClick={handleRowClick}\n  onSelectionChanged={handleSelection}\n  onPageChanged={handlePageChange}\n  onSortChanged={handleSortChange}\n  onFilterChanged={handleFilterChange}\n/>",
          "namespace": "Generic/UI/Table",
          "version": "1.0.0",
          "registry": "Skip"
        },
        {
          "name": "SingleRecordView",
          "title": "Single Record View",
          "description": "Read-only component that displays a SINGLE entity record's fields in formatted, human-readable layout with metadata-driven field type formatting. Four layout modes: list (vertical label-value pairs), table (2-column), inline (horizontal compact), card (styled with border/shadow). Formats dates (short/long/relative), numbers (commas), currency ($ for Amount/Price/Cost or money type), booleans (✓ Yes / ✗ No). Supports field selection/ordering, text truncation (maxTextLength default 200), empty value handling, field highlighting. Optional OpenRecordButton integration with cancelable openRecord event. USE for: detail panels, drill-down destinations showing one record, master-detail detail views, record previews, profile pages. DO NOT USE for: multiple records/lists (use DataGrid), editable forms (read-only only), aggregated data (use charts).",
          "type": "form",
          "location": "embedded",
          "functionalRequirements": "WHEN TO USE: Displaying details of a single specific record; Master-detail detail panel showing one record; Drill-down destination for individual record inspection; Record preview or tooltip; Profile pages or detail views; Summary cards; Read-only record display. WHEN NOT TO USE: Multiple records or lists (use DataGrid instead); Editable forms (this is read-only display only); Aggregated or summary data across multiple records (use charts); Any scenario requiring more than one record. CORE FEATURES: Displays single record's fields in clean, readable format; Metadata-driven formatting based on field SQL types from entity metadata; Selective field display in specified order via fields prop (auto-detects if omitted: filters Object.keys(record) for !startsWith('__mj'), !== 'ID', typeof !== 'object'); Four layout modes: list (vertical with uppercase labels, 12px margins), table (2-column table with labelWidth prop default 150px), inline (horizontal spans with colons, 20px margins), card (wrapper with border/shadow/padding); Auto-formats by field type: dates (short: month short/day/year, long: weekday long/month long/day/year, relative: Today/Yesterday/X days-weeks-months-years ago), booleans (✓ Yes / ✗ No symbols), numbers (int/bigint → parseInt().toLocaleString()), decimals (decimal/float/money → parseFloat with 2 decimals and commas), currency (money type OR field name includes Amount/Price/Cost → Intl.NumberFormat $USD), null/empty (returns '-' or styled 'Empty' italic gray based on showEmptyFields prop); Text truncation: Strings > maxTextLength (default 200) → substring with '...' and full text in title attribute for hover; Field highlighting: Fields in highlightFields array get yellow background (#fffbe6), border (#ffe58f), padding, borderRadius; Optional OpenRecordButton integration: When allowOpenRecord=true, loads OpenRecordButton from components registry, renders button with variant/size based on layout (primary/medium for card, default/medium for table/list, link/small for inline), wires up click handler; Field click events: If onFieldClicked provided, each field gets cursor:pointer and onClick handler, fires event with {fieldName, value, fieldType, record}; Cancelable openRecord event: Creates eventData object {record, entityName, cancel: false, primaryKeys: Array<{FieldName, Value}>}, fires onOpenRecord if provided, checks eventData.cancel flag, if false calls callbacks.OpenEntityRecord(entityName, primaryKeys); Primary key extraction: Handles entityInfo.PrimaryKey as Columns array, Name property, or string, fallback to 'ID' field; Special __mj field handling: __mj_CreatedAt/UpdatedAt/DeletedAt get proper DisplayName ('Created At', 'Updated At', 'Deleted At'). LAYOUT MODES: list (vertical divs with label div and value div stacked), table (table/tbody with tr per field, td for label with labelWidth, td for value), inline (horizontal span elements with label: and value separated), card (container div with border: 1px solid #d9d9d9, borderRadius: 8px, padding: 16px, backgroundColor: #fff, boxShadow: 0 2px 4px rgba(0,0,0,0.05), renders fields inside then optional button with top border separator). Empty state: If !record, returns centered div with 'No record to display' gray text.",
          "technicalDesign": "Read-only display for single record only. React hooks: useState for entityInfo; useCallback for handleOpenRecordClick (extracts primary keys, creates cancelable eventData, fires onOpenRecord, checks cancel flag, calls OpenEntityRecord callback); useMemo for WrappedOpenRecordButton (wraps OpenRecordButton with custom click handler). Loads entity metadata from utilities.md.Entities on mount (useEffect), finds entity by Name, stores in entityInfo for field info access (Type, DisplayName). Field selection: Uses fields prop if provided; Else calls getDisplayFields: Object.keys(record).filter(key => !key.startsWith('__mj') && key !== 'ID' && typeof record[key] !== 'object') - auto-filters system fields, ID, and nested objects. Field info lookup: getFieldInfo function finds field in entityInfo.Fields array by Name, returns field object with Type/DisplayName/etc or null. Format value function (formatValue): Takes value and fieldInfo; Returns null if value null/empty AND !showEmptyFields, else returns styled 'Empty' span (color: #999, fontStyle: italic); Bit fields → value ? '✓ Yes' : '✗ No'; Datetime/date fields → try/catch Date parsing, format based on dateFormat prop: short (toLocaleDateString month: short, day: numeric, year: numeric), long (weekday: long, month: long, day: numeric, year: numeric), relative (calculates diff: 0 days→Today, 1→Yesterday, <7→X days ago, <30→X weeks ago, <365→X months ago, else→X years ago); Int/bigint → parseInt(value).toLocaleString(); Decimal/float/money → parseFloat, check if fieldInfo.Name.toLowerCase() includes 'amount'/'price'/'cost' OR Type === 'money', if yes Intl.NumberFormat USD currency style 2 decimal places, else toLocaleString 2 min/max decimals; Strings > maxTextLength → span with title={value} (full text hover), displays substring(0, maxTextLength) + '...'. Render field function (renderField): Gets fieldInfo from getFieldInfo; Gets value from record[fieldName]; Calls formatValue; Returns null if !showEmptyFields and !formattedValue; Checks if field in highlightFields array, creates highlightStyle object (backgroundColor: #fffbe6, padding: 4px 8px, borderRadius: 4px, border: 1px solid #ffe58f); Creates fieldStyle with cursor (pointer if onFieldClicked else default); Adds onClick handler if onFieldClicked (calls with fieldName, value); Layout-specific rendering: list (div with marginBottom: 12px, highlightStyle, label div with fontWeight: 500, color: #666, fontSize: 12px, marginBottom: 4px, textTransform: uppercase, value div with fontSize: 14px, color: #333), table (tr with highlightStyle, label td with fontWeight: 500, color: #666, fontSize: 14px, padding: 8px, width: labelWidth, verticalAlign: top, value td with fontSize: 14px, color: #333, padding: 8px), inline (span with marginRight: 20px, display: inline-block, highlightStyle, label span with fontWeight: 500, color: #666, fontSize: 12px, marginRight: 4px, colon separator, value span with fontSize: 14px, color: #333), card (same as list but wrapped in card container). OpenRecordButton integration: When allowOpenRecord=true, checks if OpenRecordButton exists in components registry; Creates WrappedOpenRecordButton using useMemo: Returns wrapper function (props) => div onClick handler; handleWrapperClick: e.preventDefault(), e.stopPropagation(), calls handleOpenRecordClick(props.record, props.entityName); Renders button manually (not actual OpenRecordButton to avoid its onClick): padding: 8px 16px, backgroundColor: #3B82F6, color: #fff, border: none, borderRadius: 6px, cursor: pointer, fontSize: 14px, fontWeight: 500, display: inline-flex, alignItems: center, gap: 6px, pointerEvents: none (prevents button from handling clicks), shows props.text or 'Open Record', arrow icon →; handleOpenRecordClick: Extracts primary keys from entityInfo.PrimaryKey (handles different structures: Columns array, Name property, string, fallback to ['ID']), maps to primaryKeys array [{FieldName, Value}], creates eventData {record, entityName, cancel: false, primaryKeys}, fires onOpenRecord if exists, checks eventData.cancel, if !cancel calls callbacks.OpenEntityRecord(entityName, primaryKeys); Button rendered after fields with margin/padding/border based on layout mode. Four layout render paths: card (container div with border/shadow styles, maps displayFields calling renderField, if allowOpenRecord && WrappedOpenRecordButton renders button with marginTop, paddingTop, borderTop separator), table (table with width: 100%, borderCollapse: collapse, tbody maps displayFields calling renderField, if allowOpenRecord renders button div with marginTop: 12px), inline (div with padding: 8px, lineHeight: 1.8, maps displayFields calling renderField, if allowOpenRecord renders button span with marginLeft: 20px inline-block), list default (div with padding: 8px, maps displayFields calling renderField, if allowOpenRecord renders button div with marginTop: 12px). Empty state: If !record, returns div with padding: 20px, textAlign: center, color: #999, 'No record to display' text.",
          "dataRequirements": {
            "mode": "props",
            "description": "Receives record data through props"
          },
          "properties": [
            {
              "name": "record",
              "type": "Record<string, any>",
              "description": "The entity record to display",
              "required": true
            },
            {
              "name": "entityName",
              "type": "string",
              "description": "Name of the entity for metadata lookup",
              "required": true
            },
            {
              "name": "fields",
              "type": "Array<string>",
              "description": "Fields to display in order. If not provided, shows all non-system fields",
              "required": false
            },
            {
              "name": "layout",
              "type": "'list' | 'table' | 'inline' | 'card'",
              "description": "Display layout style",
              "required": false,
              "defaultValue": "list",
              "possibleValues": [
                "list",
                "table",
                "inline",
                "card"
              ]
            },
            {
              "name": "showLabels",
              "type": "boolean",
              "description": "Whether to show field labels",
              "required": false,
              "defaultValue": true
            },
            {
              "name": "labelWidth",
              "type": "number",
              "description": "Width of label column in pixels (table layout)",
              "required": false,
              "defaultValue": 150
            },
            {
              "name": "dateFormat",
              "type": "'short' | 'long' | 'relative'",
              "description": "Date formatting style",
              "required": false,
              "defaultValue": "short",
              "possibleValues": [
                "short",
                "long",
                "relative"
              ]
            },
            {
              "name": "showEmptyFields",
              "type": "boolean",
              "description": "Whether to show fields with no value",
              "required": false,
              "defaultValue": false
            },
            {
              "name": "maxTextLength",
              "type": "number",
              "description": "Maximum characters for text fields before truncation",
              "required": false,
              "defaultValue": 200
            },
            {
              "name": "highlightFields",
              "type": "Array<string>",
              "description": "Fields to highlight visually",
              "required": false
            },
            {
              "name": "allowOpenRecord",
              "type": "boolean",
              "description": "Whether to show an Open Record button for the record",
              "required": false,
              "defaultValue": false
            }
          ],
          "events": [
            {
              "name": "fieldClicked",
              "description": "Fired when a field value is clicked",
              "parameters": [
                {
                  "name": "eventData",
                  "type": "{ fieldName: string; value: any; fieldType?: string; record: Record<string, any> }",
                  "description": "Object containing field name, value, optional field type, and the full record"
                }
              ]
            },
            {
              "name": "openRecord",
              "description": "Cancelable event fired before opening a record. Set eventData.cancel = true to prevent default behavior",
              "cancelable": true,
              "parameters": [
                {
                  "name": "eventData",
                  "type": "{ record: Record<string, any>; entityName: string; cancel: boolean; primaryKeys: Array<{ FieldName: string; Value: any }> }",
                  "description": "Cancelable event object. Set cancel to true to prevent the record from opening"
                }
              ]
            }
          ],
          "dependencies": [
            {
              "name": "OpenRecordButton",
              "title": "Open Record Button",
              "description": "A simple button component that intelligently opens entity records using metadata to determine primary keys",
              "type": "navigation",
              "location": "embedded",
              "functionalRequirements": "Button that opens entity records using metadata-determined primary keys. Requires only entity name and record object. Auto-detects single/composite primary keys from metadata, extracts values from record. Configurable text, style, size. Uses: grid row actions, record cards, drill-down navigation, dashboard quick links.",
              "technicalDesign": "Looks up entity in utilities.md.Entities → finds primary key fields → extracts values from record → calls OpenEntityRecord with field/value pairs. Handles single and composite keys automatically. Minimal props: just entityName and record. Error handling for missing metadata or key values.",
              "dataRequirements": {
                "mode": "props",
                "description": "Receives record data through props, uses metadata for key information"
              },
              "properties": [
                {
                  "name": "record",
                  "type": "Record<string, any>",
                  "description": "The entity record to open (must contain primary key fields)",
                  "required": true
                },
                {
                  "name": "entityName",
                  "type": "string",
                  "description": "Name of the entity (used to look up metadata)",
                  "required": true
                },
                {
                  "name": "text",
                  "type": "string",
                  "description": "Button text",
                  "required": false,
                  "defaultValue": "Open Record"
                },
                {
                  "name": "variant",
                  "type": "'primary' | 'default' | 'text' | 'link'",
                  "description": "Button style variant",
                  "required": false,
                  "defaultValue": "default",
                  "possibleValues": [
                    "primary",
                    "default",
                    "text",
                    "link"
                  ]
                },
                {
                  "name": "size",
                  "type": "'small' | 'medium' | 'large'",
                  "description": "Button size",
                  "required": false,
                  "defaultValue": "medium",
                  "possibleValues": [
                    "small",
                    "medium",
                    "large"
                  ]
                },
                {
                  "name": "icon",
                  "type": "string",
                  "description": "Icon to show (emoji or unicode)",
                  "required": false,
                  "defaultValue": "📂"
                },
                {
                  "name": "showIcon",
                  "type": "boolean",
                  "description": "Whether to show the icon",
                  "required": false,
                  "defaultValue": true
                },
                {
                  "name": "fullWidth",
                  "type": "boolean",
                  "description": "Whether button takes full width",
                  "required": false,
                  "defaultValue": false
                }
              ],
              "events": [
                {
                  "name": "recordOpened",
                  "description": "Fired after record is successfully opened",
                  "parameters": [
                    {
                      "name": "record",
                      "type": "Record<string, any>",
                      "description": "The opened record"
                    },
                    {
                      "name": "entityName",
                      "type": "string",
                      "description": "Entity name"
                    },
                    {
                      "name": "primaryKeys",
                      "type": "Array<{ FieldName: string; Value: any }>",
                      "description": "Primary key field/value pairs used to open"
                    }
                  ]
                }
              ],
              "dependencies": [],
              "code": "function OpenRecordButton({\n  record,\n  entityName,\n  text = 'Open Record',\n  variant = 'default',\n  size = 'medium',\n  icon,\n  showIcon = false,\n  fullWidth = false,\n  onRecordOpened,\n  utilities,\n  styles,\n  components,\n  callbacks,\n  savedUserSettings,\n  onSaveUserSettings\n}) {\n  // State for button interaction\n  const [isHovered, setIsHovered] = React.useState(false);\n  const [primaryKeyFields, setPrimaryKeyFields] = React.useState([]);\n  const [entityInfo, setEntityInfo] = React.useState(null);\n  \n  // Load entity metadata and determine primary key fields\n  React.useEffect(() => {\n    if (!entityName || !utilities?.md?.Entities) {\n      if (!entityName) console.error('Entity name not provided');\n      if (!utilities?.md?.Entities) console.error('Entity metadata not loaded.');\n      return;\n    }\n    \n    // Find the entity in metadata\n    const entity = utilities.md.Entities.find(e => e.Name === entityName);\n    if (entity) {\n      setEntityInfo(entity);\n      \n      // Get primary key fields from the entity object\n      // The entity has a PrimaryKeys property that returns an array of primary key fields\n      const keyFields = [];\n      \n      if (entity.PrimaryKeys && entity.PrimaryKeys.length > 0) {\n        // Use the PrimaryKeys property from the entity\n        entity.PrimaryKeys.forEach(field => {\n          keyFields.push({\n            FieldName: field.Name,\n            DisplayName: field.DisplayName || field.Name\n          });\n        });\n      } else if (entity.FirstPrimaryKey) {\n        // Fallback to FirstPrimaryKey if available\n        keyFields.push({\n          FieldName: entity.FirstPrimaryKey.Name,\n          DisplayName: entity.FirstPrimaryKey.DisplayName || entity.FirstPrimaryKey.Name\n        });\n      } else {\n        // Final fallback to ID field\n        keyFields.push({\n          FieldName: 'ID',\n          DisplayName: 'ID'\n        });\n      }\n      \n      setPrimaryKeyFields(keyFields);\n    }\n  }, [entityName, utilities]);\n  \n  // Check if we can open the record\n  const canOpen = React.useMemo(() => {\n    if (!record || !entityName || !callbacks?.OpenEntityRecord) return false;\n    if (primaryKeyFields.length === 0) return false;\n    \n    // Check that all primary key fields have values\n    for (const keyField of primaryKeyFields) {\n      if (!record[keyField.FieldName]) {\n        return false;\n      }\n    }\n    \n    return true;\n  }, [record, entityName, callbacks, primaryKeyFields]);\n  \n  // Handle button click\n  const handleClick = () => {\n    if (!canOpen) return;\n    \n    try {\n      // Build the key-value pairs for OpenEntityRecord\n      const keyValues = primaryKeyFields.map(keyField => ({\n        FieldName: keyField.FieldName,\n        Value: record[keyField.FieldName]\n      }));\n      \n      // Use MJ's OpenEntityRecord callback with the primary key fields\n      callbacks.OpenEntityRecord(entityName, keyValues);\n      \n      // Fire event with details\n      if (onRecordOpened) {\n        onRecordOpened({ \n          record, \n          entityName,\n          primaryKeys: keyValues\n        });\n      }\n      \n      // Log opening action\n      console.log(`Opening ${entityName}`);\n    } catch (err) {\n      console.error('[OpenRecordButton] Error opening record:', err);\n    }\n  };\n  \n  // Button styles based on variant and size\n  const getButtonStyles = () => {\n    const baseStyles = {\n      display: 'inline-flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n      gap: '6px',\n      border: 'none',\n      borderRadius: '4px',\n      cursor: canOpen ? 'pointer' : 'not-allowed',\n      transition: 'all 0.3s ease',\n      fontFamily: 'inherit',\n      width: fullWidth ? '100%' : 'auto',\n      opacity: canOpen ? 1 : 0.5\n    };\n    \n    // Size styles\n    const sizeStyles = {\n      small: {\n        padding: '4px 8px',\n        fontSize: '12px'\n      },\n      medium: {\n        padding: '6px 12px',\n        fontSize: '14px'\n      },\n      large: {\n        padding: '8px 16px',\n        fontSize: '16px'\n      }\n    };\n    \n    // Variant styles\n    const variantStyles = {\n      primary: {\n        backgroundColor: '#1890ff',\n        color: '#fff',\n        boxShadow: '0 2px 4px rgba(0,0,0,0.1)'\n      },\n      default: {\n        backgroundColor: '#3B82F6',\n        color: '#fff',\n        border: 'none'\n      },\n      text: {\n        backgroundColor: 'transparent',\n        color: '#1890ff',\n        padding: '2px 4px'\n      },\n      link: {\n        backgroundColor: 'transparent',\n        color: '#1890ff',\n        textDecoration: 'underline',\n        padding: '0'\n      }\n    };\n    \n    return {\n      ...baseStyles,\n      ...sizeStyles[size],\n      ...variantStyles[variant]\n    };\n  };\n  \n  // Hover styles\n  const getHoverStyles = () => {\n    if (!canOpen || !isHovered) return {};\n    \n    const hoverStyles = {\n      primary: {\n        backgroundColor: '#40a9ff'\n      },\n      default: {\n        backgroundColor: '#2563EB'\n      },\n      text: {\n        backgroundColor: '#f0f5ff'\n      },\n      link: {\n        color: '#40a9ff'\n      }\n    };\n    \n    return hoverStyles[variant] || {};\n  };\n  \n  // Combined styles\n  const buttonStyles = {\n    ...getButtonStyles(),\n    ...getHoverStyles()\n  };\n  \n  // Tooltip text\n  const getTooltipText = () => {\n    if (!record) return 'No record selected';\n    if (!entityName) return 'Entity name not provided';\n    if (!entityInfo) return `Entity '${entityName}' not found in metadata`;\n    if (primaryKeyFields.length === 0) return 'No primary key fields found';\n    \n    // Check for missing key values\n    for (const keyField of primaryKeyFields) {\n      if (!record[keyField.FieldName]) {\n        return `Missing value for primary key field: ${keyField.DisplayName}`;\n      }\n    }\n    \n    // Build descriptive text\n    const displayValue = record.Name || record.Title || record.DisplayName || \n                        primaryKeyFields.map(kf => record[kf.FieldName]).join('-');\n    return `Open ${entityName}: ${displayValue}`;\n  };\n  \n  return (\n    <button\n      onClick={handleClick}\n      disabled={!canOpen}\n      style={buttonStyles}\n      onMouseEnter={() => setIsHovered(true)}\n      onMouseLeave={() => setIsHovered(false)}\n      title={getTooltipText()}\n      aria-label={`Open ${entityName} record`}\n    >\n      {showIcon && icon && (\n        <span style={{ fontSize: size === 'small' ? '14px' : size === 'large' ? '18px' : '16px' }}>\n          {icon}\n        </span>\n      )}\n      <span>{text}</span>\n      <span style={{ fontSize: '14px', marginLeft: '4px' }}>↗</span>\n    </button>\n  );\n}",
              "exampleUsage": "<OpenRecordButton\n  record={selectedDeal}\n  entityName=\"Deals\"\n  text=\"View Deal\"\n  variant=\"primary\"\n/>",
              "namespace": "Generic/Navigation",
              "version": "1.0.0",
              "registry": "Skip"
            }
          ],
          "code": "function SingleRecordView({\n  record,\n  entityName,\n  fields,\n  layout = 'list',\n  showLabels = true,\n  labelWidth = 150,\n  dateFormat = 'short',\n  showEmptyFields = false,\n  maxTextLength = 200,\n  highlightFields = [],\n  allowOpenRecord = false,\n  onFieldClicked,\n  onOpenRecord,\n  utilities,\n  styles,\n  components,\n  callbacks,\n  savedUserSettings,\n  onSaveUserSettings\n}) {\n  const [entityInfo, setEntityInfo] = React.useState(null);\n  \n  // Get OpenRecordButton component from registry if needed\n  const OpenRecordButton = allowOpenRecord ? components?.['OpenRecordButton'] : null;\n  \n  // Handle open record button click with cancelable event - moved outside useMemo\n  const handleOpenRecordClick = React.useCallback((recordToOpen, entityNameToOpen) => {\n    console.log('handleOpenRecordClick called for:', entityNameToOpen, recordToOpen);\n    \n    // Get primary keys from entity metadata\n    let primaryKeys = [];\n    if (entityInfo) {\n      // Handle different PrimaryKey structures in MJ metadata\n      let primaryKeyFields = [];\n      \n      if (entityInfo.PrimaryKey) {\n        if (entityInfo.PrimaryKey.Columns && Array.isArray(entityInfo.PrimaryKey.Columns)) {\n          // Multi-column primary key\n          primaryKeyFields = entityInfo.PrimaryKey.Columns;\n        } else if (entityInfo.PrimaryKey.Name) {\n          // Single column primary key with Name property\n          primaryKeyFields = [entityInfo.PrimaryKey.Name];\n        } else if (typeof entityInfo.PrimaryKey === 'string') {\n          // Primary key as string\n          primaryKeyFields = [entityInfo.PrimaryKey];\n        }\n      }\n      \n      // Fallback to ID if no primary key found\n      if (primaryKeyFields.length === 0) {\n        primaryKeyFields = ['ID'];\n      }\n      \n      primaryKeys = primaryKeyFields.map(fieldName => ({\n        FieldName: fieldName,\n        Value: recordToOpen[fieldName]\n      }));\n    }\n    \n    // Create cancelable event object\n    const eventData = {\n      record: recordToOpen,\n      entityName: entityNameToOpen,\n      cancel: false, // Parent can set this to true to cancel\n      primaryKeys // Populated with actual primary key values\n    };\n    \n    // Fire the event if handler exists\n    if (onOpenRecord) {\n      onOpenRecord(eventData);\n    }\n    \n    // Check if the event was canceled\n    if (eventData.cancel) {\n      return false; // Return false to prevent default action\n    }\n    \n    // If not canceled (or no handler), proceed with default behavior\n    // Call the OpenEntityRecord callback directly\n    if (callbacks && callbacks.OpenEntityRecord && primaryKeys.length > 0) {\n      callbacks.OpenEntityRecord(entityNameToOpen, primaryKeys);\n    } else {\n      console.error('Unable to open record - missing callback or primary keys', {\n        hasCallbacks: !!callbacks,\n        hasOpenEntityRecord: !!(callbacks && callbacks.OpenEntityRecord),\n        primaryKeysLength: primaryKeys.length\n      });\n    }\n    \n    return true;\n  }, [entityInfo, onOpenRecord, callbacks]);\n  \n  // Create wrapped OpenRecordButton with intercepted click\n  const WrappedOpenRecordButton = React.useMemo(() => {\n    if (!OpenRecordButton) return null;\n    \n    return (props) => {\n      const handleWrapperClick = (e) => {\n        // Stop all propagation first\n        e.preventDefault();\n        e.stopPropagation();\n        \n        // Call the centralized handler\n        handleOpenRecordClick(props.record, props.entityName);\n      };\n      \n      return (\n        <div \n          onClick={handleWrapperClick} \n          style={{ \n            display: 'inline-block',\n            cursor: 'pointer'\n          }}\n        >\n          {/* Render a button that looks like OpenRecordButton but doesn't have onClick */}\n          <button\n            style={{\n              padding: '8px 16px',\n              backgroundColor: '#3B82F6',\n              color: '#fff',\n              border: 'none',\n              borderRadius: '6px',\n              cursor: 'pointer',\n              fontSize: '14px',\n              fontWeight: '500',\n              display: 'inline-flex',\n              alignItems: 'center',\n              gap: '6px',\n              transition: 'none',\n              pointerEvents: 'none' // Prevent button from handling clicks\n            }}\n          >\n            {props.text || 'Open Record'}\n            <span style={{ fontSize: '14px' }}>↗</span>\n          </button>\n        </div>\n      );\n    };\n  }, [OpenRecordButton, handleOpenRecordClick]);\n  \n  // Load entity metadata\n  React.useEffect(() => {\n    if (!entityName || !utilities?.md?.Entities) return;\n    \n    const entity = utilities.md.Entities.find(e => e.Name === entityName);\n    if (entity) {\n      setEntityInfo(entity);\n    }\n  }, [entityName, utilities]);\n  \n  // Format value based on field type\n  const formatValue = (value, fieldInfo) => {\n    if (value == null || value === '') {\n      return showEmptyFields ? <span style={{ color: '#999', fontStyle: 'italic' }}>Empty</span> : null;\n    }\n    \n    // Handle different field types\n    if (fieldInfo) {\n      // Boolean fields\n      if (fieldInfo.Type === 'bit') {\n        return value ? '✓ Yes' : '✗ No';\n      }\n      \n      // Date fields\n      if (fieldInfo.Type === 'datetime' || fieldInfo.Type === 'date') {\n        try {\n          const date = new Date(value);\n          if (isNaN(date.getTime())) return value;\n          \n          if (dateFormat === 'long') {\n            return date.toLocaleDateString('en-US', { \n              weekday: 'long', \n              year: 'numeric', \n              month: 'long', \n              day: 'numeric' \n            });\n          } else if (dateFormat === 'relative') {\n            const now = new Date();\n            const diff = now - date;\n            const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n            if (days === 0) return 'Today';\n            if (days === 1) return 'Yesterday';\n            if (days < 7) return `${days} days ago`;\n            if (days < 30) return `${Math.floor(days / 7)} weeks ago`;\n            if (days < 365) return `${Math.floor(days / 30)} months ago`;\n            return `${Math.floor(days / 365)} years ago`;\n          } else {\n            return date.toLocaleDateString('en-US', { \n              year: 'numeric', \n              month: 'short', \n              day: 'numeric' \n            });\n          }\n        } catch {\n          return value;\n        }\n      }\n      \n      // Number fields\n      if (fieldInfo.Type === 'int' || fieldInfo.Type === 'bigint') {\n        return parseInt(value).toLocaleString();\n      }\n      \n      // Decimal/currency fields\n      if (fieldInfo.Type === 'decimal' || fieldInfo.Type === 'float' || fieldInfo.Type === 'money') {\n        const num = parseFloat(value);\n        // Check if field name suggests currency\n        if (fieldInfo.Name.toLowerCase().includes('amount') || \n            fieldInfo.Name.toLowerCase().includes('price') ||\n            fieldInfo.Name.toLowerCase().includes('cost') ||\n            fieldInfo.Type === 'money') {\n          return new Intl.NumberFormat('en-US', {\n            style: 'currency',\n            currency: 'USD',\n            minimumFractionDigits: 2,\n            maximumFractionDigits: 2\n          }).format(num);\n        }\n        return num.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n      }\n    }\n    \n    // Text fields - truncate if needed\n    if (typeof value === 'string' && value.length > maxTextLength) {\n      return (\n        <span title={value}>\n          {value.substring(0, maxTextLength)}...\n        </span>\n      );\n    }\n    \n    return value;\n  };\n  \n  // Get fields to display\n  const getDisplayFields = () => {\n    if (fields && fields.length > 0) {\n      return fields;\n    }\n    \n    // Auto-select fields if not specified\n    if (!record) return [];\n    \n    return Object.keys(record).filter(key => \n      !key.startsWith('__mj') && \n      key !== 'ID' &&\n      typeof record[key] !== 'object'\n    );\n  };\n  \n  // Get field info from entity\n  const getFieldInfo = (fieldName) => {\n    if (!entityInfo || !entityInfo.Fields) return null;\n    return entityInfo.Fields.find(f => f.Name === fieldName);\n  };\n  \n  // Handle field click\n  const handleFieldClick = (fieldName, value) => {\n    if (onFieldClicked) {\n      const fieldInfo = getFieldInfo(fieldName);\n      onFieldClicked({ \n        fieldName, \n        value, \n        fieldType: fieldInfo?.Type,\n        record \n      });\n    }\n  };\n  \n  \n  // Render field based on layout\n  const renderField = (fieldName) => {\n    const fieldInfo = getFieldInfo(fieldName);\n    const value = record[fieldName];\n    const formattedValue = formatValue(value, fieldInfo);\n    \n    if (!showEmptyFields && !formattedValue) return null;\n    \n    const isHighlighted = highlightFields.includes(fieldName);\n    const label = fieldInfo?.DisplayName || fieldName;\n    \n    const fieldStyle = {\n      cursor: onFieldClicked ? 'pointer' : 'default'\n    };\n    \n    const highlightStyle = isHighlighted ? {\n      backgroundColor: '#fffbe6',\n      padding: '4px 8px',\n      borderRadius: '4px',\n      border: '1px solid #ffe58f'\n    } : {};\n    \n    if (layout === 'list' \n        || layout === 'card') {\n      return (\n        <div \n          key={fieldName}\n          style={{ \n            marginBottom: '12px',\n            ...highlightStyle\n          }}\n          onClick={() => handleFieldClick(fieldName, value)}\n        >\n          {showLabels && (\n            <div style={{ \n              fontWeight: 500, \n              color: '#666', \n              fontSize: '12px',\n              marginBottom: '4px',\n              textTransform: 'uppercase'\n            }}>\n              {label}\n            </div>\n          )}\n          <div style={{ \n            fontSize: '14px', \n            color: '#333',\n            ...fieldStyle\n          }}>\n            {formattedValue || '-'}\n          </div>\n        </div>\n      );\n    }\n    \n    if (layout === 'table') {\n      return (\n        <tr \n          key={fieldName}\n          style={highlightStyle}\n          onClick={() => handleFieldClick(fieldName, value)}\n        >\n          {showLabels && (\n            <td style={{ \n              fontWeight: 500, \n              color: '#666', \n              fontSize: '14px',\n              padding: '8px',\n              width: labelWidth,\n              verticalAlign: 'top'\n            }}>\n              {label}\n            </td>\n          )}\n          <td style={{ \n            fontSize: '14px', \n            color: '#333',\n            padding: '8px',\n            ...fieldStyle\n          }}>\n            {formattedValue || '-'}\n          </td>\n        </tr>\n      );\n    }\n    \n    if (layout === 'inline') {\n      return (\n        <span \n          key={fieldName}\n          style={{ \n            marginRight: '20px',\n            display: 'inline-block',\n            ...highlightStyle\n          }}\n          onClick={() => handleFieldClick(fieldName, value)}\n        >\n          {showLabels && (\n            <span style={{ \n              fontWeight: 500, \n              color: '#666', \n              fontSize: '12px',\n              marginRight: '4px'\n            }}>\n              {label}:\n            </span>\n          )}\n          <span style={{ \n            fontSize: '14px', \n            color: '#333',\n            ...fieldStyle\n          }}>\n            {formattedValue || '-'}\n          </span>\n        </span>\n      );\n    }\n    \n    return null;\n  };\n  \n  // No record provided\n  if (!record) {\n    return (\n      <div style={{ \n        padding: '20px', \n        textAlign: 'center', \n        color: '#999' \n      }}>\n        No record to display\n      </div>\n    );\n  }\n  \n  const displayFields = getDisplayFields();\n  \n  // Render based on layout\n  if (layout === 'card') {\n    return (\n      <div style={{\n        border: '1px solid #d9d9d9',\n        borderRadius: '8px',\n        padding: '16px',\n        backgroundColor: '#fff',\n        boxShadow: '0 2px 4px rgba(0,0,0,0.05)'\n      }}>\n        {displayFields.map(renderField)}\n        {allowOpenRecord && WrappedOpenRecordButton && (\n          <div style={{ marginTop: '16px', paddingTop: '16px', borderTop: '1px solid #f0f0f0' }}>\n            <WrappedOpenRecordButton\n              record={record}\n              entityName={entityName}\n              variant=\"primary\"\n              size=\"medium\"\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings}\n              onSaveUserSettings={onSaveUserSettings}\n            />\n          </div>\n        )}\n      </div>\n    );\n  }\n  \n  if (layout === 'table') {\n    return (\n      <div>\n        <table style={{\n          width: '100%',\n          borderCollapse: 'collapse'\n        }}>\n          <tbody>\n            {displayFields.map(renderField)}\n          </tbody>\n        </table>\n        {allowOpenRecord && WrappedOpenRecordButton && (\n          <div style={{ marginTop: '12px' }}>\n            <WrappedOpenRecordButton\n              record={record}\n              entityName={entityName}\n              variant=\"default\"\n              size=\"medium\"\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings}\n              onSaveUserSettings={onSaveUserSettings}\n            />\n          </div>\n        )}\n      </div>\n    );\n  }\n  \n  if (layout === 'inline') {\n    return (\n      <div style={{\n        padding: '8px',\n        lineHeight: '1.8'\n      }}>\n        {displayFields.map(renderField)}\n        {allowOpenRecord && WrappedOpenRecordButton && (\n          <span style={{ marginLeft: '20px', display: 'inline-block' }}>\n            <WrappedOpenRecordButton\n              record={record}\n              entityName={entityName}\n              variant=\"link\"\n              size=\"small\"\n              utilities={utilities}\n              styles={styles}\n              components={components}\n              callbacks={callbacks}\n              savedUserSettings={savedUserSettings}\n              onSaveUserSettings={onSaveUserSettings}\n            />\n          </span>\n        )}\n      </div>\n    );\n  }\n  \n  // Default list layout\n  return (\n    <div style={{ padding: '8px' }}>\n      {displayFields.map(renderField)}\n      {allowOpenRecord && OpenRecordButton && (\n        <div style={{ marginTop: '12px' }}>\n          <OpenRecordButton\n            record={record}\n            entityName={entityName}\n            variant=\"default\"\n            size=\"medium\"\n            utilities={utilities}\n            styles={styles}\n            components={components}\n            callbacks={callbacks}\n            savedUserSettings={savedUserSettings}\n            onSaveUserSettings={onSaveUserSettings}\n          />\n        </div>\n      )}\n    </div>\n  );\n}",
          "exampleUsage": "<SingleRecordView\n  record={selectedDeal}\n  entityName=\"Deals\"\n  fields={['DealName', 'Stage', 'Amount', 'CloseDate', 'OwnerID']}\n  layout=\"card\"\n  highlightFields={['Amount', 'Stage']}\n  allowOpenRecord={true}\n  onOpenRecord={(eventData) => {\n    // Example: Cancel if deal is in certain stage\n    if (selectedDeal.Stage === 'Lost') {\n      eventData.cancel = true;\n      alert('Cannot open lost deals');\n    }\n  }}\n/>",
          "namespace": "Generic/UI/Form",
          "version": "1.0.0",
          "registry": "Skip"
        }
      ],
      "code": "function SimpleDrilldownChart({\n  data,\n  groupBy,\n  valueField,\n  aggregateMethod = 'count',\n  chartType = 'auto',\n  title,\n  gridFields,\n  entityName,\n  entityPrimaryKeys,\n  showDrilldown = true,\n  drilldownHeight = 300,\n  showSingleRecordView = false,\n  singleRecordViewFields,\n  onSegmentSelected,\n  onSelectionCleared,\n  onDataPointClick,\n  onRowSelected,\n  utilities,\n  styles,\n  components,\n  callbacks,\n  savedUserSettings,\n  onSaveUserSettings\n}) {\n  // State for drill-down\n  const [selectedSegment, setSelectedSegment] = React.useState(null);\n  const [showGrid, setShowGrid] = React.useState(false);\n  const [selectedRecord, setSelectedRecord] = React.useState(null);\n  \n  // Get components from registry\n  const { SimpleChart, DataGrid, SingleRecordView } = components;\n  \n  // Handle chart click\n  const handleChartClick = (clickData) => {\n    // Always bubble up the chart click event\n    if (onDataPointClick) {\n      onDataPointClick(clickData);\n    }\n    \n    if (!showDrilldown) return;\n    \n    // Set selected segment\n    setSelectedSegment(clickData);\n    setShowGrid(true);\n    setSelectedRecord(null); // Clear any selected record when new segment is selected\n    \n    // Fire segment selected event\n    if (onSegmentSelected) {\n      onSegmentSelected({ segment: clickData });\n    }\n  };\n  \n  // Clear selection\n  const handleClearSelection = () => {\n    setSelectedSegment(null);\n    setShowGrid(false);\n    setSelectedRecord(null);\n    \n    if (onSelectionCleared) {\n      onSelectionCleared();\n    }\n  };\n  \n  // Handle row selection in grid\n  const handleRowClick = (event) => {\n    // event has shape: { record: object, cancel: boolean }\n    setSelectedRecord(event.record);\n\n    // Bubble up the row selection event\n    if (onRowSelected) {\n      onRowSelected({\n        record: event.record,\n        segment: selectedSegment\n      });\n    }\n\n    // Don't prevent default OpenEntityRecord behavior\n    // (leave event.cancel as false to allow DataGrid to open record if entityPrimaryKeys provided)\n  };\n  \n  // Filter data for selected segment\n  const getDrilldownData = () => {\n    if (!selectedSegment || !selectedSegment.records) {\n      return [];\n    }\n    return selectedSegment.records;\n  };\n  \n  // Determine which fields to show in grid\n  const getGridFields = () => {\n    if (gridFields && gridFields.length > 0) {\n      return gridFields;\n    }\n    \n    // Auto-detect fields from first record\n    const records = getDrilldownData();\n    if (records.length > 0) {\n      const firstRecord = records[0];\n      return Object.keys(firstRecord).filter(key => \n        !key.startsWith('__mj') && \n        key !== 'ID' &&\n        typeof firstRecord[key] !== 'object'\n      ).slice(0, 10); // Limit to 10 fields\n    }\n    \n    return [];\n  };\n  \n  return (\n    <div style={{ width: '100%' }}>\n      {/* Chart Section */}\n      <div style={{ \n        width: '100%',\n        border: selectedSegment ? '2px solid #1890ff' : 'none',\n        borderRadius: '8px',\n        padding: selectedSegment ? '2px' : '0',\n        transition: 'all 0.3s ease'\n      }}>\n        <SimpleChart\n          entityName={entityName}\n          data={data}\n          groupBy={groupBy}\n          valueField={valueField}\n          aggregateMethod={aggregateMethod}\n          chartType={chartType}\n          title={title || `${entityName} by ${groupBy}`}\n          onDataPointClick={handleChartClick}\n          utilities={utilities}\n          styles={styles}\n          components={components}\n          callbacks={callbacks}\n          savedUserSettings={savedUserSettings}\n          onSaveUserSettings={onSaveUserSettings}\n        />\n      </div>\n      \n      {/* Selection Info Bar */}\n      {showDrilldown && selectedSegment && (\n        <div style={{\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          padding: '12px 16px',\n          backgroundColor: '#f0f5ff',\n          borderLeft: '4px solid #1890ff',\n          marginTop: '16px',\n          borderRadius: '4px'\n        }}>\n          <div style={{ display: 'flex', alignItems: 'center', gap: '20px' }}>\n            <div>\n              <strong style={{ color: '#333' }}>Selected:</strong>{' '}\n              <span style={{ color: '#1890ff', fontWeight: 600 }}>\n                {selectedSegment.label}\n              </span>\n            </div>\n            <div>\n              <strong style={{ color: '#333' }}>Value:</strong>{' '}\n              <span style={{ color: '#52c41a', fontWeight: 600 }}>\n                {typeof selectedSegment.value === 'number' \n                  ? selectedSegment.value.toLocaleString()\n                  : selectedSegment.value}\n              </span>\n            </div>\n            <div>\n              <strong style={{ color: '#333' }}>Records:</strong>{' '}\n              <span style={{ color: '#666', fontWeight: 600 }}>\n                {selectedSegment.records?.length || 0}\n              </span>\n            </div>\n            {selectedSegment.percentage != null && (\n              <div>\n                <strong style={{ color: '#333' }}>Percentage:</strong>{' '}\n                <span style={{ color: '#722ed1', fontWeight: 600 }}>\n                  {selectedSegment.percentage.toFixed(1)}%\n                </span>\n              </div>\n            )}\n          </div>\n          <button\n            onClick={handleClearSelection}\n            style={{\n              padding: '6px 12px',\n              backgroundColor: '#fff',\n              border: '1px solid #d9d9d9',\n              borderRadius: '4px',\n              cursor: 'pointer',\n              fontSize: '14px',\n              color: '#333',\n              transition: 'all 0.3s'\n            }}\n            onMouseEnter={(e) => {\n              e.target.style.borderColor = '#1890ff';\n              e.target.style.color = '#1890ff';\n            }}\n            onMouseLeave={(e) => {\n              e.target.style.borderColor = '#d9d9d9';\n              e.target.style.color = '#333';\n            }}\n          >\n            ✕ Clear Selection\n          </button>\n        </div>\n      )}\n      \n      {/* Drill-down Grid */}\n      {showDrilldown && showGrid && selectedSegment && (\n        <div style={{\n          marginTop: '16px',\n          display: showSingleRecordView && selectedRecord ? 'flex' : 'block',\n          gap: '16px'\n        }}>\n          {/* Grid Section */}\n          <div style={{\n            flex: showSingleRecordView && selectedRecord ? '1 1 60%' : '1',\n            height: drilldownHeight,\n            overflow: 'auto',\n            border: '1px solid #d9d9d9',\n            borderRadius: '4px',\n            animation: 'slideDown 0.3s ease'\n          }}>\n            {DataGrid ? (\n              <DataGrid\n                data={getDrilldownData()}\n                entityName={entityName}\n                entityPrimaryKeys={entityPrimaryKeys}\n                columns={getGridFields()}\n                sorting={true}\n                paging={true}\n                pageSize={10}\n                filtering={true}\n                onRowClick={showSingleRecordView ? handleRowClick : undefined}\n                highlightedRow={selectedRecord}\n                utilities={utilities}\n                styles={styles}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings}\n                onSaveUserSettings={onSaveUserSettings}\n              />\n            ) : (\n              <div style={{ \n                padding: '20px', \n                textAlign: 'center',\n                color: '#ff4d4f'\n              }}>\n                Error: DataGrid component not found. Please ensure DataGrid is properly registered.\n              </div>\n            )}\n          </div>\n          \n          {/* Single Record View */}\n          {showSingleRecordView && selectedRecord && SingleRecordView && (\n            <div style={{\n              flex: '1 1 40%',\n              height: drilldownHeight,\n              overflow: 'auto',\n              border: '1px solid #d9d9d9',\n              borderRadius: '4px',\n              padding: '16px',\n              backgroundColor: '#fafafa',\n              animation: 'slideIn 0.3s ease'\n            }}>\n              <SingleRecordView\n                record={selectedRecord}\n                entityName={entityName}\n                fields={singleRecordViewFields}\n                layout=\"list\"\n                showLabels={true}\n                allowOpenRecord={true}\n                utilities={utilities}\n                styles={styles}\n                components={components}\n                callbacks={callbacks}\n                savedUserSettings={savedUserSettings}\n                onSaveUserSettings={onSaveUserSettings}\n              />\n            </div>\n          )}\n        </div>\n      )}\n      \n      {/* Animation keyframes */}\n      <style>{`\n        @keyframes slideDown {\n          from {\n            opacity: 0;\n            transform: translateY(-10px);\n          }\n          to {\n            opacity: 1;\n            transform: translateY(0);\n          }\n        }\n        \n        @keyframes slideIn {\n          from {\n            opacity: 0;\n            transform: translateX(10px);\n          }\n          to {\n            opacity: 1;\n            transform: translateX(0);\n          }\n        }\n      `}</style>\n    </div>\n  );\n}",
      "exampleUsage": "<SimpleDrilldownChart\n  entityName=\"Invoice Line Items\"\n  data={invoiceItems}\n  groupBy=\"ProductCategory\"\n  valueField=\"TotalAmount\"\n  aggregateMethod=\"sum\"\n  chartType=\"bar\"\n  title=\"Revenue by Category - Click to drill down\"\n  gridFields={['ProductName', 'Quantity', 'TotalAmount', 'InvoiceDate']}\n  entityPrimaryKeys={['ID']}\n  showSingleRecordView={false}\n  onDataPointClick={handleChartClick}\n/>\n\n<!-- With SingleRecordView instead of OpenEntityRecord -->\n<SimpleDrilldownChart\n  entityName=\"Invoice Line Items\"\n  data={invoiceItems}\n  groupBy=\"ProductCategory\"\n  valueField=\"TotalAmount\"\n  aggregateMethod=\"sum\"\n  chartType=\"bar\"\n  title=\"Revenue by Category - Click to drill down\"\n  gridFields={['ProductName', 'Quantity', 'TotalAmount', 'InvoiceDate']}\n  showSingleRecordView={true}\n  singleRecordViewFields={['ProductName', 'Description', 'Quantity', 'UnitPrice', 'TotalAmount']}\n  onDataPointClick={handleChartClick}\n  onRowSelected={handleRowSelection}\n/>",
      "namespace": "Generic/UI/Chart",
      "version": "1.0.0",
      "registry": "Skip"
    }
  ],
  "exampleUsage": "<MembershipTypeChart />",
  "events": [
    {
      "name": "onChartSegmentClick",
      "description": "Raised by the root component when a chart segment is clicked; forwards the MembershipTypeID to parent consumers.",
      "parameters": [
        {
          "name": "membershipTypeId",
          "type": "string",
          "description": "GUID of the membership type that was selected."
        }
      ]
    }
  ],
  "relevantExamples": [
    {
      "name": "AccountsByIndustry",
      "namespace": "CRM/Analytics",
      "version": "1.0.0",
      "description": "Interactive pie chart showing distribution of CRM accounts by industry with drill-down capability to view detailed account lists and individual account information.",
      "relevance": 0.8151563317123398
    },
    {
      "name": "DealVelocityChart",
      "namespace": "CRM/Analytics",
      "version": "1.0.0",
      "description": "Interactive line chart showing deal velocity metrics over time with multiple view modes",
      "relevance": 0.7112391641234163
    },
    {
      "name": "InvoiceStatusDashboard",
      "namespace": "CRM/Finance",
      "version": "1.0.0",
      "description": "Track invoice statuses, payment timelines, and accounts receivable aging with actionable insights and collection metrics",
      "relevance": 0.6890951185348548
    }
  ],
  "code": "function MembershipTypeChart({ utilities, styles, components, callbacks, savedUserSettings, onSaveUserSettings, onChartSegmentClick }) {\n  const { SimpleDrilldownChart } = components;\n  const [chartData, setChartData] = useState([]);\n\n  useEffect(() => {\n    const fetchChartData = async () => {\n      try {\n        const result = await utilities.rq.RunQuery({\n          QueryName: 'ActiveMemberCountByMembershipType',\n          CategoryPath: 'Skip/Reporting/Membership',\n          Parameters: { Status: 'Active', IncludeInactiveTypes: 0 }\n        });\n        const rows = result?.records ?? result?.Rows ?? [];\n        setChartData(rows);\n      } catch (e) {\n        console.error('Error fetching ActiveMemberCountByMembershipType:', e);\n        setChartData([]);\n      }\n    };\n    fetchChartData();\n  }, [utilities?.refresh]);\n\n  const handleDataPointClick = async (clickInfo) => {\n    const membershipLabel = clickInfo?.label;\n    const records = clickInfo?.records ?? [];\n    const membershipId = records?.[0]?.MembershipTypeID ?? membershipLabel;\n\n    if (onChartSegmentClick) {\n      onChartSegmentClick(membershipId);\n    }\n\n    try {\n      await utilities.rq.RunQuery({\n        QueryName: 'ActiveMembersByMembershipType',\n        CategoryPath: 'Skip/Reporting/Membership',\n        Parameters: { MembershipTypeID: membershipId }\n      });\n    } catch (err) {\n      console.error('Error fetching ActiveMembersByMembershipType:', err);\n    }\n  };\n\n  return (\n    <SimpleDrilldownChart\n      utilities={utilities}\n      styles={styles}\n      components={components}\n      data={chartData}\n      groupBy=\"MembershipType\"\n      valueField=\"ActiveMemberCount\"\n      aggregateMethod=\"sum\"\n      chartType=\"pie\"\n      title=\"Active Members by Membership Type\"\n      gridFields={[\"FirstName\", \"LastName\", \"Email\", \"JoinDate\"]}\n      entityName=\"Members\"\n      entityPrimaryKeys={[\"MemberID\"]}\n      showSingleRecordView={false}\n      dataPointClick={handleDataPointClick}\n    />\n  );\n}",
  "namespace": "analytics/membership/alt-1",
  "version": "1.0.0",
  "registry": "Skip"
}
